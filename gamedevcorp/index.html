<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
	<title>gamedevcorp</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no">
	
	<!-- Made with Construct, the game and app creator :: https://www.construct.net -->
	

<style>
html, body {
	padding: 0;
	margin: 0;
	overflow: hidden;
	height: 100%;
}

body {
	background: #000000;
	color: white;
}

html, body, canvas {
	touch-action-delay: none;
	touch-action: none;
}

canvas, .c3htmlwrap {
	position: absolute;
}

.c3htmlwrap {
	contain: strict;
}

.c3overlay {
	pointer-events: none;
}

.c3htmlwrap[interactive] > * {
	pointer-events: auto;
}

/* HACK - work around elements being selectable only in iOS WKWebView for some reason */
html[ioswebview] .c3htmlwrap,
html[ioswebview] canvas {
	-webkit-user-select: none;
	user-select: none;
}

html[ioswebview] .c3htmlwrap > * {
	-webkit-user-select: auto;
	user-select: auto;
}

#notSupportedWrap {
	margin: 2em auto 1em auto;
	width: 75%;
	max-width: 45em;
	border: 2px solid #aaa;
	border-radius: 1em;
	padding: 2em;
	background-color: #f0f0f0;
	font-family: "Segoe UI", Frutiger, "Frutiger Linotype", "Dejavu Sans", "Helvetica Neue", Arial, sans-serif;
	color: black;
}

#notSupportedTitle {
	font-size: 1.8em;
}

.notSupportedMessage {
	font-size: 1.2em;
}

.notSupportedMessage em {
	color: #888;
}

/* bbcode styles */
.bbCodeH1 {
	font-size: 2em;
	font-weight: bold;
}

.bbCodeH2 {
	font-size: 1.5em;
	font-weight: bold;
}

.bbCodeH3 {
	font-size: 1.25em;
	font-weight: bold;
}

.bbCodeH4 {
	font-size: 1.1em;
	font-weight: bold;
}

.bbCodeItem::before {
	content: " â€¢ ";
}

/* For text icons converted to HTML: size the height to the line height
   preserving the aspect ratio. Also add position: relative as that allows
   just adding a 'top' style for the iconoffsety style. */
.c3-text-icon {
	height: 1em;
	width: auto;
	position: relative;
}

/* screen reader text */
.c3-screen-reader-text {
	position: absolute;
	width: 1px;
    height: 1px;
    overflow: hidden;
    clip: rect(1px, 1px, 1px, 1px);
}
</style>



</head> 
 
<body>

<script>
self.c3_base64files = {
	"scripts/c3main.js": {
		"type": "application/javascript",
		"str": "// Generated by Construct, the game and animation creation tool\n// Visit: https://www.construct.net\n\n// file-map:scripts/c3runtime.js\n{\n  let setMatrixArrayType = function(t) {\n    ARRAY_TYPE = t;\n  }, toRadian = function(t) {\n    return t * degree;\n  }, equals$9 = function(t, a) {\n    return Math.abs(t - a) <= EPSILON * Math.max(1, Math.abs(t), Math.abs(a));\n  }, create$8 = function() {\n    var t = new ARRAY_TYPE(4);\n    return ARRAY_TYPE != Float32Array && (t[1] = 0, t[2] = 0), t[0] = 1, t[3] = 1, t;\n  }, clone$8 = function(t) {\n    var a = new ARRAY_TYPE(4);\n    return a[0] = t[0], a[1] = t[1], a[2] = t[2], a[3] = t[3], a;\n  }, copy$8 = function(t, a) {\n    return t[0] = a[0], t[1] = a[1], t[2] = a[2], t[3] = a[3], t;\n  }, identity$5 = function(t) {\n    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t;\n  }, fromValues$8 = function(t, a, r, n) {\n    var e = new ARRAY_TYPE(4);\n    return e[0] = t, e[1] = a, e[2] = r, e[3] = n, e;\n  }, set$8 = function(t, a, r, n, e) {\n    return t[0] = a, t[1] = r, t[2] = n, t[3] = e, t;\n  }, transpose$2 = function(t, a) {\n    var r;\n    return t === a ? (r = a[1], t[1] = a[2], t[2] = r) : (t[0] = a[0], t[1] = a[2], t[2] = a[1], t[3] = a[3]), t;\n  }, invert$5 = function(t, a) {\n    var r = a[0], n = a[1], e = a[2], a = a[3], o = r * a - e * n;\n    return o ? (t[0] = a * (o = 1 / o), t[1] = -n * o, t[2] = -e * o, t[3] = r * o, t) : null;\n  }, adjoint$2 = function(t, a) {\n    var r = a[0];\n    return t[0] = a[3], t[1] = -a[1], t[2] = -a[2], t[3] = r, t;\n  }, determinant$3 = function(t) {\n    return t[0] * t[3] - t[2] * t[1];\n  }, multiply$8 = function(t, a, r) {\n    var n = a[0], e = a[1], o = a[2], a = a[3], u = r[0], s = r[1], i = r[2], r = r[3];\n    return t[0] = n * u + o * s, t[1] = e * u + a * s, t[2] = n * i + o * r, t[3] = e * i + a * r, t;\n  }, rotate$4 = function(t, a, r) {\n    var n = a[0], e = a[1], o = a[2], a = a[3], u = Math.sin(r), r = Math.cos(r);\n    return t[0] = n * r + o * u, t[1] = e * r + a * u, t[2] = n * -u + o * r, t[3] = e * -u + a * r, t;\n  }, scale$8 = function(t, a, r) {\n    var n = a[0], e = a[1], o = a[2], a = a[3], u = r[0], r = r[1];\n    return t[0] = n * u, t[1] = e * u, t[2] = o * r, t[3] = a * r, t;\n  }, fromRotation$4 = function(t, a) {\n    var r = Math.sin(a), a = Math.cos(a);\n    return t[0] = a, t[1] = r, t[2] = -r, t[3] = a, t;\n  }, fromScaling$3 = function(t, a) {\n    return t[0] = a[0], t[1] = 0, t[2] = 0, t[3] = a[1], t;\n  }, str$8 = function(t) {\n    return \"mat2(\" + t[0] + \", \" + t[1] + \", \" + t[2] + \", \" + t[3] + \")\";\n  }, frob$3 = function(t) {\n    return Math.hypot(t[0], t[1], t[2], t[3]);\n  }, LDU = function(t, a, r, n) {\n    return t[2] = n[2] / n[0], r[0] = n[0], r[1] = n[1], r[3] = n[3] - t[2] * r[1], [t, a, r];\n  }, add$8 = function(t, a, r) {\n    return t[0] = a[0] + r[0], t[1] = a[1] + r[1], t[2] = a[2] + r[2], t[3] = a[3] + r[3], t;\n  }, subtract$6 = function(t, a, r) {\n    return t[0] = a[0] - r[0], t[1] = a[1] - r[1], t[2] = a[2] - r[2], t[3] = a[3] - r[3], t;\n  }, exactEquals$8 = function(t, a) {\n    return t[0] === a[0] && t[1] === a[1] && t[2] === a[2] && t[3] === a[3];\n  }, equals$8 = function(t, a) {\n    var r = t[0], n = t[1], e = t[2], t = t[3], o = a[0], u = a[1], s = a[2], a = a[3];\n    return Math.abs(r - o) <= EPSILON * Math.max(1, Math.abs(r), Math.abs(o)) && Math.abs(n - u) <= EPSILON * Math.max(1, Math.abs(n), Math.abs(u)) && Math.abs(e - s) <= EPSILON * Math.max(1, Math.abs(e), Math.abs(s)) && Math.abs(t - a) <= EPSILON * Math.max(1, Math.abs(t), Math.abs(a));\n  }, multiplyScalar$3 = function(t, a, r) {\n    return t[0] = a[0] * r, t[1] = a[1] * r, t[2] = a[2] * r, t[3] = a[3] * r, t;\n  }, multiplyScalarAndAdd$3 = function(t, a, r, n) {\n    return t[0] = a[0] + r[0] * n, t[1] = a[1] + r[1] * n, t[2] = a[2] + r[2] * n, t[3] = a[3] + r[3] * n, t;\n  }, create$7 = function() {\n    var t = new ARRAY_TYPE(6);\n    return ARRAY_TYPE != Float32Array && (t[1] = 0, t[2] = 0, t[4] = 0, t[5] = 0), t[0] = 1, t[3] = 1, t;\n  }, clone$7 = function(t) {\n    var a = new ARRAY_TYPE(6);\n    return a[0] = t[0], a[1] = t[1], a[2] = t[2], a[3] = t[3], a[4] = t[4], a[5] = t[5], a;\n  }, copy$7 = function(t, a) {\n    return t[0] = a[0], t[1] = a[1], t[2] = a[2], t[3] = a[3], t[4] = a[4], t[5] = a[5], t;\n  }, identity$4 = function(t) {\n    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t;\n  }, fromValues$7 = function(t, a, r, n, e, o) {\n    var u = new ARRAY_TYPE(6);\n    return u[0] = t, u[1] = a, u[2] = r, u[3] = n, u[4] = e, u[5] = o, u;\n  }, set$7 = function(t, a, r, n, e, o, u) {\n    return t[0] = a, t[1] = r, t[2] = n, t[3] = e, t[4] = o, t[5] = u, t;\n  }, invert$4 = function(t, a) {\n    var r = a[0], n = a[1], e = a[2], o = a[3], u = a[4], a = a[5], s = r * o - n * e;\n    return s ? (t[0] = o * (s = 1 / s), t[1] = -n * s, t[2] = -e * s, t[3] = r * s, t[4] = (e * a - o * u) * s, t[5] = (n * u - r * a) * s, t) : null;\n  }, determinant$2 = function(t) {\n    return t[0] * t[3] - t[1] * t[2];\n  }, multiply$7 = function(t, a, r) {\n    var n = a[0], e = a[1], o = a[2], u = a[3], s = a[4], a = a[5], i = r[0], c = r[1], l = r[2], $ = r[3], h = r[4], r = r[5];\n    return t[0] = n * i + o * c, t[1] = e * i + u * c, t[2] = n * l + o * $, t[3] = e * l + u * $, t[4] = n * h + o * r + s, t[5] = e * h + u * r + a, t;\n  }, rotate$3 = function(t, a, r) {\n    var n = a[0], e = a[1], o = a[2], u = a[3], s = a[4], a = a[5], i = Math.sin(r), r = Math.cos(r);\n    return t[0] = n * r + o * i, t[1] = e * r + u * i, t[2] = n * -i + o * r, t[3] = e * -i + u * r, t[4] = s, t[5] = a, t;\n  }, scale$7 = function(t, a, r) {\n    var n = a[0], e = a[1], o = a[2], u = a[3], s = a[4], a = a[5], i = r[0], r = r[1];\n    return t[0] = n * i, t[1] = e * i, t[2] = o * r, t[3] = u * r, t[4] = s, t[5] = a, t;\n  }, translate$3 = function(t, a, r) {\n    var n = a[0], e = a[1], o = a[2], u = a[3], s = a[4], a = a[5], i = r[0], r = r[1];\n    return t[0] = n, t[1] = e, t[2] = o, t[3] = u, t[4] = n * i + o * r + s, t[5] = e * i + u * r + a, t;\n  }, fromRotation$3 = function(t, a) {\n    var r = Math.sin(a), a = Math.cos(a);\n    return t[0] = a, t[1] = r, t[2] = -r, t[3] = a, t[4] = 0, t[5] = 0, t;\n  }, fromScaling$2 = function(t, a) {\n    return t[0] = a[0], t[1] = 0, t[2] = 0, t[3] = a[1], t[4] = 0, t[5] = 0, t;\n  }, fromTranslation$3 = function(t, a) {\n    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = a[0], t[5] = a[1], t;\n  }, str$7 = function(t) {\n    return \"mat2d(\" + t[0] + \", \" + t[1] + \", \" + t[2] + \", \" + t[3] + \", \" + t[4] + \", \" + t[5] + \")\";\n  }, frob$2 = function(t) {\n    return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], 1);\n  }, add$7 = function(t, a, r) {\n    return t[0] = a[0] + r[0], t[1] = a[1] + r[1], t[2] = a[2] + r[2], t[3] = a[3] + r[3], t[4] = a[4] + r[4], t[5] = a[5] + r[5], t;\n  }, subtract$5 = function(t, a, r) {\n    return t[0] = a[0] - r[0], t[1] = a[1] - r[1], t[2] = a[2] - r[2], t[3] = a[3] - r[3], t[4] = a[4] - r[4], t[5] = a[5] - r[5], t;\n  }, multiplyScalar$2 = function(t, a, r) {\n    return t[0] = a[0] * r, t[1] = a[1] * r, t[2] = a[2] * r, t[3] = a[3] * r, t[4] = a[4] * r, t[5] = a[5] * r, t;\n  }, multiplyScalarAndAdd$2 = function(t, a, r, n) {\n    return t[0] = a[0] + r[0] * n, t[1] = a[1] + r[1] * n, t[2] = a[2] + r[2] * n, t[3] = a[3] + r[3] * n, t[4] = a[4] + r[4] * n, t[5] = a[5] + r[5] * n, t;\n  }, exactEquals$7 = function(t, a) {\n    return t[0] === a[0] && t[1] === a[1] && t[2] === a[2] && t[3] === a[3] && t[4] === a[4] && t[5] === a[5];\n  }, equals$7 = function(t, a) {\n    var r = t[0], n = t[1], e = t[2], o = t[3], u = t[4], t = t[5], s = a[0], i = a[1], c = a[2], l = a[3], $ = a[4], a = a[5];\n    return Math.abs(r - s) <= EPSILON * Math.max(1, Math.abs(r), Math.abs(s)) && Math.abs(n - i) <= EPSILON * Math.max(1, Math.abs(n), Math.abs(i)) && Math.abs(e - c) <= EPSILON * Math.max(1, Math.abs(e), Math.abs(c)) && Math.abs(o - l) <= EPSILON * Math.max(1, Math.abs(o), Math.abs(l)) && Math.abs(u - $) <= EPSILON * Math.max(1, Math.abs(u), Math.abs($)) && Math.abs(t - a) <= EPSILON * Math.max(1, Math.abs(t), Math.abs(a));\n  }, create$6 = function() {\n    var t = new ARRAY_TYPE(9);\n    return ARRAY_TYPE != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[5] = 0, t[6] = 0, t[7] = 0), t[0] = 1, t[4] = 1, t[8] = 1, t;\n  }, fromMat4$1 = function(t, a) {\n    return t[0] = a[0], t[1] = a[1], t[2] = a[2], t[3] = a[4], t[4] = a[5], t[5] = a[6], t[6] = a[8], t[7] = a[9], t[8] = a[10], t;\n  }, clone$6 = function(t) {\n    var a = new ARRAY_TYPE(9);\n    return a[0] = t[0], a[1] = t[1], a[2] = t[2], a[3] = t[3], a[4] = t[4], a[5] = t[5], a[6] = t[6], a[7] = t[7], a[8] = t[8], a;\n  }, copy$6 = function(t, a) {\n    return t[0] = a[0], t[1] = a[1], t[2] = a[2], t[3] = a[3], t[4] = a[4], t[5] = a[5], t[6] = a[6], t[7] = a[7], t[8] = a[8], t;\n  }, fromValues$6 = function(t, a, r, n, e, o, u, s, i) {\n    var c = new ARRAY_TYPE(9);\n    return c[0] = t, c[1] = a, c[2] = r, c[3] = n, c[4] = e, c[5] = o, c[6] = u, c[7] = s, c[8] = i, c;\n  }, set$6 = function(t, a, r, n, e, o, u, s, i, c) {\n    return t[0] = a, t[1] = r, t[2] = n, t[3] = e, t[4] = o, t[5] = u, t[6] = s, t[7] = i, t[8] = c, t;\n  }, identity$3 = function(t) {\n    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t;\n  }, transpose$1 = function(t, a) {\n    var r, n, e;\n    return t === a ? (r = a[1], n = a[2], e = a[5], t[1] = a[3], t[2] = a[6], t[3] = r, t[5] = a[7], t[6] = n, t[7] = e) : (t[0] = a[0], t[1] = a[3], t[2] = a[6], t[3] = a[1], t[4] = a[4], t[5] = a[7], t[6] = a[2], t[7] = a[5], t[8] = a[8]), t;\n  }, invert$3 = function(t, a) {\n    var r = a[0], n = a[1], e = a[2], o = a[3], u = a[4], s = a[5], i = a[6], c = a[7], a = a[8], l = a * u - s * c, $ = -a * o + s * i, h = c * o - u * i, f = r * l + n * $ + e * h;\n    return f ? (t[0] = l * (f = 1 / f), t[1] = (-a * n + e * c) * f, t[2] = (s * n - e * u) * f, t[3] = $ * f, t[4] = (a * r - e * i) * f, t[5] = (-s * r + e * o) * f, t[6] = h * f, t[7] = (-c * r + n * i) * f, t[8] = (u * r - n * o) * f, t) : null;\n  }, adjoint$1 = function(t, a) {\n    var r = a[0], n = a[1], e = a[2], o = a[3], u = a[4], s = a[5], i = a[6], c = a[7], a = a[8];\n    return t[0] = u * a - s * c, t[1] = e * c - n * a, t[2] = n * s - e * u, t[3] = s * i - o * a, t[4] = r * a - e * i, t[5] = e * o - r * s, t[6] = o * c - u * i, t[7] = n * i - r * c, t[8] = r * u - n * o, t;\n  }, determinant$1 = function(t) {\n    var a = t[0], r = t[3], n = t[4], e = t[5], o = t[6], u = t[7], s = t[8];\n    return a * (s * n - e * u) + t[1] * (-s * r + e * o) + t[2] * (u * r - n * o);\n  }, multiply$6 = function(t, a, r) {\n    var n = a[0], e = a[1], o = a[2], u = a[3], s = a[4], i = a[5], c = a[6], l = a[7], a = a[8], $ = r[0], h = r[1], f = r[2], M = r[3], m = r[4], d = r[5], v = r[6], b = r[7], r = r[8];\n    return t[0] = $ * n + h * u + f * c, t[1] = $ * e + h * s + f * l, t[2] = $ * o + h * i + f * a, t[3] = M * n + m * u + d * c, t[4] = M * e + m * s + d * l, t[5] = M * o + m * i + d * a, t[6] = v * n + b * u + r * c, t[7] = v * e + b * s + r * l, t[8] = v * o + b * i + r * a, t;\n  }, translate$2 = function(t, a, r) {\n    var n = a[0], e = a[1], o = a[2], u = a[3], s = a[4], i = a[5], c = a[6], l = a[7], a = a[8], $ = r[0], r = r[1];\n    return t[0] = n, t[1] = e, t[2] = o, t[3] = u, t[4] = s, t[5] = i, t[6] = $ * n + r * u + c, t[7] = $ * e + r * s + l, t[8] = $ * o + r * i + a, t;\n  }, rotate$2 = function(t, a, r) {\n    var n = a[0], e = a[1], o = a[2], u = a[3], s = a[4], i = a[5], c = a[6], l = a[7], a = a[8], $ = Math.sin(r), r = Math.cos(r);\n    return t[0] = r * n + $ * u, t[1] = r * e + $ * s, t[2] = r * o + $ * i, t[3] = r * u - $ * n, t[4] = r * s - $ * e, t[5] = r * i - $ * o, t[6] = c, t[7] = l, t[8] = a, t;\n  }, scale$6 = function(t, a, r) {\n    var n = r[0], r = r[1];\n    return t[0] = n * a[0], t[1] = n * a[1], t[2] = n * a[2], t[3] = r * a[3], t[4] = r * a[4], t[5] = r * a[5], t[6] = a[6], t[7] = a[7], t[8] = a[8], t;\n  }, fromTranslation$2 = function(t, a) {\n    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = a[0], t[7] = a[1], t[8] = 1, t;\n  }, fromRotation$2 = function(t, a) {\n    var r = Math.sin(a), a = Math.cos(a);\n    return t[0] = a, t[1] = r, t[2] = 0, t[3] = -r, t[4] = a, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t;\n  }, fromScaling$1 = function(t, a) {\n    return t[0] = a[0], t[1] = 0, t[2] = 0, t[3] = 0, t[4] = a[1], t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t;\n  }, fromMat2d = function(t, a) {\n    return t[0] = a[0], t[1] = a[1], t[2] = 0, t[3] = a[2], t[4] = a[3], t[5] = 0, t[6] = a[4], t[7] = a[5], t[8] = 1, t;\n  }, fromQuat$1 = function(t, a) {\n    var r = a[0], n = a[1], e = a[2], a = a[3], o = r + r, u = n + n, s = e + e, r = r * o, i = n * o, n = n * u, c = e * o, l = e * u, e = e * s, o = a * o, u = a * u, a = a * s;\n    return t[0] = 1 - n - e, t[3] = i - a, t[6] = c + u, t[1] = i + a, t[4] = 1 - r - e, t[7] = l - o, t[2] = c - u, t[5] = l + o, t[8] = 1 - r - n, t;\n  }, normalFromMat4 = function(t, a) {\n    var r = a[0], n = a[1], e = a[2], o = a[3], u = a[4], s = a[5], i = a[6], c = a[7], l = a[8], $ = a[9], h = a[10], f = a[11], M = a[12], m = a[13], d = a[14], a = a[15], v = r * s - n * u, b = r * i - e * u, p = r * c - o * u, A = n * i - e * s, y = n * c - o * s, g = e * c - o * i, R = l * m - $ * M, E = l * d - h * M, l = l * a - f * M, q = $ * d - h * m, $ = $ * a - f * m, h = h * a - f * d, f = v * h - b * $ + p * q + A * l - y * E + g * R;\n    return f ? (t[0] = (s * h - i * $ + c * q) * (f = 1 / f), t[1] = (i * l - u * h - c * E) * f, t[2] = (u * $ - s * l + c * R) * f, t[3] = (e * $ - n * h - o * q) * f, t[4] = (r * h - e * l + o * E) * f, t[5] = (n * l - r * $ - o * R) * f, t[6] = (m * g - d * y + a * A) * f, t[7] = (d * p - M * g - a * b) * f, t[8] = (M * y - m * p + a * v) * f, t) : null;\n  }, projection = function(t, a, r) {\n    return t[0] = 2 / a, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = -2 / r, t[5] = 0, t[6] = -1, t[7] = 1, t[8] = 1, t;\n  }, str$6 = function(t) {\n    return \"mat3(\" + t[0] + \", \" + t[1] + \", \" + t[2] + \", \" + t[3] + \", \" + t[4] + \", \" + t[5] + \", \" + t[6] + \", \" + t[7] + \", \" + t[8] + \")\";\n  }, frob$1 = function(t) {\n    return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8]);\n  }, add$6 = function(t, a, r) {\n    return t[0] = a[0] + r[0], t[1] = a[1] + r[1], t[2] = a[2] + r[2], t[3] = a[3] + r[3], t[4] = a[4] + r[4], t[5] = a[5] + r[5], t[6] = a[6] + r[6], t[7] = a[7] + r[7], t[8] = a[8] + r[8], t;\n  }, subtract$4 = function(t, a, r) {\n    return t[0] = a[0] - r[0], t[1] = a[1] - r[1], t[2] = a[2] - r[2], t[3] = a[3] - r[3], t[4] = a[4] - r[4], t[5] = a[5] - r[5], t[6] = a[6] - r[6], t[7] = a[7] - r[7], t[8] = a[8] - r[8], t;\n  }, multiplyScalar$1 = function(t, a, r) {\n    return t[0] = a[0] * r, t[1] = a[1] * r, t[2] = a[2] * r, t[3] = a[3] * r, t[4] = a[4] * r, t[5] = a[5] * r, t[6] = a[6] * r, t[7] = a[7] * r, t[8] = a[8] * r, t;\n  }, multiplyScalarAndAdd$1 = function(t, a, r, n) {\n    return t[0] = a[0] + r[0] * n, t[1] = a[1] + r[1] * n, t[2] = a[2] + r[2] * n, t[3] = a[3] + r[3] * n, t[4] = a[4] + r[4] * n, t[5] = a[5] + r[5] * n, t[6] = a[6] + r[6] * n, t[7] = a[7] + r[7] * n, t[8] = a[8] + r[8] * n, t;\n  }, exactEquals$6 = function(t, a) {\n    return t[0] === a[0] && t[1] === a[1] && t[2] === a[2] && t[3] === a[3] && t[4] === a[4] && t[5] === a[5] && t[6] === a[6] && t[7] === a[7] && t[8] === a[8];\n  }, equals$6 = function(t, a) {\n    var r = t[0], n = t[1], e = t[2], o = t[3], u = t[4], s = t[5], i = t[6], c = t[7], t = t[8], l = a[0], $ = a[1], h = a[2], f = a[3], M = a[4], m = a[5], d = a[6], v = a[7], a = a[8];\n    return Math.abs(r - l) <= EPSILON * Math.max(1, Math.abs(r), Math.abs(l)) && Math.abs(n - $) <= EPSILON * Math.max(1, Math.abs(n), Math.abs($)) && Math.abs(e - h) <= EPSILON * Math.max(1, Math.abs(e), Math.abs(h)) && Math.abs(o - f) <= EPSILON * Math.max(1, Math.abs(o), Math.abs(f)) && Math.abs(u - M) <= EPSILON * Math.max(1, Math.abs(u), Math.abs(M)) && Math.abs(s - m) <= EPSILON * Math.max(1, Math.abs(s), Math.abs(m)) && Math.abs(i - d) <= EPSILON * Math.max(1, Math.abs(i), Math.abs(d)) && Math.abs(c - v) <= EPSILON * Math.max(1, Math.abs(c), Math.abs(v)) && Math.abs(t - a) <= EPSILON * Math.max(1, Math.abs(t), Math.abs(a));\n  }, create$5 = function() {\n    var t = new ARRAY_TYPE(16);\n    return ARRAY_TYPE != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0), t[0] = 1, t[5] = 1, t[10] = 1, t[15] = 1, t;\n  }, clone$5 = function(t) {\n    var a = new ARRAY_TYPE(16);\n    return a[0] = t[0], a[1] = t[1], a[2] = t[2], a[3] = t[3], a[4] = t[4], a[5] = t[5], a[6] = t[6], a[7] = t[7], a[8] = t[8], a[9] = t[9], a[10] = t[10], a[11] = t[11], a[12] = t[12], a[13] = t[13], a[14] = t[14], a[15] = t[15], a;\n  }, copy$5 = function(t, a) {\n    return t[0] = a[0], t[1] = a[1], t[2] = a[2], t[3] = a[3], t[4] = a[4], t[5] = a[5], t[6] = a[6], t[7] = a[7], t[8] = a[8], t[9] = a[9], t[10] = a[10], t[11] = a[11], t[12] = a[12], t[13] = a[13], t[14] = a[14], t[15] = a[15], t;\n  }, fromValues$5 = function(t, a, r, n, e, o, u, s, i, c, l, $, h, f, M, m) {\n    var d = new ARRAY_TYPE(16);\n    return d[0] = t, d[1] = a, d[2] = r, d[3] = n, d[4] = e, d[5] = o, d[6] = u, d[7] = s, d[8] = i, d[9] = c, d[10] = l, d[11] = $, d[12] = h, d[13] = f, d[14] = M, d[15] = m, d;\n  }, set$5 = function(t, a, r, n, e, o, u, s, i, c, l, $, h, f, M, m, d) {\n    return t[0] = a, t[1] = r, t[2] = n, t[3] = e, t[4] = o, t[5] = u, t[6] = s, t[7] = i, t[8] = c, t[9] = l, t[10] = $, t[11] = h, t[12] = f, t[13] = M, t[14] = m, t[15] = d, t;\n  }, identity$2 = function(t) {\n    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;\n  }, transpose = function(t, a) {\n    var r, n, e, o, u, s;\n    return t === a ? (r = a[1], n = a[2], e = a[3], o = a[6], u = a[7], s = a[11], t[1] = a[4], t[2] = a[8], t[3] = a[12], t[4] = r, t[6] = a[9], t[7] = a[13], t[8] = n, t[9] = o, t[11] = a[14], t[12] = e, t[13] = u, t[14] = s) : (t[0] = a[0], t[1] = a[4], t[2] = a[8], t[3] = a[12], t[4] = a[1], t[5] = a[5], t[6] = a[9], t[7] = a[13], t[8] = a[2], t[9] = a[6], t[10] = a[10], t[11] = a[14], t[12] = a[3], t[13] = a[7], t[14] = a[11], t[15] = a[15]), t;\n  }, invert$2 = function(t, a) {\n    var r = a[0], n = a[1], e = a[2], o = a[3], u = a[4], s = a[5], i = a[6], c = a[7], l = a[8], $ = a[9], h = a[10], f = a[11], M = a[12], m = a[13], d = a[14], a = a[15], v = r * s - n * u, b = r * i - e * u, p = r * c - o * u, A = n * i - e * s, y = n * c - o * s, g = e * c - o * i, R = l * m - $ * M, E = l * d - h * M, q = l * a - f * M, x = $ * d - h * m, P = $ * a - f * m, L = h * a - f * d, O = v * L - b * P + p * x + A * q - y * E + g * R;\n    return O ? (t[0] = (s * L - i * P + c * x) * (O = 1 / O), t[1] = (e * P - n * L - o * x) * O, t[2] = (m * g - d * y + a * A) * O, t[3] = (h * y - $ * g - f * A) * O, t[4] = (i * q - u * L - c * E) * O, t[5] = (r * L - e * q + o * E) * O, t[6] = (d * p - M * g - a * b) * O, t[7] = (l * g - h * p + f * b) * O, t[8] = (u * P - s * q + c * R) * O, t[9] = (n * q - r * P - o * R) * O, t[10] = (M * y - m * p + a * v) * O, t[11] = ($ * p - l * y - f * v) * O, t[12] = (s * E - u * x - i * R) * O, t[13] = (r * x - n * E + e * R) * O, t[14] = (m * b - M * A - d * v) * O, t[15] = (l * A - $ * b + h * v) * O, t) : null;\n  }, adjoint = function(t, a) {\n    var r = a[0], n = a[1], e = a[2], o = a[3], u = a[4], s = a[5], i = a[6], c = a[7], l = a[8], $ = a[9], h = a[10], f = a[11], M = a[12], m = a[13], d = a[14], a = a[15], v = r * s - n * u, b = r * i - e * u, p = r * c - o * u, A = n * i - e * s, y = n * c - o * s, g = e * c - o * i, R = l * m - $ * M, E = l * d - h * M, q = l * a - f * M, x = $ * d - h * m, P = $ * a - f * m, L = h * a - f * d;\n    return t[0] = s * L - i * P + c * x, t[1] = e * P - n * L - o * x, t[2] = m * g - d * y + a * A, t[3] = h * y - $ * g - f * A, t[4] = i * q - u * L - c * E, t[5] = r * L - e * q + o * E, t[6] = d * p - M * g - a * b, t[7] = l * g - h * p + f * b, t[8] = u * P - s * q + c * R, t[9] = n * q - r * P - o * R, t[10] = M * y - m * p + a * v, t[11] = $ * p - l * y - f * v, t[12] = s * E - u * x - i * R, t[13] = r * x - n * E + e * R, t[14] = m * b - M * A - d * v, t[15] = l * A - $ * b + h * v, t;\n  }, determinant = function(t) {\n    var a = t[0], r = t[1], n = t[2], e = t[4], o = t[5], u = t[6], s = t[8], i = t[9], c = t[10], l = t[12], $ = t[13], h = t[14], f = a * o - r * e, M = a * u - n * e, m = r * u - n * o, d = s * $ - i * l, v = s * h - c * l, b = i * h - c * $;\n    return t[7] * (a * b - r * v + n * d) - t[3] * (e * b - o * v + u * d) + t[15] * (s * m - i * M + c * f) - t[11] * (l * m - $ * M + h * f);\n  }, multiply$5 = function(t, a, r) {\n    var n = a[0], e = a[1], o = a[2], u = a[3], s = a[4], i = a[5], c = a[6], l = a[7], $ = a[8], h = a[9], f = a[10], M = a[11], m = a[12], d = a[13], v = a[14], a = a[15], b = r[0], p = r[1], A = r[2], y = r[3];\n    return t[0] = b * n + p * s + A * $ + y * m, t[1] = b * e + p * i + A * h + y * d, t[2] = b * o + p * c + A * f + y * v, t[3] = b * u + p * l + A * M + y * a, t[4] = (b = r[4]) * n + (p = r[5]) * s + (A = r[6]) * $ + (y = r[7]) * m, t[5] = b * e + p * i + A * h + y * d, t[6] = b * o + p * c + A * f + y * v, t[7] = b * u + p * l + A * M + y * a, t[8] = (b = r[8]) * n + (p = r[9]) * s + (A = r[10]) * $ + (y = r[11]) * m, t[9] = b * e + p * i + A * h + y * d, t[10] = b * o + p * c + A * f + y * v, t[11] = b * u + p * l + A * M + y * a, t[12] = (b = r[12]) * n + (p = r[13]) * s + (A = r[14]) * $ + (y = r[15]) * m, t[13] = b * e + p * i + A * h + y * d, t[14] = b * o + p * c + A * f + y * v, t[15] = b * u + p * l + A * M + y * a, t;\n  }, translate$1 = function(t, a, r) {\n    var n, e, o, u, s, i, c, l, $, h, f, M, m = r[0], d = r[1], r = r[2];\n    return a === t ? (t[12] = a[0] * m + a[4] * d + a[8] * r + a[12], t[13] = a[1] * m + a[5] * d + a[9] * r + a[13], t[14] = a[2] * m + a[6] * d + a[10] * r + a[14], t[15] = a[3] * m + a[7] * d + a[11] * r + a[15]) : (n = a[0], e = a[1], o = a[2], u = a[3], s = a[4], i = a[5], c = a[6], l = a[7], $ = a[8], h = a[9], f = a[10], M = a[11], t[0] = n, t[1] = e, t[2] = o, t[3] = u, t[4] = s, t[5] = i, t[6] = c, t[7] = l, t[8] = $, t[9] = h, t[10] = f, t[11] = M, t[12] = n * m + s * d + $ * r + a[12], t[13] = e * m + i * d + h * r + a[13], t[14] = o * m + c * d + f * r + a[14], t[15] = u * m + l * d + M * r + a[15]), t;\n  }, scale$5 = function(t, a, r) {\n    var n = r[0], e = r[1], r = r[2];\n    return t[0] = a[0] * n, t[1] = a[1] * n, t[2] = a[2] * n, t[3] = a[3] * n, t[4] = a[4] * e, t[5] = a[5] * e, t[6] = a[6] * e, t[7] = a[7] * e, t[8] = a[8] * r, t[9] = a[9] * r, t[10] = a[10] * r, t[11] = a[11] * r, t[12] = a[12], t[13] = a[13], t[14] = a[14], t[15] = a[15], t;\n  }, rotate$1 = function(t, a, r, n) {\n    var e, o, u, s, i, c, l, $, h, f, M, m, d, v, b, p, A, y, g, R, E = n[0], q = n[1], n = n[2], x = Math.hypot(E, q, n);\n    return x < EPSILON ? null : (E *= x = 1 / x, q *= x, n *= x, x = Math.sin(r), r = Math.cos(r), o = a[0], u = a[1], s = a[2], i = a[3], l = a[5], $ = a[6], h = a[7], M = a[9], m = a[10], d = a[11], b = E * q * (e = 1 - r) - n * x, p = q * q * e + r, A = n * q * e + E * x, y = E * n * e + q * x, g = q * n * e - E * x, R = n * n * e + r, t[0] = o * (r = E * E * e + r) + (c = a[4]) * (v = q * E * e + n * x) + (f = a[8]) * (n = n * E * e - q * x), t[1] = u * r + l * v + M * n, t[2] = s * r + $ * v + m * n, t[3] = i * r + h * v + d * n, t[4] = o * b + c * p + f * A, t[5] = u * b + l * p + M * A, t[6] = s * b + $ * p + m * A, t[7] = i * b + h * p + d * A, t[8] = o * y + c * g + f * R, t[9] = u * y + l * g + M * R, t[10] = s * y + $ * g + m * R, t[11] = i * y + h * g + d * R, a !== t && (t[12] = a[12], t[13] = a[13], t[14] = a[14], t[15] = a[15]), t);\n  }, rotateX$3 = function(t, a, r) {\n    var n = Math.sin(r), r = Math.cos(r), e = a[4], o = a[5], u = a[6], s = a[7], i = a[8], c = a[9], l = a[10], $ = a[11];\n    return a !== t && (t[0] = a[0], t[1] = a[1], t[2] = a[2], t[3] = a[3], t[12] = a[12], t[13] = a[13], t[14] = a[14], t[15] = a[15]), t[4] = e * r + i * n, t[5] = o * r + c * n, t[6] = u * r + l * n, t[7] = s * r + $ * n, t[8] = i * r - e * n, t[9] = c * r - o * n, t[10] = l * r - u * n, t[11] = $ * r - s * n, t;\n  }, rotateY$3 = function(t, a, r) {\n    var n = Math.sin(r), r = Math.cos(r), e = a[0], o = a[1], u = a[2], s = a[3], i = a[8], c = a[9], l = a[10], $ = a[11];\n    return a !== t && (t[4] = a[4], t[5] = a[5], t[6] = a[6], t[7] = a[7], t[12] = a[12], t[13] = a[13], t[14] = a[14], t[15] = a[15]), t[0] = e * r - i * n, t[1] = o * r - c * n, t[2] = u * r - l * n, t[3] = s * r - $ * n, t[8] = e * n + i * r, t[9] = o * n + c * r, t[10] = u * n + l * r, t[11] = s * n + $ * r, t;\n  }, rotateZ$3 = function(t, a, r) {\n    var n = Math.sin(r), r = Math.cos(r), e = a[0], o = a[1], u = a[2], s = a[3], i = a[4], c = a[5], l = a[6], $ = a[7];\n    return a !== t && (t[8] = a[8], t[9] = a[9], t[10] = a[10], t[11] = a[11], t[12] = a[12], t[13] = a[13], t[14] = a[14], t[15] = a[15]), t[0] = e * r + i * n, t[1] = o * r + c * n, t[2] = u * r + l * n, t[3] = s * r + $ * n, t[4] = i * r - e * n, t[5] = c * r - o * n, t[6] = l * r - u * n, t[7] = $ * r - s * n, t;\n  }, fromTranslation$1 = function(t, a) {\n    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = a[0], t[13] = a[1], t[14] = a[2], t[15] = 1, t;\n  }, fromScaling = function(t, a) {\n    return t[0] = a[0], t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = a[1], t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = a[2], t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;\n  }, fromRotation$1 = function(t, a, r) {\n    var n, e = r[0], o = r[1], r = r[2], u = Math.hypot(e, o, r);\n    return u < EPSILON ? null : (e *= u = 1 / u, o *= u, r *= u, u = Math.sin(a), a = Math.cos(a), t[0] = e * e * (n = 1 - a) + a, t[1] = o * e * n + r * u, t[2] = r * e * n - o * u, t[3] = 0, t[4] = e * o * n - r * u, t[5] = o * o * n + a, t[6] = r * o * n + e * u, t[7] = 0, t[8] = e * r * n + o * u, t[9] = o * r * n - e * u, t[10] = r * r * n + a, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t);\n  }, fromXRotation = function(t, a) {\n    var r = Math.sin(a), a = Math.cos(a);\n    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = a, t[6] = r, t[7] = 0, t[8] = 0, t[9] = -r, t[10] = a, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;\n  }, fromYRotation = function(t, a) {\n    var r = Math.sin(a), a = Math.cos(a);\n    return t[0] = a, t[1] = 0, t[2] = -r, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = r, t[9] = 0, t[10] = a, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;\n  }, fromZRotation = function(t, a) {\n    var r = Math.sin(a), a = Math.cos(a);\n    return t[0] = a, t[1] = r, t[2] = 0, t[3] = 0, t[4] = -r, t[5] = a, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;\n  }, fromRotationTranslation$1 = function(t, a, r) {\n    var n = a[0], e = a[1], o = a[2], a = a[3], u = n + n, s = e + e, i = o + o, c = n * u, l = n * s, n = n * i, $ = e * s, e = e * i, o = o * i, u = a * u, s = a * s, a = a * i;\n    return t[0] = 1 - ($ + o), t[1] = l + a, t[2] = n - s, t[3] = 0, t[4] = l - a, t[5] = 1 - (c + o), t[6] = e + u, t[7] = 0, t[8] = n + s, t[9] = e - u, t[10] = 1 - (c + $), t[11] = 0, t[12] = r[0], t[13] = r[1], t[14] = r[2], t[15] = 1, t;\n  }, fromQuat2 = function(t, a) {\n    var r = new ARRAY_TYPE(3), n = -a[0], e = -a[1], o = -a[2], u = a[3], s = a[4], i = a[5], c = a[6], l = a[7], $ = n * n + e * e + o * o + u * u;\n    return 0 < $ ? (r[0] = 2 * (s * u + l * n + i * o - c * e) / $, r[1] = 2 * (i * u + l * e + c * n - s * o) / $, r[2] = 2 * (c * u + l * o + s * e - i * n) / $) : (r[0] = 2 * (s * u + l * n + i * o - c * e), r[1] = 2 * (i * u + l * e + c * n - s * o), r[2] = 2 * (c * u + l * o + s * e - i * n)), fromRotationTranslation$1(t, a, r), t;\n  }, getTranslation$1 = function(t, a) {\n    return t[0] = a[12], t[1] = a[13], t[2] = a[14], t;\n  }, getScaling = function(t, a) {\n    var r = a[0], n = a[4], e = a[5], o = a[6], u = a[8], s = a[9], i = a[10];\n    return t[0] = Math.hypot(r, a[1], a[2]), t[1] = Math.hypot(n, e, o), t[2] = Math.hypot(u, s, i), t;\n  }, getRotation = function(t, a) {\n    var r = new ARRAY_TYPE(3), n = (getScaling(r, a), 1 / r[0]), e = 1 / r[1], r = 1 / r[2], o = a[0] * n, u = a[1] * e, s = a[2] * r, i = a[4] * n, c = a[5] * e, l = a[6] * r, n = a[8] * n, e = a[9] * e, a = a[10] * r, r = o + c + a, $ = 0;\n    return 0 < r ? ($ = 2 * Math.sqrt(1 + r), t[3] = 0.25 * $, t[0] = (l - e) / $, t[1] = (n - s) / $, t[2] = (u - i) / $) : c < o && a < o ? ($ = 2 * Math.sqrt(1 + o - c - a), t[3] = (l - e) / $, t[0] = 0.25 * $, t[1] = (u + i) / $, t[2] = (n + s) / $) : a < c ? ($ = 2 * Math.sqrt(1 + c - o - a), t[3] = (n - s) / $, t[0] = (u + i) / $, t[1] = 0.25 * $, t[2] = (l + e) / $) : ($ = 2 * Math.sqrt(1 + a - o - c), t[3] = (u - i) / $, t[0] = (n + s) / $, t[1] = (l + e) / $, t[2] = 0.25 * $), t;\n  }, decompose = function(t, a, r, n) {\n    a[0] = n[12], a[1] = n[13], a[2] = n[14];\n    var a = n[0], e = n[1], o = n[2], u = n[4], s = n[5], i = n[6], c = n[8], l = n[9], n = n[10], $ = (r[0] = Math.hypot(a, e, o), r[1] = Math.hypot(u, s, i), r[2] = Math.hypot(c, l, n), 1 / r[0]), h = 1 / r[1], r = 1 / r[2], a = a * $, e = e * h, o = o * r, u = u * $, s = s * h, i = i * r, c = c * $, $ = l * h, l = n * r, h = a + s + l, n = 0;\n    return 0 < h ? (n = 2 * Math.sqrt(1 + h), t[3] = 0.25 * n, t[0] = (i - $) / n, t[1] = (c - o) / n, t[2] = (e - u) / n) : s < a && l < a ? (n = 2 * Math.sqrt(1 + a - s - l), t[3] = (i - $) / n, t[0] = 0.25 * n, t[1] = (e + u) / n, t[2] = (c + o) / n) : l < s ? (n = 2 * Math.sqrt(1 + s - a - l), t[3] = (c - o) / n, t[0] = (e + u) / n, t[1] = 0.25 * n, t[2] = (i + $) / n) : (n = 2 * Math.sqrt(1 + l - a - s), t[3] = (e - u) / n, t[0] = (c + o) / n, t[1] = (i + $) / n, t[2] = 0.25 * n), t;\n  }, fromRotationTranslationScale = function(t, a, r, n) {\n    var e = a[0], o = a[1], u = a[2], a = a[3], s = e + e, i = o + o, c = u + u, l = e * s, $ = e * i, e = e * c, h = o * i, o = o * c, u = u * c, s = a * s, i = a * i, a = a * c, c = n[0], f = n[1], n = n[2];\n    return t[0] = (1 - (h + u)) * c, t[1] = ($ + a) * c, t[2] = (e - i) * c, t[3] = 0, t[4] = ($ - a) * f, t[5] = (1 - (l + u)) * f, t[6] = (o + s) * f, t[7] = 0, t[8] = (e + i) * n, t[9] = (o - s) * n, t[10] = (1 - (l + h)) * n, t[11] = 0, t[12] = r[0], t[13] = r[1], t[14] = r[2], t[15] = 1, t;\n  }, fromRotationTranslationScaleOrigin = function(t, a, r, n, e) {\n    var o = a[0], u = a[1], s = a[2], a = a[3], i = o + o, c = u + u, l = s + s, $ = o * i, h = o * c, o = o * l, f = u * c, u = u * l, s = s * l, i = a * i, c = a * c, a = a * l, l = n[0], M = n[1], n = n[2], m = e[0], d = e[1], e = e[2], v = (1 - (f + s)) * l, b = (h + a) * l, l = (o - c) * l, h = (h - a) * M, a = (1 - ($ + s)) * M, s = (u + i) * M, M = (o + c) * n, o = (u - i) * n, c = (1 - ($ + f)) * n;\n    return t[0] = v, t[1] = b, t[2] = l, t[3] = 0, t[4] = h, t[5] = a, t[6] = s, t[7] = 0, t[8] = M, t[9] = o, t[10] = c, t[11] = 0, t[12] = r[0] + m - (v * m + h * d + M * e), t[13] = r[1] + d - (b * m + a * d + o * e), t[14] = r[2] + e - (l * m + s * d + c * e), t[15] = 1, t;\n  }, fromQuat = function(t, a) {\n    var r = a[0], n = a[1], e = a[2], a = a[3], o = r + r, u = n + n, s = e + e, r = r * o, i = n * o, n = n * u, c = e * o, l = e * u, e = e * s, o = a * o, u = a * u, a = a * s;\n    return t[0] = 1 - n - e, t[1] = i + a, t[2] = c - u, t[3] = 0, t[4] = i - a, t[5] = 1 - r - e, t[6] = l + o, t[7] = 0, t[8] = c + u, t[9] = l - o, t[10] = 1 - r - n, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;\n  }, frustum = function(t, a, r, n, e, o, u) {\n    var s = 1 / (r - a), i = 1 / (e - n), c = 1 / (o - u);\n    return t[0] = 2 * o * s, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 2 * o * i, t[6] = 0, t[7] = 0, t[8] = (r + a) * s, t[9] = (e + n) * i, t[10] = (u + o) * c, t[11] = -1, t[12] = 0, t[13] = 0, t[14] = u * o * 2 * c, t[15] = 0, t;\n  }, perspectiveNO = function(t, a, r, n, e) {\n    a = 1 / Math.tan(a / 2);\n    return t[0] = a / r, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = a, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, null != e && e !== 1 / 0 ? (t[10] = (e + n) * (r = 1 / (n - e)), t[14] = 2 * e * n * r) : (t[10] = -1, t[14] = -2 * n), t;\n  }, perspectiveZO = function(t, a, r, n, e) {\n    a = 1 / Math.tan(a / 2);\n    return t[0] = a / r, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = a, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, null != e && e !== 1 / 0 ? (t[10] = e * (r = 1 / (n - e)), t[14] = e * n * r) : (t[10] = -1, t[14] = -n), t;\n  }, perspectiveFromFieldOfView = function(t, a, r, n) {\n    var e = Math.tan(a.upDegrees * Math.PI / 180), o = Math.tan(a.downDegrees * Math.PI / 180), u = Math.tan(a.leftDegrees * Math.PI / 180), a = Math.tan(a.rightDegrees * Math.PI / 180), s = 2 / (u + a), i = 2 / (e + o);\n    return t[0] = s, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = i, t[6] = 0, t[7] = 0, t[8] = -(u - a) * s * 0.5, t[9] = (e - o) * i * 0.5, t[10] = n / (r - n), t[11] = -1, t[12] = 0, t[13] = 0, t[14] = n * r / (r - n), t[15] = 0, t;\n  }, orthoNO = function(t, a, r, n, e, o, u) {\n    var s = 1 / (a - r), i = 1 / (n - e), c = 1 / (o - u);\n    return t[0] = -2 * s, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * i, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 2 * c, t[11] = 0, t[12] = (a + r) * s, t[13] = (e + n) * i, t[14] = (u + o) * c, t[15] = 1, t;\n  }, orthoZO = function(t, a, r, n, e, o, u) {\n    var s = 1 / (a - r), i = 1 / (n - e), u = 1 / (o - u);\n    return t[0] = -2 * s, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * i, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = u, t[11] = 0, t[12] = (a + r) * s, t[13] = (e + n) * i, t[14] = o * u, t[15] = 1, t;\n  }, lookAt = function(t, a, r, n) {\n    var e, o, u, s, i = a[0], c = a[1], a = a[2], l = n[0], $ = n[1], n = n[2], h = r[0], f = r[1], r = r[2];\n    return Math.abs(i - h) < EPSILON && Math.abs(c - f) < EPSILON && Math.abs(a - r) < EPSILON ? identity$2(t) : (h = i - h, f = c - f, r = a - r, e = $ * (r *= s = 1 / Math.hypot(h, f, r)) - n * (f *= s), n = n * (h *= s) - l * r, l = l * f - $ * h, (s = Math.hypot(e, n, l)) ? (e *= s = 1 / s, n *= s, l *= s) : l = n = e = 0, $ = f * l - r * n, o = r * e - h * l, u = h * n - f * e, (s = Math.hypot($, o, u)) ? ($ *= s = 1 / s, o *= s, u *= s) : u = o = $ = 0, t[0] = e, t[1] = $, t[2] = h, t[3] = 0, t[4] = n, t[5] = o, t[6] = f, t[7] = 0, t[8] = l, t[9] = u, t[10] = r, t[11] = 0, t[12] = -(e * i + n * c + l * a), t[13] = -($ * i + o * c + u * a), t[14] = -(h * i + f * c + r * a), t[15] = 1, t);\n  }, targetTo = function(t, a, r, n) {\n    var e = a[0], o = a[1], a = a[2], u = n[0], s = n[1], n = n[2], i = e - r[0], c = o - r[1], r = a - r[2], l = i * i + c * c + r * r, $ = (0 < l && (i *= l = 1 / Math.sqrt(l), c *= l, r *= l), s * r - n * c), n = n * i - u * r, u = u * c - s * i;\n    return 0 < (l = $ * $ + n * n + u * u) && ($ *= l = 1 / Math.sqrt(l), n *= l, u *= l), t[0] = $, t[1] = n, t[2] = u, t[3] = 0, t[4] = c * u - r * n, t[5] = r * $ - i * u, t[6] = i * n - c * $, t[7] = 0, t[8] = i, t[9] = c, t[10] = r, t[11] = 0, t[12] = e, t[13] = o, t[14] = a, t[15] = 1, t;\n  }, str$5 = function(t) {\n    return \"mat4(\" + t[0] + \", \" + t[1] + \", \" + t[2] + \", \" + t[3] + \", \" + t[4] + \", \" + t[5] + \", \" + t[6] + \", \" + t[7] + \", \" + t[8] + \", \" + t[9] + \", \" + t[10] + \", \" + t[11] + \", \" + t[12] + \", \" + t[13] + \", \" + t[14] + \", \" + t[15] + \")\";\n  }, frob = function(t) {\n    return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8], t[9], t[10], t[11], t[12], t[13], t[14], t[15]);\n  }, add$5 = function(t, a, r) {\n    return t[0] = a[0] + r[0], t[1] = a[1] + r[1], t[2] = a[2] + r[2], t[3] = a[3] + r[3], t[4] = a[4] + r[4], t[5] = a[5] + r[5], t[6] = a[6] + r[6], t[7] = a[7] + r[7], t[8] = a[8] + r[8], t[9] = a[9] + r[9], t[10] = a[10] + r[10], t[11] = a[11] + r[11], t[12] = a[12] + r[12], t[13] = a[13] + r[13], t[14] = a[14] + r[14], t[15] = a[15] + r[15], t;\n  }, subtract$3 = function(t, a, r) {\n    return t[0] = a[0] - r[0], t[1] = a[1] - r[1], t[2] = a[2] - r[2], t[3] = a[3] - r[3], t[4] = a[4] - r[4], t[5] = a[5] - r[5], t[6] = a[6] - r[6], t[7] = a[7] - r[7], t[8] = a[8] - r[8], t[9] = a[9] - r[9], t[10] = a[10] - r[10], t[11] = a[11] - r[11], t[12] = a[12] - r[12], t[13] = a[13] - r[13], t[14] = a[14] - r[14], t[15] = a[15] - r[15], t;\n  }, multiplyScalar = function(t, a, r) {\n    return t[0] = a[0] * r, t[1] = a[1] * r, t[2] = a[2] * r, t[3] = a[3] * r, t[4] = a[4] * r, t[5] = a[5] * r, t[6] = a[6] * r, t[7] = a[7] * r, t[8] = a[8] * r, t[9] = a[9] * r, t[10] = a[10] * r, t[11] = a[11] * r, t[12] = a[12] * r, t[13] = a[13] * r, t[14] = a[14] * r, t[15] = a[15] * r, t;\n  }, multiplyScalarAndAdd = function(t, a, r, n) {\n    return t[0] = a[0] + r[0] * n, t[1] = a[1] + r[1] * n, t[2] = a[2] + r[2] * n, t[3] = a[3] + r[3] * n, t[4] = a[4] + r[4] * n, t[5] = a[5] + r[5] * n, t[6] = a[6] + r[6] * n, t[7] = a[7] + r[7] * n, t[8] = a[8] + r[8] * n, t[9] = a[9] + r[9] * n, t[10] = a[10] + r[10] * n, t[11] = a[11] + r[11] * n, t[12] = a[12] + r[12] * n, t[13] = a[13] + r[13] * n, t[14] = a[14] + r[14] * n, t[15] = a[15] + r[15] * n, t;\n  }, exactEquals$5 = function(t, a) {\n    return t[0] === a[0] && t[1] === a[1] && t[2] === a[2] && t[3] === a[3] && t[4] === a[4] && t[5] === a[5] && t[6] === a[6] && t[7] === a[7] && t[8] === a[8] && t[9] === a[9] && t[10] === a[10] && t[11] === a[11] && t[12] === a[12] && t[13] === a[13] && t[14] === a[14] && t[15] === a[15];\n  }, equals$5 = function(t, a) {\n    var r = t[0], n = t[1], e = t[2], o = t[3], u = t[4], s = t[5], i = t[6], c = t[7], l = t[8], $ = t[9], h = t[10], f = t[11], M = t[12], m = t[13], d = t[14], t = t[15], v = a[0], b = a[1], p = a[2], A = a[3], y = a[4], g = a[5], R = a[6], E = a[7], q = a[8], x = a[9], P = a[10], L = a[11], O = a[12], S = a[13], Y = a[14], a = a[15];\n    return Math.abs(r - v) <= EPSILON * Math.max(1, Math.abs(r), Math.abs(v)) && Math.abs(n - b) <= EPSILON * Math.max(1, Math.abs(n), Math.abs(b)) && Math.abs(e - p) <= EPSILON * Math.max(1, Math.abs(e), Math.abs(p)) && Math.abs(o - A) <= EPSILON * Math.max(1, Math.abs(o), Math.abs(A)) && Math.abs(u - y) <= EPSILON * Math.max(1, Math.abs(u), Math.abs(y)) && Math.abs(s - g) <= EPSILON * Math.max(1, Math.abs(s), Math.abs(g)) && Math.abs(i - R) <= EPSILON * Math.max(1, Math.abs(i), Math.abs(R)) && Math.abs(c - E) <= EPSILON * Math.max(1, Math.abs(c), Math.abs(E)) && Math.abs(l - q) <= EPSILON * Math.max(1, Math.abs(l), Math.abs(q)) && Math.abs($ - x) <= EPSILON * Math.max(1, Math.abs($), Math.abs(x)) && Math.abs(h - P) <= EPSILON * Math.max(1, Math.abs(h), Math.abs(P)) && Math.abs(f - L) <= EPSILON * Math.max(1, Math.abs(f), Math.abs(L)) && Math.abs(M - O) <= EPSILON * Math.max(1, Math.abs(M), Math.abs(O)) && Math.abs(m - S) <= EPSILON * Math.max(1, Math.abs(m), Math.abs(S)) && Math.abs(d - Y) <= EPSILON * Math.max(1, Math.abs(d), Math.abs(Y)) && Math.abs(t - a) <= EPSILON * Math.max(1, Math.abs(t), Math.abs(a));\n  }, create$4 = function() {\n    var t = new ARRAY_TYPE(3);\n    return ARRAY_TYPE != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t;\n  }, clone$4 = function(t) {\n    var a = new ARRAY_TYPE(3);\n    return a[0] = t[0], a[1] = t[1], a[2] = t[2], a;\n  }, length$4 = function(t) {\n    var a = t[0];\n    return Math.hypot(a, t[1], t[2]);\n  }, fromValues$4 = function(t, a, r) {\n    var n = new ARRAY_TYPE(3);\n    return n[0] = t, n[1] = a, n[2] = r, n;\n  }, copy$4 = function(t, a) {\n    return t[0] = a[0], t[1] = a[1], t[2] = a[2], t;\n  }, set$4 = function(t, a, r, n) {\n    return t[0] = a, t[1] = r, t[2] = n, t;\n  }, add$4 = function(t, a, r) {\n    return t[0] = a[0] + r[0], t[1] = a[1] + r[1], t[2] = a[2] + r[2], t;\n  }, subtract$2 = function(t, a, r) {\n    return t[0] = a[0] - r[0], t[1] = a[1] - r[1], t[2] = a[2] - r[2], t;\n  }, multiply$4 = function(t, a, r) {\n    return t[0] = a[0] * r[0], t[1] = a[1] * r[1], t[2] = a[2] * r[2], t;\n  }, divide$2 = function(t, a, r) {\n    return t[0] = a[0] / r[0], t[1] = a[1] / r[1], t[2] = a[2] / r[2], t;\n  }, ceil$2 = function(t, a) {\n    return t[0] = Math.ceil(a[0]), t[1] = Math.ceil(a[1]), t[2] = Math.ceil(a[2]), t;\n  }, floor$2 = function(t, a) {\n    return t[0] = Math.floor(a[0]), t[1] = Math.floor(a[1]), t[2] = Math.floor(a[2]), t;\n  }, min$2 = function(t, a, r) {\n    return t[0] = Math.min(a[0], r[0]), t[1] = Math.min(a[1], r[1]), t[2] = Math.min(a[2], r[2]), t;\n  }, max$2 = function(t, a, r) {\n    return t[0] = Math.max(a[0], r[0]), t[1] = Math.max(a[1], r[1]), t[2] = Math.max(a[2], r[2]), t;\n  }, round$2 = function(t, a) {\n    return t[0] = Math.round(a[0]), t[1] = Math.round(a[1]), t[2] = Math.round(a[2]), t;\n  }, scale$4 = function(t, a, r) {\n    return t[0] = a[0] * r, t[1] = a[1] * r, t[2] = a[2] * r, t;\n  }, scaleAndAdd$2 = function(t, a, r, n) {\n    return t[0] = a[0] + r[0] * n, t[1] = a[1] + r[1] * n, t[2] = a[2] + r[2] * n, t;\n  }, distance$2 = function(t, a) {\n    var r = a[0] - t[0];\n    return Math.hypot(r, a[1] - t[1], a[2] - t[2]);\n  }, squaredDistance$2 = function(t, a) {\n    var r = a[0] - t[0], n = a[1] - t[1], a = a[2] - t[2];\n    return r * r + n * n + a * a;\n  }, squaredLength$4 = function(t) {\n    var a = t[0], r = t[1], t = t[2];\n    return a * a + r * r + t * t;\n  }, negate$2 = function(t, a) {\n    return t[0] = -a[0], t[1] = -a[1], t[2] = -a[2], t;\n  }, inverse$2 = function(t, a) {\n    return t[0] = 1 / a[0], t[1] = 1 / a[1], t[2] = 1 / a[2], t;\n  }, normalize$4 = function(t, a) {\n    var r = a[0], n = a[1], e = a[2], r = r * r + n * n + e * e;\n    return 0 < r && (r = 1 / Math.sqrt(r)), t[0] = a[0] * r, t[1] = a[1] * r, t[2] = a[2] * r, t;\n  }, dot$4 = function(t, a) {\n    return t[0] * a[0] + t[1] * a[1] + t[2] * a[2];\n  }, cross$2 = function(t, a, r) {\n    var n = a[0], e = a[1], a = a[2], o = r[0], u = r[1], r = r[2];\n    return t[0] = e * r - a * u, t[1] = a * o - n * r, t[2] = n * u - e * o, t;\n  }, lerp$4 = function(t, a, r, n) {\n    var e = a[0], o = a[1], a = a[2];\n    return t[0] = e + n * (r[0] - e), t[1] = o + n * (r[1] - o), t[2] = a + n * (r[2] - a), t;\n  }, slerp$1 = function(t, a, r, n) {\n    var e = Math.acos(Math.min(Math.max(dot$4(a, r), -1), 1)), o = Math.sin(e), u = Math.sin((1 - n) * e) / o, n = Math.sin(n * e) / o;\n    return t[0] = u * a[0] + n * r[0], t[1] = u * a[1] + n * r[1], t[2] = u * a[2] + n * r[2], t;\n  }, hermite = function(t, a, r, n, e, o) {\n    var u = o * o, s = u * (2 * o - 3) + 1, i = u * (o - 2) + o, c = u * (o - 1), u = u * (3 - 2 * o);\n    return t[0] = a[0] * s + r[0] * i + n[0] * c + e[0] * u, t[1] = a[1] * s + r[1] * i + n[1] * c + e[1] * u, t[2] = a[2] * s + r[2] * i + n[2] * c + e[2] * u, t;\n  }, bezier = function(t, a, r, n, e, o) {\n    var u = 1 - o, s = u * u, i = o * o, c = s * u, s = 3 * o * s, u = 3 * i * u, i = i * o;\n    return t[0] = a[0] * c + r[0] * s + n[0] * u + e[0] * i, t[1] = a[1] * c + r[1] * s + n[1] * u + e[1] * i, t[2] = a[2] * c + r[2] * s + n[2] * u + e[2] * i, t;\n  }, random$3 = function(t, a) {\n    a = a || 1;\n    var r = 2 * RANDOM() * Math.PI, n = 2 * RANDOM() - 1, e = Math.sqrt(1 - n * n) * a;\n    return t[0] = Math.cos(r) * e, t[1] = Math.sin(r) * e, t[2] = n * a, t;\n  }, transformMat4$2 = function(t, a, r) {\n    var n = a[0], e = a[1], a = a[2], o = r[3] * n + r[7] * e + r[11] * a + r[15];\n    return t[0] = (r[0] * n + r[4] * e + r[8] * a + r[12]) / (o = o || 1), t[1] = (r[1] * n + r[5] * e + r[9] * a + r[13]) / o, t[2] = (r[2] * n + r[6] * e + r[10] * a + r[14]) / o, t;\n  }, transformMat3$1 = function(t, a, r) {\n    var n = a[0], e = a[1], a = a[2];\n    return t[0] = n * r[0] + e * r[3] + a * r[6], t[1] = n * r[1] + e * r[4] + a * r[7], t[2] = n * r[2] + e * r[5] + a * r[8], t;\n  }, transformQuat$1 = function(t, a, r) {\n    var n = r[0], e = r[1], o = r[2], u = a[0], s = a[1], a = a[2], i = e * a - o * s, c = o * u - n * a, l = n * s - e * u, $ = e * l - o * c, o = o * i - n * l, n = n * c - e * i, e = 2 * r[3];\n    return c *= e, l *= e, o *= 2, n *= 2, t[0] = u + (i *= e) + ($ *= 2), t[1] = s + c + o, t[2] = a + l + n, t;\n  }, rotateX$2 = function(t, a, r, n) {\n    var e = [], o = [];\n    return e[0] = a[0] - r[0], e[1] = a[1] - r[1], e[2] = a[2] - r[2], o[0] = e[0], o[1] = e[1] * Math.cos(n) - e[2] * Math.sin(n), o[2] = e[1] * Math.sin(n) + e[2] * Math.cos(n), t[0] = o[0] + r[0], t[1] = o[1] + r[1], t[2] = o[2] + r[2], t;\n  }, rotateY$2 = function(t, a, r, n) {\n    var e = [], o = [];\n    return e[0] = a[0] - r[0], e[1] = a[1] - r[1], e[2] = a[2] - r[2], o[0] = e[2] * Math.sin(n) + e[0] * Math.cos(n), o[1] = e[1], o[2] = e[2] * Math.cos(n) - e[0] * Math.sin(n), t[0] = o[0] + r[0], t[1] = o[1] + r[1], t[2] = o[2] + r[2], t;\n  }, rotateZ$2 = function(t, a, r, n) {\n    var e = [], o = [];\n    return e[0] = a[0] - r[0], e[1] = a[1] - r[1], e[2] = a[2] - r[2], o[0] = e[0] * Math.cos(n) - e[1] * Math.sin(n), o[1] = e[0] * Math.sin(n) + e[1] * Math.cos(n), o[2] = e[2], t[0] = o[0] + r[0], t[1] = o[1] + r[1], t[2] = o[2] + r[2], t;\n  }, angle$1 = function(t, a) {\n    var r = t[0], n = t[1], e = t[2], o = a[0], u = a[1], s = a[2], r = Math.sqrt((r * r + n * n + e * e) * (o * o + u * u + s * s)), n = r && dot$4(t, a) / r;\n    return Math.acos(Math.min(Math.max(n, -1), 1));\n  }, zero$2 = function(t) {\n    return t[0] = 0, t[1] = 0, t[2] = 0, t;\n  }, str$4 = function(t) {\n    return \"vec3(\" + t[0] + \", \" + t[1] + \", \" + t[2] + \")\";\n  }, exactEquals$4 = function(t, a) {\n    return t[0] === a[0] && t[1] === a[1] && t[2] === a[2];\n  }, equals$4 = function(t, a) {\n    var r = t[0], n = t[1], t = t[2], e = a[0], o = a[1], a = a[2];\n    return Math.abs(r - e) <= EPSILON * Math.max(1, Math.abs(r), Math.abs(e)) && Math.abs(n - o) <= EPSILON * Math.max(1, Math.abs(n), Math.abs(o)) && Math.abs(t - a) <= EPSILON * Math.max(1, Math.abs(t), Math.abs(a));\n  }, create$3 = function() {\n    var t = new ARRAY_TYPE(4);\n    return ARRAY_TYPE != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0), t;\n  }, clone$3 = function(t) {\n    var a = new ARRAY_TYPE(4);\n    return a[0] = t[0], a[1] = t[1], a[2] = t[2], a[3] = t[3], a;\n  }, fromValues$3 = function(t, a, r, n) {\n    var e = new ARRAY_TYPE(4);\n    return e[0] = t, e[1] = a, e[2] = r, e[3] = n, e;\n  }, copy$3 = function(t, a) {\n    return t[0] = a[0], t[1] = a[1], t[2] = a[2], t[3] = a[3], t;\n  }, set$3 = function(t, a, r, n, e) {\n    return t[0] = a, t[1] = r, t[2] = n, t[3] = e, t;\n  }, add$3 = function(t, a, r) {\n    return t[0] = a[0] + r[0], t[1] = a[1] + r[1], t[2] = a[2] + r[2], t[3] = a[3] + r[3], t;\n  }, subtract$1 = function(t, a, r) {\n    return t[0] = a[0] - r[0], t[1] = a[1] - r[1], t[2] = a[2] - r[2], t[3] = a[3] - r[3], t;\n  }, multiply$3 = function(t, a, r) {\n    return t[0] = a[0] * r[0], t[1] = a[1] * r[1], t[2] = a[2] * r[2], t[3] = a[3] * r[3], t;\n  }, divide$1 = function(t, a, r) {\n    return t[0] = a[0] / r[0], t[1] = a[1] / r[1], t[2] = a[2] / r[2], t[3] = a[3] / r[3], t;\n  }, ceil$1 = function(t, a) {\n    return t[0] = Math.ceil(a[0]), t[1] = Math.ceil(a[1]), t[2] = Math.ceil(a[2]), t[3] = Math.ceil(a[3]), t;\n  }, floor$1 = function(t, a) {\n    return t[0] = Math.floor(a[0]), t[1] = Math.floor(a[1]), t[2] = Math.floor(a[2]), t[3] = Math.floor(a[3]), t;\n  }, min$1 = function(t, a, r) {\n    return t[0] = Math.min(a[0], r[0]), t[1] = Math.min(a[1], r[1]), t[2] = Math.min(a[2], r[2]), t[3] = Math.min(a[3], r[3]), t;\n  }, max$1 = function(t, a, r) {\n    return t[0] = Math.max(a[0], r[0]), t[1] = Math.max(a[1], r[1]), t[2] = Math.max(a[2], r[2]), t[3] = Math.max(a[3], r[3]), t;\n  }, round$1 = function(t, a) {\n    return t[0] = Math.round(a[0]), t[1] = Math.round(a[1]), t[2] = Math.round(a[2]), t[3] = Math.round(a[3]), t;\n  }, scale$3 = function(t, a, r) {\n    return t[0] = a[0] * r, t[1] = a[1] * r, t[2] = a[2] * r, t[3] = a[3] * r, t;\n  }, scaleAndAdd$1 = function(t, a, r, n) {\n    return t[0] = a[0] + r[0] * n, t[1] = a[1] + r[1] * n, t[2] = a[2] + r[2] * n, t[3] = a[3] + r[3] * n, t;\n  }, distance$1 = function(t, a) {\n    var r = a[0] - t[0];\n    return Math.hypot(r, a[1] - t[1], a[2] - t[2], a[3] - t[3]);\n  }, squaredDistance$1 = function(t, a) {\n    var r = a[0] - t[0], n = a[1] - t[1], e = a[2] - t[2], a = a[3] - t[3];\n    return r * r + n * n + e * e + a * a;\n  }, length$3 = function(t) {\n    var a = t[0];\n    return Math.hypot(a, t[1], t[2], t[3]);\n  }, squaredLength$3 = function(t) {\n    var a = t[0], r = t[1], n = t[2], t = t[3];\n    return a * a + r * r + n * n + t * t;\n  }, negate$1 = function(t, a) {\n    return t[0] = -a[0], t[1] = -a[1], t[2] = -a[2], t[3] = -a[3], t;\n  }, inverse$1 = function(t, a) {\n    return t[0] = 1 / a[0], t[1] = 1 / a[1], t[2] = 1 / a[2], t[3] = 1 / a[3], t;\n  }, normalize$3 = function(t, a) {\n    var r = a[0], n = a[1], e = a[2], a = a[3], o = r * r + n * n + e * e + a * a;\n    return 0 < o && (o = 1 / Math.sqrt(o)), t[0] = r * o, t[1] = n * o, t[2] = e * o, t[3] = a * o, t;\n  }, dot$3 = function(t, a) {\n    return t[0] * a[0] + t[1] * a[1] + t[2] * a[2] + t[3] * a[3];\n  }, cross$1 = function(t, a, r, n) {\n    var e = r[0] * n[1] - r[1] * n[0], o = r[0] * n[2] - r[2] * n[0], u = r[0] * n[3] - r[3] * n[0], s = r[1] * n[2] - r[2] * n[1], i = r[1] * n[3] - r[3] * n[1], r = r[2] * n[3] - r[3] * n[2], n = a[0], c = a[1], l = a[2], a = a[3];\n    return t[0] = c * r - l * i + a * s, t[1] = -n * r + l * u - a * o, t[2] = n * i - c * u + a * e, t[3] = -n * s + c * o - l * e, t;\n  }, lerp$3 = function(t, a, r, n) {\n    var e = a[0], o = a[1], u = a[2], a = a[3];\n    return t[0] = e + n * (r[0] - e), t[1] = o + n * (r[1] - o), t[2] = u + n * (r[2] - u), t[3] = a + n * (r[3] - a), t;\n  }, random$2 = function(t, a) {\n    var r, n, e, o, u, s;\n    for (a = a || 1; 1 <= (u = (r = 2 * RANDOM() - 1) * r + (n = 2 * RANDOM() - 1) * n); ) ;\n    for (; 1 <= (s = (e = 2 * RANDOM() - 1) * e + (o = 2 * RANDOM() - 1) * o); ) ;\n    var i = Math.sqrt((1 - u) / s);\n    return t[0] = a * r, t[1] = a * n, t[2] = a * e * i, t[3] = a * o * i, t;\n  }, transformMat4$1 = function(t, a, r) {\n    var n = a[0], e = a[1], o = a[2], a = a[3];\n    return t[0] = r[0] * n + r[4] * e + r[8] * o + r[12] * a, t[1] = r[1] * n + r[5] * e + r[9] * o + r[13] * a, t[2] = r[2] * n + r[6] * e + r[10] * o + r[14] * a, t[3] = r[3] * n + r[7] * e + r[11] * o + r[15] * a, t;\n  }, transformQuat = function(t, a, r) {\n    var n = a[0], e = a[1], o = a[2], u = r[0], s = r[1], i = r[2], r = r[3], c = r * n + s * o - i * e, l = r * e + i * n - u * o, $ = r * o + u * e - s * n, n = -u * n - s * e - i * o;\n    return t[0] = c * r + n * -u + l * -i - $ * -s, t[1] = l * r + n * -s + $ * -u - c * -i, t[2] = $ * r + n * -i + c * -s - l * -u, t[3] = a[3], t;\n  }, zero$1 = function(t) {\n    return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0, t;\n  }, str$3 = function(t) {\n    return \"vec4(\" + t[0] + \", \" + t[1] + \", \" + t[2] + \", \" + t[3] + \")\";\n  }, exactEquals$3 = function(t, a) {\n    return t[0] === a[0] && t[1] === a[1] && t[2] === a[2] && t[3] === a[3];\n  }, equals$3 = function(t, a) {\n    var r = t[0], n = t[1], e = t[2], t = t[3], o = a[0], u = a[1], s = a[2], a = a[3];\n    return Math.abs(r - o) <= EPSILON * Math.max(1, Math.abs(r), Math.abs(o)) && Math.abs(n - u) <= EPSILON * Math.max(1, Math.abs(n), Math.abs(u)) && Math.abs(e - s) <= EPSILON * Math.max(1, Math.abs(e), Math.abs(s)) && Math.abs(t - a) <= EPSILON * Math.max(1, Math.abs(t), Math.abs(a));\n  }, create$2 = function() {\n    var t = new ARRAY_TYPE(4);\n    return ARRAY_TYPE != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t[3] = 1, t;\n  }, identity$1 = function(t) {\n    return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t;\n  }, setAxisAngle = function(t, a, r) {\n    r *= 0.5;\n    var n = Math.sin(r);\n    return t[0] = n * a[0], t[1] = n * a[1], t[2] = n * a[2], t[3] = Math.cos(r), t;\n  }, getAxisAngle = function(t, a) {\n    var r = 2 * Math.acos(a[3]), n = Math.sin(r / 2);\n    return EPSILON < n ? (t[0] = a[0] / n, t[1] = a[1] / n, t[2] = a[2] / n) : (t[0] = 1, t[1] = 0, t[2] = 0), r;\n  }, getAngle = function(t, a) {\n    t = dot$2(t, a);\n    return Math.acos(2 * t * t - 1);\n  }, multiply$2 = function(t, a, r) {\n    var n = a[0], e = a[1], o = a[2], a = a[3], u = r[0], s = r[1], i = r[2], r = r[3];\n    return t[0] = n * r + a * u + e * i - o * s, t[1] = e * r + a * s + o * u - n * i, t[2] = o * r + a * i + n * s - e * u, t[3] = a * r - n * u - e * s - o * i, t;\n  }, rotateX$1 = function(t, a, r) {\n    r *= 0.5;\n    var n = a[0], e = a[1], o = a[2], a = a[3], u = Math.sin(r), r = Math.cos(r);\n    return t[0] = n * r + a * u, t[1] = e * r + o * u, t[2] = o * r - e * u, t[3] = a * r - n * u, t;\n  }, rotateY$1 = function(t, a, r) {\n    r *= 0.5;\n    var n = a[0], e = a[1], o = a[2], a = a[3], u = Math.sin(r), r = Math.cos(r);\n    return t[0] = n * r - o * u, t[1] = e * r + a * u, t[2] = o * r + n * u, t[3] = a * r - e * u, t;\n  }, rotateZ$1 = function(t, a, r) {\n    r *= 0.5;\n    var n = a[0], e = a[1], o = a[2], a = a[3], u = Math.sin(r), r = Math.cos(r);\n    return t[0] = n * r + e * u, t[1] = e * r - n * u, t[2] = o * r + a * u, t[3] = a * r - o * u, t;\n  }, calculateW = function(t, a) {\n    var r = a[0], n = a[1], a = a[2];\n    return t[0] = r, t[1] = n, t[2] = a, t[3] = Math.sqrt(Math.abs(1 - r * r - n * n - a * a)), t;\n  }, exp = function(t, a) {\n    var r = a[0], n = a[1], e = a[2], a = a[3], o = Math.sqrt(r * r + n * n + e * e), a = Math.exp(a), u = 0 < o ? a * Math.sin(o) / o : 0;\n    return t[0] = r * u, t[1] = n * u, t[2] = e * u, t[3] = a * Math.cos(o), t;\n  }, ln = function(t, a) {\n    var r = a[0], n = a[1], e = a[2], a = a[3], o = Math.sqrt(r * r + n * n + e * e), o = 0 < o ? Math.atan2(o, a) / o : 0;\n    return t[0] = r * o, t[1] = n * o, t[2] = e * o, t[3] = 0.5 * Math.log(r * r + n * n + e * e + a * a), t;\n  }, pow = function(t, a, r) {\n    return ln(t, a), scale$2(t, t, r), exp(t, t), t;\n  }, slerp = function(t, a, r, n) {\n    var e, o, u = a[0], s = a[1], i = a[2], a = a[3], c = r[0], l = r[1], $ = r[2], r = r[3], h = u * c + s * l + i * $ + a * r;\n    return h < 0 && (h = -h, c = -c, l = -l, $ = -$, r = -r), h = EPSILON < 1 - h ? (h = Math.acos(h), e = Math.sin(h), o = Math.sin((1 - n) * h) / e, Math.sin(n * h) / e) : (o = 1 - n, n), t[0] = o * u + h * c, t[1] = o * s + h * l, t[2] = o * i + h * $, t[3] = o * a + h * r, t;\n  }, random$1 = function(t) {\n    var a = RANDOM(), r = RANDOM(), n = RANDOM(), e = Math.sqrt(1 - a), a = Math.sqrt(a);\n    return t[0] = e * Math.sin(2 * Math.PI * r), t[1] = e * Math.cos(2 * Math.PI * r), t[2] = a * Math.sin(2 * Math.PI * n), t[3] = a * Math.cos(2 * Math.PI * n), t;\n  }, invert$1 = function(t, a) {\n    var r = a[0], n = a[1], e = a[2], a = a[3], o = r * r + n * n + e * e + a * a, o = o ? 1 / o : 0;\n    return t[0] = -r * o, t[1] = -n * o, t[2] = -e * o, t[3] = a * o, t;\n  }, conjugate$1 = function(t, a) {\n    return t[0] = -a[0], t[1] = -a[1], t[2] = -a[2], t[3] = a[3], t;\n  }, fromMat3 = function(t, a) {\n    var r, n, e, o = a[0] + a[4] + a[8];\n    return 0 < o ? (e = Math.sqrt(o + 1), t[3] = 0.5 * e, t[0] = (a[5] - a[7]) * (e = 0.5 / e), t[1] = (a[6] - a[2]) * e, t[2] = (a[1] - a[3]) * e) : (r = ((o = a[3 * (o = a[4] > a[o = 0] ? 1 : o) + o] < a[8] ? 2 : o) + 1) % 3, n = (o + 2) % 3, e = Math.sqrt(a[3 * o + o] - a[3 * r + r] - a[3 * n + n] + 1), t[o] = 0.5 * e, t[3] = (a[3 * r + n] - a[3 * n + r]) * (e = 0.5 / e), t[r] = (a[3 * r + o] + a[3 * o + r]) * e, t[n] = (a[3 * n + o] + a[3 * o + n]) * e), t;\n  }, fromEuler = function(t, a, r, n) {\n    var e = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : ANGLE_ORDER, o = Math.PI / 360, u = (n *= o, r *= o, Math.sin(a *= o)), s = Math.cos(a), i = Math.sin(r), c = Math.cos(r), l = Math.sin(n), $ = Math.cos(n);\n    switch (e) {\n      case \"xyz\":\n        t[0] = u * c * $ + s * i * l, t[1] = s * i * $ - u * c * l, t[2] = s * c * l + u * i * $, t[3] = s * c * $ - u * i * l;\n        break;\n      case \"xzy\":\n        t[0] = u * c * $ - s * i * l, t[1] = s * i * $ - u * c * l, t[2] = s * c * l + u * i * $, t[3] = s * c * $ + u * i * l;\n        break;\n      case \"yxz\":\n        t[0] = u * c * $ + s * i * l, t[1] = s * i * $ - u * c * l, t[2] = s * c * l - u * i * $, t[3] = s * c * $ + u * i * l;\n        break;\n      case \"yzx\":\n        t[0] = u * c * $ + s * i * l, t[1] = s * i * $ + u * c * l, t[2] = s * c * l - u * i * $, t[3] = s * c * $ - u * i * l;\n        break;\n      case \"zxy\":\n        t[0] = u * c * $ - s * i * l, t[1] = s * i * $ + u * c * l, t[2] = s * c * l + u * i * $, t[3] = s * c * $ - u * i * l;\n        break;\n      case \"zyx\":\n        t[0] = u * c * $ - s * i * l, t[1] = s * i * $ + u * c * l, t[2] = s * c * l - u * i * $, t[3] = s * c * $ + u * i * l;\n        break;\n      default:\n        throw new Error(\"Unknown angle order \" + e);\n    }\n    return t;\n  }, str$2 = function(t) {\n    return \"quat(\" + t[0] + \", \" + t[1] + \", \" + t[2] + \", \" + t[3] + \")\";\n  }, equals$2 = function(t, a) {\n    return Math.abs(dot$3(t, a)) >= 1 - EPSILON;\n  }, create$1 = function() {\n    var t = new ARRAY_TYPE(8);\n    return ARRAY_TYPE != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0, t[4] = 0, t[5] = 0, t[6] = 0, t[7] = 0), t[3] = 1, t;\n  }, clone$1 = function(t) {\n    var a = new ARRAY_TYPE(8);\n    return a[0] = t[0], a[1] = t[1], a[2] = t[2], a[3] = t[3], a[4] = t[4], a[5] = t[5], a[6] = t[6], a[7] = t[7], a;\n  }, fromValues$1 = function(t, a, r, n, e, o, u, s) {\n    var i = new ARRAY_TYPE(8);\n    return i[0] = t, i[1] = a, i[2] = r, i[3] = n, i[4] = e, i[5] = o, i[6] = u, i[7] = s, i;\n  }, fromRotationTranslationValues = function(t, a, r, n, e, o, u) {\n    var s = new ARRAY_TYPE(8), e = (s[0] = t, s[1] = a, s[2] = r, s[3] = n, 0.5 * e), o = 0.5 * o, u = 0.5 * u;\n    return s[4] = e * n + o * r - u * a, s[5] = o * n + u * t - e * r, s[6] = u * n + e * a - o * t, s[7] = -e * t - o * a - u * r, s;\n  }, fromRotationTranslation = function(t, a, r) {\n    var n = 0.5 * r[0], e = 0.5 * r[1], r = 0.5 * r[2], o = a[0], u = a[1], s = a[2], a = a[3];\n    return t[0] = o, t[1] = u, t[2] = s, t[3] = a, t[4] = n * a + e * s - r * u, t[5] = e * a + r * o - n * s, t[6] = r * a + n * u - e * o, t[7] = -n * o - e * u - r * s, t;\n  }, fromTranslation = function(t, a) {\n    return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0.5 * a[0], t[5] = 0.5 * a[1], t[6] = 0.5 * a[2], t[7] = 0, t;\n  }, fromRotation = function(t, a) {\n    return t[0] = a[0], t[1] = a[1], t[2] = a[2], t[3] = a[3], t[4] = 0, t[5] = 0, t[6] = 0, t[7] = 0, t;\n  }, fromMat4 = function(t, a) {\n    var r = create$2(), n = (getRotation(r, a), new ARRAY_TYPE(3));\n    return getTranslation$1(n, a), fromRotationTranslation(t, r, n), t;\n  }, copy$1 = function(t, a) {\n    return t[0] = a[0], t[1] = a[1], t[2] = a[2], t[3] = a[3], t[4] = a[4], t[5] = a[5], t[6] = a[6], t[7] = a[7], t;\n  }, identity = function(t) {\n    return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t[6] = 0, t[7] = 0, t;\n  }, set$1 = function(t, a, r, n, e, o, u, s, i) {\n    return t[0] = a, t[1] = r, t[2] = n, t[3] = e, t[4] = o, t[5] = u, t[6] = s, t[7] = i, t;\n  }, getDual = function(t, a) {\n    return t[0] = a[4], t[1] = a[5], t[2] = a[6], t[3] = a[7], t;\n  }, setDual = function(t, a) {\n    return t[4] = a[0], t[5] = a[1], t[6] = a[2], t[7] = a[3], t;\n  }, getTranslation = function(t, a) {\n    var r = a[4], n = a[5], e = a[6], o = a[7], u = -a[0], s = -a[1], i = -a[2], a = a[3];\n    return t[0] = 2 * (r * a + o * u + n * i - e * s), t[1] = 2 * (n * a + o * s + e * u - r * i), t[2] = 2 * (e * a + o * i + r * s - n * u), t;\n  }, translate = function(t, a, r) {\n    var n = a[0], e = a[1], o = a[2], u = a[3], s = 0.5 * r[0], i = 0.5 * r[1], r = 0.5 * r[2], c = a[4], l = a[5], $ = a[6], a = a[7];\n    return t[0] = n, t[1] = e, t[2] = o, t[3] = u, t[4] = u * s + e * r - o * i + c, t[5] = u * i + o * s - n * r + l, t[6] = u * r + n * i - e * s + $, t[7] = -n * s - e * i - o * r + a, t;\n  }, rotateX = function(t, a, r) {\n    var n = -a[0], e = -a[1], o = -a[2], u = a[3], s = a[4], i = a[5], c = a[6], l = a[7], $ = s * u + l * n + i * o - c * e, h = i * u + l * e + c * n - s * o, f = c * u + l * o + s * e - i * n, l = l * u - s * n - i * e - c * o;\n    return rotateX$1(t, a, r), n = t[0], t[4] = $ * (u = t[3]) + l * n + h * (o = t[2]) - f * (e = t[1]), t[5] = h * u + l * e + f * n - $ * o, t[6] = f * u + l * o + $ * e - h * n, t[7] = l * u - $ * n - h * e - f * o, t;\n  }, rotateY = function(t, a, r) {\n    var n = -a[0], e = -a[1], o = -a[2], u = a[3], s = a[4], i = a[5], c = a[6], l = a[7], $ = s * u + l * n + i * o - c * e, h = i * u + l * e + c * n - s * o, f = c * u + l * o + s * e - i * n, l = l * u - s * n - i * e - c * o;\n    return rotateY$1(t, a, r), n = t[0], t[4] = $ * (u = t[3]) + l * n + h * (o = t[2]) - f * (e = t[1]), t[5] = h * u + l * e + f * n - $ * o, t[6] = f * u + l * o + $ * e - h * n, t[7] = l * u - $ * n - h * e - f * o, t;\n  }, rotateZ = function(t, a, r) {\n    var n = -a[0], e = -a[1], o = -a[2], u = a[3], s = a[4], i = a[5], c = a[6], l = a[7], $ = s * u + l * n + i * o - c * e, h = i * u + l * e + c * n - s * o, f = c * u + l * o + s * e - i * n, l = l * u - s * n - i * e - c * o;\n    return rotateZ$1(t, a, r), n = t[0], t[4] = $ * (u = t[3]) + l * n + h * (o = t[2]) - f * (e = t[1]), t[5] = h * u + l * e + f * n - $ * o, t[6] = f * u + l * o + $ * e - h * n, t[7] = l * u - $ * n - h * e - f * o, t;\n  }, rotateByQuatAppend = function(t, a, r) {\n    var n = r[0], e = r[1], o = r[2], r = r[3], u = a[0], s = a[1], i = a[2], c = a[3];\n    return t[0] = u * r + c * n + s * o - i * e, t[1] = s * r + c * e + i * n - u * o, t[2] = i * r + c * o + u * e - s * n, t[3] = c * r - u * n - s * e - i * o, t[4] = (u = a[4]) * r + (c = a[7]) * n + (s = a[5]) * o - (i = a[6]) * e, t[5] = s * r + c * e + i * n - u * o, t[6] = i * r + c * o + u * e - s * n, t[7] = c * r - u * n - s * e - i * o, t;\n  }, rotateByQuatPrepend = function(t, a, r) {\n    var n = a[0], e = a[1], o = a[2], a = a[3], u = r[0], s = r[1], i = r[2], c = r[3];\n    return t[0] = n * c + a * u + e * i - o * s, t[1] = e * c + a * s + o * u - n * i, t[2] = o * c + a * i + n * s - e * u, t[3] = a * c - n * u - e * s - o * i, t[4] = n * (c = r[7]) + a * (u = r[4]) + e * (i = r[6]) - o * (s = r[5]), t[5] = e * c + a * s + o * u - n * i, t[6] = o * c + a * i + n * s - e * u, t[7] = a * c - n * u - e * s - o * i, t;\n  }, rotateAroundAxis = function(t, a, r, n) {\n    var e, o, u, s, i, c;\n    return Math.abs(n) < EPSILON ? copy$1(t, a) : (c = Math.hypot(r[0], r[1], r[2]), n *= 0.5, e = (u = Math.sin(n)) * r[0] / c, o = u * r[1] / c, u = u * r[2] / c, r = Math.cos(n), c = a[0], t[0] = c * r + (n = a[3]) * e + (s = a[1]) * u - (i = a[2]) * o, t[1] = s * r + n * o + i * e - c * u, t[2] = i * r + n * u + c * o - s * e, t[3] = n * r - c * e - s * o - i * u, t[4] = (n = a[4]) * r + (c = a[7]) * e + (s = a[5]) * u - (i = a[6]) * o, t[5] = s * r + c * o + i * e - n * u, t[6] = i * r + c * u + n * o - s * e, t[7] = c * r - n * e - s * o - i * u, t);\n  }, add$1 = function(t, a, r) {\n    return t[0] = a[0] + r[0], t[1] = a[1] + r[1], t[2] = a[2] + r[2], t[3] = a[3] + r[3], t[4] = a[4] + r[4], t[5] = a[5] + r[5], t[6] = a[6] + r[6], t[7] = a[7] + r[7], t;\n  }, multiply$1 = function(t, a, r) {\n    var n = a[0], e = a[1], o = a[2], u = a[3], s = r[4], i = r[5], c = r[6], l = r[7], $ = a[4], h = a[5], f = a[6], a = a[7], M = r[0], m = r[1], d = r[2], r = r[3];\n    return t[0] = n * r + u * M + e * d - o * m, t[1] = e * r + u * m + o * M - n * d, t[2] = o * r + u * d + n * m - e * M, t[3] = u * r - n * M - e * m - o * d, t[4] = n * l + u * s + e * c - o * i + $ * r + a * M + h * d - f * m, t[5] = e * l + u * i + o * s - n * c + h * r + a * m + f * M - $ * d, t[6] = o * l + u * c + n * i - e * s + f * r + a * d + $ * m - h * M, t[7] = u * l - n * s - e * i - o * c + a * r - $ * M - h * m - f * d, t;\n  }, scale$1 = function(t, a, r) {\n    return t[0] = a[0] * r, t[1] = a[1] * r, t[2] = a[2] * r, t[3] = a[3] * r, t[4] = a[4] * r, t[5] = a[5] * r, t[6] = a[6] * r, t[7] = a[7] * r, t;\n  }, lerp$1 = function(t, a, r, n) {\n    var e = 1 - n;\n    return dot$1(a, r) < 0 && (n = -n), t[0] = a[0] * e + r[0] * n, t[1] = a[1] * e + r[1] * n, t[2] = a[2] * e + r[2] * n, t[3] = a[3] * e + r[3] * n, t[4] = a[4] * e + r[4] * n, t[5] = a[5] * e + r[5] * n, t[6] = a[6] * e + r[6] * n, t[7] = a[7] * e + r[7] * n, t;\n  }, invert = function(t, a) {\n    var r = squaredLength$1(a);\n    return t[0] = -a[0] / r, t[1] = -a[1] / r, t[2] = -a[2] / r, t[3] = a[3] / r, t[4] = -a[4] / r, t[5] = -a[5] / r, t[6] = -a[6] / r, t[7] = a[7] / r, t;\n  }, conjugate = function(t, a) {\n    return t[0] = -a[0], t[1] = -a[1], t[2] = -a[2], t[3] = a[3], t[4] = -a[4], t[5] = -a[5], t[6] = -a[6], t[7] = a[7], t;\n  }, normalize$1 = function(t, a) {\n    var r, n, e, o, u, s, i, c, l = squaredLength$1(a);\n    return 0 < l && (l = Math.sqrt(l), c = (r = a[0] / l) * (u = a[4]) + (n = a[1] / l) * (s = a[5]) + (e = a[2] / l) * (i = a[6]) + (o = a[3] / l) * (a = a[7]), t[0] = r, t[1] = n, t[2] = e, t[3] = o, t[4] = (u - r * c) / l, t[5] = (s - n * c) / l, t[6] = (i - e * c) / l, t[7] = (a - o * c) / l), t;\n  }, str$1 = function(t) {\n    return \"quat2(\" + t[0] + \", \" + t[1] + \", \" + t[2] + \", \" + t[3] + \", \" + t[4] + \", \" + t[5] + \", \" + t[6] + \", \" + t[7] + \")\";\n  }, exactEquals$1 = function(t, a) {\n    return t[0] === a[0] && t[1] === a[1] && t[2] === a[2] && t[3] === a[3] && t[4] === a[4] && t[5] === a[5] && t[6] === a[6] && t[7] === a[7];\n  }, equals$1 = function(t, a) {\n    var r = t[0], n = t[1], e = t[2], o = t[3], u = t[4], s = t[5], i = t[6], t = t[7], c = a[0], l = a[1], $ = a[2], h = a[3], f = a[4], M = a[5], m = a[6], a = a[7];\n    return Math.abs(r - c) <= EPSILON * Math.max(1, Math.abs(r), Math.abs(c)) && Math.abs(n - l) <= EPSILON * Math.max(1, Math.abs(n), Math.abs(l)) && Math.abs(e - $) <= EPSILON * Math.max(1, Math.abs(e), Math.abs($)) && Math.abs(o - h) <= EPSILON * Math.max(1, Math.abs(o), Math.abs(h)) && Math.abs(u - f) <= EPSILON * Math.max(1, Math.abs(u), Math.abs(f)) && Math.abs(s - M) <= EPSILON * Math.max(1, Math.abs(s), Math.abs(M)) && Math.abs(i - m) <= EPSILON * Math.max(1, Math.abs(i), Math.abs(m)) && Math.abs(t - a) <= EPSILON * Math.max(1, Math.abs(t), Math.abs(a));\n  }, create = function() {\n    var t = new ARRAY_TYPE(2);\n    return ARRAY_TYPE != Float32Array && (t[0] = 0, t[1] = 0), t;\n  }, clone = function(t) {\n    var a = new ARRAY_TYPE(2);\n    return a[0] = t[0], a[1] = t[1], a;\n  }, fromValues = function(t, a) {\n    var r = new ARRAY_TYPE(2);\n    return r[0] = t, r[1] = a, r;\n  }, copy = function(t, a) {\n    return t[0] = a[0], t[1] = a[1], t;\n  }, set = function(t, a, r) {\n    return t[0] = a, t[1] = r, t;\n  }, add = function(t, a, r) {\n    return t[0] = a[0] + r[0], t[1] = a[1] + r[1], t;\n  }, subtract = function(t, a, r) {\n    return t[0] = a[0] - r[0], t[1] = a[1] - r[1], t;\n  }, multiply = function(t, a, r) {\n    return t[0] = a[0] * r[0], t[1] = a[1] * r[1], t;\n  }, divide = function(t, a, r) {\n    return t[0] = a[0] / r[0], t[1] = a[1] / r[1], t;\n  }, ceil = function(t, a) {\n    return t[0] = Math.ceil(a[0]), t[1] = Math.ceil(a[1]), t;\n  }, floor = function(t, a) {\n    return t[0] = Math.floor(a[0]), t[1] = Math.floor(a[1]), t;\n  }, min = function(t, a, r) {\n    return t[0] = Math.min(a[0], r[0]), t[1] = Math.min(a[1], r[1]), t;\n  }, max = function(t, a, r) {\n    return t[0] = Math.max(a[0], r[0]), t[1] = Math.max(a[1], r[1]), t;\n  }, round = function(t, a) {\n    return t[0] = Math.round(a[0]), t[1] = Math.round(a[1]), t;\n  }, scale = function(t, a, r) {\n    return t[0] = a[0] * r, t[1] = a[1] * r, t;\n  }, scaleAndAdd = function(t, a, r, n) {\n    return t[0] = a[0] + r[0] * n, t[1] = a[1] + r[1] * n, t;\n  }, distance = function(t, a) {\n    var r = a[0] - t[0];\n    return Math.hypot(r, a[1] - t[1]);\n  }, squaredDistance = function(t, a) {\n    var r = a[0] - t[0], a = a[1] - t[1];\n    return r * r + a * a;\n  }, length = function(t) {\n    var a = t[0];\n    return Math.hypot(a, t[1]);\n  }, squaredLength = function(t) {\n    var a = t[0], t = t[1];\n    return a * a + t * t;\n  }, negate = function(t, a) {\n    return t[0] = -a[0], t[1] = -a[1], t;\n  }, inverse = function(t, a) {\n    return t[0] = 1 / a[0], t[1] = 1 / a[1], t;\n  }, normalize = function(t, a) {\n    var r = a[0], n = a[1], r = r * r + n * n;\n    return 0 < r && (r = 1 / Math.sqrt(r)), t[0] = a[0] * r, t[1] = a[1] * r, t;\n  }, dot = function(t, a) {\n    return t[0] * a[0] + t[1] * a[1];\n  }, cross = function(t, a, r) {\n    a = a[0] * r[1] - a[1] * r[0];\n    return t[0] = t[1] = 0, t[2] = a, t;\n  }, lerp = function(t, a, r, n) {\n    var e = a[0], a = a[1];\n    return t[0] = e + n * (r[0] - e), t[1] = a + n * (r[1] - a), t;\n  }, random = function(t, a) {\n    a = a || 1;\n    var r = 2 * RANDOM() * Math.PI;\n    return t[0] = Math.cos(r) * a, t[1] = Math.sin(r) * a, t;\n  }, transformMat2 = function(t, a, r) {\n    var n = a[0], a = a[1];\n    return t[0] = r[0] * n + r[2] * a, t[1] = r[1] * n + r[3] * a, t;\n  }, transformMat2d = function(t, a, r) {\n    var n = a[0], a = a[1];\n    return t[0] = r[0] * n + r[2] * a + r[4], t[1] = r[1] * n + r[3] * a + r[5], t;\n  }, transformMat3 = function(t, a, r) {\n    var n = a[0], a = a[1];\n    return t[0] = r[0] * n + r[3] * a + r[6], t[1] = r[1] * n + r[4] * a + r[7], t;\n  }, transformMat4 = function(t, a, r) {\n    var n = a[0], a = a[1];\n    return t[0] = r[0] * n + r[4] * a + r[12], t[1] = r[1] * n + r[5] * a + r[13], t;\n  }, rotate = function(t, a, r, n) {\n    var e = a[0] - r[0], a = a[1] - r[1], o = Math.sin(n), n = Math.cos(n);\n    return t[0] = e * n - a * o + r[0], t[1] = e * o + a * n + r[1], t;\n  }, angle = function(t, a) {\n    var r = t[0], t = t[1], n = a[0], a = a[1], e = Math.sqrt((r * r + t * t) * (n * n + a * a));\n    return Math.acos(Math.min(Math.max(e && (r * n + t * a) / e, -1), 1));\n  }, zero = function(t) {\n    return t[0] = 0, t[1] = 0, t;\n  }, str = function(t) {\n    return \"vec2(\" + t[0] + \", \" + t[1] + \")\";\n  }, exactEquals = function(t, a) {\n    return t[0] === a[0] && t[1] === a[1];\n  }, equals = function(t, a) {\n    var r = t[0], t = t[1], n = a[0], a = a[1];\n    return Math.abs(r - n) <= EPSILON * Math.max(1, Math.abs(r), Math.abs(n)) && Math.abs(t - a) <= EPSILON * Math.max(1, Math.abs(t), Math.abs(a));\n  };\n  setMatrixArrayType2 = setMatrixArrayType, toRadian2 = toRadian, equals$92 = equals$9, create$82 = create$8, clone$82 = clone$8, copy$82 = copy$8, identity$52 = identity$5, fromValues$82 = fromValues$8, set$82 = set$8, transpose$22 = transpose$2, invert$52 = invert$5, adjoint$22 = adjoint$2, determinant$32 = determinant$3, multiply$82 = multiply$8, rotate$42 = rotate$4, scale$82 = scale$8, fromRotation$42 = fromRotation$4, fromScaling$32 = fromScaling$3, str$82 = str$8, frob$32 = frob$3, LDU2 = LDU, add$82 = add$8, subtract$62 = subtract$6, exactEquals$82 = exactEquals$8, equals$82 = equals$8, multiplyScalar$32 = multiplyScalar$3, multiplyScalarAndAdd$32 = multiplyScalarAndAdd$3, create$72 = create$7, clone$72 = clone$7, copy$72 = copy$7, identity$42 = identity$4, fromValues$72 = fromValues$7, set$72 = set$7, invert$42 = invert$4, determinant$22 = determinant$2, multiply$72 = multiply$7, rotate$32 = rotate$3, scale$72 = scale$7, translate$32 = translate$3, fromRotation$32 = fromRotation$3, fromScaling$22 = fromScaling$2, fromTranslation$32 = fromTranslation$3, str$72 = str$7, frob$22 = frob$2, add$72 = add$7, subtract$52 = subtract$5, multiplyScalar$22 = multiplyScalar$2, multiplyScalarAndAdd$22 = multiplyScalarAndAdd$2, exactEquals$72 = exactEquals$7, equals$72 = equals$7, create$62 = create$6, fromMat4$12 = fromMat4$1, clone$62 = clone$6, copy$62 = copy$6, fromValues$62 = fromValues$6, set$62 = set$6, identity$32 = identity$3, transpose$12 = transpose$1, invert$32 = invert$3, adjoint$12 = adjoint$1, determinant$12 = determinant$1, multiply$62 = multiply$6, translate$22 = translate$2, rotate$22 = rotate$2, scale$62 = scale$6, fromTranslation$22 = fromTranslation$2, fromRotation$22 = fromRotation$2, fromScaling$12 = fromScaling$1, fromMat2d2 = fromMat2d, fromQuat$12 = fromQuat$1, normalFromMat42 = normalFromMat4, projection2 = projection, str$62 = str$6, frob$12 = frob$1, add$62 = add$6, subtract$42 = subtract$4, multiplyScalar$12 = multiplyScalar$1, multiplyScalarAndAdd$12 = multiplyScalarAndAdd$1, exactEquals$62 = exactEquals$6, equals$62 = equals$6, create$52 = create$5, clone$52 = clone$5, copy$52 = copy$5, fromValues$52 = fromValues$5, set$52 = set$5, identity$22 = identity$2, transpose2 = transpose, invert$22 = invert$2, adjoint2 = adjoint, determinant2 = determinant, multiply$52 = multiply$5, translate$12 = translate$1, scale$52 = scale$5, rotate$12 = rotate$1, rotateX$32 = rotateX$3, rotateY$32 = rotateY$3, rotateZ$32 = rotateZ$3, fromTranslation$12 = fromTranslation$1, fromScaling2 = fromScaling, fromRotation$12 = fromRotation$1, fromXRotation2 = fromXRotation, fromYRotation2 = fromYRotation, fromZRotation2 = fromZRotation, fromRotationTranslation$12 = fromRotationTranslation$1, fromQuat22 = fromQuat2, getTranslation$12 = getTranslation$1, getScaling2 = getScaling, getRotation2 = getRotation, decompose2 = decompose, fromRotationTranslationScale2 = fromRotationTranslationScale, fromRotationTranslationScaleOrigin2 = fromRotationTranslationScaleOrigin, fromQuat3 = fromQuat, frustum2 = frustum, perspectiveNO2 = perspectiveNO, perspectiveZO2 = perspectiveZO, perspectiveFromFieldOfView2 = perspectiveFromFieldOfView, orthoNO2 = orthoNO, orthoZO2 = orthoZO, lookAt2 = lookAt, targetTo2 = targetTo, str$52 = str$5, frob2 = frob, add$52 = add$5, subtract$32 = subtract$3, multiplyScalar2 = multiplyScalar, multiplyScalarAndAdd2 = multiplyScalarAndAdd, exactEquals$52 = exactEquals$5, equals$52 = equals$5, create$42 = create$4, clone$42 = clone$4, length$42 = length$4, fromValues$42 = fromValues$4, copy$42 = copy$4, set$42 = set$4, add$42 = add$4, subtract$22 = subtract$2, multiply$42 = multiply$4, divide$22 = divide$2, ceil$22 = ceil$2, floor$22 = floor$2, min$22 = min$2, max$22 = max$2, round$22 = round$2, scale$42 = scale$4, scaleAndAdd$22 = scaleAndAdd$2, distance$22 = distance$2, squaredDistance$22 = squaredDistance$2, squaredLength$42 = squaredLength$4, negate$22 = negate$2, inverse$22 = inverse$2, normalize$42 = normalize$4, dot$42 = dot$4, cross$22 = cross$2, lerp$42 = lerp$4, slerp$12 = slerp$1, hermite2 = hermite, bezier2 = bezier, random$32 = random$3, transformMat4$22 = transformMat4$2, transformMat3$12 = transformMat3$1, transformQuat$12 = transformQuat$1, rotateX$22 = rotateX$2, rotateY$22 = rotateY$2, rotateZ$22 = rotateZ$2, angle$12 = angle$1, zero$22 = zero$2, str$42 = str$4, exactEquals$42 = exactEquals$4, equals$42 = equals$4, create$32 = create$3, clone$32 = clone$3, fromValues$32 = fromValues$3, copy$32 = copy$3, set$32 = set$3, add$32 = add$3, subtract$12 = subtract$1, multiply$32 = multiply$3, divide$12 = divide$1, ceil$12 = ceil$1, floor$12 = floor$1, min$12 = min$1, max$12 = max$1, round$12 = round$1, scale$32 = scale$3, scaleAndAdd$12 = scaleAndAdd$1, distance$12 = distance$1, squaredDistance$12 = squaredDistance$1, length$32 = length$3, squaredLength$32 = squaredLength$3, negate$12 = negate$1, inverse$12 = inverse$1, normalize$32 = normalize$3, dot$32 = dot$3, cross$12 = cross$1, lerp$32 = lerp$3, random$22 = random$2, transformMat4$12 = transformMat4$1, transformQuat2 = transformQuat, zero$12 = zero$1, str$32 = str$3, exactEquals$32 = exactEquals$3, equals$32 = equals$3, create$22 = create$2, identity$12 = identity$1, setAxisAngle2 = setAxisAngle, getAxisAngle2 = getAxisAngle, getAngle2 = getAngle, multiply$22 = multiply$2, rotateX$12 = rotateX$1, rotateY$12 = rotateY$1, rotateZ$12 = rotateZ$1, calculateW2 = calculateW, exp2 = exp, ln2 = ln, pow2 = pow, slerp2 = slerp, random$12 = random$1, invert$12 = invert$1, conjugate$12 = conjugate$1, fromMat32 = fromMat3, fromEuler2 = fromEuler, str$22 = str$2, equals$22 = equals$2, create$12 = create$1, clone$12 = clone$1, fromValues$12 = fromValues$1, fromRotationTranslationValues2 = fromRotationTranslationValues, fromRotationTranslation2 = fromRotationTranslation, fromTranslation2 = fromTranslation, fromRotation2 = fromRotation, fromMat42 = fromMat4, copy$12 = copy$1, identity2 = identity, set$12 = set$1, getDual2 = getDual, setDual2 = setDual, getTranslation2 = getTranslation, translate2 = translate, rotateX2 = rotateX, rotateY2 = rotateY, rotateZ2 = rotateZ, rotateByQuatAppend2 = rotateByQuatAppend, rotateByQuatPrepend2 = rotateByQuatPrepend, rotateAroundAxis2 = rotateAroundAxis, add$12 = add$1, multiply$12 = multiply$1, scale$12 = scale$1, lerp$12 = lerp$1, invert2 = invert, conjugate2 = conjugate, normalize$12 = normalize$1, str$12 = str$1, exactEquals$12 = exactEquals$1, equals$12 = equals$1, create2 = create, clone2 = clone, fromValues2 = fromValues, copy2 = copy, set2 = set, add2 = add, subtract2 = subtract, multiply2 = multiply, divide2 = divide, ceil2 = ceil, floor2 = floor, min2 = min, max2 = max, round2 = round, scale2 = scale, scaleAndAdd2 = scaleAndAdd, distance2 = distance, squaredDistance2 = squaredDistance, length2 = length, squaredLength2 = squaredLength, negate2 = negate, inverse2 = inverse, normalize2 = normalize, dot2 = dot, cross2 = cross, lerp2 = lerp, random2 = random, transformMat22 = transformMat2, transformMat2d2 = transformMat2d, transformMat32 = transformMat3, transformMat42 = transformMat4, rotate2 = rotate, angle2 = angle, zero2 = zero, str2 = str, exactEquals2 = exactEquals, equals2 = equals;\n  EPSILON = 1e-6, ARRAY_TYPE = \"undefined\" != typeof Float32Array ? Float32Array : Array, RANDOM = Math.random, ANGLE_ORDER = \"zyx\";\n  degree = Math.PI / 180;\n  Math.hypot || (Math.hypot = function() {\n    for (var t = 0, a = arguments.length; a--; ) t += arguments[a] * arguments[a];\n    return Math.sqrt(t);\n  });\n  common = { __proto__: null, EPSILON, get ARRAY_TYPE() {\n    return ARRAY_TYPE;\n  }, RANDOM, ANGLE_ORDER, setMatrixArrayType, toRadian, equals: equals$9 };\n  mul$8 = multiply$8, sub$6 = subtract$6, mat2 = Object.freeze({ __proto__: null, create: create$8, clone: clone$8, copy: copy$8, identity: identity$5, fromValues: fromValues$8, set: set$8, transpose: transpose$2, invert: invert$5, adjoint: adjoint$2, determinant: determinant$3, multiply: multiply$8, rotate: rotate$4, scale: scale$8, fromRotation: fromRotation$4, fromScaling: fromScaling$3, str: str$8, frob: frob$3, LDU, add: add$8, subtract: subtract$6, exactEquals: exactEquals$8, equals: equals$8, multiplyScalar: multiplyScalar$3, multiplyScalarAndAdd: multiplyScalarAndAdd$3, mul: mul$8, sub: sub$6 });\n  mul$7 = multiply$7, sub$5 = subtract$5, mat2d = Object.freeze({ __proto__: null, create: create$7, clone: clone$7, copy: copy$7, identity: identity$4, fromValues: fromValues$7, set: set$7, invert: invert$4, determinant: determinant$2, multiply: multiply$7, rotate: rotate$3, scale: scale$7, translate: translate$3, fromRotation: fromRotation$3, fromScaling: fromScaling$2, fromTranslation: fromTranslation$3, str: str$7, frob: frob$2, add: add$7, subtract: subtract$5, multiplyScalar: multiplyScalar$2, multiplyScalarAndAdd: multiplyScalarAndAdd$2, exactEquals: exactEquals$7, equals: equals$7, mul: mul$7, sub: sub$5 });\n  mul$6 = multiply$6, sub$4 = subtract$4, mat3 = Object.freeze({ __proto__: null, create: create$6, fromMat4: fromMat4$1, clone: clone$6, copy: copy$6, fromValues: fromValues$6, set: set$6, identity: identity$3, transpose: transpose$1, invert: invert$3, adjoint: adjoint$1, determinant: determinant$1, multiply: multiply$6, translate: translate$2, rotate: rotate$2, scale: scale$6, fromTranslation: fromTranslation$2, fromRotation: fromRotation$2, fromScaling: fromScaling$1, fromMat2d, fromQuat: fromQuat$1, normalFromMat4, projection, str: str$6, frob: frob$1, add: add$6, subtract: subtract$4, multiplyScalar: multiplyScalar$1, multiplyScalarAndAdd: multiplyScalarAndAdd$1, exactEquals: exactEquals$6, equals: equals$6, mul: mul$6, sub: sub$4 });\n  perspective = perspectiveNO;\n  ortho = orthoNO;\n  mul$5 = multiply$5, sub$3 = subtract$3, mat4 = Object.freeze({ __proto__: null, create: create$5, clone: clone$5, copy: copy$5, fromValues: fromValues$5, set: set$5, identity: identity$2, transpose, invert: invert$2, adjoint, determinant, multiply: multiply$5, translate: translate$1, scale: scale$5, rotate: rotate$1, rotateX: rotateX$3, rotateY: rotateY$3, rotateZ: rotateZ$3, fromTranslation: fromTranslation$1, fromScaling, fromRotation: fromRotation$1, fromXRotation, fromYRotation, fromZRotation, fromRotationTranslation: fromRotationTranslation$1, fromQuat2, getTranslation: getTranslation$1, getScaling, getRotation, decompose, fromRotationTranslationScale, fromRotationTranslationScaleOrigin, fromQuat, frustum, perspectiveNO, perspective, perspectiveZO, perspectiveFromFieldOfView, orthoNO, ortho, orthoZO, lookAt, targetTo, str: str$5, frob, add: add$5, subtract: subtract$3, multiplyScalar, multiplyScalarAndAdd, exactEquals: exactEquals$5, equals: equals$5, mul: mul$5, sub: sub$3 });\n  sub$2 = subtract$2, mul$4 = multiply$4, div$2 = divide$2, dist$2 = distance$2, sqrDist$2 = squaredDistance$2, len$4 = length$4, sqrLen$4 = squaredLength$4, forEach$2 = function() {\n    var i = create$4();\n    return function(t, a, r, n, e, o) {\n      var u, s;\n      for (a = a || 3, r = r || 0, s = n ? Math.min(n * a + r, t.length) : t.length, u = r; u < s; u += a) i[0] = t[u], i[1] = t[u + 1], i[2] = t[u + 2], e(i, i, o), t[u] = i[0], t[u + 1] = i[1], t[u + 2] = i[2];\n      return t;\n    };\n  }(), vec3 = Object.freeze({ __proto__: null, create: create$4, clone: clone$4, length: length$4, fromValues: fromValues$4, copy: copy$4, set: set$4, add: add$4, subtract: subtract$2, multiply: multiply$4, divide: divide$2, ceil: ceil$2, floor: floor$2, min: min$2, max: max$2, round: round$2, scale: scale$4, scaleAndAdd: scaleAndAdd$2, distance: distance$2, squaredDistance: squaredDistance$2, squaredLength: squaredLength$4, negate: negate$2, inverse: inverse$2, normalize: normalize$4, dot: dot$4, cross: cross$2, lerp: lerp$4, slerp: slerp$1, hermite, bezier, random: random$3, transformMat4: transformMat4$2, transformMat3: transformMat3$1, transformQuat: transformQuat$1, rotateX: rotateX$2, rotateY: rotateY$2, rotateZ: rotateZ$2, angle: angle$1, zero: zero$2, str: str$4, exactEquals: exactEquals$4, equals: equals$4, sub: sub$2, mul: mul$4, div: div$2, dist: dist$2, sqrDist: sqrDist$2, len: len$4, sqrLen: sqrLen$4, forEach: forEach$2 });\n  sub$1 = subtract$1, mul$3 = multiply$3, div$1 = divide$1, dist$1 = distance$1, sqrDist$1 = squaredDistance$1, len$3 = length$3, sqrLen$3 = squaredLength$3, forEach$1 = function() {\n    var i = create$3();\n    return function(t, a, r, n, e, o) {\n      var u, s;\n      for (a = a || 4, r = r || 0, s = n ? Math.min(n * a + r, t.length) : t.length, u = r; u < s; u += a) i[0] = t[u], i[1] = t[u + 1], i[2] = t[u + 2], i[3] = t[u + 3], e(i, i, o), t[u] = i[0], t[u + 1] = i[1], t[u + 2] = i[2], t[u + 3] = i[3];\n      return t;\n    };\n  }(), vec4 = Object.freeze({ __proto__: null, create: create$3, clone: clone$3, fromValues: fromValues$3, copy: copy$3, set: set$3, add: add$3, subtract: subtract$1, multiply: multiply$3, divide: divide$1, ceil: ceil$1, floor: floor$1, min: min$1, max: max$1, round: round$1, scale: scale$3, scaleAndAdd: scaleAndAdd$1, distance: distance$1, squaredDistance: squaredDistance$1, length: length$3, squaredLength: squaredLength$3, negate: negate$1, inverse: inverse$1, normalize: normalize$3, dot: dot$3, cross: cross$1, lerp: lerp$3, random: random$2, transformMat4: transformMat4$1, transformQuat, zero: zero$1, str: str$3, exactEquals: exactEquals$3, equals: equals$3, sub: sub$1, mul: mul$3, div: div$1, dist: dist$1, sqrDist: sqrDist$1, len: len$3, sqrLen: sqrLen$3, forEach: forEach$1 });\n  clone$2 = clone$3, fromValues$2 = fromValues$3, copy$2 = copy$3, set$2 = set$3, add$2 = add$3, mul$2 = multiply$2, scale$2 = scale$3, dot$2 = dot$3, lerp$2 = lerp$3, length$2 = length$3, len$2 = length$2, squaredLength$2 = squaredLength$3, sqrLen$2 = squaredLength$2, normalize$2 = normalize$3, exactEquals$2 = exactEquals$3;\n  rotationTo = function() {\n    var e = create$4(), o = fromValues$4(1, 0, 0), u = fromValues$4(0, 1, 0);\n    return function(t, a, r) {\n      var n = dot$4(a, r);\n      return n < -0.999999 ? (cross$2(e, o, a), len$4(e) < 1e-6 && cross$2(e, u, a), normalize$4(e, e), setAxisAngle(t, e, Math.PI), t) : 0.999999 < n ? (t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t) : (cross$2(e, a, r), t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = 1 + n, normalize$2(t, t));\n    };\n  }(), sqlerp = function() {\n    var u = create$2(), s = create$2();\n    return function(t, a, r, n, e, o) {\n      return slerp(u, a, e, o), slerp(s, r, n, o), slerp(t, u, s, 2 * o * (1 - o)), t;\n    };\n  }(), setAxes = function() {\n    var e = create$6();\n    return function(t, a, r, n) {\n      return e[0] = r[0], e[3] = r[1], e[6] = r[2], e[1] = n[0], e[4] = n[1], e[7] = n[2], e[2] = -a[0], e[5] = -a[1], e[8] = -a[2], normalize$2(t, fromMat3(t, e));\n    };\n  }(), quat = Object.freeze({ __proto__: null, create: create$2, identity: identity$1, setAxisAngle, getAxisAngle, getAngle, multiply: multiply$2, rotateX: rotateX$1, rotateY: rotateY$1, rotateZ: rotateZ$1, calculateW, exp, ln, pow, slerp, random: random$1, invert: invert$1, conjugate: conjugate$1, fromMat3, fromEuler, str: str$2, clone: clone$2, fromValues: fromValues$2, copy: copy$2, set: set$2, add: add$2, mul: mul$2, scale: scale$2, dot: dot$2, lerp: lerp$2, length: length$2, len: len$2, squaredLength: squaredLength$2, sqrLen: sqrLen$2, normalize: normalize$2, exactEquals: exactEquals$2, equals: equals$2, rotationTo, sqlerp, setAxes });\n  getReal = copy$2;\n  setReal = copy$2;\n  mul$1 = multiply$1;\n  dot$1 = dot$2;\n  length$1 = length$2, len$1 = length$1, squaredLength$1 = squaredLength$2, sqrLen$1 = squaredLength$1;\n  quat2 = Object.freeze({ __proto__: null, create: create$1, clone: clone$1, fromValues: fromValues$1, fromRotationTranslationValues, fromRotationTranslation, fromTranslation, fromRotation, fromMat4, copy: copy$1, identity, set: set$1, getReal, getDual, setReal, setDual, getTranslation, translate, rotateX, rotateY, rotateZ, rotateByQuatAppend, rotateByQuatPrepend, rotateAroundAxis, add: add$1, multiply: multiply$1, mul: mul$1, scale: scale$1, dot: dot$1, lerp: lerp$1, invert, conjugate, length: length$1, len: len$1, squaredLength: squaredLength$1, sqrLen: sqrLen$1, normalize: normalize$1, str: str$1, exactEquals: exactEquals$1, equals: equals$1 });\n  len = length, sub = subtract, mul = multiply, div = divide, dist = distance, sqrDist = squaredDistance, sqrLen = squaredLength, forEach = function() {\n    var i = create();\n    return function(t, a, r, n, e, o) {\n      var u, s;\n      for (a = a || 2, r = r || 0, s = n ? Math.min(n * a + r, t.length) : t.length, u = r; u < s; u += a) i[0] = t[u], i[1] = t[u + 1], e(i, i, o), t[u] = i[0], t[u + 1] = i[1];\n      return t;\n    };\n  }(), vec2 = Object.freeze({ __proto__: null, create, clone, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, length, squaredLength, negate, inverse, normalize, dot, cross, lerp, random, transformMat2, transformMat2d, transformMat3, transformMat4, rotate, angle, zero, str, exactEquals, equals, len, sub, mul, div, dist, sqrDist, sqrLen, forEach });\n  globalThis.glMatrix = common, globalThis.glMatrix.mat2 = mat2, globalThis.glMatrix.mat2d = mat2d, globalThis.glMatrix.mat3 = mat3, globalThis.glMatrix.mat4 = mat4, globalThis.glMatrix.quat = quat, globalThis.glMatrix.quat2 = quat2, globalThis.glMatrix.vec2 = vec2, globalThis.glMatrix.vec3 = vec3, globalThis.glMatrix.vec4 = vec4;\n}\nvar EPSILON;\nvar ARRAY_TYPE;\nvar RANDOM;\nvar ANGLE_ORDER;\nvar degree;\nvar common;\nvar mul$8;\nvar sub$6;\nvar mat2;\nvar mul$7;\nvar sub$5;\nvar mat2d;\nvar mul$6;\nvar sub$4;\nvar mat3;\nvar perspective;\nvar ortho;\nvar mul$5;\nvar sub$3;\nvar mat4;\nvar sub$2;\nvar mul$4;\nvar div$2;\nvar dist$2;\nvar sqrDist$2;\nvar len$4;\nvar sqrLen$4;\nvar forEach$2;\nvar vec3;\nvar sub$1;\nvar mul$3;\nvar div$1;\nvar dist$1;\nvar sqrDist$1;\nvar len$3;\nvar sqrLen$3;\nvar forEach$1;\nvar vec4;\nvar clone$2;\nvar fromValues$2;\nvar copy$2;\nvar set$2;\nvar add$2;\nvar mul$2;\nvar scale$2;\nvar dot$2;\nvar lerp$2;\nvar length$2;\nvar len$2;\nvar squaredLength$2;\nvar sqrLen$2;\nvar normalize$2;\nvar exactEquals$2;\nvar rotationTo;\nvar sqlerp;\nvar setAxes;\nvar quat;\nvar getReal;\nvar setReal;\nvar mul$1;\nvar dot$1;\nvar length$1;\nvar len$1;\nvar squaredLength$1;\nvar sqrLen$1;\nvar quat2;\nvar len;\nvar sub;\nvar mul;\nvar div;\nvar dist;\nvar sqrDist;\nvar sqrLen;\nvar forEach;\nvar vec2;\nvar setMatrixArrayType2;\nvar toRadian2;\nvar equals$92;\nvar create$82;\nvar clone$82;\nvar copy$82;\nvar identity$52;\nvar fromValues$82;\nvar set$82;\nvar transpose$22;\nvar invert$52;\nvar adjoint$22;\nvar determinant$32;\nvar multiply$82;\nvar rotate$42;\nvar scale$82;\nvar fromRotation$42;\nvar fromScaling$32;\nvar str$82;\nvar frob$32;\nvar LDU2;\nvar add$82;\nvar subtract$62;\nvar exactEquals$82;\nvar equals$82;\nvar multiplyScalar$32;\nvar multiplyScalarAndAdd$32;\nvar create$72;\nvar clone$72;\nvar copy$72;\nvar identity$42;\nvar fromValues$72;\nvar set$72;\nvar invert$42;\nvar determinant$22;\nvar multiply$72;\nvar rotate$32;\nvar scale$72;\nvar translate$32;\nvar fromRotation$32;\nvar fromScaling$22;\nvar fromTranslation$32;\nvar str$72;\nvar frob$22;\nvar add$72;\nvar subtract$52;\nvar multiplyScalar$22;\nvar multiplyScalarAndAdd$22;\nvar exactEquals$72;\nvar equals$72;\nvar create$62;\nvar fromMat4$12;\nvar clone$62;\nvar copy$62;\nvar fromValues$62;\nvar set$62;\nvar identity$32;\nvar transpose$12;\nvar invert$32;\nvar adjoint$12;\nvar determinant$12;\nvar multiply$62;\nvar translate$22;\nvar rotate$22;\nvar scale$62;\nvar fromTranslation$22;\nvar fromRotation$22;\nvar fromScaling$12;\nvar fromMat2d2;\nvar fromQuat$12;\nvar normalFromMat42;\nvar projection2;\nvar str$62;\nvar frob$12;\nvar add$62;\nvar subtract$42;\nvar multiplyScalar$12;\nvar multiplyScalarAndAdd$12;\nvar exactEquals$62;\nvar equals$62;\nvar create$52;\nvar clone$52;\nvar copy$52;\nvar fromValues$52;\nvar set$52;\nvar identity$22;\nvar transpose2;\nvar invert$22;\nvar adjoint2;\nvar determinant2;\nvar multiply$52;\nvar translate$12;\nvar scale$52;\nvar rotate$12;\nvar rotateX$32;\nvar rotateY$32;\nvar rotateZ$32;\nvar fromTranslation$12;\nvar fromScaling2;\nvar fromRotation$12;\nvar fromXRotation2;\nvar fromYRotation2;\nvar fromZRotation2;\nvar fromRotationTranslation$12;\nvar fromQuat22;\nvar getTranslation$12;\nvar getScaling2;\nvar getRotation2;\nvar decompose2;\nvar fromRotationTranslationScale2;\nvar fromRotationTranslationScaleOrigin2;\nvar fromQuat3;\nvar frustum2;\nvar perspectiveNO2;\nvar perspectiveZO2;\nvar perspectiveFromFieldOfView2;\nvar orthoNO2;\nvar orthoZO2;\nvar lookAt2;\nvar targetTo2;\nvar str$52;\nvar frob2;\nvar add$52;\nvar subtract$32;\nvar multiplyScalar2;\nvar multiplyScalarAndAdd2;\nvar exactEquals$52;\nvar equals$52;\nvar create$42;\nvar clone$42;\nvar length$42;\nvar fromValues$42;\nvar copy$42;\nvar set$42;\nvar add$42;\nvar subtract$22;\nvar multiply$42;\nvar divide$22;\nvar ceil$22;\nvar floor$22;\nvar min$22;\nvar max$22;\nvar round$22;\nvar scale$42;\nvar scaleAndAdd$22;\nvar distance$22;\nvar squaredDistance$22;\nvar squaredLength$42;\nvar negate$22;\nvar inverse$22;\nvar normalize$42;\nvar dot$42;\nvar cross$22;\nvar lerp$42;\nvar slerp$12;\nvar hermite2;\nvar bezier2;\nvar random$32;\nvar transformMat4$22;\nvar transformMat3$12;\nvar transformQuat$12;\nvar rotateX$22;\nvar rotateY$22;\nvar rotateZ$22;\nvar angle$12;\nvar zero$22;\nvar str$42;\nvar exactEquals$42;\nvar equals$42;\nvar create$32;\nvar clone$32;\nvar fromValues$32;\nvar copy$32;\nvar set$32;\nvar add$32;\nvar subtract$12;\nvar multiply$32;\nvar divide$12;\nvar ceil$12;\nvar floor$12;\nvar min$12;\nvar max$12;\nvar round$12;\nvar scale$32;\nvar scaleAndAdd$12;\nvar distance$12;\nvar squaredDistance$12;\nvar length$32;\nvar squaredLength$32;\nvar negate$12;\nvar inverse$12;\nvar normalize$32;\nvar dot$32;\nvar cross$12;\nvar lerp$32;\nvar random$22;\nvar transformMat4$12;\nvar transformQuat2;\nvar zero$12;\nvar str$32;\nvar exactEquals$32;\nvar equals$32;\nvar create$22;\nvar identity$12;\nvar setAxisAngle2;\nvar getAxisAngle2;\nvar getAngle2;\nvar multiply$22;\nvar rotateX$12;\nvar rotateY$12;\nvar rotateZ$12;\nvar calculateW2;\nvar exp2;\nvar ln2;\nvar pow2;\nvar slerp2;\nvar random$12;\nvar invert$12;\nvar conjugate$12;\nvar fromMat32;\nvar fromEuler2;\nvar str$22;\nvar equals$22;\nvar create$12;\nvar clone$12;\nvar fromValues$12;\nvar fromRotationTranslationValues2;\nvar fromRotationTranslation2;\nvar fromTranslation2;\nvar fromRotation2;\nvar fromMat42;\nvar copy$12;\nvar identity2;\nvar set$12;\nvar getDual2;\nvar setDual2;\nvar getTranslation2;\nvar translate2;\nvar rotateX2;\nvar rotateY2;\nvar rotateZ2;\nvar rotateByQuatAppend2;\nvar rotateByQuatPrepend2;\nvar rotateAroundAxis2;\nvar add$12;\nvar multiply$12;\nvar scale$12;\nvar lerp$12;\nvar invert2;\nvar conjugate2;\nvar normalize$12;\nvar str$12;\nvar exactEquals$12;\nvar equals$12;\nvar create2;\nvar clone2;\nvar fromValues2;\nvar copy2;\nvar set2;\nvar add2;\nvar subtract2;\nvar multiply2;\nvar divide2;\nvar ceil2;\nvar floor2;\nvar min2;\nvar max2;\nvar round2;\nvar scale2;\nvar scaleAndAdd2;\nvar distance2;\nvar squaredDistance2;\nvar length2;\nvar squaredLength2;\nvar negate2;\nvar inverse2;\nvar normalize2;\nvar dot2;\nvar cross2;\nvar lerp2;\nvar random2;\nvar transformMat22;\nvar transformMat2d2;\nvar transformMat32;\nvar transformMat42;\nvar rotate2;\nvar angle2;\nvar zero2;\nvar str2;\nvar exactEquals2;\nvar equals2;\n{\n  let lineInt = function(o, n, t) {\n    var e = [0, 0], l = o[1][1] - o[0][1], p = o[0][0] - o[1][0], o = l * o[0][0] + p * o[0][1], g = n[1][1] - n[0][1], r = n[0][0] - n[1][0], n = g * n[0][0] + r * n[0][1], i = l * r - g * p;\n    return scalar_eq(i, 0, t = t || 0) || (e[0] = (r * o - p * n) / i, e[1] = (l * n - g * o) / i), e;\n  }, lineSegmentsIntersect = function(o, n, t, e) {\n    var l, p = n[0] - o[0], n = n[1] - o[1], g = e[0] - t[0], e = e[1] - t[1];\n    return g * n - e * p != 0 && (l = (g * (o[1] - t[1]) + e * (t[0] - o[0])) / (e * p - g * n), 0 <= (o = (p * (t[1] - o[1]) + n * (o[0] - t[0])) / (g * n - e * p))) && o <= 1 && 0 <= l && l <= 1;\n  }, triangleArea = function(o, n, t) {\n    return (n[0] - o[0]) * (t[1] - o[1]) - (t[0] - o[0]) * (n[1] - o[1]);\n  }, isLeft = function(o, n, t) {\n    return 0 < triangleArea(o, n, t);\n  }, isLeftOn = function(o, n, t) {\n    return 0 <= triangleArea(o, n, t);\n  }, isRight = function(o, n, t) {\n    return triangleArea(o, n, t) < 0;\n  }, isRightOn = function(o, n, t) {\n    return triangleArea(o, n, t) <= 0;\n  }, collinear = function(o, n, t, e) {\n    var l, p, g;\n    return e ? (g = tmpPoint2, (p = tmpPoint1)[0] = n[0] - o[0], p[1] = n[1] - o[1], g[0] = t[0] - n[0], g[1] = t[1] - n[1], l = p[0] * g[0] + p[1] * g[1], p = Math.sqrt(p[0] * p[0] + p[1] * p[1]), g = Math.sqrt(g[0] * g[0] + g[1] * g[1]), Math.acos(l / (p * g)) < e) : 0 === triangleArea(o, n, t);\n  }, sqdist = function(o, n) {\n    var t = n[0] - o[0], n = n[1] - o[1];\n    return t * t + n * n;\n  }, polygonAt = function(o, n) {\n    var t = o.length;\n    return o[n < 0 ? n % t + t : n % t];\n  }, polygonClear = function(o) {\n    o.length = 0;\n  }, polygonAppend = function(o, n, t, e) {\n    for (var l = t; l < e; l++) o.push(n[l]);\n  }, polygonMakeCCW = function(o) {\n    for (var n = 0, t = o, e = 1; e < o.length; ++e) (t[e][1] < t[n][1] || t[e][1] === t[n][1] && t[e][0] > t[n][0]) && (n = e);\n    return !isLeft(polygonAt(o, n - 1), polygonAt(o, n), polygonAt(o, n + 1)) && (polygonReverse(o), true);\n  }, polygonReverse = function(o) {\n    for (var n = [], t = o.length, e = 0; e !== t; e++) n.push(o.pop());\n    for (e = 0; e !== t; e++) o[e] = n[e];\n  }, polygonIsReflex = function(o, n) {\n    return isRight(polygonAt(o, n - 1), polygonAt(o, n), polygonAt(o, n + 1));\n  }, polygonCanSee = function(o, n, t) {\n    var e, l = tmpLine1, p = tmpLine2;\n    if (isLeftOn(polygonAt(o, n + 1), polygonAt(o, n), polygonAt(o, t)) && isRightOn(polygonAt(o, n - 1), polygonAt(o, n), polygonAt(o, t))) return false;\n    for (var g = sqdist(polygonAt(o, n), polygonAt(o, t)), r = 0; r !== o.length; ++r) if ((r + 1) % o.length !== n && r !== n && isLeftOn(polygonAt(o, n), polygonAt(o, t), polygonAt(o, r + 1)) && isRightOn(polygonAt(o, n), polygonAt(o, t), polygonAt(o, r)) && (l[0] = polygonAt(o, n), l[1] = polygonAt(o, t), p[0] = polygonAt(o, r), p[1] = polygonAt(o, r + 1), e = lineInt(l, p), sqdist(polygonAt(o, n), e) < g)) return false;\n    return true;\n  }, polygonCanSee2 = function(o, n, t) {\n    for (var e = 0; e !== o.length; ++e) if (e !== n && e !== t && (e + 1) % o.length !== n && (e + 1) % o.length !== t && lineSegmentsIntersect(polygonAt(o, n), polygonAt(o, t), polygonAt(o, e), polygonAt(o, e + 1))) return false;\n    return true;\n  }, polygonCopy = function(o, n, t, e) {\n    var l = e || [];\n    if (polygonClear(l), n < t) for (var p = n; p <= t; p++) l.push(o[p]);\n    else {\n      for (p = 0; p <= t; p++) l.push(o[p]);\n      for (p = n; p < o.length; p++) l.push(o[p]);\n    }\n    return l;\n  }, polygonGetCutEdges = function(o) {\n    for (var n = [], t = [], e = [], l = Number.MAX_VALUE, p = 0; p < o.length; ++p) if (polygonIsReflex(o, p)) {\n      for (var g = 0; g < o.length; ++g) if (polygonCanSee(o, p, g)) {\n        for (var t = polygonGetCutEdges(polygonCopy(o, p, g, e)), r = polygonGetCutEdges(polygonCopy(o, g, p, e)), i = 0; i < r.length; i++) t.push(r[i]);\n        t.length < l && (l = (n = t).length, n.push([polygonAt(o, p), polygonAt(o, g)]));\n      }\n    }\n    return n;\n  }, polygonDecomp = function(o) {\n    var n = polygonGetCutEdges(o);\n    return 0 < n.length ? polygonSlice(o, n) : [o];\n  }, polygonSlice = function(o, n) {\n    if (0 === n.length) return [o];\n    if (n instanceof Array && n.length && n[0] instanceof Array && 2 === n[0].length && n[0][0] instanceof Array) {\n      for (var t = [o], e = 0; e < n.length; e++) for (var l = n[e], p = 0; p < t.length; p++) {\n        var g = polygonSlice(t[p], l);\n        if (g) {\n          t.splice(p, 1), t.push(g[0], g[1]);\n          break;\n        }\n      }\n      return t;\n    }\n    return e = o.indexOf((l = n)[0]), p = o.indexOf(l[1]), -1 !== e && -1 !== p && [polygonCopy(o, e, p), polygonCopy(o, p, e)];\n  }, polygonIsSimple = function(o) {\n    for (var n = o, t = 0; t < n.length - 1; t++) for (var e = 0; e < t - 1; e++) if (lineSegmentsIntersect(n[t], n[t + 1], n[e], n[e + 1])) return false;\n    for (t = 1; t < n.length - 2; t++) if (lineSegmentsIntersect(n[0], n[n.length - 1], n[t], n[t + 1])) return false;\n    return true;\n  }, getIntersectionPoint = function(o, n, t, e, l) {\n    var p = n[1] - o[1], n = o[0] - n[0], o = p * o[0] + n * o[1], g = e[1] - t[1], e = t[0] - e[0], t = g * t[0] + e * t[1], r = p * e - g * n;\n    return scalar_eq(r, 0, l = l || 0) ? [0, 0] : [(e * o - n * t) / r, (p * t - g * o) / r];\n  }, polygonQuickDecomp = function(o, n, t, e, l, p, g) {\n    p = p || 100, g = g || 0, l = l || 25, n = void 0 !== n ? n : [], t = t || [], e = e || [];\n    var r = [0, 0], i = [0, 0], y = [0, 0], s = 0, A = 0, u = 0, a = 0, f = 0, c = 0, h = 0, v = [], m = [], d = o, C = o;\n    if (!(C.length < 3)) if (p < ++g) console.warn(\"quickDecomp: max level (\" + p + \") reached.\");\n    else {\n      for (var R = 0; R < o.length; ++R) if (polygonIsReflex(d, R)) {\n        t.push(d[R]);\n        for (var s = A = Number.MAX_VALUE, q = 0; q < o.length; ++q) isLeft(polygonAt(d, R - 1), polygonAt(d, R), polygonAt(d, q)) && isRightOn(polygonAt(d, R - 1), polygonAt(d, R), polygonAt(d, q - 1)) && (y = getIntersectionPoint(polygonAt(d, R - 1), polygonAt(d, R), polygonAt(d, q), polygonAt(d, q - 1)), isRight(polygonAt(d, R + 1), polygonAt(d, R), y)) && (u = sqdist(d[R], y)) < A && (A = u, i = y, c = q), isLeft(polygonAt(d, R + 1), polygonAt(d, R), polygonAt(d, q + 1)) && isRightOn(polygonAt(d, R + 1), polygonAt(d, R), polygonAt(d, q)) && (y = getIntersectionPoint(polygonAt(d, R + 1), polygonAt(d, R), polygonAt(d, q), polygonAt(d, q + 1)), isLeft(polygonAt(d, R - 1), polygonAt(d, R), y)) && (u = sqdist(d[R], y)) < s && (s = u, r = y, f = q);\n        if (c === (f + 1) % o.length) y[0] = (i[0] + r[0]) / 2, y[1] = (i[1] + r[1]) / 2, e.push(y), R < f ? (polygonAppend(v, d, R, f + 1), v.push(y), m.push(y), 0 !== c && polygonAppend(m, d, c, d.length), polygonAppend(m, d, 0, R + 1)) : (0 !== R && polygonAppend(v, d, R, d.length), polygonAppend(v, d, 0, f + 1), v.push(y), m.push(y), polygonAppend(m, d, c, R + 1));\n        else {\n          if (f < c && (f += o.length), a = Number.MAX_VALUE, f < c) return n;\n          for (q = c; q <= f; ++q) isLeftOn(polygonAt(d, R - 1), polygonAt(d, R), polygonAt(d, q)) && isRightOn(polygonAt(d, R + 1), polygonAt(d, R), polygonAt(d, q)) && (u = sqdist(polygonAt(d, R), polygonAt(d, q))) < a && polygonCanSee2(d, R, q) && (a = u, h = q % o.length);\n          R < h ? (polygonAppend(v, d, R, h + 1), 0 !== h && polygonAppend(m, d, h, C.length), polygonAppend(m, d, 0, R + 1)) : (0 !== R && polygonAppend(v, d, R, C.length), polygonAppend(v, d, 0, h + 1), polygonAppend(m, d, h, R + 1));\n        }\n        return v.length < m.length ? (polygonQuickDecomp(v, n, t, e, l, p, g), polygonQuickDecomp(m, n, t, e, l, p, g)) : (polygonQuickDecomp(m, n, t, e, l, p, g), polygonQuickDecomp(v, n, t, e, l, p, g)), n;\n      }\n      n.push(o);\n    }\n    return n;\n  }, polygonRemoveCollinearPoints = function(o, n) {\n    for (var t = 0, e = o.length - 1; 3 < o.length && 0 <= e; --e) collinear(polygonAt(o, e - 1), polygonAt(o, e), polygonAt(o, e + 1), n) && (o.splice(e % o.length, 1), t++);\n    return t;\n  }, polygonRemoveDuplicatePoints = function(o, n) {\n    for (var t = o.length - 1; 1 <= t; --t) for (var e = o[t], l = t - 1; 0 <= l; --l) points_eq(e, o[l], n) && o.splice(t, 1);\n  }, scalar_eq = function(o, n, t) {\n    return t = t || 0, Math.abs(o - n) <= t;\n  }, points_eq = function(o, n, t) {\n    return scalar_eq(o[0], n[0], t) && scalar_eq(o[1], n[1], t);\n  };\n  lineInt2 = lineInt, lineSegmentsIntersect2 = lineSegmentsIntersect, triangleArea2 = triangleArea, isLeft2 = isLeft, isLeftOn2 = isLeftOn, isRight2 = isRight, isRightOn2 = isRightOn, collinear2 = collinear, sqdist2 = sqdist, polygonAt2 = polygonAt, polygonClear2 = polygonClear, polygonAppend2 = polygonAppend, polygonMakeCCW2 = polygonMakeCCW, polygonReverse2 = polygonReverse, polygonIsReflex2 = polygonIsReflex, polygonCanSee3 = polygonCanSee, polygonCanSee22 = polygonCanSee2, polygonCopy2 = polygonCopy, polygonGetCutEdges2 = polygonGetCutEdges, polygonDecomp2 = polygonDecomp, polygonSlice2 = polygonSlice, polygonIsSimple2 = polygonIsSimple, getIntersectionPoint2 = getIntersectionPoint, polygonQuickDecomp2 = polygonQuickDecomp, polygonRemoveCollinearPoints2 = polygonRemoveCollinearPoints, polygonRemoveDuplicatePoints2 = polygonRemoveDuplicatePoints, scalar_eq2 = scalar_eq, points_eq2 = points_eq;\n  tmpPoint1 = [], tmpPoint2 = [];\n  tmpLine1 = [], tmpLine2 = [];\n  self.polyDecomp = { decomp: polygonDecomp, quickDecomp: polygonQuickDecomp, isSimple: polygonIsSimple, removeCollinearPoints: polygonRemoveCollinearPoints, removeDuplicatePoints: polygonRemoveDuplicatePoints, makeCCW: polygonMakeCCW };\n}\nvar tmpPoint1;\nvar tmpPoint2;\nvar tmpLine1;\nvar tmpLine2;\nvar lineInt2;\nvar lineSegmentsIntersect2;\nvar triangleArea2;\nvar isLeft2;\nvar isLeftOn2;\nvar isRight2;\nvar isRightOn2;\nvar collinear2;\nvar sqdist2;\nvar polygonAt2;\nvar polygonClear2;\nvar polygonAppend2;\nvar polygonMakeCCW2;\nvar polygonReverse2;\nvar polygonIsReflex2;\nvar polygonCanSee3;\nvar polygonCanSee22;\nvar polygonCopy2;\nvar polygonGetCutEdges2;\nvar polygonDecomp2;\nvar polygonSlice2;\nvar polygonIsSimple2;\nvar getIntersectionPoint2;\nvar polygonQuickDecomp2;\nvar polygonRemoveCollinearPoints2;\nvar polygonRemoveDuplicatePoints2;\nvar scalar_eq2;\nvar points_eq2;\n{\n  let isReady = false, hasAppStarted = false, buildMode = \"dev\";\n  const internalApiToken = Symbol(\"Construct internal API token\");\n  let internalApiTokenAccessesRemaining = 14;\n  const C32 = self.C3 = class {\n    constructor() {\n      throw TypeError(\"static class can't be instantiated\");\n    }\n    static _GetInternalAPIToken() {\n      if (internalApiTokenAccessesRemaining <= 0) throw new Error(\"cannot obtain internal API token\");\n      return --internalApiTokenAccessesRemaining, internalApiToken;\n    }\n    static SetReady() {\n      isReady = true;\n    }\n    static IsReady() {\n      return isReady;\n    }\n    static SetAppStarted() {\n      hasAppStarted = true;\n    }\n    static HasAppStarted() {\n      return hasAppStarted;\n    }\n    static SetBuildMode(e) {\n      buildMode = e;\n    }\n    static GetBuildMode() {\n      return buildMode;\n    }\n    static IsReleaseBuild() {\n      return \"final\" === buildMode;\n    }\n  };\n  C32.isDebug = false, C32.isDebugDefend = false, C32.hardwareConcurrency = navigator.hardwareConcurrency || 2, self.C3X = {};\n}\n{\n  const C32 = self.C3;\n  C32.QueryParser = class {\n    constructor(e) {\n      this._queryString = e, this._parameters = /* @__PURE__ */ new Map(), this._Parse();\n    }\n    _Parse() {\n      let e = this._queryString;\n      const r = (e = e.startsWith(\"?\") || e.startsWith(\"#\") ? e.substr(1) : e).split(\"&\");\n      for (const t of r) this._ParseParameter(t);\n    }\n    _ParseParameter(e) {\n      if (e) if (e.includes(\"=\")) {\n        const r = e.indexOf(\"=\"), t = decodeURIComponent(e.substring(0, r)), s = decodeURIComponent(e.substring(r + 1));\n        this._parameters.set(t, s);\n      } else this._parameters.set(e, null);\n    }\n    LogAll() {\n      for (const e of this._parameters) console.log(\"[QueryParser] Parameter '\" + e[0] + \"' = \" + (null === e[1] ? \"null\" : \"'\" + e[1] + \"'\"));\n    }\n    Has(e) {\n      return this._parameters.has(e);\n    }\n    Get(e) {\n      const r = this._parameters.get(e);\n      return void 0 === r ? null : r;\n    }\n    ClearHash() {\n      history.replaceState(\"\", document.title, location.pathname + location.search);\n    }\n    Reparse(e) {\n      this._queryString = e, this._parameters.clear(), this._Parse();\n    }\n  }, C32.QueryString = new C32.QueryParser(location.search), C32.LocationHashString = new C32.QueryParser(location.hash), C32.QueryString.Has(\"perf\") && (C32.isPerformanceProfiling = true), \"dev\" !== C32.QueryString.Get(\"mode\") && C32.SetBuildMode(\"final\");\n}\n{\n  let GetWindowsNTVersionName = function(r) {\n    const o = parseFloat(r), e = windowsNTVerMap.get(o);\n    return e || (13 <= o ? \"11\" : \"NT \" + r);\n  };\n  GetWindowsNTVersionName2 = GetWindowsNTVersionName;\n  const C32 = self.C3, UNKNOWN = \"(unknown)\", windowsNTVerMap = (C32.Platform = { OS: UNKNOWN, OSVersion: UNKNOWN, Browser: UNKNOWN, BrowserVersion: UNKNOWN, BrowserVersionNumber: NaN, BrowserEngine: UNKNOWN, Context: \"browser\", IsDesktop: true, IsMobile: false, IsAppleOS: false, IsIpadOS: false, GetDetailedInfo: async () => {\n  } }, /* @__PURE__ */ new Map([[5, \"2000\"], [5.1, \"XP\"], [5.2, \"XP\"], [6, \"Vista\"], [6.1, \"7\"], [6.2, \"8\"], [6.3, \"8.1\"], [10, \"10\"]]));\n  const uaStr = navigator.userAgent, uaData = navigator[\"userAgentData\"];\n  if (uaData && 0 < uaData[\"brands\"].length) {\n    let ReadBrandList = function(r) {\n      let o2 = \"\", t = \"\", a = \"\", s = \"\";\n      for (const i of r) {\n        const n = d.get(i[\"brand\"]), m = (!o2 && n && (o2 = n, t = i[\"version\"]), e.get(i[\"brand\"]));\n        !a && m && (a = m, s = i[\"version\"]);\n      }\n      o2 || \"Chromium\" !== a || (C32.Platform.Browser = \"Chromium\", C32.Platform.BrowserVersion = s), C32.Platform.Browser = o2 || UNKNOWN, C32.Platform.BrowserVersion = t || UNKNOWN, C32.Platform.BrowserEngine = a || UNKNOWN;\n    };\n    ReadBrandList2 = ReadBrandList;\n    C32.Platform.OS = uaData[\"platform\"], C32.Platform.IsMobile = uaData[\"mobile\"], C32.Platform.IsDesktop = !C32.Platform.IsMobile;\n    const d = /* @__PURE__ */ new Map([[\"Google Chrome\", \"Chrome\"], [\"Microsoft Edge\", \"Edge\"], [\"Opera\", \"Opera\"], [\"Opera GX\", \"Opera GX\"], [\"Mozilla Firefox\", \"Firefox\"], [\"Apple Safari\", \"Safari\"], [\"NW.js\", \"NW.js\"]]), e = /* @__PURE__ */ new Map([[\"Chromium\", \"Chromium\"], [\"Gecko\", \"Gecko\"], [\"WebKit\", \"WebKit\"]]);\n    ReadBrandList(uaData[\"brands\"]);\n    let o = false;\n    C32.Platform.GetDetailedInfo = async () => {\n      if (!o) try {\n        const r = await navigator[\"userAgentData\"][\"getHighEntropyValues\"]([\"platformVersion\", \"fullVersionList\"]);\n        ReadBrandList(r[\"fullVersionList\"]), \"Windows\" === C32.Platform.OS ? C32.Platform.OSVersion = GetWindowsNTVersionName(r[\"platformVersion\"]) : C32.Platform.OSVersion = r[\"platformVersion\"], o = true;\n      } catch (r) {\n        console.warn(\"Failed to get detailed user agent information: \", r);\n      }\n    };\n  } else {\n    let RunTest = function(r2, o) {\n      const e = Array.isArray(r2) ? r2 : [r2];\n      for (const t2 of e) {\n        const a = t2.exec(uaStr);\n        if (a) {\n          o(a);\n          break;\n        }\n      }\n    };\n    RunTest2 = RunTest;\n    RunTest(/windows\\s+nt\\s+([\\d\\.]+)/i, (r2) => {\n      C32.Platform.OS = \"Windows\";\n      const o = r2[1];\n      C32.Platform.OSVersion = GetWindowsNTVersionName(o);\n    }), RunTest(/mac\\s+os\\s+x\\s+([\\d\\._]+)/i, (r2) => {\n      C32.Platform.OS = \"macOS\", C32.Platform.OSVersion = r2[1].replace(/_/g, \".\");\n    }), RunTest(/CrOS/, () => {\n      C32.Platform.OS = \"Chrome OS\";\n    }), RunTest(/linux|openbsd|freebsd|netbsd/i, () => {\n      C32.Platform.OS = \"Linux\";\n    }), RunTest(/android/i, () => {\n      C32.Platform.OS = \"Android\";\n    }), RunTest(/android\\s+([\\d\\.]+)/i, (r2) => {\n      C32.Platform.OS = \"Android\", C32.Platform.OSVersion = r2[1];\n    }), C32.Platform.OS === UNKNOWN && (RunTest(/(iphone|ipod|ipad)/i, (r2) => {\n      C32.Platform.OS = \"iOS\";\n    }), RunTest([/iphone\\s+os\\s+([\\d\\._]+)/i, /ipad[^)]*os\\s+([\\d\\._]+)/i], (r2) => {\n      C32.Platform.OS = \"iOS\", C32.Platform.OSVersion = r2[1].replace(/_/g, \".\");\n    }));\n    const q = /chrome\\//i.test(uaStr), r = /chromium\\//i.test(uaStr), s = /edg\\//i.test(uaStr), t = /OPR\\//.test(uaStr), u = /nwjs/i.test(uaStr), v = /safari\\//i.test(uaStr), w = /webkit/i.test(uaStr), x = (s || t || RunTest(/chrome\\/([\\d\\.]+)/i, (r2) => {\n      C32.Platform.Browser = \"Chrome\", C32.Platform.BrowserVersion = r2[1], C32.Platform.BrowserEngine = \"Chromium\";\n    }), RunTest(/edg\\/([\\d\\.]+)/i, (r2) => {\n      C32.Platform.Browser = \"Edge\", C32.Platform.BrowserVersion = r2[1], C32.Platform.BrowserEngine = \"Chromium\";\n    }), RunTest(/OPR\\/([\\d\\.]+)/, (r2) => {\n      C32.Platform.Browser = \"Opera\", C32.Platform.BrowserVersion = r2[1], C32.Platform.BrowserEngine = \"Chromium\";\n    }), RunTest(/chromium\\/([\\d\\.]+)/i, (r2) => {\n      C32.Platform.Browser = \"Chromium\", C32.Platform.BrowserVersion = r2[1], C32.Platform.BrowserEngine = \"Chromium\";\n    }), RunTest(/nwjs\\/[0-9.]+/i, (r2) => {\n      C32.Platform.Browser = \"NW.js\", C32.Platform.BrowserVersion = r2[1], C32.Platform.BrowserEngine = \"Chromium\", C32.Platform.Context = \"nwjs\";\n    }), RunTest(/firefox\\/([\\d\\.]+)/i, (r2) => {\n      C32.Platform.Browser = \"Firefox\", C32.Platform.BrowserVersion = r2[1], C32.Platform.BrowserEngine = \"Gecko\";\n    }), !v || q || r || s || t || u || (C32.Platform.Browser = \"Safari\", C32.Platform.BrowserEngine = \"WebKit\", RunTest(/version\\/([\\d\\.]+)/i, (r2) => {\n      C32.Platform.BrowserVersion = r2[1];\n    }), RunTest(/crios\\/([\\d\\.]+)/i, (r2) => {\n      C32.Platform.Browser = \"Chrome for iOS\", C32.Platform.BrowserVersion = r2[1];\n    }), RunTest(/fxios\\/([\\d\\.]+)/i, (r2) => {\n      C32.Platform.Browser = \"Firefox for iOS\", C32.Platform.BrowserVersion = r2[1];\n    }), RunTest(/edgios\\/([\\d\\.]+)/i, (r2) => {\n      C32.Platform.Browser = \"Edge for iOS\", C32.Platform.BrowserVersion = r2[1];\n    })), C32.Platform.BrowserEngine === UNKNOWN && w && (C32.Platform.BrowserEngine = \"WebKit\"), \"Android\" === C32.Platform.OS && \"Safari\" === C32.Platform.Browser && (C32.Platform.Browser = \"Stock\"), /* @__PURE__ */ new Set([\"Windows\", \"macOS\", \"Linux\", \"Chrome OS\"])), y = x.has(C32.Platform.OS) || \"nwjs\" === C32.Platform.Context;\n    C32.Platform.IsDesktop = y, C32.Platform.IsMobile = !y;\n  }\n  \"Chrome\" === C32.Platform.Browser && \"browser\" === C32.Platform.Context && /wv\\)/.test(uaStr) && (C32.Platform.Context = \"webview\"), \"nwjs\" !== C32.Platform.Context && \"undefined\" != typeof window && (window.matchMedia && window.matchMedia(\"(display-mode: standalone)\").matches || navigator[\"standalone\"]) && (C32.Platform.Context = \"webapp\"), C32.Platform.BrowserVersionNumber = parseFloat(C32.Platform.BrowserVersion);\n  const looksLikeIPadOS = \"macOS\" === C32.Platform.OS && navigator[\"maxTouchPoints\"] && 2 < navigator[\"maxTouchPoints\"];\n  looksLikeIPadOS && (C32.Platform.OS = \"iOS\", C32.Platform.OSVersion = C32.Platform.BrowserVersion, C32.Platform.IsDesktop = false, C32.Platform.IsMobile = true, C32.Platform.IsIpadOS = true), C32.Platform.IsAppleOS = \"macOS\" === C32.Platform.OS || \"iOS\" === C32.Platform.OS;\n}\nvar ReadBrandList2;\nvar RunTest2;\nvar GetWindowsNTVersionName2;\n{\n  \"use strict\";\n  {\n    let asyncifyRequest = function(n) {\n      return new Promise((e2, t) => {\n        n.onsuccess = () => e2(n.result), n.onerror = () => t(n.error);\n      });\n    }, asyncifyTransaction = function(n) {\n      return new Promise((e2, t) => {\n        n.oncomplete = () => e2(), n.onerror = () => t(n.error), n.onabort = () => t(n.error);\n      });\n    }, openReadOnlyTransaction = function(e2, t) {\n      return openTransaction(e2, t);\n    }, openWriteTransaction = function(e2, t) {\n      return openTransaction(e2, t, true);\n    }, lazyOpenDatabase = function(t) {\n      RequireString(t);\n      let e2 = c.get(t);\n      return e2 instanceof Promise || (e2 = openDatabase(t), c.set(t, e2), e2.catch((e3) => c.delete(t))), e2;\n    }, RequireString = function(e2) {\n      if (\"string\" != typeof e2) throw new TypeError(\"expected string\");\n    }, getEntriesFromCursor = function(e2, a2) {\n      const t = e2.objectStore(b).openCursor();\n      return new Promise((n) => {\n        const r = [];\n        t.onsuccess = (e3) => {\n          const t2 = e3.target.result;\n          if (t2) {\n            switch (a2) {\n              case \"entries\":\n                r.push([t2.key, t2.value]);\n                break;\n              case \"keys\":\n                r.push(t2.key);\n                break;\n              case \"values\":\n                r.push(t2.value);\n            }\n            t2.continue();\n          } else n(r);\n        };\n      });\n    };\n    asyncifyRequest2 = asyncifyRequest, asyncifyTransaction2 = asyncifyTransaction, openReadOnlyTransaction2 = openReadOnlyTransaction, openWriteTransaction2 = openWriteTransaction, lazyOpenDatabase2 = lazyOpenDatabase, RequireString2 = RequireString, getEntriesFromCursor2 = getEntriesFromCursor;\n    const a = 2, b = \"keyvaluepairs\", c = /* @__PURE__ */ new Map(), d = \"undefined\" != typeof IDBObjectStore && \"function\" == typeof IDBObjectStore.prototype.getAll, e = \"undefined\" != typeof IDBObjectStore && \"function\" == typeof IDBObjectStore.prototype.getAllKeys;\n    async function openTransaction(t, n, r = false, a2 = true) {\n      const e2 = await lazyOpenDatabase(t);\n      try {\n        const s = e2.transaction([b], r ? \"readwrite\" : \"readonly\");\n        return n(s);\n      } catch (e3) {\n        if (a2 && \"InvalidStateError\" === e3[\"name\"]) return c.delete(t), openTransaction(t, n, r, false);\n        throw e3;\n      }\n    }\n    async function openDatabase(n) {\n      RequireString(n);\n      const e2 = indexedDB.open(n, a);\n      return e2.addEventListener(\"upgradeneeded\", (e3) => {\n        try {\n          const t = e3.target.result;\n          t.createObjectStore(b);\n        } catch (e4) {\n          console.error(\"Failed to create objectstore for database \" + n, e4);\n        }\n      }), asyncifyRequest(e2);\n    }\n    class f {\n      constructor(e2) {\n        RequireString(e2), this.name = e2;\n      }\n      async ready() {\n        await lazyOpenDatabase(this.name);\n      }\n      set(a2, s) {\n        return RequireString(a2), openWriteTransaction(this.name, async (e2) => {\n          const t = e2.objectStore(b).put(s, a2), n = asyncifyRequest(t), r = asyncifyTransaction(e2);\n          await Promise.all([r, n]);\n        });\n      }\n      get(s) {\n        return RequireString(s), openReadOnlyTransaction(this.name, async (e2) => {\n          const t = e2.objectStore(b).get(s), n = asyncifyRequest(t), r = asyncifyTransaction(e2), [, a2] = await Promise.all([r, n]);\n          return a2;\n        });\n      }\n      delete(a2) {\n        return RequireString(a2), openWriteTransaction(this.name, async (e2) => {\n          const t = e2.objectStore(b).delete(a2), n = asyncifyRequest(t), r = asyncifyTransaction(e2);\n          await Promise.all([r, n]);\n        });\n      }\n      clear() {\n        return openWriteTransaction(this.name, async (e2) => {\n          const t = e2.objectStore(b).clear(), n = asyncifyRequest(t), r = asyncifyTransaction(e2);\n          await Promise.all([r, n]);\n        });\n      }\n      keys() {\n        return openReadOnlyTransaction(this.name, async (t) => {\n          let n;\n          if (e) {\n            const s = t.objectStore(b).getAllKeys();\n            n = asyncifyRequest(s);\n          } else n = getEntriesFromCursor(t, \"keys\");\n          const r = asyncifyTransaction(t), [, a2] = await Promise.all([r, n]);\n          return a2;\n        });\n      }\n      values() {\n        return openReadOnlyTransaction(this.name, async (e2) => {\n          let t;\n          if (d) {\n            const a2 = e2.objectStore(b).getAll();\n            t = asyncifyRequest(a2);\n          } else t = getEntriesFromCursor(e2, \"values\");\n          const n = asyncifyTransaction(e2), [, r] = await Promise.all([n, t]);\n          return r;\n        });\n      }\n      entries() {\n        return openReadOnlyTransaction(this.name, async (e2) => {\n          const t = getEntriesFromCursor(e2, \"entries\"), n = asyncifyTransaction(e2), [, r] = await Promise.all([n, t]);\n          return r;\n        });\n      }\n    }\n    self.KVStorageContainer = f;\n  }\n}\nvar asyncifyRequest2;\nvar asyncifyTransaction2;\nvar openReadOnlyTransaction2;\nvar openWriteTransaction2;\nvar lazyOpenDatabase2;\nvar RequireString2;\nvar getEntriesFromCursor2;\n{\n  \"use strict\";\n  {\n    let NOT_IMPLEMENTED = function(e) {\n      throw new Error(`\"${e}\" is not implemented`);\n    }, DISALLOW_CALLBACK = function(e) {\n      if (\"function\" == typeof e) throw new Error(\"localforage callback API is not implemented; please use the promise API instead\");\n    }, StructuredClone = function(a2) {\n      return \"object\" == typeof a2 ? new Promise((t) => {\n        const { port1: e, port2: r } = new MessageChannel();\n        r.onmessage = (e2) => t(e2.data), e.postMessage(a2);\n      }) : Promise.resolve(a2);\n    };\n    NOT_IMPLEMENTED2 = NOT_IMPLEMENTED, DISALLOW_CALLBACK2 = DISALLOW_CALLBACK, StructuredClone2 = StructuredClone;\n    const a = self.KVStorageContainer, b = [/no available storage method found/i, /an attempt was made to break through the security policy of the user agent/i, /the user denied permission to access the database/i, /a mutation operation was attempted on a database that did not allow mutations/i, /idbfactory\\.open\\(\\) called in an invalid security context/i], c = /* @__PURE__ */ new WeakMap();\n    class d {\n      constructor(e) {\n        this._inst = e, this._isInMemory = !this._inst, this._isInMemory || \"undefined\" != typeof indexedDB || (this._isInMemory = true, console.warn(\"Unable to use local storage because IndexedDB API is not available\")), this._memoryStorage = /* @__PURE__ */ new Map();\n      }\n      _MaybeSwitchToMemoryFallback(e) {\n        if (!this._isInMemory) {\n          for (const t of b) if (e && t.test(e.message)) {\n            console.error(\"Unable to use local storage, reverting to in-memory store: \", e, e.message), this._isInMemory = true;\n            break;\n          }\n        }\n      }\n      async _getItemFallback(e) {\n        const t = this._memoryStorage.get(e), r = await StructuredClone(t);\n        return void 0 === r ? null : r;\n      }\n      async _setItemFallback(e, t) {\n        t = await StructuredClone(t), this._memoryStorage.set(e, t);\n      }\n      _removeItemFallback(e) {\n        this._memoryStorage.delete(e);\n      }\n      _clearFallback() {\n        this._memoryStorage.clear();\n      }\n      _keysFallback() {\n        return Array.from(this._memoryStorage.keys());\n      }\n      IsInMemory() {\n        return this._isInMemory;\n      }\n      GetMemoryStorage() {\n        return this._memoryStorage;\n      }\n      SetMemoryStorage(e) {\n        this._memoryStorage = e;\n      }\n      async getItem(t, e) {\n        if (DISALLOW_CALLBACK(e), this._isInMemory) return this._getItemFallback(t);\n        let r;\n        try {\n          r = await this._inst.get(t);\n        } catch (e2) {\n          return this._MaybeSwitchToMemoryFallback(e2), this._isInMemory ? this._getItemFallback(t) : (console.error(`Error reading '${t}' from storage, returning null: `, e2), null);\n        }\n        return void 0 === r ? null : r;\n      }\n      async setItem(t, r, e) {\n        if (DISALLOW_CALLBACK(e), void 0 === r && (r = null), this._isInMemory) await this._setItemFallback(t, r);\n        else try {\n          await this._inst.set(t, r);\n        } catch (e2) {\n          if (this._MaybeSwitchToMemoryFallback(e2), !this._isInMemory) throw e2;\n          await this._setItemFallback(t, r);\n        }\n      }\n      async removeItem(t, e) {\n        if (DISALLOW_CALLBACK(e), this._isInMemory) this._removeItemFallback(t);\n        else try {\n          await this._inst.delete(t);\n        } catch (e2) {\n          this._MaybeSwitchToMemoryFallback(e2), this._isInMemory ? this._removeItemFallback(t) : console.error(`Error removing '${t}' from storage: `, e2);\n        }\n      }\n      async clear(e) {\n        if (DISALLOW_CALLBACK(e), this._isInMemory) this._clearFallback();\n        else try {\n          await this._inst.clear();\n        } catch (e2) {\n          this._MaybeSwitchToMemoryFallback(e2), this._isInMemory ? this._clearFallback() : console.error(\"Error clearing storage: \", e2);\n        }\n      }\n      async keys(e) {\n        if (DISALLOW_CALLBACK(e), this._isInMemory) return this._keysFallback();\n        let t = [];\n        try {\n          t = await this._inst.keys();\n        } catch (e2) {\n          if (this._MaybeSwitchToMemoryFallback(e2), this._isInMemory) return this._keysFallback();\n          console.error(\"Error getting storage keys: \", e2);\n        }\n        return t;\n      }\n      ready(e) {\n        return DISALLOW_CALLBACK(e), this._isInMemory ? Promise.resolve(true) : this._inst.ready();\n      }\n      createInstance(e) {\n        if (e.forceInMemoryFallback) return new d(null);\n        {\n          const t = e.name;\n          if (\"string\" != typeof t) throw new TypeError(\"invalid store name\");\n          const r = new a(t);\n          return new d(r);\n        }\n      }\n      length(e) {\n        NOT_IMPLEMENTED(\"localforage.length()\");\n      }\n      key(e, t) {\n        NOT_IMPLEMENTED(\"localforage.key()\");\n      }\n      iterate(e, t) {\n        NOT_IMPLEMENTED(\"localforage.iterate()\");\n      }\n      setDriver(e) {\n        NOT_IMPLEMENTED(\"localforage.setDriver()\");\n      }\n      config(e) {\n        NOT_IMPLEMENTED(\"localforage.config()\");\n      }\n      defineDriver(e) {\n        NOT_IMPLEMENTED(\"localforage.defineDriver()\");\n      }\n      driver() {\n        NOT_IMPLEMENTED(\"localforage.driver()\");\n      }\n      supports(e) {\n        NOT_IMPLEMENTED(\"localforage.supports()\");\n      }\n      dropInstance() {\n        NOT_IMPLEMENTED(\"localforage.dropInstance()\");\n      }\n    }\n    self[\"localforage\"] = new d(new a(\"localforage\"));\n  }\n}\nvar NOT_IMPLEMENTED2;\nvar DISALLOW_CALLBACK2;\nvar StructuredClone2;\n{\n  const C32 = self.C3;\n  if (C32.Supports = {}, C32.Supports.WebAnimations = (() => {\n    try {\n      if (\"undefined\" == typeof document) return false;\n      const e = document.createElement(\"div\");\n      if (void 0 === e.animate) return false;\n      const t = e.animate([{ opacity: \"0\" }, { opacity: \"1\" }], 1e3);\n      return void 0 !== t.reverse;\n    } catch (e) {\n      return false;\n    }\n  })(), C32.Supports.DialogElement = \"undefined\" != typeof HTMLDialogElement, C32.Supports.RequestIdleCallback = !!self.requestIdleCallback, C32.Supports.ImageBitmap = !!self.createImageBitmap, C32.Supports.ImageBitmapOptions = false, C32.Supports.ImageBitmapOptionsResize = false, C32.Supports.ImageBitmap) {\n    try {\n      self.createImageBitmap(new ImageData(32, 32), { \"premultiplyAlpha\": \"none\" }).then(() => {\n        C32.Supports.ImageBitmapOptions = true;\n      }).catch(() => {\n        C32.Supports.ImageBitmapOptions = false;\n      });\n    } catch (e) {\n      C32.Supports.ImageBitmapOptions = false;\n    }\n    try {\n      self.createImageBitmap(new ImageData(32, 32), { \"resizeWidth\": 10, \"resizeHeight\": 10 }).then((e) => {\n        C32.Supports.ImageBitmapOptionsResize = 10 === e.width && 10 === e.height;\n      }).catch(() => {\n        C32.Supports.ImageBitmapOptionsResize = false;\n      });\n    } catch (e) {\n      C32.Supports.ImageBitmapOptionsResize = false;\n    }\n  }\n  if (C32.Supports.ClipboardReadText = !(!navigator[\"clipboard\"] || !navigator[\"clipboard\"][\"readText\"]), C32.Supports.PermissionsQuery = !(!navigator[\"permissions\"] || !navigator[\"permissions\"][\"query\"]), C32.Supports.ClipboardPermissionsQuery = false, C32.Supports.PermissionsQuery) {\n    const g = { \"name\": \"clipboard-read\" };\n    navigator[\"permissions\"][\"query\"](g).then(() => {\n      C32.Supports.ClipboardPermissionsQuery = true;\n    }).catch(() => {\n      C32.Supports.ClipboardPermissionsQuery = false;\n    });\n  }\n  C32.Supports.AsyncClipboardApi = !!(navigator[\"permissions\"] && navigator[\"clipboard\"] && self[\"ClipboardItem\"]), C32.Supports.Proxies = \"undefined\" != typeof Proxy, C32.Supports.DownloadAttribute = (() => {\n    if (\"undefined\" == typeof document) return false;\n    const e = document.createElement(\"a\");\n    return void 0 !== e.download;\n  })(), C32.Supports.Fetch = \"function\" == typeof fetch, C32.Supports.PersistentStorage = !!(self.isSecureContext && \"Opera\" !== C32.Platform.Browser && navigator[\"storage\"] && navigator[\"storage\"][\"persist\"]), C32.Supports.StorageQuotaEstimate = !!(self.isSecureContext && navigator[\"storage\"] && navigator[\"storage\"][\"estimate\"]), C32.Supports.Fullscreen = (() => {\n    if (\"undefined\" == typeof document) return false;\n    if (\"iOS\" === C32.Platform.OS) return false;\n    const e = document.documentElement;\n    return !!(e.requestFullscreen || e.msRequestFullscreen || e.mozRequestFullScreen || e.webkitRequestFullscreen);\n  })(), C32.Supports.ImageDecoder = void 0 !== self[\"ImageDecoder\"], C32.Supports.WebCodecs = !!self[\"VideoEncoder\"], C32.Supports.NativeFileSystemAPI = !!self[\"showOpenFilePicker\"], C32.Supports.QueryLocalFonts = !!self[\"queryLocalFonts\"], C32.Supports.UserActivation = !!navigator[\"userActivation\"], C32.Supports.CanvasToBlobWebP = false, (async () => {\n    let t;\n    \"undefined\" == typeof document ? t = new OffscreenCanvas(32, 32) : ((t = document.createElement(\"canvas\")).width = 32, t.height = 32);\n    const e = t.getContext(\"2d\");\n    e.fillStyle = \"blue\", e.fillRect(0, 0, 32, 32);\n    let o = null;\n    try {\n      t[\"convertToBlob\"] ? o = await t[\"convertToBlob\"]({ \"type\": \"image/webp\", \"quality\": 1 }) : t.toBlob && (o = await new Promise((e2) => t.toBlob(e2, \"image/webp\", 1))), C32.Supports.CanvasToBlobWebP = o && \"image/webp\" === o.type;\n    } catch (e2) {\n      C32.Supports.CanvasToBlobWebP = false;\n    }\n  })();\n}\n{\n  let arrayFlat = function(t, e) {\n    return t.reduce((t2, r) => (0 < e && Array.isArray(r) ? Array.prototype.push.apply(t2, arrayFlat(r, e - 1)) : t2.push(r), t2), []);\n  };\n  arrayFlat2 = arrayFlat;\n  const C32 = self.C3;\n  if (!String.prototype.trimStart) {\n    const a = /^[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]*/;\n    String.prototype.trimStart = function() {\n      return this.replace(a, \"\");\n    };\n  }\n  if (!String.prototype.trimEnd) {\n    const c = /[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]*$/;\n    String.prototype.trimEnd = function() {\n      return this.replace(c, \"\");\n    };\n  }\n  String.prototype.replaceAll || (String.prototype.replaceAll = function(t, r) {\n    return this.replace(new RegExp(C32.EscapeRegex(t), \"g\"), r);\n  }), Array.prototype.values || (Array.prototype.values = function* () {\n    for (const t of this) yield t;\n  }), Array.prototype.flat || (Array.prototype.flat = function(t = 1) {\n    return arrayFlat(this, t);\n  }), Array.prototype.at || (Array.prototype.at = function(t) {\n    if ((t = Math.trunc(t) || 0) < 0 && (t += this.length), !(t < 0 || t >= this.length)) return this[t];\n  }), String.prototype.at || (String.prototype.at = function(t) {\n    if ((t = Math.trunc(t) || 0) < 0 && (t += this.length), !(t < 0 || t >= this.length)) return this[t];\n  }), RegExp.escape || (RegExp.escape = function(t) {\n    return String(t).replace(/[\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n  }), Set.prototype.isSubsetOf || (Set.prototype.isSubsetOf = function(t) {\n    if (!(t instanceof Set)) throw new TypeError(\"argument must be a Set\");\n    for (const r of this) if (!t.has(r)) return false;\n    return true;\n  }), navigator[\"storage\"] && !navigator[\"storage\"][\"estimate\"] && navigator[\"webkitTemporaryStorage\"] && navigator[\"webkitTemporaryStorage\"][\"queryUsageAndQuota\"] && (navigator[\"storage\"][\"estimate\"] = function() {\n    return new Promise((e, t) => navigator[\"webkitTemporaryStorage\"][\"queryUsageAndQuota\"]((t2, r) => e({ \"usage\": t2, \"quota\": r }), t));\n  }), void 0 === self.isSecureContext && (self.isSecureContext = \"https:\" === location.protocol), void 0 === self[\"globalThis\"] && (self[\"globalThis\"] = self);\n}\nvar arrayFlat2;\n{\n  let assertFail = function(e) {\n    let s = C32.GetCallStack(), t = \"Assertion failure: \" + e + \"\\n\\nStack trace:\\n\" + s;\n    console.error(t);\n  };\n  assertFail2 = assertFail;\n  const C32 = self.C3;\n  self.assert = function(e, s) {\n    e || assertFail(s);\n  };\n}\nvar assertFail2;\n{\n  const C32 = self.C3, C3X = self.C3X, TypedArray = (C32.IsNumber = function(e) {\n    return \"number\" == typeof e;\n  }, C32.IsFiniteNumber = function(e) {\n    return C32.IsNumber(e) && isFinite(e);\n  }, C32.RequireNumber = function(e) {\n    if (!C32.IsNumber(e)) throw new TypeError(\"expected number\");\n  }, C32.RequireOptionalNumber = function(e) {\n    C32.IsNullOrUndefined(e);\n  }, C32.RequireNumberInRange = function(e, n, r) {\n    if (!C32.IsNumber(e) || isNaN(e) || e < n || r < e) throw new RangeError(\"number outside of range\");\n  }, C32.RequireAllNumber = function(...n) {\n    for (let e of n) ;\n  }, C32.RequireFiniteNumber = function(e) {\n    if (!C32.IsFiniteNumber(e)) throw new TypeError(\"expected finite number\");\n  }, C32.RequireOptionalFiniteNumber = function(e) {\n    C32.IsNullOrUndefined(e);\n  }, C32.RequireAllFiniteNumber = function(...n) {\n    for (let e of n) ;\n  }, C32.IsString = function(e) {\n    return \"string\" == typeof e;\n  }, C32.RequireString = function(e) {\n    if (!C32.IsString(e)) throw new TypeError(\"expected string\");\n  }, C32.RequireOptionalString = function(e) {\n    C32.IsNullOrUndefined(e);\n  }, C32.RequireAllString = function(...n) {\n    for (let e of n) ;\n  }, C32.IsSimpleObject = function(e) {\n    if (\"object\" != typeof e || null === e) return false;\n    let n = Object.getPrototypeOf(e);\n    return n ? n.constructor === Object : null === n;\n  }, C32.RequireSimpleObject = function(e) {\n    if (!C32.IsSimpleObject(e)) throw new TypeError(\"expected simple object\");\n  }, C32.RequireOptionalSimpleObject = function(e) {\n    if (!C32.IsNullOrUndefined(e) && !C32.IsSimpleObject(e)) throw new TypeError(\"expected simple object\");\n  }, C32.IsObject = function(e) {\n    return \"object\" == typeof e && null !== e && !Array.isArray(e);\n  }, C32.RequireObject = function(e) {\n    if (!C32.IsObject(e)) throw new TypeError(\"expected object\");\n  }, C32.RequireOptionalObject = function(e) {\n    C32.IsNullOrUndefined(e);\n  }, C32.RequireAllObject = function(...n) {\n    for (let e of n) ;\n  }, C32.IsFileLike = function(e) {\n    return C32.WeakIsInstanceOf(e, Blob) && \"string\" == typeof e[\"name\"];\n  }, C32.RequireFileLike = function(e) {\n    if (!C32.IsFileLike(e)) throw new TypeError(\"expected file\");\n  }, C32.RequireOptionalFileLike = function(e) {\n    C32.IsNullOrUndefined(e);\n  }, C32.IsArray = function(e) {\n    return Array.isArray(e);\n  }, C32.RequireArray = function(e) {\n    if (!C32.IsArray(e)) throw new TypeError(\"expected array\");\n  }, C32.RequireOptionalArray = function(e) {\n    C32.IsNullOrUndefined(e);\n  }, C32.RequireAllArray = function(...n) {\n    for (let e of n) ;\n  }, C32.Is2DArray = function(e) {\n    return !(!C32.IsArray(e) || e.length && !C32.IsArray(e[0]));\n  }, C32.Require2DArray = function(n) {\n    if (!C32.Is2DArray(n)) throw new TypeError(\"expected 2d array\");\n    for (let e of n) if (!C32.IsArray(e)) throw new TypeError(\"expected 2d array\");\n  }, C32.RequireOptional2DArray = function(e) {\n    C32.IsNullOrUndefined(e);\n  }, C32.IsFunction = function(e) {\n    return \"function\" == typeof e;\n  }, C32.RequireFunction = function(e, n) {\n    if (!C32.IsFunction(e)) throw new TypeError(\"expected function\");\n    if (!C32.IsNullOrUndefined(n) && e !== n) throw new TypeError(\"expected same function reference\");\n  }, C32.RequireOptionalFunction = function(e) {\n    C32.IsNullOrUndefined(e);\n  }, C32.RequireAllFunction = function(...n) {\n    for (let e of n) ;\n  }, C32.RequireAnyFunction = function(n, ...r) {\n    if (!C32.IsFunction(n)) throw new TypeError(\"expected function\");\n    if (!r.length) throw new Error(\"missing comparison functions\");\n    for (let e of r) if (!C32.IsNullOrUndefined(e) && n === e) return;\n    throw new TypeError(\"expected same function reference\");\n  }, C32.RequireOptionalAllFunction = function(...n) {\n    if (!C32.IsNullOrUndefined(n)) for (let e of n) ;\n  }, C32.IsInstanceOf = function(e, n) {\n    return e instanceof n;\n  }, C32.IsInstanceOfAny = function(n, ...r) {\n    for (let e of r) if (C32.IsInstanceOf(n, e)) return true;\n    return false;\n  }, C32.RequireInstanceOf = function(e, n) {\n    if (!C32.IsInstanceOf(e, n)) throw new TypeError(\"unexpected type\");\n  }, C32.RequireOptionalInstanceOf = function(e, n) {\n    C32.IsNullOrUndefined(e);\n  }, C32.RequireAllInstanceOf = function(e, ...n) {\n    for (let e2 of n) ;\n  }, C32.RequireAnyInstanceOf = function(e, ...n) {\n    if (!C32.IsInstanceOfAny(e, ...n)) throw new TypeError(\"unexpected type\");\n  }, C32.RequireAnyOptionalInstanceOf = function(e, ...n) {\n    if (!C32.IsNullOrUndefined(e) && !C32.IsInstanceOfAny(e, ...n)) throw new TypeError(\"unexpected type\");\n  }, C32.IsArrayOf = function(n, r) {\n    for (let e of n) if (!C32.IsInstanceOf(e, r)) return false;\n    return true;\n  }, C32.IsArrayOfFiniteNumbers = function(n) {\n    for (let e of n) if (!C32.IsFiniteNumber(e)) return false;\n    return true;\n  }, C32.RequireArrayOf = function(n, e) {\n    for (let e2 of n) ;\n  }, C32.RequireOptionalArrayOf = function(n, e) {\n    if (!C32.IsNullOrUndefined(n)) for (let e2 of n) ;\n  }, C32.RequireOptionalArrayOfFunctions = function(n, e) {\n    if (!C32.IsNullOrUndefined(n)) for (let e2 of n) ;\n  }, C32.RequireArrayOfAny = function(n) {\n    for (let e of n) ;\n  }, C32.RequireOptionalArrayOfAny = function(n) {\n    if (!C32.IsNullOrUndefined(n)) for (let e of n) ;\n  }, C32.IsDOMNode = function(e, n) {\n    return !(C32.IsNullOrUndefined(e) || !C32.IsString(e.nodeName)) && (!n || C32.equalsNoCase(e.nodeName, n));\n  }, C32.RequireDOMNode = function(e, n) {\n    if (C32.IsNullOrUndefined(e) || !C32.IsString(e.nodeName)) throw new TypeError(\"expected DOM node\");\n    if (n && !C32.equalsNoCase(e.nodeName, n)) throw new TypeError(`expected DOM '${n}' node`);\n  }, C32.RequireOptionalDOMNode = function(e, n) {\n    C32.IsNullOrUndefined(e);\n  }, C32.IsHTMLElement = function(e, n) {\n    return !(C32.IsNullOrUndefined(e) || !C32.IsString(e.tagName)) && (!n || C32.equalsNoCase(e.tagName, n));\n  }, C32.RequireHTMLElement = function(e, n) {\n    if (C32.IsNullOrUndefined(e) || !C32.IsString(e.tagName)) throw new TypeError(\"expected HTML element\");\n    if (n && !C32.equalsNoCase(e.tagName, n)) throw new TypeError(`expected HTML '${n}' element`);\n  }, C32.RequireOptionalHTMLElement = function(e, n) {\n    C32.IsNullOrUndefined(e);\n  }, C32.IsDrawable = function(e) {\n    return C32.IsHTMLElement(e, \"img\") || C32.IsHTMLElement(e, \"canvas\") || C32.IsHTMLElement(e, \"video\") || \"undefined\" != typeof OffscreenCanvas && e instanceof OffscreenCanvas || \"undefined\" != typeof ImageBitmap && e instanceof ImageBitmap;\n  }, C32.RequireDrawable = function(e) {\n    if (!C32.IsDrawable(e)) throw new TypeError(\"expected drawable\");\n  }, C32.RequireOptionalDrawable = function(e) {\n    C32.IsNullOrUndefined(e);\n  }, C32.IsDrawableOrImageData = function(e) {\n    return e instanceof ImageData || C32.IsDrawable(e);\n  }, C32.RequireDrawableOrImageData = function(e) {\n    if (!C32.IsDrawableOrImageData(e)) throw new TypeError(\"expected drawable or image data\");\n  }, C32.RequireOptionalDrawableOrImageData = function(e) {\n    if (!C32.IsNullOrUndefined(e) && !C32.IsDrawableOrImageData(e)) throw new TypeError(\"expected drawable or image data\");\n  }, C32.IsStringLike = function(e) {\n    return \"string\" == typeof e || C32.HtmlString && e instanceof C32.HtmlString || e instanceof C32.BBString;\n  }, C32.RequireStringLike = function(e) {\n    if (!C32.IsStringLike(e)) throw new TypeError(\"expected string-like\");\n  }, C32.RequireOptionalStringLike = function(e) {\n    C32.IsNullOrUndefined(e);\n  }, C32.RequireAllStringLike = function(...n) {\n    for (let e of n) ;\n  }, C32.RequireOverride = function() {\n    throw new Error(\"must be overridden\");\n  }, C32.NotYetImplemented = function() {\n    throw new Error(\"not yet implemented\");\n  }, C32.IsGeneratorFunction = function(e) {\n    return e.constructor === function* () {\n    }.constructor;\n  }, C32.RequireGeneratorFunction = function(e) {\n    if (!C32.IsGeneratorFunction(e)) throw new Error(\"expected generator function\");\n  }, C32.IsIterable = function(e) {\n    return \"function\" === e[Symbol.iterator];\n  }, C32.RequireIterable = function(e) {\n    if (!C32.IsIterable(e)) throw new Error(\"expected iterable\");\n  }, C32.IsDefined = function(e) {\n    return !C32.IsNullOrUndefined(e);\n  }, C32.IsNullOrUndefined = function(e) {\n    return null == e;\n  }, C32.AreArrayElementsOfSameType = function(n) {\n    let r = n[0].constructor;\n    for (let e of n) if (e.constructor !== r) return false;\n    return r;\n  }, C32.AreArrayElementsOfType = function(n, r) {\n    for (let e of n) if (!(e instanceof r)) return false;\n    return true;\n  }, Object.getPrototypeOf(Uint8Array));\n  C32.IsTypedArray = function(e) {\n    return C32.IsInstanceOf(e, TypedArray);\n  }, C32.RequireTypedArray = function(e) {\n  }, C32.WeakRequireTypedArray = function(e) {\n    C32.WeakRequireInstanceOf(e, TypedArray);\n  }, C32.WeakRequireAnyInstanceOf = function(e, ...n) {\n    if (!C32.WeakIsAnyInstanceOf(e, ...n)) throw new TypeError(\"unexpected type\");\n  }, C32.WeakIsAnyInstanceOf = function(e, ...n) {\n    for (const r of n) if (C32.WeakIsInstanceOf(e, r)) return true;\n    return false;\n  }, C32.WeakRequireInstanceOf = function(e, n) {\n    if (!C32.WeakIsInstanceOf(e, n)) throw new TypeError(\"unexpected type\");\n  }, C32.WeakIsInstanceOf = function(e, n) {\n    for (; e = Object.getPrototypeOf(e); ) if (e.constructor.name === n.name) return true;\n    return false;\n  }, C3X.RequireNumber = C32.RequireNumber, C3X.RequireOptionalNumber = C32.RequireOptionalNumber, C3X.RequireFiniteNumber = C32.RequireFiniteNumber, C3X.RequireOptionalFiniteNumber = C32.RequireOptionalFiniteNumber, C3X.RequireString = C32.RequireString, C3X.RequireOptionalString = C32.RequireOptionalString, C3X.RequireObject = C32.RequireObject, C3X.RequireOptionalObject = C32.RequireOptionalObject, C3X.RequireArray = C32.RequireArray, C3X.RequireOptionalArray = C32.RequireOptionalArray, C3X.RequireFunction = C32.RequireFunction, C3X.RequireOptionalFunction = C32.RequireOptionalFunction, C3X.RequireInstanceOf = C32.RequireInstanceOf, C3X.RequireOptionalInstanceOf = C32.RequireOptionalInstanceOf, C3X.IsNullOrUndefined = C32.IsNullOrUndefined;\n}\n{\n  let isValidTypeChange = function(e, t) {\n    let r = C32.getType(e), n = C32.getType(t);\n    return \"null\" === r || \"null\" === n || \"undefined\" !== r && \"undefined\" !== n && r === n;\n  }, logDefendedObjectWarning = function(e) {\n    console.warn(\"[Defence] \" + e + \" @\", C32.GetCallStack());\n  }, CheckDefendedObjectsUsedCorrectly = function() {\n    if (checkRafId = -1, 0 < ctorObjectToProxy.size || 0 < ctorProxyToObject.size) {\n      let e = new Set([...ctorObjectToProxy.keys()].map((e2) => C32.getName(e2))), t = [...e].join(\",\");\n      console.warn(\"An object derived from DefendedBase was not protected with debugDefend(). This will disable some checks. See the coding guidelines! Possible affected class names: \" + t), ctorObjectToProxy.clear(), ctorProxyToObject.clear();\n    }\n  }, getObjectPropertySet = function(t) {\n    let r = /* @__PURE__ */ new Set();\n    for (let e in t) r.add(e);\n    return r;\n  }, VerifyObjectPropertiesConsistent = function(e, t) {\n    let r = getObjectPropertySet(t), n = typeProperties.get(e);\n    if (n) {\n      let t2 = [];\n      for (let e2 of n.values()) r.has(e2) ? r.delete(e2) : t2.push(e2);\n      C32.appendArray(t2, [...r]), t2.length && console.warn(`[Defence] '${C32.getName(e)}' constructor creates inconsistent properties: ` + t2.join(\", \"));\n    } else typeProperties.set(e, r);\n  };\n  isValidTypeChange2 = isValidTypeChange, logDefendedObjectWarning2 = logDefendedObjectWarning, CheckDefendedObjectsUsedCorrectly2 = CheckDefendedObjectsUsedCorrectly, getObjectPropertySet2 = getObjectPropertySet, VerifyObjectPropertiesConsistent2 = VerifyObjectPropertiesConsistent;\n  const C32 = self.C3, logRafIds = /* @__PURE__ */ new Map();\n  C32.ColorLog = function(e, t) {\n    console.log(\"%c\" + e, \"font-weight: bold; color:\" + t);\n  }, C32.RafLog = function(e, ...t) {\n    logRafIds.has(e) || logRafIds.set(e, -1), -1 === logRafIds.get(e) && logRafIds.set(e, requestAnimationFrame(() => {\n      console.log(\"%c\" + e, \"font-weight: bold\", ...t), logRafIds.set(e, -1);\n    }));\n  };\n  let measures;\n  C32.StartMeasure = function(e) {\n    performance.mark(e), (measures = measures || /* @__PURE__ */ new Map()).has(e) || measures.set(e, { current: 0, total: 0, average: 0, calls: 1, toString: function() {\n      return `${e} :: current => ${this.current.toPrecision(3)} :: average => ${this.average.toPrecision(3)} :: calls => ` + this.calls;\n    } });\n  }, C32.EndMeasure = function(e) {\n    performance.measure(\"measure-\" + e, e);\n    const t = performance.getEntriesByName(\"measure-\" + e)[0], r = measures.get(e);\n    r.current = t.duration, r.total += r.current, r.average = r.total / r.calls, console.log(r.toString()), r.calls++, performance.clearMarks(e), performance.clearMeasures(\"measure-\" + e);\n  }, C32.GetCallStack = function() {\n    return new Error().stack;\n  }, C32.Debugger = function() {\n  }, C32.cast = function(e, t) {\n    return e && e instanceof t ? e : null;\n  }, C32.getName = function(e) {\n    return void 0 === e ? \"undefined\" : null === e ? \"null\" : \"boolean\" == typeof e ? \"<boolean>\" : C32.IsNumber(e) ? \"<number>\" : C32.IsString(e) ? \"<string>\" : C32.IsArray(e) ? \"<array>\" : \"symbol\" == typeof e ? \"<\" + e.toString() + \">\" : C32.IsFunction(e) ? e.name && \"Function\" !== e.name ? e.name : \"<anonymous function>\" : \"object\" == typeof e ? e.constructor && e.constructor.name && \"Object\" !== e.constructor.name ? e.constructor.name : \"<anonymous object>\" : \"<unknown>\";\n  }, C32.getType = function(e) {\n    return null === e ? \"null\" : Array.isArray(e) ? \"array\" : typeof e;\n  }, C32.range = function* (t, r) {\n    if (!isFinite(Math.abs(t - r))) throw new Error(\"Invalid parameters\");\n    if (r < t) for (let e = t - 1; e >= r; e--) yield e;\n    else for (let e = t; e < r; e++) yield e;\n  };\n  let ctorObjectToProxy = /* @__PURE__ */ new Map(), ctorProxyToObject = /* @__PURE__ */ new Map(), proxyToObject = /* @__PURE__ */ new WeakMap(), releasedObjects = /* @__PURE__ */ new WeakMap();\n  C32.DefendHandler = {};\n  const VALID_GET_MISSING_KEYS = /* @__PURE__ */ new Set([\"then\", \"splice\"]);\n  C32.DefendHandler.get = function(e, t) {\n    return t in e || \"symbol\" == typeof t || VALID_GET_MISSING_KEYS.has(t) || logDefendedObjectWarning(`Accessed missing property '${t}' from defended object '${C32.getName(e)}', returning undefined`), releasedObjects.has(e) && \"symbol\" != typeof t && !VALID_GET_MISSING_KEYS.has(t) && logDefendedObjectWarning(`Accessed property '${t}' on a released object '${C32.getName(e)}'\nObject was originally released at: ${releasedObjects.get(e)})\nCall stack at access: `), e[t];\n  }, C32.DefendHandler.set = function(e, t, r) {\n    return t in e || ctorObjectToProxy.has(e) || logDefendedObjectWarning(`Set non-existent property '${t}' to '${r}' on defended object '${C32.getName(e)}'`), isValidTypeChange(e[t], r) || ctorObjectToProxy.has(e) || logDefendedObjectWarning(`Set '${C32.getType(e[t])}' property '${t}' to type '${C32.getType(r)}' on defended object '${C32.getName(e)}'`), releasedObjects.has(e) && logDefendedObjectWarning(`Set property '${t}' on a released object '${C32.getName(e)}'\nObject was originally released at: ${releasedObjects.get(e)})\nCall stack at access: `), e[t] = r, true;\n  }, C32.DefendHandler.deleteProperty = function(e, t) {\n    throw new ReferenceError(`Cannot delete property '${t}' from defended object '${C32.getName(e)}'`);\n  }, C32.DefendHandler.defineProperty = function(e, t, r) {\n    throw new ReferenceError(`Cannot define property '${t}' on defended object '${C32.getName(e)}'`);\n  }, C32.DefendHandler.enumerate = function(e) {\n    throw new ReferenceError(`Cannot enumerate defended object '${C32.getName(e)}'`);\n  };\n  let checkRafId = -1;\n  C32.DefendedBase = class {\n    constructor() {\n      if (C32.isDebugDefend && C32.Supports.Proxies) {\n        let e = Object.create(new.target.prototype), t = new Proxy(e, C32.DefendHandler);\n        return ctorObjectToProxy.set(e, t), ctorProxyToObject.set(t, e), proxyToObject.set(t, e), -1 === checkRafId && (checkRafId = requestAnimationFrame(CheckDefendedObjectsUsedCorrectly)), t;\n      }\n    }\n  }, C32.debugDefend = function(t) {\n    if (C32.isDebugDefend && C32.Supports.Proxies && t instanceof C32.DefendedBase) {\n      if (ctorProxyToObject.has(t)) {\n        let e = ctorProxyToObject.get(t);\n        ctorProxyToObject.delete(t), ctorObjectToProxy.delete(e);\n      }\n      return t;\n    }\n    return C32.isDebug ? Object.seal(t) : t;\n  }, C32.New = function(e, ...t) {\n    let r;\n    try {\n      r = new e(...t);\n    } catch (e2) {\n      throw ctorProxyToObject.clear(), ctorObjectToProxy.clear(), e2;\n    }\n    return C32.isDebugDefend && VerifyObjectPropertiesConsistent(e, r), C32.debugDefend(r);\n  }, C32.Release = function(e) {\n    let t = proxyToObject.get(e);\n    t && releasedObjects.set(t, C32.GetCallStack());\n  }, C32.WasReleased = function(e) {\n    let t = proxyToObject.get(e);\n    return !!t && !!releasedObjects.get(t);\n  };\n  let typeProperties = /* @__PURE__ */ new Map();\n  C32.PerfMark = class {\n    constructor(e) {\n      this._name = \"\", e && this.start(e);\n    }\n    start(e) {\n      C32.isPerformanceProfiling && (this._name = e, performance.mark(this._name + \"-Start\"));\n    }\n    end() {\n      C32.isPerformanceProfiling && (performance.mark(this._name + \"-End\"), performance.measure(this._name, this._name + \"-Start\", this._name + \"-End\"));\n    }\n    next(e) {\n      C32.isPerformanceProfiling && (this.end(), this._name = e, performance.mark(this._name + \"-Start\"));\n    }\n  };\n}\nvar isValidTypeChange2;\nvar logDefendedObjectWarning2;\nvar CheckDefendedObjectsUsedCorrectly2;\nvar getObjectPropertySet2;\nvar VerifyObjectPropertiesConsistent2;\n{\n  let isNegativeZero = function(t) {\n    return 0 === t && 1 / t < 0;\n  };\n  isNegativeZero2 = isNegativeZero;\n  const C32 = self.C3, TWO_PI = 2 * Math.PI, D_TO_R = Math.PI / 180, R_TO_D = 180 / Math.PI, ALPHAEX_SHIFT = (C32.wrap = function(t, n, e) {\n    t = Math.floor(t), n = Math.floor(n);\n    const r = (e = Math.floor(e)) - n;\n    if (0 == r) return e;\n    if (t < n) {\n      const a = e - (n - t) % r;\n      return a === e ? 0 : a;\n    }\n    return n + (t - n) % r;\n  }, C32.mapToRange = function(t, n, e, r, a) {\n    const o = e - n;\n    if (0 == o && 0 === r) return t;\n    const c = a - r;\n    return (t - n) * c / o + r;\n  }, C32.normalize = function(t, n, e) {\n    return n - e == 0 ? 1 : (t - n) / (e - n);\n  }, C32.clamp = function(t, n, e) {\n    return t < n ? n : e < t ? e : t;\n  }, C32.clampAngle = function(t) {\n    return (t %= TWO_PI) < 0 && (t += TWO_PI), t;\n  }, C32.toRadians = function(t) {\n    return t * D_TO_R;\n  }, C32.toDegrees = function(t) {\n    return t * R_TO_D;\n  }, C32.hypot2DFast = function(t, n) {\n    return Math.sqrt(t * t + n * n);\n  }, C32.hypot3DFast = function(t, n, e) {\n    return Math.sqrt(t * t + n * n + e * e);\n  }, C32.distanceTo = function(t, n, e, r) {\n    return C32.hypot2DFast(e - t, r - n);\n  }, C32.distanceSquared = function(t, n, e, r) {\n    const a = e - t, o = r - n;\n    return a * a + o * o;\n  }, C32.angleTo = function(t, n, e, r) {\n    return Math.atan2(r - n, e - t);\n  }, C32.angleDiff = function(t, n) {\n    if (t === n) return 0;\n    let e = Math.sin(t), r = Math.cos(t), a = Math.sin(n), o = Math.cos(n), c = e * a + r * o;\n    return 1 <= c ? 0 : c <= -1 ? Math.PI : Math.acos(c);\n  }, C32.angleRotate = function(t, n, e) {\n    let r = Math.sin(t), a = Math.cos(t), o = Math.sin(n), c = Math.cos(n);\n    return Math.acos(r * o + a * c) > e ? 0 < a * o - r * c ? C32.clampAngle(t + e) : C32.clampAngle(t - e) : C32.clampAngle(n);\n  }, C32.angleClockwise = function(t, n) {\n    let e = Math.sin(t), r = Math.cos(t), a = Math.sin(n), o = Math.cos(n);\n    return r * a - e * o <= 0;\n  }, C32.angleLerp = function(t, n, e, r = 0) {\n    let a = C32.angleDiff(t, n);\n    const o = TWO_PI * r;\n    return C32.angleClockwise(n, t) ? C32.clampAngle(t + (a + o) * e) : C32.clampAngle(t - (a + o) * e);\n  }, C32.angleLerpClockwise = function(t, n, e, r = 0) {\n    const a = C32.angleDiff(t, n), o = TWO_PI * r;\n    return C32.angleClockwise(n, t) ? C32.clampAngle(t + (a + o) * e) : C32.clampAngle(t + (TWO_PI - a + o) * e);\n  }, C32.angleLerpAntiClockwise = function(t, n, e, r = 0) {\n    const a = C32.angleDiff(t, n), o = TWO_PI * r;\n    return C32.angleClockwise(n, t) ? C32.clampAngle(t - (-TWO_PI + a - o) * e) : C32.clampAngle(t - (a + o) * e);\n  }, C32.angleReflect = function(t, n) {\n    const e = C32.angleDiff(t, n);\n    return C32.angleClockwise(t, n) ? C32.clampAngle(n - e) : C32.clampAngle(n + e);\n  }, C32.lerp = function(t, n, e) {\n    return t + e * (n - t);\n  }, C32.unlerp = function(t, n, e) {\n    return t === n ? 0 : (e - t) / (n - t);\n  }, C32.relerp = function(t, n, e, r, a) {\n    return C32.lerp(r, a, C32.unlerp(t, n, e));\n  }, C32.qarp = function(t, n, e, r) {\n    return C32.lerp(C32.lerp(t, n, r), C32.lerp(n, e, r), r);\n  }, C32.cubic = function(t, n, e, r, a) {\n    return C32.lerp(C32.qarp(t, n, e, a), C32.qarp(n, e, r, a), a);\n  }, C32.cosp = function(t, n, e) {\n    return (t + n + (t - n) * Math.cos(e * Math.PI)) / 2;\n  }, C32.isPOT = function(t) {\n    return 0 < t && 0 == (t - 1 & t);\n  }, C32.nextHighestPowerOfTwo = function(n) {\n    --n;\n    for (let t = 1; t < 32; t <<= 1) n |= n >> t;\n    return n + 1;\n  }, C32.roundToNearestFraction = function(t, n) {\n    return Math.round(t * n) / n;\n  }, C32.floorToNearestFraction = function(t, n) {\n    return Math.floor(t * n) / n;\n  }, C32.roundToDp = function(t, n) {\n    n = Math.max(Math.floor(n), 0);\n    const e = Math.pow(10, n);\n    return Math.round(t * e) / e;\n  }, C32.countDecimals = function(t) {\n    return Math.floor(t) !== t && t.toString().split(\".\")[1].length || 0;\n  }, C32.toFixed = function(t, n) {\n    let e = t.toFixed(n), r = e.length - 1;\n    for (; 0 <= r && \"0\" === e.charAt(r); --r) ;\n    return 0 <= r && \".\" === e.charAt(r) && --r, r < 0 ? e : e.substr(0, r + 1);\n  }, C32.PackRGB = function(t, n, e) {\n    return C32.clamp(t, 0, 255) | C32.clamp(n, 0, 255) << 8 | C32.clamp(e, 0, 255) << 16;\n  }, 1024), ALPHAEX_MAX = 1023, RGBEX_SHIFT = 16384, RGBEX_MAX = 8191, RGBEX_MIN = -8192;\n  C32.PackRGBAEx = function(t, n, e, r) {\n    return t = C32.clamp(Math.floor(1024 * t), RGBEX_MIN, RGBEX_MAX), n = C32.clamp(Math.floor(1024 * n), RGBEX_MIN, RGBEX_MAX), e = C32.clamp(Math.floor(1024 * e), RGBEX_MIN, RGBEX_MAX), r = C32.clamp(Math.floor(r * ALPHAEX_MAX), 0, ALPHAEX_MAX), t < 0 && (t += RGBEX_SHIFT), n < 0 && (n += RGBEX_SHIFT), e < 0 && (e += RGBEX_SHIFT), -(t * RGBEX_SHIFT * RGBEX_SHIFT * ALPHAEX_SHIFT + n * RGBEX_SHIFT * ALPHAEX_SHIFT + e * ALPHAEX_SHIFT + r);\n  }, C32.PackRGBEx = function(t, n, e) {\n    return C32.PackRGBAEx(t, n, e, 1);\n  }, C32.GetRValue = function(n) {\n    if (0 <= n) return (255 & n) / 255;\n    {\n      let t = Math.floor(-n / (RGBEX_SHIFT * RGBEX_SHIFT * ALPHAEX_SHIFT));\n      return t > RGBEX_MAX && (t -= RGBEX_SHIFT), t / 1024;\n    }\n  }, C32.GetGValue = function(n) {\n    if (0 <= n) return ((65280 & n) >> 8) / 255;\n    {\n      let t = Math.floor(-n % (RGBEX_SHIFT * RGBEX_SHIFT * ALPHAEX_SHIFT) / (RGBEX_SHIFT * ALPHAEX_SHIFT));\n      return t > RGBEX_MAX && (t -= RGBEX_SHIFT), t / 1024;\n    }\n  }, C32.GetBValue = function(n) {\n    if (0 <= n) return ((16711680 & n) >> 16) / 255;\n    {\n      let t = Math.floor(-n % (RGBEX_SHIFT * ALPHAEX_SHIFT) / ALPHAEX_SHIFT);\n      return t > RGBEX_MAX && (t -= RGBEX_SHIFT), t / 1024;\n    }\n  }, C32.GetAValue = function(t) {\n    if (isNegativeZero(t)) return 0;\n    if (0 <= t) return 1;\n    {\n      const n = Math.floor(-t % ALPHAEX_SHIFT);\n      return n / ALPHAEX_MAX;\n    }\n  }, C32.greatestCommonDivisor = function(n, e) {\n    for (n = Math.floor(n), e = Math.floor(e); 0 !== e; ) {\n      let t = e;\n      e = n % e, n = t;\n    }\n    return n;\n  };\n  const COMMON_ASPECT_RATIOS = [[3, 2], [4, 3], [5, 4], [5, 3], [6, 5], [14, 9], [16, 9], [16, 10], [21, 9]], NO_HIT = (C32.getAspectRatio = function(e, r) {\n    if ((e = Math.floor(e)) === (r = Math.floor(r))) return [1, 1];\n    for (let n of COMMON_ASPECT_RATIOS) {\n      let t2 = e / n[0] * n[1];\n      if (Math.abs(r - t2) < 1) return n.slice(0);\n      if (t2 = e / n[1] * n[0], Math.abs(r - t2) < 1) return [n[1], n[0]];\n    }\n    let t = C32.greatestCommonDivisor(e, r);\n    return [e / t, r / t];\n  }, C32.segmentsIntersect = function(t, n, e, r, a, o, c, u) {\n    const i = Math.min(t, e), l = Math.max(t, e), s = Math.min(a, c), C = Math.max(a, c);\n    if (l < s || C < i) return false;\n    const f = Math.min(n, r), M = Math.max(n, r), h = Math.min(o, u), A = Math.max(o, u);\n    if (M < h || A < f) return false;\n    const I = a - t + c - e, _ = o - n + u - r, g = e - t, T = r - n, m = c - a, X = u - o, E = Math.abs(T * m - X * g), p = m * _ - X * I;\n    if (Math.abs(p) > E) return false;\n    const P = g * _ - T * I;\n    return Math.abs(P) <= E;\n  }, C32.segmentsIntersectPreCalc = function(t, n, e, r, a, o, c, u, i, l, s, C) {\n    const f = Math.min(i, s), M = Math.max(i, s);\n    if (o < f || M < a) return false;\n    const h = Math.min(l, C), A = Math.max(l, C);\n    if (u < h || A < c) return false;\n    const I = i - t + s - e, _ = l - n + C - r, g = e - t, T = r - n, m = s - i, X = C - l, E = Math.abs(T * m - X * g), p = m * _ - X * I;\n    if (Math.abs(p) > E) return false;\n    const P = g * _ - T * I;\n    return Math.abs(P) <= E;\n  }, C32.segmentIntersectsQuad = function(t, n, e, r, a) {\n    const o = Math.min(t, e), c = Math.max(t, e), u = Math.min(n, r), i = Math.max(n, r), l = a.getTlx(), s = a.getTly(), C = a.getTrx(), f = a.getTry(), M = a.getBrx(), h = a.getBry(), A = a.getBlx(), I = a.getBly();\n    return C32.segmentsIntersectPreCalc(t, n, e, r, o, c, u, i, l, s, C, f) || C32.segmentsIntersectPreCalc(t, n, e, r, o, c, u, i, C, f, M, h) || C32.segmentsIntersectPreCalc(t, n, e, r, o, c, u, i, M, h, A, I) || C32.segmentsIntersectPreCalc(t, n, e, r, o, c, u, i, A, I, l, s);\n  }, C32.segmentIntersectsAnyN = function(n, e, r, a, o) {\n    const c = Math.min(n, r), u = Math.max(n, r), i = Math.min(e, a), l = Math.max(e, a);\n    let s = 0;\n    for (let t = o.length - 4; s <= t; s += 2) if (C32.segmentsIntersectPreCalc(n, e, r, a, c, u, i, l, o[s], o[s + 1], o[s + 2], o[s + 3])) return true;\n    return C32.segmentsIntersectPreCalc(n, e, r, a, c, u, i, l, o[s], o[s + 1], o[0], o[1]);\n  }, 2), PADDING = 1e-6;\n  C32.rayIntersect = function(t, n, e, r, a, o, c, u) {\n    const i = e - t, l = r - n, s = c - a, C = u - o, f = i * C - l * s;\n    if (0 == f) return NO_HIT;\n    const M = ((n - r) * (c - t) + i * (u - n)) / f;\n    return 0 < M && M < 1 + PADDING ? (C * (c - t) + (a - c) * (u - n)) / f : NO_HIT;\n  }, C32.rayIntersectExtended = function(t, n, e, r, a, o, c, u, i) {\n    const l = (c - a) * i, s = (u - o) * i;\n    return C32.rayIntersect(t, n, e, r, a - l, o - s, c + l, u + s);\n  }, C32.isPointInTriangleInclusive = function(t, n, e, r, a, o, c, u) {\n    const i = a - e, l = o - r, s = c - e, C = u - r, f = t - e, M = n - r, h = i * i + l * l, A = i * s + l * C, I = i * f + l * M, _ = s * s + C * C, g = s * f + C * M, T = 1 / (h * _ - A * A), m = (_ * I - A * g) * T, X = (h * g - A * I) * T;\n    return 0 <= m && 0 <= X && m + X <= 1;\n  }, C32.triangleCartesianToBarycentric = function(t, n, e, r, a, o, c, u) {\n    const i = a - e, l = o - r, s = c - e, C = u - r, f = t - e, M = n - r, h = i * i + l * l, A = i * s + l * C, I = s * s + C * C, _ = f * i + M * l, g = f * s + M * C, T = h * I - A * A, m = (I * _ - A * g) / T, X = (h * g - A * _) / T, E = 1 - m - X;\n    return [E, m, X];\n  }, C32.triangleBarycentricToCartesian3d = function(t, n, e, r, a, o, c, u, i, l, s, C) {\n    return [t * r + n * c + e * l, t * a + n * u + e * s, t * o + n * i + e * C];\n  };\n}\nvar isNegativeZero2;\n{\n  const C32 = self.C3;\n  let mainDocument = null, baseHref = \"\";\n  if (\"undefined\" != typeof document) {\n    const a = (mainDocument = document).querySelector(\"base\");\n    !(baseHref = a && a.hasAttribute(\"href\") ? a.getAttribute(\"href\") : \"\") || (baseHref = baseHref.startsWith(\"/\") ? baseHref.substr(1) : baseHref).endsWith(\"/\") || (baseHref += \"/\");\n  }\n  C32.GetBaseHref = function() {\n    return baseHref;\n  }, C32.GetBaseURL = function() {\n    if (!mainDocument) return \"\";\n    const e = mainDocument.location;\n    return C32.GetPathFromURL(e.origin + e.pathname) + baseHref;\n  }, C32.GetPathFromURL = function(e) {\n    if (!e.length) return e;\n    if (e.endsWith(\"/\") || e.endsWith(\"\\\\\")) return e;\n    const t = Math.max(e.lastIndexOf(\"/\"), e.lastIndexOf(\"\\\\\"));\n    return -1 === t ? \"\" : e.substr(0, t + 1);\n  }, C32.GetFilenameFromURL = function(e) {\n    if (!e.length) return e;\n    if (e.endsWith(\"/\") || e.endsWith(\"\\\\\")) return \"\";\n    const t = Math.max(e.lastIndexOf(\"/\"), e.lastIndexOf(\"\\\\\"));\n    return -1 === t ? e : e.substr(t + 1);\n  }, C32.GetFileExtension = function(e) {\n    let t = e.lastIndexOf(\".\");\n    return t < 1 ? \"\" : e.substr(t);\n  }, C32.SetFileExtension = function(e, t) {\n    const n = e.lastIndexOf(\".\");\n    return -1 === n ? e + \".\" + t : e.substr(0, n + 1) + t;\n  }, C32.GetFileNamePart = function(e) {\n    let t = e.lastIndexOf(\".\");\n    return t < 1 ? e : e.substr(0, t);\n  }, C32.NormalizeFileSeparator = function(e) {\n    return e.replace(/\\\\/g, \"/\");\n  }, C32.IsFileExtension = function(e, t) {\n    const n = e ? C32.GetFileExtension(e).slice(1) : \"\";\n    return t === n;\n  }, C32.FileNameEquals = function(e, t) {\n    let n, r;\n    return C32.IsFileLike(e) && (n = C32.GetFileNamePart(e[\"name\"])), C32.IsString(e) && (n = C32.GetFileNamePart(e)), C32.IsFileLike(t) && (r = C32.GetFileNamePart(t[\"name\"])), C32.IsString(t) && (r = C32.GetFileNamePart(t)), n === r;\n  }, C32.ParseFilePath = function(e) {\n    e = C32.NormalizeFileSeparator(e);\n    let t = /^\\w\\:\\//.exec(e);\n    t ? (t = t[0], \"/\" !== (e = e.slice(3))[0] && (e = \"/\" + e)) : t = \"\";\n    const n = (e = 1 < (e = e.replace(/\\/{2,}/g, \"/\")).length && \"/\" === e.slice(-1) ? e.slice(0, -1) : e).lastIndexOf(\"/\") + 1;\n    let r = \"\", a = e, o, s = \"\";\n    0 < n && (r = e.slice(0, n), a = e.slice(n));\n    const i = (o = a).lastIndexOf(\".\"), l = (0 < i && (s = a.slice(i), o = a.slice(0, -s.length)), t + r + a);\n    return { dir: r, base: a, name: o, root: t, ext: s, full: l };\n  }, C32.Wait = function(n, r) {\n    return new Promise((e, t) => {\n      self.setTimeout(e, n, r);\n    });\n  }, C32.swallowException = function(e) {\n    try {\n      e();\n    } catch (e2) {\n      C32.isDebug && console.warn(\"Swallowed exception: \", e2);\n    }\n  }, C32.noop = function() {\n  }, C32.equalsNoCase = function(e, t) {\n    return \"string\" == typeof e && \"string\" == typeof t && (e === t || e.normalize().toLowerCase() === t.normalize().toLowerCase());\n  }, C32.equalsCase = function(e, t) {\n    return \"string\" == typeof e && \"string\" == typeof t && (e === t || e.normalize() === t.normalize());\n  }, C32.typedArraySet16 = function(e, t, n) {\n    e[n++] = t[0], e[n++] = t[1], e[n++] = t[2], e[n++] = t[3], e[n++] = t[4], e[n++] = t[5], e[n++] = t[6], e[n++] = t[7], e[n++] = t[8], e[n++] = t[9], e[n++] = t[10], e[n++] = t[11], e[n++] = t[12], e[n++] = t[13], e[n++] = t[14], e[n] = t[15];\n  }, C32.truncateArray = function(e, t) {\n    e.length = t;\n  }, C32.clearArray = function(e) {\n    e && 0 !== e.length && C32.truncateArray(e, 0);\n  }, C32.clear2DArray = function(n) {\n    if (n) {\n      for (let t = 0; t < n.length; t++) {\n        let e = n[t];\n        C32.truncateArray(e, 0);\n      }\n      C32.truncateArray(n, 0);\n    }\n  }, C32.extendArray = function(t, n, r) {\n    n |= 0;\n    const a = t.length;\n    if (!(n <= a)) for (let e = a; e < n; ++e) t.push(r);\n  }, C32.resizeArray = function(e, t, n) {\n    const r = e.length;\n    (t |= 0) < r ? C32.truncateArray(e, t) : r < t && C32.extendArray(e, t, n);\n  }, C32.shallowAssignArray = function(e, t) {\n    C32.clearArray(e), C32.appendArray(e, t);\n  }, C32.appendArray = function(n, r) {\n    if (r.length < 1e4) n.push(...r);\n    else for (let e = 0, t = r.length; e < t; ++e) n.push(r[e]);\n  }, C32.arrayRemove = function(n, r) {\n    if (!((r = Math.floor(r)) < 0 || r >= n.length)) {\n      let t = n.length - 1;\n      for (let e = r; e < t; ++e) n[e] = n[e + 1];\n      C32.truncateArray(n, t);\n    }\n  }, C32.arrayFindRemove = function(e, t) {\n    let n = e.indexOf(t);\n    0 <= n && e.splice(n, 1);\n  }, C32.arraysEqual = function(t, n) {\n    let r = t.length;\n    if (n.length !== r) return false;\n    for (let e = 0; e < r; ++e) if (t[e] !== n[e]) return false;\n    return true;\n  }, C32.arrayFilterOut = function(n, r) {\n    let a = [], o = 0;\n    for (let t = 0, e = n.length; t < e; ++t) {\n      let e2 = n[t];\n      r(e2) ? a.push(e2) : (n[o] = e2, ++o);\n    }\n    return C32.truncateArray(n, o), a;\n  }, C32.arrayRemoveAllInSet = function(n, r) {\n    const e = n.length;\n    let a = 0;\n    for (let t = 0, e2 = n.length; t < e2; ++t) {\n      let e3 = n[t];\n      r.has(e3) || (n[a++] = e3);\n    }\n    return C32.truncateArray(n, a), e - a;\n  }, C32.isArrayIndexInBounds = function(e, t) {\n    return e === Math.floor(e) && 0 <= e && e < t.length;\n  }, C32.validateArrayIndex = function(e, t) {\n    if (!C32.isArrayIndexInBounds(e, t)) throw new RangeError(\"array index out of bounds\");\n  }, C32.cloneArray = function(e) {\n    return e.slice();\n  }, C32.deepCloneArray = function(e, n) {\n    let r = [];\n    for (let t of e) if (C32.IsObject(t)) {\n      let e2 = n(t);\n      if (!e2) throw new Error(\"missing clone\");\n      if (e2.constructor !== t.constructor) throw new Error(\"object is not a clone\");\n      r.push(e2);\n    } else C32.IsArray(t) ? r.push(C32.deepCloneArray(t, n)) : r.push(t);\n    return r;\n  }, C32.clone2DArray = function(t) {\n    let n = [];\n    for (let e of t) n.push(e.slice());\n    return n;\n  }, C32.splitStringAndNormalize = function(e, t = \" \") {\n    return e ? e.split(t).map((e2) => e2.trim()).filter((e2) => !!e2) : [];\n  }, C32.filterSet = function(e, t, n) {\n    const r = /* @__PURE__ */ new Set();\n    for (const a of e.values()) t(a) && (n ? r.add(n(a)) : r.add(a));\n    return r;\n  }, C32.mergeSets = function(e, t) {\n    return e[\"union\"] ? e[\"union\"](t) : /* @__PURE__ */ new Set([...e, ...t]);\n  }, C32.mergeSetsInPlace = function(e, t) {\n    for (const n of t) e.add(n);\n    return e;\n  }, C32.first = function(t) {\n    for (let e of t) return e;\n    return null;\n  }, C32.xor = function(e, t) {\n    return !e != !t;\n  }, C32.compare = function(e, t, n) {\n    switch (t) {\n      case 0:\n        return e === n;\n      case 1:\n        return e !== n;\n      case 2:\n        return e < n;\n      case 3:\n        return e <= n;\n      case 4:\n        return n < e;\n      case 5:\n        return n <= e;\n      default:\n        return false;\n    }\n  }, C32.hasAnyOwnProperty = function(t) {\n    for (let e in t) if (t.hasOwnProperty(e)) return true;\n    return false;\n  }, C32.PromiseAllWithProgress = function(i, l) {\n    return i.length ? new Promise((n, r) => {\n      const a = [];\n      let o = 0, s = false;\n      for (let t = 0, e = i.length; t < e; ++t) a.push(void 0), i[t].then((e2) => {\n        s || (a[t] = e2, ++o === i.length ? n(a) : l(o, i.length));\n      }).catch((e2) => {\n        s = true, r(e2);\n      });\n    }) : Promise.resolve([]);\n  };\n  let memoryCallbacks = [], nextTaskId = (C32.AddLibraryMemoryCallback = function(e) {\n    memoryCallbacks.push(e);\n  }, C32.GetEstimatedLibraryMemoryUsage = function() {\n    let n = 0;\n    for (let t of memoryCallbacks) {\n      let e = t();\n      n += e;\n    }\n    return Math.floor(n);\n  }, 1);\n  const activeTaskIds = /* @__PURE__ */ new Map(), taskMessageChannel = new MessageChannel(), activeRPAFids = (taskMessageChannel.port2.onmessage = function(e) {\n    const t = e.data, n = activeTaskIds.get(t);\n    activeTaskIds.delete(t), n && n(performance.now());\n  }, C32.RequestUnlimitedAnimationFrame = function(e) {\n    const t = nextTaskId++;\n    return activeTaskIds.set(t, e), taskMessageChannel.port1.postMessage(t), t;\n  }, C32.CancelUnlimitedAnimationFrame = function(e) {\n    activeTaskIds.delete(e);\n  }, C32.PostTask = C32.RequestUnlimitedAnimationFrame, C32.WaitForNextTask = function() {\n    return new Promise((e) => C32.PostTask(e));\n  }, /* @__PURE__ */ new Set());\n  C32.RequestPostAnimationFrame = function(t) {\n    const n = self.requestAnimationFrame(async (e) => {\n      await C32.WaitForNextTask(), activeRPAFids.has(n) && (activeRPAFids.delete(n), t(e));\n    });\n    return activeRPAFids.add(n), n;\n  }, C32.CancelPostAnimationFrame = function(e) {\n    activeRPAFids.has(e) && (self.cancelAnimationFrame(e), activeRPAFids.delete(e));\n  };\n}\n{\n  const C32 = self.C3;\n  C32.IsAbsoluteURL = function(e) {\n    return /^(?:[a-z\\-]+:)?\\/\\//.test(e) || \"data:\" === e.substr(0, 5) || \"blob:\" === e.substr(0, 5);\n  }, C32.IsRelativeURL = function(e) {\n    return !C32.IsAbsoluteURL(e);\n  }, C32.ThrowIfNotOk = function(e) {\n    if (!e.ok) throw new Error(`fetch '${e.url}' response returned ${e.status} ` + e.statusText);\n  }, C32.FetchOk = function(e, t) {\n    return fetch(e, t).then((e2) => (C32.ThrowIfNotOk(e2), e2));\n  }, C32.FetchText = function(e) {\n    return C32.FetchOk(e).then((e2) => e2.text());\n  }, C32.FetchJson = function(e) {\n    return C32.FetchOk(e).then((e2) => e2.json());\n  }, C32.FetchBlob = function(e) {\n    return C32.FetchOk(e).then((e2) => e2.blob());\n  }, C32.FetchArrayBuffer = function(e) {\n    return C32.FetchOk(e).then((e2) => e2.arrayBuffer());\n  }, C32.FetchImage = function(r) {\n    return new Promise((e, t) => {\n      const n = new Image();\n      n.onload = () => e(n), n.onerror = (e2) => t(e2), n.src = r;\n    });\n  }, C32.BlobToArrayBuffer = function(r) {\n    return \"function\" == typeof r[\"arrayBuffer\"] ? r[\"arrayBuffer\"]() : new Promise((e, t) => {\n      const n = new FileReader();\n      n.onload = () => e(n.result), n.onerror = () => t(n.error), n.readAsArrayBuffer(r);\n    });\n  }, C32.BlobToString = function(r) {\n    return \"function\" == typeof r[\"text\"] ? r[\"text\"]() : new Promise((e, t) => {\n      const n = new FileReader();\n      n.onload = () => e(n.result), n.onerror = () => t(n.error), n.readAsText(r);\n    });\n  }, C32.BlobToJson = function(e) {\n    return C32.BlobToString(e).then((e2) => JSON.parse(e2));\n  }, C32.BlobToImage = async function(e, t) {\n    let n = URL.createObjectURL(e);\n    try {\n      const r = await C32.FetchImage(n);\n      return URL.revokeObjectURL(n), n = \"\", t && \"function\" == typeof r[\"decode\"] && await r[\"decode\"](), r;\n    } finally {\n      n && URL.revokeObjectURL(n);\n    }\n  }, C32.CreateCanvas = function(e, t) {\n    if (\"undefined\" == typeof document || \"function\" != typeof document.createElement) return new OffscreenCanvas(e, t);\n    {\n      const n = document.createElement(\"canvas\");\n      return n.width = e, n.height = t, n;\n    }\n  }, C32.CanvasToBlob = function(t, n, r) {\n    if (\"number\" != typeof r && (r = 1), n = n || \"image/png\", r = C32.clamp(r, 0, 1), t[\"convertToBlob\"]) return t[\"convertToBlob\"]({ \"type\": n, \"quality\": r });\n    if (t.toBlob) return new Promise((e) => t.toBlob(e, n, r));\n    throw new Error(\"could not convert canvas to blob\");\n  }, C32.DrawableToBlob = function(e, t, n) {\n    const r = C32.CreateCanvas(e.width, e.height), o = r.getContext(\"2d\");\n    return o.drawImage(e, 0, 0), C32.CanvasToBlob(r, t, n);\n  }, C32.ImageDataToBlob = function(e, t, n) {\n    if (C32.Supports.ImageBitmapOptions) return createImageBitmap(e, { \"premultiplyAlpha\": \"none\" }).then((e2) => C32.DrawableToBlob(e2, t, n));\n    if (C32.Supports.ImageBitmap) return createImageBitmap(e).then((e2) => C32.DrawableToBlob(e2, t, n));\n    {\n      const r = C32.CreateCanvas(e.width, e.height), o = r.getContext(\"2d\");\n      return o.putImageData(e, 0, 0), C32.CanvasToBlob(r, t, n);\n    }\n  }, C32.CopySet = function(e, t) {\n    e.clear();\n    for (const n of t) e.add(n);\n  }, C32.MapToObject = function(e) {\n    const t = /* @__PURE__ */ Object.create(null);\n    for (const [n, r] of e.entries()) t[n] = r;\n    return t;\n  }, C32.ObjectToMap = function(e, t) {\n    t.clear();\n    for (const [n, r] of Object.entries(e)) t.set(n, r);\n  }, C32.ToSuperJSON = function t(e) {\n    if (\"object\" != typeof e || null === e) return e;\n    if (e instanceof Set) return { \"_c3type_\": \"set\", \"data\": [...e].map((e2) => t(e2)) };\n    if (e instanceof Map) return { \"_c3type_\": \"map\", \"data\": [...e].map((e2) => [e2[0], t(e2[1])]) };\n    {\n      const n = /* @__PURE__ */ Object.create(null);\n      for (const [r, o] of Object.entries(e)) n[r] = t(o);\n      return n;\n    }\n  }, C32.FromSuperJSON = function t(e) {\n    if (\"object\" == typeof e & null !== e) {\n      if (\"set\" === e[\"_c3type_\"]) return new Set(e[\"data\"].map((e2) => t(e2)));\n      if (\"map\" === e[\"_c3type_\"]) return new Map(e[\"data\"].map((e2) => [e2[0], t(e2[1])]));\n      {\n        const n = /* @__PURE__ */ Object.create(null);\n        for (const [r, o] of Object.entries(e)) n[r] = t(o);\n        return n;\n      }\n    }\n    return e;\n  }, C32.CSSToCamelCase = function(e) {\n    if (e.startsWith(\"--\")) return e;\n    let t = \"\", n = false, r = 0;\n    for (const o of e) \"-\" === o ? 0 < r && (n = true) : n ? (t += o.toUpperCase(), n = false) : t += o, ++r;\n    return t;\n  }, C32.IsIterator = function(e) {\n    return \"object\" == typeof e && \"function\" == typeof e.next;\n  }, C32.MakeFilledArray = function(t, n) {\n    const r = [];\n    if (\"function\" == typeof n) for (let e = 0; e < t; ++e) r.push(n());\n    else for (let e = 0; e < t; ++e) r.push(n);\n    return r;\n  };\n}\n{\n  let padTwoDigits = function(t) {\n    return 0 === t.length ? \"00\" : 1 === t.length ? \"0\" + t : t;\n  }, hueToRGB = function(t, s, e) {\n    return e < 0 && (e += 1), 1 < e && --e, e < 1 / 6 ? t + 6 * (s - t) * e : e < 0.5 ? s : e < 2 / 3 ? t + (s - t) * (2 / 3 - e) * 6 : t;\n  };\n  padTwoDigits2 = padTwoDigits, hueToRGB2 = hueToRGB;\n  const C32 = self.C3, HSL_TEST = /([0-9.]+),([0-9.]+)\\%?,([0-9.]+)\\%?/i, HSLA_TEST = /([0-9.]+),([0-9.]+)\\%?,([0-9.]+)\\%?,([0-9.])/i;\n  C32.Color = class {\n    constructor(t, s, e, r) {\n      this._r = NaN, this._g = NaN, this._b = NaN, this._a = NaN, this._r = 0, this._g = 0, this._b = 0, this._a = 0, t instanceof C32.Color ? this.set(t) : this.setRgba(t || 0, s || 0, e || 0, r || 0);\n    }\n    setRgb(t, s, e) {\n      return this._r = +t, this._g = +s, this._b = +e, this.clamp(), this;\n    }\n    setRgba(t, s, e, r) {\n      return this._r = +t, this._g = +s, this._b = +e, this._a = +r, this.clamp(), this;\n    }\n    set(t) {\n      return this._r = t._r, this._g = t._g, this._b = t._b, this._a = t._a, this;\n    }\n    copy(t) {\n      return this.set(t);\n    }\n    add(t) {\n      this._r += t._r, this._g += t._g, this._b += t._b, this._a += t._a, this.clamp();\n    }\n    addRgb(t, s, e, r = 0) {\n      this._r += +t, this._g += +s, this._b += +e, this._a += +r, this.clamp();\n    }\n    diff(t) {\n      this.setR(Math.max(this._r, t._r) - Math.min(this._r, t._r)), this.setG(Math.max(this._g, t._g) - Math.min(this._g, t._g)), this.setB(Math.max(this._b, t._b) - Math.min(this._b, t._b)), this.setA(Math.max(this._a, t._a) - Math.min(this._a, t._a)), this.clamp();\n    }\n    copyRgb(t) {\n      this._r = t._r, this._g = t._g, this._b = t._b;\n    }\n    setR(t) {\n      this._r = C32.clamp(+t, 0, 1);\n    }\n    getR() {\n      return this._r;\n    }\n    setG(t) {\n      this._g = C32.clamp(+t, 0, 1);\n    }\n    getG() {\n      return this._g;\n    }\n    setB(t) {\n      this._b = C32.clamp(+t, 0, 1);\n    }\n    getB() {\n      return this._b;\n    }\n    setA(t) {\n      this._a = C32.clamp(+t, 0, 1);\n    }\n    getA() {\n      return this._a;\n    }\n    clone() {\n      return C32.New(C32.Color, this._r, this._g, this._b, this._a);\n    }\n    toArray() {\n      return [this._r, this._g, this._b, this._a];\n    }\n    toTypedArray() {\n      return new Float64Array(this.toArray());\n    }\n    writeToTypedArray(t, s) {\n      t[s++] = this._r, t[s++] = this._g, t[s++] = this._b, t[s] = this._a;\n    }\n    writeRGBToTypedArray(t, s) {\n      t[s++] = this._r, t[s++] = this._g, t[s] = this._b;\n    }\n    equals(t) {\n      return this._r === t._r && this._g === t._g && this._b === t._b && this._a === t._a;\n    }\n    equalsIgnoringAlpha(t) {\n      return this._r === t._r && this._g === t._g && this._b === t._b;\n    }\n    equalsRgb(t, s, e) {\n      return this._r === t && this._g === s && this._b === e;\n    }\n    equalsRgba(t, s, e, r) {\n      return this._r === t && this._g === s && this._b === e && this._a === r;\n    }\n    equalsF32Array(t, s) {\n      return t[s] === Math.fround(this._r) && t[s + 1] === Math.fround(this._g) && t[s + 2] === Math.fround(this._b) && t[s + 3] === Math.fround(this._a);\n    }\n    equalsRGBF32Array(t, s) {\n      return t[s] === Math.fround(this._r) && t[s + 1] === Math.fround(this._g) && t[s + 2] === Math.fround(this._b);\n    }\n    multiply(t) {\n      this._r *= t._r, this._g *= t._g, this._b *= t._b, this._a *= t._a;\n    }\n    multiplyAlpha(t) {\n      this._r *= t, this._g *= t, this._b *= t, this._a *= t;\n    }\n    premultiply() {\n      return this._r *= this._a, this._g *= this._a, this._b *= this._a, this;\n    }\n    unpremultiply() {\n      return this._r /= this._a, this._g /= this._a, this._b /= this._a, this;\n    }\n    clamp() {\n      return this._r = C32.clamp(this._r, 0, 1), this._g = C32.clamp(this._g, 0, 1), this._b = C32.clamp(this._b, 0, 1), this._a = C32.clamp(this._a, 0, 1), this;\n    }\n    setFromRgbValue(t) {\n      this._r = C32.GetRValue(t), this._g = C32.GetGValue(t), this._b = C32.GetBValue(t), this._a = C32.GetAValue(t);\n    }\n    getCssRgb(t, s, e) {\n      const r = C32.IsFiniteNumber(t) ? t : this.getR(), i = C32.IsFiniteNumber(s) ? s : this.getG(), a = C32.IsFiniteNumber(e) ? e : this.getB();\n      return `rgb(${100 * r}%, ${100 * i}%, ${100 * a}%)`;\n    }\n    getCssRgba(t, s, e, r) {\n      const i = C32.IsFiniteNumber(t) ? t : this.getR(), a = C32.IsFiniteNumber(s) ? s : this.getG(), h = C32.IsFiniteNumber(e) ? e : this.getB(), n = C32.IsFiniteNumber(r) ? r : this.getA();\n      return `rgba(${100 * i}%, ${100 * a}%, ${100 * h}%, ${n})`;\n    }\n    toHexString() {\n      const t = Math.round(255 * this.getR()), s = Math.round(255 * this.getG()), e = Math.round(255 * this.getB());\n      return \"#\" + padTwoDigits(t.toString(16)) + padTwoDigits(s.toString(16)) + padTwoDigits(e.toString(16));\n    }\n    parseHexString(t) {\n      if (\"string\" != typeof t) return false;\n      let s, e, r;\n      if (3 === (t = \"#\" === (t = t.trim()).charAt(0) ? t.substr(1) : t).length) s = parseInt(t[0], 16) / 15, e = parseInt(t[1], 16) / 15, r = parseInt(t[2], 16) / 15;\n      else {\n        if (6 !== t.length) return false;\n        s = parseInt(t.substr(0, 2), 16) / 255, e = parseInt(t.substr(2, 2), 16) / 255, r = parseInt(t.substr(4, 2), 16) / 255;\n      }\n      return isFinite(s) && this.setR(s), isFinite(e) && this.setG(e), isFinite(r) && this.setB(r), this.setA(1), true;\n    }\n    toCommaSeparatedRgb() {\n      const t = Math.round(255 * this.getR()), s = Math.round(255 * this.getG()), e = Math.round(255 * this.getB());\n      return t + `, ${s}, ` + e;\n    }\n    toRgbArray() {\n      const t = Math.round(255 * this.getR()), s = Math.round(255 * this.getG()), e = Math.round(255 * this.getB());\n      return [t, s, e];\n    }\n    parseCommaSeparatedRgb(t) {\n      if (\"string\" != typeof t) return false;\n      const s = (t = t.replace(/^rgb\\(|\\)|%/, \"\")).split(\",\");\n      if (s.length < 3) return false;\n      const e = parseInt(s[0].trim(), 10) / 255, r = parseInt(s[1].trim(), 10) / 255, i = parseInt(s[2].trim(), 10) / 255;\n      return isFinite(e) && this.setR(e), isFinite(r) && this.setG(r), isFinite(i) && this.setB(i), this.setA(1), true;\n    }\n    parseCommaSeparatedPercentageRgb(t) {\n      if (\"string\" != typeof t) return false;\n      const s = (t = t.replace(/^rgb\\(|\\)|%/, \"\")).split(\",\");\n      if (s.length < 3) return false;\n      const e = parseInt(s[0].trim(), 10) / 100, r = parseInt(s[1].trim(), 10) / 100, i = parseInt(s[2].trim(), 10) / 100;\n      return isFinite(e) && this.setR(e), isFinite(r) && this.setG(r), isFinite(i) && this.setB(i), this.setA(1), true;\n    }\n    parseCommaSeparatedRgba(t) {\n      if (\"string\" != typeof t) return false;\n      const s = (t = t.replace(/^rgba\\(|\\)|%/, \"\")).split(\",\");\n      if (s.length < 4) return false;\n      const e = parseInt(s[0].trim(), 10) / 255, r = parseInt(s[1].trim(), 10) / 255, i = parseInt(s[2].trim(), 10) / 255, a = parseFloat(s[3].trim());\n      return isFinite(e) && this.setR(e), isFinite(r) && this.setG(r), isFinite(i) && this.setB(i), isFinite(a) && this.setA(a), true;\n    }\n    parseCommaSeparatedPercentageRgba(t) {\n      if (\"string\" != typeof t) return false;\n      const s = (t = t.replace(/^rgba\\(|\\)|%/, \"\")).split(\",\");\n      if (s.length < 4) return false;\n      const e = parseInt(s[0].trim(), 10) / 100, r = parseInt(s[1].trim(), 10) / 100, i = parseInt(s[2].trim(), 10) / 100, a = parseFloat(s[3].trim());\n      return isFinite(e) && this.setR(e), isFinite(r) && this.setG(r), isFinite(i) && this.setB(i), isFinite(a) && this.setA(a), true;\n    }\n    parseString(t) {\n      if (\"string\" != typeof t) return false;\n      if ((t = t.replace(/\\s+/, \"\")).includes(\",\")) {\n        if (t.startsWith(\"rgb(\")) return t.includes(\"%\") ? this.parseCommaSeparatedPercentageRgb(t) : this.parseCommaSeparatedRgb(t);\n        if (t.startsWith(\"rgba(\")) return t.includes(\"%\") ? this.parseCommaSeparatedPercentageRgba(t) : this.parseCommaSeparatedRgba(t);\n        if (t.startsWith(\"hsl(\") || t.startsWith(\"hsla(\")) return this.parseHSLString(t);\n        {\n          const s = t.split(\",\");\n          return t.includes(\"%\") ? 3 === s.length ? this.parseCommaSeparatedPercentageRgb(t) : 4 === s.length && this.parseCommaSeparatedPercentageRgba(t) : 3 === s.length ? this.parseCommaSeparatedRgb(t) : 4 === s.length && this.parseCommaSeparatedRgba(t);\n        }\n      }\n      return this.parseHexString(t);\n    }\n    toJSON() {\n      return [this._r, this._g, this._b, this._a];\n    }\n    setFromHSLA(t, s, e, r) {\n      let i, a, h;\n      if (t %= 360, s = C32.clamp(s, 0, 100), e = C32.clamp(e, 0, 100), r = C32.clamp(r, 0, 1), t /= 360, e /= 100, 0 === (s /= 100)) i = a = h = e;\n      else {\n        const n = e < 0.5 ? e * (1 + s) : e + s - e * s, _ = 2 * e - n;\n        i = hueToRGB(_, n, t + 1 / 3), a = hueToRGB(_, n, t), h = hueToRGB(_, n, t - 1 / 3);\n      }\n      return this.setR(i), this.setG(a), this.setB(h), this.setA(r), this;\n    }\n    parseHSLString(t) {\n      const s = t.replace(/ |hsl|hsla|\\(|\\)|;/gi, \"\"), e = HSL_TEST.exec(s), r = HSLA_TEST.exec(s);\n      return e && 4 === e.length ? (this.setFromHSLA(+e[1], +e[2], +e[3], 1), true) : !(!r || 5 !== r.length || (this.setFromHSLA(+e[1], +e[2], +e[3], +e[4]), 0));\n    }\n    toHSLAString() {\n      const t = this._r, s = this._g, e = this._b, r = this._a, i = C32.Color.GetHue(t, s, e), a = C32.Color.GetSaturation(t, s, e), h = C32.Color.GetLuminosity(t, s, e);\n      return `hsla(${i}, ${a}%, ${h}%, ${r})`;\n    }\n    toHSLAArray() {\n      const t = this._r, s = this._g, e = this._b;\n      return [C32.Color.GetHue(t, s, e), C32.Color.GetSaturation(t, s, e), C32.Color.GetLuminosity(t, s, e), this._a];\n    }\n    setFromJSON(t) {\n      !Array.isArray(t) || t.length < 3 || (this._r = t[0], this._g = t[1], this._b = t[2], this._a = 4 <= t.length ? t[3] : 1);\n    }\n    set r(t) {\n      this.setR(t);\n    }\n    get r() {\n      return this.getR();\n    }\n    set g(t) {\n      this.setG(t);\n    }\n    get g() {\n      return this.getG();\n    }\n    set b(t) {\n      this.setB(t);\n    }\n    get b() {\n      return this.getB();\n    }\n    set a(t) {\n      this.setA(t);\n    }\n    get a() {\n      return this.getA();\n    }\n    setAtIndex(t, s) {\n      switch (t) {\n        case 0:\n          this.setR(s);\n          break;\n        case 1:\n          this.setG(s);\n          break;\n        case 2:\n          this.setB(s);\n          break;\n        case 3:\n          this.setA(s);\n          break;\n        default:\n          throw new RangeError(\"invalid color index\");\n      }\n    }\n    getAtIndex(t) {\n      switch (t) {\n        case 0:\n          return this.getR();\n        case 1:\n          return this.getG();\n        case 2:\n          return this.getB();\n        case 3:\n          return this.getA();\n        default:\n          throw new RangeError(\"invalid color index\");\n      }\n    }\n    static Equals(t, s) {\n      let e, r;\n      if (Array.isArray(t)) (e = new C32.Color()).setFromJSON(t);\n      else {\n        if (!(t instanceof C32.Color)) throw new Error(\"unexpected type\");\n        e = t;\n      }\n      if (Array.isArray(s)) (r = new C32.Color()).setFromJSON(s);\n      else {\n        if (!(s instanceof C32.Color)) throw new Error(\"unexpected type\");\n        r = s;\n      }\n      return e.equals(r);\n    }\n    static DiffChannel(t, s) {\n      return C32.clamp(Math.max(t, s) - Math.min(t, s), 0, 1);\n    }\n    static Diff(t, s) {\n      const e = new C32.Color();\n      return e.setR(Math.max(t._r, s._r) - Math.min(t._r, s._r)), e.setG(Math.max(t._g, s._g) - Math.min(t._g, s._g)), e.setB(Math.max(t._b, s._b) - Math.min(t._b, s._b)), e.setA(Math.max(t._a, s._a) - Math.min(t._a, s._a)), e;\n    }\n    static DiffNoAlpha(t, s) {\n      const e = new C32.Color(0, 0, 0, 1);\n      return e.setR(Math.max(t._r, s._r) - Math.min(t._r, s._r)), e.setG(Math.max(t._g, s._g) - Math.min(t._g, s._g)), e.setB(Math.max(t._b, s._b) - Math.min(t._b, s._b)), e;\n    }\n    static GetHue(t, s, e) {\n      const r = Math.max(t, s, e), i = Math.min(t, s, e);\n      if (r === i) return 0;\n      let a = 0;\n      switch (r) {\n        case t:\n          a = (s - e) / (r - i) + (s < e ? 6 : 0);\n          break;\n        case s:\n          a = (e - t) / (r - i) + 2;\n          break;\n        case e:\n          a = (t - s) / (r - i) + 4;\n      }\n      return Math.round(a / 6 * 360);\n    }\n    static GetSaturation(t, s, e) {\n      const r = Math.max(t, s, e), i = Math.min(t, s, e);\n      if (r === i) return 0;\n      const a = (r + i) / 2, h = r - i, n = 0.5 < a ? h / (2 - r - i) : h / (r + i);\n      return Math.round(100 * n);\n    }\n    static GetLuminosity(t, s, e) {\n      const r = Math.max(t, s, e), i = Math.min(t, s, e), a = (r + i) / 2;\n      return r ? Math.round(100 * a) : 0;\n    }\n  }, C32.Color.White = Object.freeze(C32.New(C32.Color, 1, 1, 1, 1)), C32.Color.Black = Object.freeze(C32.New(C32.Color, 0, 0, 0, 1)), C32.Color.TransparentBlack = Object.freeze(C32.New(C32.Color, 0, 0, 0, 0));\n}\nvar padTwoDigits2;\nvar hueToRGB2;\n{\n  const C32 = self.C3;\n  C32.Vector2 = class {\n    constructor(t, s) {\n      this._x = 0, this._y = 0, t instanceof C32.Vector2 ? this.copy(t) : this.set(t || 0, s || 0);\n    }\n    set(t, s) {\n      this._x = +t, this._y = +s;\n    }\n    copy(t) {\n      this._x = t._x, this._y = t._y;\n    }\n    equals(t) {\n      return this._x === t._x && this._y === t._y;\n    }\n    equalsValues(t, s) {\n      return this._x === t && this._y === s;\n    }\n    equalsF32Array(t, s) {\n      return t[s] === Math.fround(this._x) && t[s + 1] === Math.fround(this._y);\n    }\n    setX(t) {\n      this._x = +t;\n    }\n    getX() {\n      return this._x;\n    }\n    setY(t) {\n      this._y = +t;\n    }\n    getY() {\n      return this._y;\n    }\n    toArray() {\n      return [this._x, this._y];\n    }\n    toTypedArray() {\n      return new Float64Array(this.toArray());\n    }\n    writeToTypedArray(t, s) {\n      t[s++] = this._x, t[s] = this._y;\n    }\n    offset(t, s) {\n      this._x += +t, this._y += +s;\n    }\n    scale(t, s) {\n      this._x *= t, this._y *= s;\n    }\n    divide(t, s) {\n      this._x /= t, this._y /= s;\n    }\n    round() {\n      this._x = Math.round(this._x), this._y = Math.round(this._y);\n    }\n    floor() {\n      this._x = Math.floor(this._x), this._y = Math.floor(this._y);\n    }\n    ceil() {\n      this._x = Math.ceil(this._x), this._y = Math.ceil(this._y);\n    }\n    angle() {\n      return C32.angleTo(0, 0, this._x, this._y);\n    }\n    lengthSquared() {\n      return this._x * this._x + this._y * this._y;\n    }\n    length() {\n      return C32.hypot2DFast(this._x, this._y);\n    }\n    rotatePrecalc(t, s) {\n      const h = this._x * s - this._y * t;\n      this._y = this._y * s + this._x * t, this._x = h;\n    }\n    rotate(t) {\n      0 !== t && this.rotatePrecalc(Math.sin(t), Math.cos(t));\n    }\n    rotateAbout(t, s, h) {\n      0 === t || s === this._x && h === this._y || (this._x -= s, this._y -= h, this.rotatePrecalc(Math.sin(t), Math.cos(t)), this._x += +s, this._y += +h);\n    }\n    move(t, s) {\n      0 !== s && (this._x += Math.cos(t) * s, this._y += Math.sin(t) * s);\n    }\n    normalize() {\n      const t = this.length();\n      0 !== t && 1 !== t && (this._x /= t, this._y /= t);\n    }\n    clamp(t, s) {\n      this._x = C32.clamp(this._x, t, s), this._y = C32.clamp(this._y, t, s);\n    }\n    dot(t) {\n      return this._x * t._x + this._y * t._y;\n    }\n    reverse() {\n      this._x = -this._x, this._y = -this._y;\n    }\n    perp() {\n      let t = this._x;\n      return this._x = this._y, this._y = -t, this;\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.Rect = class {\n    constructor(t, h, i, o) {\n      this._left = NaN, this._top = NaN, this._right = NaN, this._bottom = NaN, this._left = 0, this._top = 0, this._right = 0, this._bottom = 0, t instanceof C32.Rect ? this.copy(t) : this.set(t || 0, h || 0, i || 0, o || 0);\n    }\n    set(t, h, i, o) {\n      this._left = +t, this._top = +h, this._right = +i, this._bottom = +o;\n    }\n    setWH(t, h, i, o) {\n      h = +h, this._left = t = +t, this._top = h, this._right = t + +i, this._bottom = h + +o;\n    }\n    copy(t) {\n      this._left = +t._left, this._top = +t._top, this._right = +t._right, this._bottom = +t._bottom;\n    }\n    clone() {\n      return new C32.Rect(this._left, this._top, this._right, this._bottom);\n    }\n    static Merge(t, h) {\n      const i = new C32.Rect();\n      return i.setLeft(Math.min(t._left, h._left)), i.setTop(Math.min(t._top, h._top)), i.setRight(Math.max(t._right, h._right)), i.setBottom(Math.max(t._bottom, h._bottom)), i;\n    }\n    static FromObject(t) {\n      return new C32.Rect(t.left, t.top, t.right, t.bottom);\n    }\n    equals(t) {\n      return this._left === t._left && this._top === t._top && this._right === t._right && this._bottom === t._bottom;\n    }\n    equalsWH(t, h, i, o) {\n      return this._left === t && this._top === h && this.width() === i && this.height() === o;\n    }\n    equalsF32Array(t, h) {\n      return t[h] === Math.fround(this._left) && t[h + 1] === Math.fround(this._top) && t[h + 2] === Math.fround(this._right) && t[h + 3] === Math.fround(this._bottom);\n    }\n    setLeft(t) {\n      this._left = +t;\n    }\n    getLeft() {\n      return this._left;\n    }\n    setTop(t) {\n      this._top = +t;\n    }\n    getTop() {\n      return this._top;\n    }\n    setRight(t) {\n      this._right = +t;\n    }\n    getRight() {\n      return this._right;\n    }\n    setBottom(t) {\n      this._bottom = +t;\n    }\n    getBottom() {\n      return this._bottom;\n    }\n    toArray() {\n      return [this._left, this._top, this._right, this._bottom];\n    }\n    toTypedArray() {\n      return new Float64Array(this.toArray());\n    }\n    toDOMRect() {\n      return new DOMRect(this._left, this._top, this.width(), this.height());\n    }\n    static fromDOMRect(t) {\n      return C32.New(C32.Rect, t.left, t.top, t.right, t.bottom);\n    }\n    writeToTypedArray(t, h) {\n      t[h++] = this._left, t[h++] = this._top, t[h++] = this._right, t[h] = this._bottom;\n    }\n    writeAsQuadToTypedArray(t, h) {\n      t[h++] = this._left, t[h++] = this._top, t[h++] = this._right, t[h++] = this._top, t[h++] = this._right, t[h++] = this._bottom, t[h++] = this._left, t[h] = this._bottom;\n    }\n    writeAsQuadToTypedArray3D(t, h, i) {\n      t[h++] = this._left, t[h++] = this._top, t[h++] = i, t[h++] = this._right, t[h++] = this._top, t[h++] = i, t[h++] = this._right, t[h++] = this._bottom, t[h++] = i, t[h++] = this._left, t[h++] = this._bottom, t[h] = i;\n    }\n    width() {\n      return this._right - this._left;\n    }\n    height() {\n      return this._bottom - this._top;\n    }\n    midX() {\n      return (this._left + this._right) / 2;\n    }\n    midY() {\n      return (this._top + this._bottom) / 2;\n    }\n    offset(t, h) {\n      h = +h, this._left += t = +t, this._top += h, this._right += t, this._bottom += h;\n    }\n    offsetLeft(t) {\n      this._left += +t;\n    }\n    offsetTop(t) {\n      this._top += +t;\n    }\n    offsetRight(t) {\n      this._right += +t;\n    }\n    offsetBottom(t) {\n      this._bottom += +t;\n    }\n    toSquare(t) {\n      if (\"x\" !== t) throw new Error(\"invalid axis, only 'x' supported\");\n      this._top < this._bottom ? this._left < this._right ? this._bottom = this._top + this.width() : this._bottom = this._top - this.width() : this._left < this._right ? this._bottom = this._top - this.width() : this._bottom = this._top + this.width();\n    }\n    inflate(t, h) {\n      h = +h, this._left -= t = +t, this._top -= h, this._right += t, this._bottom += h;\n    }\n    deflate(t, h) {\n      h = +h, this._left += t = +t, this._top += h, this._right -= t, this._bottom -= h;\n    }\n    multiply(t, h) {\n      this._left *= t, this._top *= h, this._right *= t, this._bottom *= h;\n    }\n    divide(t, h) {\n      this._left /= t, this._top /= h, this._right /= t, this._bottom /= h;\n    }\n    mirrorAround(t) {\n      this._left = +t - this._left, this._right = +t - this._right;\n    }\n    flipAround(t) {\n      this._top = +t - this._top, this._bottom = +t - this._bottom;\n    }\n    rotate90DegreesAround(t, h) {\n      const i = this.width(), o = this.height(), s = this.getLeft() + i * t, _ = this.getTop() + o * h;\n      this.setWH(s - o * h, _ - i * t, o, i);\n    }\n    swapLeftRight() {\n      const t = this._left;\n      this._left = this._right, this._right = t;\n    }\n    swapTopBottom() {\n      const t = this._top;\n      this._top = this._bottom, this._bottom = t;\n    }\n    shuntY(t) {\n      const h = this._top;\n      this._top = +t - this._bottom, this._bottom = +t - h;\n    }\n    round() {\n      this._left = Math.round(this._left), this._top = Math.round(this._top), this._right = Math.round(this._right), this._bottom = Math.round(this._bottom);\n    }\n    roundInner() {\n      this._left = Math.ceil(this._left), this._top = Math.ceil(this._top), this._right = Math.floor(this._right), this._bottom = Math.floor(this._bottom);\n    }\n    roundOuter() {\n      this._left = Math.floor(this._left), this._top = Math.floor(this._top), this._right = Math.ceil(this._right), this._bottom = Math.ceil(this._bottom);\n    }\n    floor() {\n      this._left = Math.floor(this._left), this._top = Math.floor(this._top), this._right = Math.floor(this._right), this._bottom = Math.floor(this._bottom);\n    }\n    ceil() {\n      this._left = Math.ceil(this._left), this._top = Math.ceil(this._top), this._right = Math.ceil(this._right), this._bottom = Math.ceil(this._bottom);\n    }\n    clamp(t, h, i, o) {\n      this._left = Math.max(this._left, +t), this._top = Math.max(this._top, +h), this._right = Math.min(this._right, +i), this._bottom = Math.min(this._bottom, +o);\n    }\n    clampBoth(t, h, i, o) {\n      t = +t, h = +h, i = +i, o = +o, this._left = C32.clamp(this._left, t, i), this._top = C32.clamp(this._top, h, o), this._right = C32.clamp(this._right, t, i), this._bottom = C32.clamp(this._bottom, h, o);\n    }\n    normalize() {\n      this._left > this._right && this.swapLeftRight(), this._top > this._bottom && this.swapTopBottom();\n    }\n    intersectsRect(t) {\n      return !(t._right < this._left || t._bottom < this._top || t._left > this._right || t._top > this._bottom);\n    }\n    intersectsRectOffset(t, h, i) {\n      return !(t._right + h < this._left || t._bottom + i < this._top || t._left + h > this._right || t._top + i > this._bottom);\n    }\n    containsPoint(t, h) {\n      return t >= this._left && t <= this._right && h >= this._top && h <= this._bottom;\n    }\n    containsRect(t) {\n      return t._left >= this._left && t._top >= this._top && t._right <= this._right && t._bottom <= this._bottom;\n    }\n    expandToContain(t) {\n      t._left < this._left && (this._left = +t._left), t._top < this._top && (this._top = +t._top), t._right > this._right && (this._right = +t._right), t._bottom > this._bottom && (this._bottom = +t._bottom);\n    }\n    lerpInto(t) {\n      this._left = C32.lerp(t._left, t._right, this._left), this._top = C32.lerp(t._top, t._bottom, this._top), this._right = C32.lerp(t._left, t._right, this._right), this._bottom = C32.lerp(t._top, t._bottom, this._bottom);\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.Quad = class {\n    constructor(t, s, i, h, _, r, l, e) {\n      this._tlx = NaN, this._tly = NaN, this._trx = NaN, this._try = NaN, this._brx = NaN, this._bry = NaN, this._blx = NaN, this._bly = NaN, this._tlx = 0, this._tly = 0, this._trx = 0, this._try = 0, this._brx = 0, this._bry = 0, this._blx = 0, this._bly = 0, t instanceof C32.Quad ? this.copy(t) : this.set(t || 0, s || 0, i || 0, h || 0, _ || 0, r || 0, l || 0, e || 0);\n    }\n    set(t, s, i, h, _, r, l, e) {\n      this._tlx = +t, this._tly = +s, this._trx = +i, this._try = +h, this._brx = +_, this._bry = +r, this._blx = +l, this._bly = +e;\n    }\n    setRect(t, s, i, h) {\n      this.set(t, s, i, s, i, h, t, h);\n    }\n    copy(t) {\n      this._tlx = t._tlx, this._tly = t._tly, this._trx = t._trx, this._try = t._try, this._brx = t._brx, this._bry = t._bry, this._blx = t._blx, this._bly = t._bly;\n    }\n    equals(t) {\n      return this._tlx === t._tlx && this._tly === t._tly && this._trx === t._trx && this._try === t._try && this._brx === t._brx && this._bry === t._bry && this._blx === t._blx && this._bly === t._bly;\n    }\n    setTlx(t) {\n      this._tlx = +t;\n    }\n    getTlx() {\n      return this._tlx;\n    }\n    setTly(t) {\n      this._tly = +t;\n    }\n    getTly() {\n      return this._tly;\n    }\n    setTrx(t) {\n      this._trx = +t;\n    }\n    getTrx() {\n      return this._trx;\n    }\n    setTry(t) {\n      this._try = +t;\n    }\n    getTry() {\n      return this._try;\n    }\n    setBrx(t) {\n      this._brx = +t;\n    }\n    getBrx() {\n      return this._brx;\n    }\n    setBry(t) {\n      this._bry = +t;\n    }\n    getBry() {\n      return this._bry;\n    }\n    setBlx(t) {\n      this._blx = +t;\n    }\n    getBlx() {\n      return this._blx;\n    }\n    setBly(t) {\n      this._bly = +t;\n    }\n    getBly() {\n      return this._bly;\n    }\n    toDOMQuad() {\n      return new DOMQuad(new DOMPoint(this._tlx, this._tly), new DOMPoint(this._trx, this._try), new DOMPoint(this._brx, this._bry), new DOMPoint(this._blx, this._bly));\n    }\n    static fromDOMQuad(t) {\n      return C32.New(C32.Quad, t.p1.x, t.p1.y, t.p2.x, t.p2.y, t.p3.x, t.p3.y, t.p4.x, t.p4.y);\n    }\n    toArray() {\n      return [this._tlx, this._tly, this._trx, this._try, this._brx, this._bry, this._blx, this._bly];\n    }\n    toTypedArray() {\n      return new Float64Array(this.toArray());\n    }\n    writeToTypedArray(t, s) {\n      t[s++] = this._tlx, t[s++] = this._tly, t[s++] = this._trx, t[s++] = this._try, t[s++] = this._brx, t[s++] = this._bry, t[s++] = this._blx, t[s] = this._bly;\n    }\n    writeToTypedArray3D(t, s, i) {\n      t[s++] = this._tlx, t[s++] = this._tly, t[s++] = i, t[s++] = this._trx, t[s++] = this._try, t[s++] = i, t[s++] = this._brx, t[s++] = this._bry, t[s++] = i, t[s++] = this._blx, t[s++] = this._bly, t[s] = i;\n    }\n    offset(t, s) {\n      s = +s, this._tlx += t = +t, this._tly += s, this._trx += t, this._try += s, this._brx += t, this._bry += s, this._blx += t, this._bly += s;\n    }\n    round() {\n      this._tlx = Math.round(this._tlx), this._tly = Math.round(this._tly), this._trx = Math.round(this._trx), this._try = Math.round(this._try), this._brx = Math.round(this._brx), this._bry = Math.round(this._bry), this._blx = Math.round(this._blx), this._bly = Math.round(this._bly);\n    }\n    floor() {\n      this._tlx = Math.floor(this._tlx), this._tly = Math.floor(this._tly), this._trx = Math.floor(this._trx), this._try = Math.floor(this._try), this._brx = Math.floor(this._brx), this._bry = Math.floor(this._bry), this._blx = Math.floor(this._blx), this._bly = Math.floor(this._bly);\n    }\n    ceil() {\n      this._tlx = Math.ceil(this._tlx), this._tly = Math.ceil(this._tly), this._trx = Math.ceil(this._trx), this._try = Math.ceil(this._try), this._brx = Math.ceil(this._brx), this._bry = Math.ceil(this._bry), this._blx = Math.ceil(this._blx), this._bly = Math.ceil(this._bly);\n    }\n    setFromRect(t) {\n      this._tlx = t._left, this._tly = t._top, this._trx = t._right, this._try = t._top, this._brx = t._right, this._bry = t._bottom, this._blx = t._left, this._bly = t._bottom;\n    }\n    setFromRotatedRect(t, s) {\n      0 === s ? this.setFromRect(t) : this.setFromRotatedRectPrecalc(t, Math.sin(s), Math.cos(s));\n    }\n    setFromRotatedRectPrecalc(t, s, i) {\n      const h = t._left * s, _ = t._top * s, r = t._right * s, l = t._bottom * s, e = t._left * i, x = t._top * i, y = t._right * i, b = t._bottom * i;\n      this._tlx = e - _, this._tly = x + h, this._trx = y - _, this._try = x + r, this._brx = y - l, this._bry = b + r, this._blx = e - l, this._bly = b + h;\n    }\n    getBoundingBox(t) {\n      t.set(Math.min(this._tlx, this._trx, this._brx, this._blx), Math.min(this._tly, this._try, this._bry, this._bly), Math.max(this._tlx, this._trx, this._brx, this._blx), Math.max(this._tly, this._try, this._bry, this._bly));\n    }\n    containsPoint(t, s) {\n      let i = this._trx - this._tlx, h = this._try - this._tly;\n      const _ = this._brx - this._tlx, r = this._bry - this._tly, l = t - this._tlx, e = s - this._tly;\n      let x = i * i + h * h, y = i * _ + h * r, b = i * l + h * e;\n      const a = _ * _ + r * r, n = _ * l + r * e;\n      let o = 1 / (x * a - y * y), c = (a * b - y * n) * o, u = (x * n - y * b) * o;\n      return 0 <= c && 0 < u && c + u < 1 || (u = ((x = (i = this._blx - this._tlx) * i + (h = this._bly - this._tly) * h) * n - (y = i * _ + h * r) * (b = i * l + h * e)) * (o = 1 / (x * a - y * y)), 0 <= (c = (a * b - y * n) * o) && 0 < u && c + u < 1);\n    }\n    midX() {\n      return (this._tlx + this._trx + this._brx + this._blx) / 4;\n    }\n    midY() {\n      return (this._tly + this._try + this._bry + this._bly) / 4;\n    }\n    intersectsSegment(t, s, i, h) {\n      return !(!this.containsPoint(t, s) && !this.containsPoint(i, h)) || C32.segmentIntersectsQuad(t, s, i, h, this);\n    }\n    intersectsQuad(t) {\n      let s = t.midX(), i = t.midY();\n      if (this.containsPoint(s, i)) return true;\n      if (s = this.midX(), i = this.midY(), t.containsPoint(s, i)) return true;\n      const h = this._tlx, _ = this._tly, r = this._trx, l = this._try, e = this._brx, x = this._bry, y = this._blx, b = this._bly;\n      return C32.segmentIntersectsQuad(h, _, r, l, t) || C32.segmentIntersectsQuad(r, l, e, x, t) || C32.segmentIntersectsQuad(e, x, y, b, t) || C32.segmentIntersectsQuad(y, b, h, _, t);\n    }\n    rotatePointsAnticlockwise() {\n      const t = this._tlx, s = this._tly;\n      this._tlx = this._trx, this._tly = this._try, this._trx = this._brx, this._try = this._bry, this._brx = this._blx, this._bry = this._bly, this._blx = t, this._bly = s;\n    }\n    mirror() {\n      this._swap(0, 2), this._swap(1, 3), this._swap(6, 4), this._swap(7, 5);\n    }\n    flip() {\n      this._swap(0, 6), this._swap(1, 7), this._swap(2, 4), this._swap(3, 5);\n    }\n    diag() {\n      this._swap(2, 6), this._swap(3, 7);\n    }\n    _swap(t, s) {\n      const i = this._getAtIndex(t);\n      this._setAtIndex(t, this._getAtIndex(s)), this._setAtIndex(s, i);\n    }\n    _getAtIndex(t) {\n      switch (t) {\n        case 0:\n          return this._tlx;\n        case 1:\n          return this._tly;\n        case 2:\n          return this._trx;\n        case 3:\n          return this._try;\n        case 4:\n          return this._brx;\n        case 5:\n          return this._bry;\n        case 6:\n          return this._blx;\n        case 7:\n          return this._bly;\n        default:\n          throw new RangeError(\"invalid quad point index\");\n      }\n    }\n    _setAtIndex(t, s) {\n      switch (s = +s, t) {\n        case 0:\n          this._tlx = s;\n          break;\n        case 1:\n          this._tly = s;\n          break;\n        case 2:\n          this._trx = s;\n          break;\n        case 3:\n          this._try = s;\n          break;\n        case 4:\n          this._brx = s;\n          break;\n        case 5:\n          this._bry = s;\n          break;\n        case 6:\n          this._blx = s;\n          break;\n        case 7:\n          this._bly = s;\n          break;\n        default:\n          throw new RangeError(\"invalid quad point index\");\n      }\n    }\n  };\n}\n{\n  const C32 = self.C3, assert = self.assert, DEFAULT_POLY_POINTS = [0, 0, 1, 0, 1, 1, 0, 1], tempQuad = C32.New(C32.Quad);\n  C32.CollisionPoly = class extends C32.DefendedBase {\n    constructor(t, s = true) {\n      super(), t = t || DEFAULT_POLY_POINTS, this._ptsArr = Float64Array.from(t), this._bbox = new C32.Rect(), this._isBboxChanged = true, this._enabled = s;\n    }\n    Release() {\n    }\n    pointsArr() {\n      return this._ptsArr;\n    }\n    pointCount() {\n      return this._ptsArr.length / 2;\n    }\n    setPoints(t) {\n      this._ptsArr.length === t.length ? this._ptsArr.set(t) : this._ptsArr = Float64Array.from(t), this._isBboxChanged = true;\n    }\n    setDefaultPoints() {\n      this.setPoints(DEFAULT_POLY_POINTS);\n    }\n    copy(t) {\n      this.setPoints(t._ptsArr);\n    }\n    setBboxChanged() {\n      this._isBboxChanged = true;\n    }\n    _updateBbox() {\n      if (this._isBboxChanged) {\n        const i = this._ptsArr;\n        let e = i[0], r = i[1], n = e, o = r;\n        for (let t = 0, s = i.length; t < s; t += 2) {\n          const h = i[t], l = i[t + 1];\n          h < e && (e = h), h > n && (n = h), l < r && (r = l), l > o && (o = l);\n        }\n        this._bbox.set(e, r, n, o), this._isBboxChanged = false;\n      }\n    }\n    setFromRect(t, s, e) {\n      let r = this._ptsArr;\n      8 !== r.length && (r = new Float64Array(8), this._ptsArr = r), r[0] = t.getLeft() - s, r[1] = t.getTop() - e, r[2] = t.getRight() - s, r[3] = t.getTop() - e, r[4] = t.getRight() - s, r[5] = t.getBottom() - e, r[6] = t.getLeft() - s, r[7] = t.getBottom() - e, this._bbox.copy(t), 0 === s && 0 === e || this._bbox.offset(-s, -e), this._isBboxChanged = false;\n    }\n    setFromQuad(t, s, e) {\n      tempQuad.copy(t), tempQuad.offset(s, e), this.setPoints(tempQuad.toArray()), this._isBboxChanged = true;\n    }\n    transform(t, s, e) {\n      let r = 0, n = 1;\n      0 !== e && (r = Math.sin(e), n = Math.cos(e)), this.transformPrecalc(t, s, r, n);\n    }\n    transformPrecalc(e, r, n, o) {\n      const i = this._ptsArr;\n      for (let t = 0, s = i.length; t < s; t += 2) {\n        const h = t + 1, l = i[t] * e, a = i[h] * r;\n        i[t] = l * o - a * n, i[h] = a * o + l * n;\n      }\n      this._isBboxChanged = true;\n    }\n    offset(e, r) {\n      const n = this._ptsArr;\n      for (let t = 0, s = n.length; t < s; t += 2) n[t] += e, n[t + 1] += r;\n    }\n    containsPoint(e, r) {\n      const n = this._ptsArr;\n      if (e === n[0] && r === n[1]) return true;\n      this._updateBbox();\n      const t = this._bbox, o = t.getLeft() - 110, i = t.getTop() - 101, h = t.getRight() + 131, l = t.getBottom() + 120;\n      let a = 0, c = 0, g = 0, _ = 0, p = 0, f = 0, u = 0, C = 0, A = (g = o < e ? (a = o, e) : (a = e, o), _ = i < r ? (c = i, r) : (c = r, i), u = h < e ? (p = h, e) : (p = e, h), C = l < r ? (f = l, r) : (f = r, l), 0), d = 0;\n      for (let t2 = 0, s = n.length; t2 < s; t2 += 2) {\n        const b = (t2 + 2) % s, P = n[t2], m = n[t2 + 1], x = n[b], B = n[1 + b];\n        C32.segmentsIntersectPreCalc(o, i, e, r, a, g, c, _, P, m, x, B) && ++A, C32.segmentsIntersectPreCalc(h, l, e, r, p, u, f, C, P, m, x, B) && ++d;\n      }\n      return A % 2 == 1 || d % 2 == 1;\n    }\n    intersectsPoly(t, i, h) {\n      const l = t._ptsArr, a = this._ptsArr;\n      if (this.containsPoint(l[0] + i, l[1] + h)) return true;\n      if (t.containsPoint(a[0] - i, a[1] - h)) return true;\n      for (let t2 = 0, s = a.length; t2 < s; t2 += 2) {\n        const c = (t2 + 2) % s, g = a[t2], _ = a[t2 + 1], p = a[c], f = a[1 + c];\n        let e = 0, r = 0, n = 0, o = 0;\n        n = g < p ? (e = g, p) : (e = p, g), o = _ < f ? (r = _, f) : (r = f, _);\n        for (let t3 = 0, s2 = l.length; t3 < s2; t3 += 2) {\n          const u = (t3 + 2) % s2, C = l[t3] + i, A = l[t3 + 1] + h, d = l[u] + i, b = l[1 + u] + h;\n          if (C32.segmentsIntersectPreCalc(g, _, p, f, e, n, r, o, C, A, d, b)) return true;\n        }\n      }\n      return false;\n    }\n    intersectsSegment(e, r, n, o, i, h) {\n      if (this.containsPoint(n - e, o - r)) return true;\n      if (this.containsPoint(i - e, h - r)) return true;\n      let l = 0, a = 0, c = 0, g = 0;\n      c = n < i ? (l = n, i) : (l = i, n), g = o < h ? (a = o, h) : (a = h, o);\n      const _ = this._ptsArr;\n      for (let t = 0, s = _.length; t < s; t += 2) {\n        const p = (t + 2) % s, f = _[t] + e, u = _[t + 1] + r, C = _[p] + e, A = _[1 + p] + r;\n        if (C32.segmentsIntersectPreCalc(n, o, i, h, l, c, a, g, f, u, C, A)) return true;\n      }\n      return false;\n    }\n    mirror(e) {\n      const r = this._ptsArr;\n      for (let t = 0, s = r.length; t < s; t += 2) r[t] = 2 * e - r[t];\n      this._isBboxChanged = true;\n    }\n    flip(e) {\n      const r = this._ptsArr;\n      for (let t = 0, s = r.length; t < s; t += 2) {\n        const n = t + 1;\n        r[n] = 2 * e - r[n];\n      }\n      this._isBboxChanged = true;\n    }\n    diag() {\n      const e = this._ptsArr;\n      for (let t = 0, s = e.length; t < s; t += 2) {\n        const r = t + 1, n = e[t];\n        e[t] = e[r], e[r] = n;\n      }\n      this._isBboxChanged = true;\n    }\n    GetMidX() {\n      const e = this._ptsArr;\n      let r = 0;\n      for (let t = 0, s = e.length; t < s; t += 2) r += e[t];\n      return r / this.pointCount();\n    }\n    GetMidY() {\n      const e = this._ptsArr;\n      let r = 0;\n      for (let t = 0, s = e.length; t < s; t += 2) r += e[t + 1];\n      return r / this.pointCount();\n    }\n    GetPointsArray() {\n      return this._ptsArr;\n    }\n    GetPointCount() {\n      return this.pointCount();\n    }\n    IsEnabled() {\n      return this._enabled;\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.PairMap = class extends C32.DefendedBase {\n    constructor(e) {\n      if (super(), this._firstMap = /* @__PURE__ */ new Map(), e) for (const [t, s, r] of e) this.Set(t, s, r);\n    }\n    Release() {\n      this.Clear(), this._firstMap = null;\n    }\n    IsEmpty() {\n      return 0 === this._firstMap.size;\n    }\n    Clear() {\n      const e = this._firstMap;\n      for (const t of e.values()) t.clear();\n      e.clear();\n    }\n    Set(e, t, s) {\n      const r = this._firstMap;\n      let i = r.get(e);\n      i || (i = /* @__PURE__ */ new Map(), r.set(e, i)), i.set(t, s);\n    }\n    Get(e, t) {\n      const s = this._firstMap.get(e);\n      return s && s.get(t);\n    }\n    Has(e, t) {\n      const s = this._firstMap.get(e);\n      return !!s && s.has(t);\n    }\n    Delete(e, t) {\n      const s = this._firstMap, r = s.get(e);\n      if (!r) return false;\n      const i = r.delete(t);\n      return i && 0 === r.size && s.delete(e), i;\n    }\n    DeleteEither(e) {\n      const t = this._firstMap, s = t.get(e);\n      s && (s.clear(), t.delete(e));\n      for (const [r, s2] of t.entries()) s2.delete(e) && 0 === s2.size && t.delete(r);\n    }\n    GetSize() {\n      let e = 0;\n      for (const t of this._firstMap.values()) e += t.size;\n      return e;\n    }\n    *values() {\n      for (const e of this._firstMap.values()) yield* e.values();\n    }\n    *keyPairs() {\n      for (const [e, t] of this._firstMap.entries()) for (const s of t.keys()) yield [e, s];\n    }\n    *entries() {\n      for (const [e, t] of this._firstMap.entries()) for (const [s, r] of t.entries()) yield [e, s, r];\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.ArraySet = class extends C32.DefendedBase {\n    constructor() {\n      super(), this._set = /* @__PURE__ */ new Set(), this._arr = [], this._needToRebuildArray = false;\n    }\n    Release() {\n      this.Clear();\n    }\n    Clear() {\n      this._set.clear(), C32.clearArray(this._arr), this._needToRebuildArray = false;\n    }\n    Add(e) {\n      this._set.has(e) || (this._set.add(e), this._needToRebuildArray) || this._arr.push(e);\n    }\n    Has(e) {\n      return this._set.has(e);\n    }\n    Delete(e) {\n      this._set.delete(e) && (this._needToRebuildArray = true);\n    }\n    GetSize() {\n      return this._set.size;\n    }\n    IsEmpty() {\n      return 0 === this._set.size;\n    }\n    GetArray() {\n      return this._needToRebuildArray && (this._RebuildArray(), this._needToRebuildArray = false), this._arr;\n    }\n    _RebuildArray() {\n      const e = this._arr;\n      C32.clearArray(e);\n      for (const r of this._set) e.push(r);\n    }\n  };\n}\n{\n  const C32 = self.C3, EASE_MAP = /* @__PURE__ */ new Map(), PREDEFINED_EASE_MAP = /* @__PURE__ */ new Map(), CUSTOM_EASE_EDITOR_MAP = /* @__PURE__ */ new Map(), CUSTOM_EASE_DATA_EDITOR_MAP = /* @__PURE__ */ new Map(), CUSTOM_EASE_RUNTIME_MAP = /* @__PURE__ */ new Map(), CUSTOM_EASE_DATA_RUNTIME_MAP = /* @__PURE__ */ new Map(), PRIVATE_EASE_MAP = /* @__PURE__ */ new Map(), BUILT_IN_TRANSITION_MAP = /* @__PURE__ */ new Map(), ALIAS_MAP = /* @__PURE__ */ new Map(), EASE_TRANSLATION_KEYS = (ALIAS_MAP.set(\"linear\", \"noease\"), ALIAS_MAP.set(\"default\", \"noease\"), [\"default\", \"noease\", \"easeinquad\", \"easeoutquad\", \"easeinoutquad\", \"easeincubic\", \"easeoutcubic\", \"easeinoutcubic\", \"easeinquart\", \"easeoutquart\", \"easeinoutquart\", \"easeinquint\", \"easeoutquint\", \"easeinoutquint\", \"easeinsine\", \"easeoutsine\", \"easeinoutsine\", \"easeinexpo\", \"easeoutexpo\", \"easeinoutexpo\", \"easeincirc\", \"easeoutcirc\", \"easeinoutcirc\", \"easeinelastic\", \"easeoutelastic\", \"easeinoutelastic\", \"easeinback\", \"easeoutback\", \"easeinoutback\", \"easeinbounce\", \"easeoutbounce\", \"easeinoutbounce\"]), SHORT_EASE_TRANSLATION_KEYS = [\"default\", \"noease\", \"quad\", \"cubic\", \"quart\", \"quint\", \"sine\", \"expo\", \"circ\", \"elastic\", \"back\", \"bounce\"], EASE_API2INTERNAL_NAMES = /* @__PURE__ */ new Map([[\"linear\", \"noease\"], [\"in-sine\", \"easeinsine\"], [\"out-sine\", \"easeoutsine\"], [\"in-out-sine\", \"easeinoutsine\"], [\"in-elastic\", \"easeinelastic\"], [\"out-elastic\", \"easeoutelastic\"], [\"in-out-elastic\", \"easeinoutelastic\"], [\"in-back\", \"easeinback\"], [\"out-back\", \"easeoutback\"], [\"in-out-back\", \"easeinoutback\"], [\"in-bounce\", \"easeinbounce\"], [\"out-bounce\", \"easeoutbounce\"], [\"in-out-bounce\", \"easeinoutbounce\"], [\"in-cubic\", \"easeincubic\"], [\"out-cubic\", \"easeoutcubic\"], [\"in-out-cubic\", \"easeinoutcubic\"], [\"in-quadratic\", \"easeinquad\"], [\"out-quadratic\", \"easeoutquad\"], [\"in-out-quadratic\", \"easeinoutquad\"], [\"in-quartic\", \"easeinquart\"], [\"out-quartic\", \"easeoutquart\"], [\"in-out-quartic\", \"easeinoutquart\"], [\"in-quintic\", \"easeinquint\"], [\"out-quintic\", \"easeoutquint\"], [\"in-out-quintic\", \"easeinoutquint\"], [\"in-circular\", \"easeincirc\"], [\"out-circular\", \"easeoutcirc\"], [\"in-out-circular\", \"easeinoutcirc\"], [\"in-exponential\", \"easeinexpo\"], [\"out-exponential\", \"easeoutexpo\"], [\"in-out-exponential\", \"easeinoutexpo\"]]), SAMPLE_COUNT = (self.Ease = class d {\n    constructor() {\n    }\n    static InheritEase() {\n      return \"default\";\n    }\n    static DefaultEase() {\n      return \"noease\";\n    }\n    static ToInternal(e) {\n      return EASE_API2INTERNAL_NAMES.get(e);\n    }\n    static GetEditorEaseNames(a2, ...s) {\n      this._CreateEaseMap();\n      let e, t;\n      const i = (t = a2 ? (CUSTOM_EASE_EDITOR_MAP.has(a2) || CUSTOM_EASE_EDITOR_MAP.set(a2, /* @__PURE__ */ new Map()), [...(e = CUSTOM_EASE_EDITOR_MAP.get(a2)).keys()].filter((e2) => !d.GetEditorEaseData(e2, a2) || d.GetEditorEaseData(e2, a2).transition.IsForAnyPurpose())) : [...(e = CUSTOM_EASE_RUNTIME_MAP).keys()]).sort();\n      return [...PREDEFINED_EASE_MAP.keys()].concat(i).filter((e2) => !s.includes(e2));\n    }\n    static GetRuntimeEaseNames() {\n      this._CreateEaseMap();\n      const e = [...CUSTOM_EASE_RUNTIME_MAP.keys()];\n      return e.sort(), [...PREDEFINED_EASE_MAP.keys()].concat(e);\n    }\n    static GetCustomRuntimeEaseNames() {\n      this._CreateEaseMap();\n      const e = [...CUSTOM_EASE_RUNTIME_MAP.keys()];\n      return e.sort(), e;\n    }\n    static IsPredefinedTranslatedName(e) {\n      for (const a2 of EASE_TRANSLATION_KEYS) {\n        const s = self.lang(\"ui.bars.timeline.eases.\" + a2);\n        if (s === e) return true;\n      }\n      for (const t of SHORT_EASE_TRANSLATION_KEYS) {\n        const i = self.lang(\"ui.bars.timeline.short-eases.\" + t);\n        if (i === e) return true;\n      }\n    }\n    static IsNamePredefined(e) {\n      return this._CreateEaseMap(), [...PREDEFINED_EASE_MAP.keys()].includes(e);\n    }\n    static _GetEase(e) {\n      const a2 = ALIAS_MAP.get(e);\n      return a2 ? EASE_MAP.get(a2) : d.IsNamePredefined(e) ? EASE_MAP.get(e) : PRIVATE_EASE_MAP.has(e) ? PRIVATE_EASE_MAP.get(e) : void 0;\n    }\n    static GetBuiltInTransition(e) {\n      return this._CreateEaseMap(), BUILT_IN_TRANSITION_MAP.get(e);\n    }\n    static GetEditorEase(e, a2) {\n      this._CreateEaseMap();\n      const s = d._GetEase(e);\n      if (s) return s;\n      if (a2) return CUSTOM_EASE_EDITOR_MAP.get(a2).get(e);\n      throw new Error(\"missing ease function\");\n    }\n    static GetEditorEaseData(e, a2) {\n      this._CreateEaseMap();\n      const s = CUSTOM_EASE_DATA_EDITOR_MAP.get(a2);\n      if (s) return s.get(e);\n    }\n    static HasEditorEase(e, a2) {\n      this._CreateEaseMap();\n      const s = d._GetEase(e);\n      return !!s || !!CUSTOM_EASE_EDITOR_MAP.get(a2).get(e);\n    }\n    static GetRuntimeEase(e) {\n      this._CreateEaseMap();\n      const a2 = d._GetEase(e);\n      return a2 || CUSTOM_EASE_RUNTIME_MAP.get(e);\n    }\n    static GetRuntimeEaseData(e) {\n      return this._CreateEaseMap(), CUSTOM_EASE_DATA_RUNTIME_MAP.get(e);\n    }\n    static GetEaseFromIndex(e) {\n      this._CreateEaseMap();\n      const a2 = this.GetRuntimeEaseNames();\n      return a2[e];\n    }\n    static GetIndexForEase(e, a2) {\n      this._CreateEaseMap();\n      const s = this.GetEditorEaseNames(a2);\n      return s.indexOf(e);\n    }\n    static GetIndexForEaseAtRuntime(e) {\n      return this.GetIndexForEase(e);\n    }\n    static _CreateEaseMap() {\n      0 === EASE_MAP.size && (this._AddPredifinedEase(\"default\", () => {\n      }), this._AddPredifinedEase(\"noease\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.336, \"say\": 0, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.336, \"eay\": 0, \"se\": false, \"ee\": true }], true), this._AddPredifinedEase(\"easeinsine\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.485, \"say\": 0, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.038, \"eay\": 0, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeoutsine\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.038, \"say\": 0, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.485, \"eay\": 0, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeinoutsine\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.336, \"say\": 0, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.336, \"eay\": 0, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeinelastic\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.018, \"say\": 0, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 0.116, \"y\": 2e-3, \"sax\": 0.025, \"say\": 0, \"eax\": -0.025, \"eay\": 0, \"se\": true, \"ee\": true }, { \"x\": 0.266, \"y\": -5e-3, \"sax\": 0.024, \"say\": 0, \"eax\": -0.021, \"eay\": 0, \"se\": true, \"ee\": true }, { \"x\": 0.416, \"y\": 0.016, \"sax\": 0.024, \"say\": 0, \"eax\": -0.026, \"eay\": 0, \"se\": true, \"ee\": true }, { \"x\": 0.566, \"y\": -0.045, \"sax\": 0.061, \"say\": 0, \"eax\": -0.025, \"eay\": 0, \"se\": true, \"ee\": true }, { \"x\": 0.716, \"y\": 0.132, \"sax\": 0.072, \"say\": -4e-3, \"eax\": -0.045, \"eay\": 0, \"se\": true, \"ee\": true }, { \"x\": 0.866, \"y\": -0.373, \"sax\": 0.06, \"say\": 0, \"eax\": -0.049, \"eay\": -2e-3, \"se\": true, \"ee\": true }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.038, \"eay\": -0.263, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeoutelastic\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.038, \"say\": 0.263, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 0.136, \"y\": 1.373, \"sax\": 0.049, \"say\": 2e-3, \"eax\": -0.06, \"eay\": 0, \"se\": true, \"ee\": true }, { \"x\": 0.286, \"y\": 0.868, \"sax\": 0.045, \"say\": 0, \"eax\": -0.072, \"eay\": 4e-3, \"se\": true, \"ee\": true }, { \"x\": 0.436, \"y\": 1.045, \"sax\": 0.025, \"say\": 0, \"eax\": -0.061, \"eay\": 0, \"se\": true, \"ee\": true }, { \"x\": 0.586, \"y\": 0.984, \"sax\": 0.026, \"say\": 0, \"eax\": -0.024, \"eay\": 0, \"se\": true, \"ee\": true }, { \"x\": 0.736, \"y\": 1.005, \"sax\": 0.021, \"say\": 0, \"eax\": -0.024, \"eay\": 0, \"se\": true, \"ee\": true }, { \"x\": 0.886, \"y\": 0.998, \"sax\": 0.025, \"say\": 0, \"eax\": -0.025, \"eay\": 0, \"se\": true, \"ee\": true }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.018, \"eay\": 0, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeinoutelastic\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.025, \"say\": 0, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 0.067, \"y\": 1e-3, \"sax\": 0.025, \"say\": 0, \"eax\": -0.025, \"eay\": 0, \"se\": true, \"ee\": true }, { \"x\": 0.18, \"y\": -5e-3, \"sax\": 0.025, \"say\": 0, \"eax\": -0.025, \"eay\": 0, \"se\": true, \"ee\": true }, { \"x\": 0.292, \"y\": 0.025, \"sax\": 0.053, \"say\": 0, \"eax\": -0.025, \"eay\": 0, \"se\": true, \"ee\": true }, { \"x\": 0.405, \"y\": -0.118, \"sax\": 0.069, \"say\": 0, \"eax\": -0.027, \"eay\": 0, \"se\": true, \"ee\": true }, { \"x\": 0.597, \"y\": 1.118, \"sax\": 0.027, \"say\": 0, \"eax\": -0.069, \"eay\": 0, \"se\": true, \"ee\": true }, { \"x\": 0.71, \"y\": 0.975, \"sax\": 0.025, \"say\": 0, \"eax\": -0.053, \"eay\": 0, \"se\": true, \"ee\": true }, { \"x\": 0.822, \"y\": 1.005, \"sax\": 0.025, \"say\": 0, \"eax\": -0.025, \"eay\": 0, \"se\": true, \"ee\": true }, { \"x\": 0.935, \"y\": 0.999, \"sax\": 0.025, \"say\": 0, \"eax\": -0.025, \"eay\": 0, \"se\": true, \"ee\": true }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.025, \"eay\": 0, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeinback\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.35, \"say\": 0, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.34, \"eay\": -1.579, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeoutback\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.34, \"say\": 1.579, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.35, \"eay\": 0, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeinoutback\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.035, \"say\": 0, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 0.242, \"y\": -0.1, \"sax\": 0.258, \"say\": 0, \"eax\": -0.025, \"eay\": 0, \"se\": true, \"ee\": true }, { \"x\": 0.76, \"y\": 1.1, \"sax\": 0.025, \"say\": 0, \"eax\": -0.26, \"eay\": 0, \"se\": true, \"ee\": true }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.035, \"eay\": 0, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeinbounce\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.033, \"say\": 0.025, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 0.092, \"y\": 0, \"sax\": 0.026, \"say\": 0.078, \"eax\": -0.033, \"eay\": 0.025, \"se\": true, \"ee\": true }, { \"x\": 0.274, \"y\": 0, \"sax\": 0.097, \"say\": 0.319, \"eax\": -0.026, \"eay\": 0.078, \"se\": true, \"ee\": true }, { \"x\": 0.637, \"y\": 0, \"sax\": 0.105, \"say\": 0.625, \"eax\": -0.097, \"eay\": 0.319, \"se\": true, \"ee\": true }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.125, \"eay\": -4e-3, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeoutbounce\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.125, \"say\": 4e-3, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 0.365, \"y\": 1, \"sax\": 0.097, \"say\": -0.319, \"eax\": -0.105, \"eay\": -0.625, \"se\": true, \"ee\": true }, { \"x\": 0.728, \"y\": 1, \"sax\": 0.026, \"say\": -0.078, \"eax\": -0.097, \"eay\": -0.319, \"se\": true, \"ee\": true }, { \"x\": 0.91, \"y\": 1, \"sax\": 0.033, \"say\": -0.025, \"eax\": -0.026, \"eay\": -0.078, \"se\": true, \"ee\": true }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.033, \"eay\": -0.025, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeinoutbounce\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.01, \"say\": 6e-3, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 0.046, \"y\": 0, \"sax\": 0.021, \"say\": 0.038, \"eax\": -0.01, \"eay\": 6e-3, \"se\": true, \"ee\": true }, { \"x\": 0.137, \"y\": 0, \"sax\": 0.059, \"say\": 0.158, \"eax\": -0.021, \"eay\": 0.038, \"se\": true, \"ee\": true }, { \"x\": 0.319, \"y\": 0, \"sax\": 0.117, \"say\": 0.744, \"eax\": -0.059, \"eay\": 0.158, \"se\": true, \"ee\": true }, { \"x\": 0.683, \"y\": 1, \"sax\": 0.059, \"say\": -0.158, \"eax\": -0.117, \"eay\": -0.744, \"se\": true, \"ee\": true }, { \"x\": 0.865, \"y\": 1, \"sax\": 0.021, \"say\": -0.038, \"eax\": -0.059, \"eay\": -0.158, \"se\": true, \"ee\": true }, { \"x\": 0.956, \"y\": 1, \"sax\": 0.01, \"say\": -6e-3, \"eax\": -0.021, \"eay\": -0.038, \"se\": true, \"ee\": true }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.01, \"eay\": -6e-3, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeincubic\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.75, \"say\": 0, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.138, \"eay\": -0.321, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeoutcubic\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.138, \"say\": 0.321, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.75, \"eay\": 0, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeinoutcubic\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.285, \"say\": 0, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 0.5, \"y\": 0.5, \"sax\": 0.081, \"say\": 0.272, \"eax\": -0.081, \"eay\": -0.272, \"se\": true, \"ee\": true }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.285, \"eay\": 0, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeinquad\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.4, \"say\": 0, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.178, \"eay\": -0.392, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeoutquad\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.178, \"say\": 0.392, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.4, \"eay\": 0, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeinoutquad\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.25, \"say\": 0, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 0.5, \"y\": 0.5, \"sax\": 0.03, \"say\": 0.065, \"eax\": -0.03, \"eay\": -0.065, \"se\": true, \"ee\": true }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.25, \"eay\": 0, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeinquart\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.25, \"say\": 1, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.5, \"eay\": 0, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeoutquart\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.5, \"say\": 0, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.25, \"eay\": -1, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeinoutquart\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.765, \"say\": 0.03, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.765, \"eay\": -0.03, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeinquint\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.6, \"say\": 0, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.2, \"eay\": -1, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeoutquint\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.2, \"say\": 1, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.6, \"eay\": 0, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeinoutquint\", [{ \"eax\": 0, \"eay\": 0, \"ee\": false, \"sax\": 0.84, \"say\": 0, \"se\": true, \"x\": 0, \"y\": 0 }, { \"eax\": -0.84, \"eay\": 0, \"ee\": true, \"sax\": 0, \"say\": 0, \"se\": false, \"x\": 1, \"y\": 1 }]), this._AddPredifinedEase(\"easeincirc\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.25, \"say\": 0, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.024, \"eay\": -0.808, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeoutcirc\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.024, \"say\": 0.808, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.25, \"eay\": 0, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeinoutcirc\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.125, \"say\": 0, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 0.5, \"y\": 0.5, \"sax\": 0.02, \"say\": 0.428, \"eax\": -0.02, \"eay\": -0.428, \"se\": true, \"ee\": true }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.125, \"eay\": 0, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeinexpo\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.66, \"say\": 0, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.14, \"eay\": -1, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeoutexpo\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.14, \"say\": 1, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.66, \"eay\": 0, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeinoutexpo\", [{ \"eax\": 0, \"eay\": 0, \"ee\": false, \"sax\": 0.345, \"say\": 0, \"se\": true, \"x\": 0, \"y\": 0 }, { \"eax\": -0.06, \"eay\": -0.5, \"ee\": true, \"sax\": 0.06, \"say\": 0.5, \"se\": true, \"x\": 0.5, \"y\": 0.5 }, { \"eax\": -0.335, \"eay\": 0, \"ee\": true, \"sax\": 0, \"say\": 0, \"se\": false, \"x\": 1, \"y\": 1 }]), this._AddPrivateCustomEase(\"cubicbezier\", this.EaseCubicBezier), this._AddPrivateCustomEase(\"spline\", this.EaseSpline));\n    }\n    static _AddPredifinedEase(e, a2, s = false) {\n      if (\"function\" == typeof a2) d._AddEase(e, a2, \"predefined\");\n      else {\n        if (!C32.IsArray(a2)) throw new Error(\"unexpected arguments\");\n        if (self.BuiltInTransition) {\n          const i = C32.New(self.BuiltInTransition, e, s);\n          i.SetFromJson(a2), d._AddEase(e, (e2, a3, s2, t) => i.Interpolate(e2, a3, s2, t), \"predefined\"), BUILT_IN_TRANSITION_MAP.set(e, i);\n        } else {\n          const x = C32.New(C32.Transition, [e, a2.map((e2) => [e2[\"x\"], e2[\"y\"], e2[\"sax\"], e2[\"say\"], e2[\"eax\"], e2[\"eay\"], e2[\"se\"], e2[\"ee\"]])], false);\n          x.MakeLinear(s), d._AddEase(e, (e2, a3, s2, t) => x.Interpolate(e2, a3, s2, t), \"predefined\");\n        }\n      }\n    }\n    static _AddPrivateCustomEase(e, a2) {\n      d._AddEase(e, a2, \"private\");\n    }\n    static AddCustomEase(e, a2, s, t) {\n      this._CreateEaseMap(), d._AddEase(e, a2, \"custom\", s, t);\n    }\n    static RemoveCustomEase(e, a2) {\n      if (!this.IsNamePredefined(e) && ![...PRIVATE_EASE_MAP.keys()].includes(e)) {\n        const s = CUSTOM_EASE_EDITOR_MAP.get(a2), t = (s && s.delete(e), CUSTOM_EASE_DATA_EDITOR_MAP.get(a2));\n        t && t.delete(e);\n      }\n    }\n    static _AddEase(e, a2, s, t, i) {\n      switch (s) {\n        case \"predefined\":\n          EASE_MAP.set(e, a2), PREDEFINED_EASE_MAP.set(e, a2);\n          break;\n        case \"custom\":\n          if (t) {\n            CUSTOM_EASE_EDITOR_MAP.has(t) || CUSTOM_EASE_EDITOR_MAP.set(t, /* @__PURE__ */ new Map()), CUSTOM_EASE_DATA_EDITOR_MAP.has(t) || CUSTOM_EASE_DATA_EDITOR_MAP.set(t, /* @__PURE__ */ new Map());\n            const x = CUSTOM_EASE_EDITOR_MAP.get(t), y = (x.set(e, a2), CUSTOM_EASE_DATA_EDITOR_MAP.get(t));\n            y.set(e, i);\n          } else CUSTOM_EASE_RUNTIME_MAP.set(e, a2), CUSTOM_EASE_DATA_RUNTIME_MAP.set(e, i);\n          break;\n        case \"private\":\n          EASE_MAP.set(e, a2), PRIVATE_EASE_MAP.set(e, a2);\n          break;\n        default:\n          throw new Error(\"unexpected ease mode\");\n      }\n    }\n    static NoEase(e, a2, s, t) {\n      return 0 === t ? a2 : s * e / t + a2;\n    }\n    static EaseCubicBezier(e, a2, s, t, i) {\n      const x = a2, y = 3 * e * (s - a2), n = 3 * e ** 2 * (a2 + t - 2 * s), E = e ** 3 * (i - a2 + 3 * s - 3 * t);\n      return x + y + n + E;\n    }\n    static EaseSpline(e, s, t, i, x, y, n, E, _, r) {\n      if (i === x && y === n) return e;\n      const u = get_t_for_x(e, s, i, y, E, r), d2 = a(t, x, n, _), A = b(t, x, n, _), o = c(t, x, n, _);\n      return calc_bezier(u, d2, A, o);\n    }\n    static GetBezierSamples(e, s, t, i) {\n      const x = [], y = a(e, s, t, i), n = b(e, s, t, i), E = c(e, s, t, i);\n      for (let e2 = 0; e2 < SAMPLE_COUNT; ++e2) {\n        const _ = calc_bezier(e2 * SAMPLE_STEP, y, n, E);\n        x.push(_);\n      }\n      return x;\n    }\n  }, 11), SAMPLE_STEP = 1 / (SAMPLE_COUNT - 1), NEWTON_RAPHSON_ITERATIONS = 4, NEWTON_RAPHSON_MIN_SLOPE = 0.01, SUBDIVISION_PRECISION = 1e-7, SUBDIVISION_MAX_ITERATIONS = 10, a = (e, a2, s, t) => t - 3 * s + 3 * a2 - e, b = (e, a2, s, t) => 3 * s - 6 * a2 + 3 * e, c = (e, a2, s, t) => 3 * (a2 - e), calc_bezier = (e, a2, s, t) => ((a2 * e + s) * e + t) * e, get_slope = (e, a2, s, t) => 3 * a2 * e * e + 2 * s * e + t, get_t_for_x = (y, e, s, t, i, x) => {\n    if (1 == y) return 1;\n    let n = 0, E = 1, _ = x[E], r = SAMPLE_COUNT - 1;\n    SAMPLE_COUNT;\n    for (; E != r && _ <= y; ) E++, _ = x[E], n += SAMPLE_STEP;\n    E--;\n    const u = (y - (_ = x[E])) / (x[E + 1] - _);\n    let d = n + u * SAMPLE_STEP;\n    const A = a(e, s, t, i), o = b(e, s, t, i), S = c(e, s, t, i), M = get_slope(d, A, o, S);\n    if (0 === M) return d;\n    if (M >= NEWTON_RAPHSON_MIN_SLOPE) {\n      for (let e2 = 0; e2 < NEWTON_RAPHSON_ITERATIONS; ++e2) {\n        const P = calc_bezier(d, A, o, S) - y, T = get_slope(d, A, o, S);\n        d -= P / T;\n      }\n      return d;\n    }\n    {\n      let a2 = n, s2 = n + SAMPLE_STEP, t2 = 0, i2, x2;\n      do {\n        d = a2 + (s2 - a2) / 2;\n        let e2 = calc_bezier(d, A, o, S) - y;\n        0 < e2 ? s2 = d : a2 = d, i2 = Math.abs(e2) > SUBDIVISION_PRECISION, x2 = ++t2 < SUBDIVISION_MAX_ITERATIONS;\n      } while (i2 && x2);\n      return d;\n    }\n  };\n}\n{\n  let RequireStringOrNumber = function(t) {\n    C32.IsString(t);\n  };\n  RequireStringOrNumber2 = RequireStringOrNumber;\n  const C32 = self.C3;\n  C32.ProbabilityTable = class {\n    constructor(t) {\n      this._items = [], this._name = t || \"\", this._totalWeight = 0;\n    }\n    Release() {\n      this.Clear(), this._items = null;\n    }\n    GetName() {\n      return this._name;\n    }\n    Clear() {\n      C32.clear2DArray(this._items), this._totalWeight = 0;\n    }\n    GetTotalWeight() {\n      return this._totalWeight;\n    }\n    Sample(t = Math.random() * this.GetTotalWeight()) {\n      let e = 0;\n      for (const [i, s] of this._items) if (t < (e += i)) return s;\n      return 0;\n    }\n    AddItem(t, e) {\n      RequireStringOrNumber(e), this._totalWeight += t, this._items.push([t, e]);\n    }\n    RemoveItem(e, i) {\n      RequireStringOrNumber(i);\n      const s = 0 === e;\n      for (let t = 0; t < this._items.length; t++) {\n        const r = this._items[t], h = s || r[0] === e, a = r[1] === i;\n        if (h && a) {\n          this._items.splice(t, 1), this._totalWeight -= r[0];\n          break;\n        }\n      }\n    }\n    asJSON() {\n      return JSON.stringify(this._items);\n    }\n    static fromJSON(t, e) {\n      const i = new C32.ProbabilityTable(e), s = JSON.parse(t);\n      for (const r of s) {\n        const h = r[0], a = r[1];\n        i.AddItem(h, a);\n      }\n      return i;\n    }\n  };\n}\nvar RequireStringOrNumber2;\n{\n  const C32 = self.C3;\n  let nextId = 0;\n  C32.ScreenReaderText = class {\n    constructor(t, e) {\n      this._runtime = t, this._text = e, this._id = nextId++, this._runtime.PostComponentMessageToDOM(\"runtime\", \"screen-reader-text\", { \"type\": \"create\", \"id\": this._id, \"text\": this._text });\n    }\n    Release() {\n      this._runtime.PostComponentMessageToDOM(\"runtime\", \"screen-reader-text\", { \"type\": \"release\", \"id\": this._id }), this._runtime = null, this._text = \"\", this._id = -1;\n    }\n    SetText(t) {\n      this._text !== t && (this._text = t, this._runtime.PostComponentMessageToDOM(\"runtime\", \"screen-reader-text\", { \"type\": \"update\", \"id\": this._id, \"text\": this._text }));\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.Event = class {\n    constructor(t, e) {\n      this.type = t, this.cancelable = !!e, this.defaultPrevented = false, this.propagationStopped = false, this.isAsync = false;\n    }\n    preventDefault() {\n      if (!this.cancelable) throw new Error(`event '${this.type}' is not cancelable`);\n      this.defaultPrevented = true;\n    }\n    stopPropagation() {\n      if (!this.cancelable) throw new Error(`event '${this.type}' cannot be stopped`);\n      if (this.isAsync) throw new Error(`cannot stop async event '${this.type}' propagation`);\n      this.propagationStopped = true;\n    }\n  };\n}\n{\n  const C32 = self.C3, assert = self.assert;\n  C32.Event.Handler = class extends C32.DefendedBase {\n    constructor(e) {\n      super(), this._type = e, this._captureListeners = [], this._captureListenersSet = /* @__PURE__ */ new Set(), this._listeners = [], this._listenersSet = /* @__PURE__ */ new Set(), this._fireDepth = 0, this._queueModifyListeners = [];\n    }\n    Release() {\n      0 < this._fireDepth || (C32.clearArray(this._captureListeners), this._captureListenersSet.clear(), C32.clearArray(this._listeners), this._listenersSet.clear(), C32.clearArray(this._queueModifyListeners), C32.Release(this));\n    }\n    _AddListener(e, t) {\n      this._IsFiring() ? this._queueModifyListeners.push({ op: \"add\", func: e, capture: t }) : t ? this._captureListenersSet.has(e) || (this._captureListeners.push(e), this._captureListenersSet.add(e)) : this._listenersSet.has(e) || (this._listeners.push(e), this._listenersSet.add(e));\n    }\n    _RemoveListener(e, t) {\n      this._IsFiring() ? this._queueModifyListeners.push({ op: \"remove\", func: e, capture: t }) : t ? this._captureListenersSet.has(e) && (this._captureListenersSet.delete(e), C32.arrayFindRemove(this._captureListeners, e)) : this._listenersSet.has(e) && (this._listenersSet.delete(e), C32.arrayFindRemove(this._listeners, e));\n    }\n    _IsEmpty() {\n      return !this._captureListeners.length && !this._listeners.length;\n    }\n    _IsFiring() {\n      return 0 < this._fireDepth;\n    }\n    _ProcessQueuedListeners() {\n      const e = /* @__PURE__ */ new Set(), t = /* @__PURE__ */ new Set();\n      for (const s of this._queueModifyListeners) if (\"add\" === s.op) this._AddListener(s.func, s.capture), (s.capture ? t : e).delete(s.func);\n      else {\n        if (\"remove\" !== s.op) throw new Error(\"invalid op\");\n        (s.capture ? (this._captureListenersSet.delete(s.func), t) : (this._listenersSet.delete(s.func), e)).add(s.func);\n      }\n      C32.arrayRemoveAllInSet(this._listeners, e), C32.arrayRemoveAllInSet(this._captureListeners, t), C32.clearArray(this._queueModifyListeners);\n    }\n    _FireCancellable(s) {\n      this._IncreaseFireDepth();\n      let r = false;\n      for (let e = 0, t = this._captureListeners.length; e < t; ++e) if (this._captureListeners[e](s), s.propagationStopped) {\n        r = true;\n        break;\n      }\n      if (!r) for (let e = 0, t = this._listeners.length; e < t && (this._listeners[e](s), !s.propagationStopped); ++e) ;\n      return this._DecreaseFireDepth(), !s.defaultPrevented;\n    }\n    _FireNonCancellable(s) {\n      this._IncreaseFireDepth();\n      for (let e = 0, t = this._captureListeners.length; e < t; ++e) this._captureListeners[e](s);\n      for (let e = 0, t = this._listeners.length; e < t; ++e) this._listeners[e](s);\n      return this._DecreaseFireDepth(), true;\n    }\n    _IncreaseFireDepth() {\n      this._fireDepth++;\n    }\n    _DecreaseFireDepth() {\n      this._fireDepth--, 0 === this._fireDepth && 0 < this._queueModifyListeners.length && this._ProcessQueuedListeners();\n    }\n    SetDelayRemoveEventsEnabled(e) {\n      e ? this._IncreaseFireDepth() : this._DecreaseFireDepth();\n    }\n    _FireAsync(s) {\n      let r = [];\n      for (let t = 0, e = this._captureListeners.length; t < e; ++t) {\n        let e2 = this._captureListeners[t];\n        r.push(C32.Asyncify(() => e2(s)));\n      }\n      for (let t = 0, e = this._listeners.length; t < e; ++t) {\n        let e2 = this._listeners[t];\n        r.push(C32.Asyncify(() => e2(s)));\n      }\n      return Promise.all(r).then(() => !s.defaultPrevented);\n    }\n    _FireAndWait_AsyncOptional(s) {\n      const r = [];\n      this._IncreaseFireDepth();\n      for (let e = 0, t = this._captureListeners.length; e < t; ++e) {\n        const i = this._captureListeners[e](s);\n        i instanceof Promise && r.push(i);\n      }\n      for (let e = 0, t = this._listeners.length; e < t; ++e) {\n        const n = this._listeners[e](s);\n        n instanceof Promise && r.push(n);\n      }\n      return this._DecreaseFireDepth(), r.length ? Promise.all(r).then(() => !s.defaultPrevented) : !s.defaultPrevented;\n    }\n    async _FireAndWaitAsync(e) {\n      return this._FireAndWait_AsyncOptional(e);\n    }\n    async _FireAndWaitAsyncSequential(s) {\n      this._IncreaseFireDepth();\n      for (let e = 0, t = this._captureListeners.length; e < t; ++e) {\n        const r = this._captureListeners[e](s);\n        r instanceof Promise && await r;\n      }\n      for (let e = 0, t = this._listeners.length; e < t; ++e) {\n        const i = this._listeners[e](s);\n        i instanceof Promise && await i;\n      }\n      return this._DecreaseFireDepth(), !s.defaultPrevented;\n    }\n    *_FireAsGenerator(s) {\n      this._IncreaseFireDepth();\n      for (let e = 0, t = this._captureListeners.length; e < t; ++e) {\n        const r = this._captureListeners[e](s);\n        C32.IsIterator(r) && (yield* r);\n      }\n      for (let e = 0, t = this._listeners.length; e < t; ++e) {\n        const i = this._listeners[e](s);\n        C32.IsIterator(i) && (yield* i);\n      }\n      this._DecreaseFireDepth();\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.Event.Dispatcher = class extends C32.DefendedBase {\n    constructor() {\n      super(), this._eventHandlers = /* @__PURE__ */ new Map(), this._dispatcherWasReleased = false;\n    }\n    Release() {\n      if (this._dispatcherWasReleased) throw new Error(\"already released\");\n      this.ClearEvents(), this._dispatcherWasReleased = true, C32.Release(this);\n    }\n    WasReleased() {\n      return this._dispatcherWasReleased;\n    }\n    ClearEvents() {\n      if (this._eventHandlers) {\n        for (let e of this._eventHandlers.values()) e.Release();\n        this._eventHandlers.clear();\n      }\n    }\n    _GetHandlerByType(e, t) {\n      let n = this._eventHandlers.get(e);\n      return n || (t ? (n = C32.New(C32.Event.Handler, e), this._eventHandlers.set(e, n), n) : null);\n    }\n    HasAnyHandlerFor(e) {\n      return this._eventHandlers.has(e);\n    }\n    addEventListener(e, t, n) {\n      let s = this._GetHandlerByType(e, true);\n      s._AddListener(t, !!n);\n    }\n    removeEventListener(e, t, n) {\n      let s = this._GetHandlerByType(e, false);\n      s && (s._RemoveListener(t, !!n), s._IsEmpty()) && this._eventHandlers.delete(e);\n    }\n    dispatchEvent(e) {\n      const t = this._GetHandlerByType(e.type, false);\n      return !t || (e.cancelable ? t._FireCancellable(e) : t._FireNonCancellable(e));\n    }\n    dispatchEventAsync(e) {\n      const t = this._GetHandlerByType(e.type, false);\n      return t ? (e.isAsync = true, t._FireAsync(e)) : Promise.resolve(true);\n    }\n    async dispatchEventAndClearAsync(e) {\n      const t = this._GetHandlerByType(e.type, false);\n      if (!t) return true;\n      this._eventHandlers.delete(e.type), e.isAsync = true;\n      const n = await t._FireAsync(e);\n      return t.Release(), n;\n    }\n    async dispatchEventAndWaitAsync(e) {\n      const t = this._GetHandlerByType(e.type, false);\n      return !t || t._FireAndWaitAsync(e);\n    }\n    dispatchEventAndWait_AsyncOptional(e) {\n      const t = this._GetHandlerByType(e.type, false);\n      return !t || t._FireAndWait_AsyncOptional(e);\n    }\n    async dispatchEventAndWaitAsyncSequential(e) {\n      const t = this._GetHandlerByType(e.type, false);\n      return !t || t._FireAndWaitAsyncSequential(e);\n    }\n    dispatchGeneratorEvent(e) {\n      const t = this._GetHandlerByType(e.type, false);\n      if (!t) return null;\n      if (e.cancelable) throw new Error(\"not supported\");\n      return t._FireAsGenerator(e);\n    }\n    SetDelayRemoveEventsEnabled(e) {\n      for (const t of this._eventHandlers.values()) t.SetDelayRemoveEventsEnabled(e);\n    }\n  };\n}\n{\n  let SetNewCallback = function(e) {\n    callbackId = SUPPORTS_RIC && 0 === highThroughputMode ? requestIdleCallback(DoAsyncifiedWork, { timeout: IDLECALLBACK_TIMEOUT }) : setTimeout(DoAsyncifiedWork, 0 < highThroughputMode ? 1 : e);\n  }, DoAsyncifiedWork = function(n) {\n    if (callbackId = -1, workQueue.length) {\n      let i = performance.now(), t = i, e = 0, o;\n      for (; DoNextAsyncifiedJob(workQueue.shift()), t = performance.now(), ++e, o = (t - i) / e * 1.1, workQueue.length && (SUPPORTS_RIC && 0 === highThroughputMode && void 0 !== n ? o < n[\"timeRemaining\"]() : t - i + o < SETTIMEOUT_WORK_DURATION); ) ;\n      if (-1 === callbackId && workQueue.length) {\n        let e2 = t - i, o2 = Math.max(SETTIMEOUT_INTERVAL - e2, 4);\n        SetNewCallback(o2);\n      }\n    }\n  }, DoNextAsyncifiedJob = function(o) {\n    let e;\n    try {\n      e = o.func();\n    } catch (e2) {\n      return void o.reject(e2);\n    }\n    o.resolve(e);\n  };\n  SetNewCallback2 = SetNewCallback, DoAsyncifiedWork2 = DoAsyncifiedWork, DoNextAsyncifiedJob2 = DoNextAsyncifiedJob;\n  const C32 = self.C3, SETTIMEOUT_WORK_DURATION = 12, SETTIMEOUT_INTERVAL = 16, IDLECALLBACK_TIMEOUT = 35, SUPPORTS_RIC = \"undefined\" != typeof requestIdleCallback;\n  let workQueue = [], callbackId = -1, highThroughputMode = 0;\n  let asyncifyDisabled = C32.QueryString.Has(\"disable-asyncify\");\n  asyncifyDisabled && console.warn(\"[Asyncify] Asyncify has been disabled due to disable-asyncify in the query string. Some work will now be done synchronously.\"), C32.Asyncify = function(i) {\n    let t = null;\n    return C32.isDebug && (t = C32.GetCallStack()), new Promise((e, o) => {\n      workQueue.push({ func: i, resolve: e, reject: o, stack: t }), asyncifyDisabled ? DoNextAsyncifiedJob(workQueue.pop()) : -1 === callbackId && SetNewCallback(SETTIMEOUT_INTERVAL);\n    });\n  }, C32.Asyncify.SetHighThroughputMode = function(e) {\n    if (e) ++highThroughputMode;\n    else if (--highThroughputMode < 0) throw new Error(\"already turned off high throughput mode\");\n  };\n}\nvar SetNewCallback2;\nvar DoAsyncifiedWork2;\nvar DoNextAsyncifiedJob2;\n{\n  let ClearTimeCache = function() {\n    cachedNowTime = -1;\n  }, CheckActiveIdleTimeouts = function() {\n    timerId = -1, nextDeadline = -1;\n    let i = Date.now();\n    for (let t of activeIdleTimeouts) if (t._CheckTimeout(i)) {\n      let e = t._GetDeadline();\n      (-1 === nextDeadline || e < nextDeadline) && (nextDeadline = e);\n    } else activeIdleTimeouts.delete(t);\n    if (-1 !== nextDeadline) {\n      let e = Math.max(nextDeadline - i + IDLE_CHECK_TIMER_OVERSHOOT, IDLE_CHECK_MIN_INTERVAL);\n      timerId = self.setTimeout(CheckActiveIdleTimeouts, e);\n    }\n  };\n  ClearTimeCache2 = ClearTimeCache, CheckActiveIdleTimeouts2 = CheckActiveIdleTimeouts;\n  const C32 = self.C3, IDLE_CHECK_MIN_INTERVAL = 1e3, IDLE_CHECK_TIMER_OVERSHOOT = 100;\n  let cachedNowTime = -1;\n  C32.FastGetDateNow = function() {\n    return -1 === cachedNowTime && (cachedNowTime = Date.now(), self.setTimeout(ClearTimeCache, 16)), cachedNowTime;\n  };\n  let timerId = -1, nextDeadline = -1, activeIdleTimeouts = /* @__PURE__ */ new Set();\n  C32.IdleTimeout = class {\n    constructor(e, t) {\n      this._callback = e, this._timeout = 1e3 * t, this._deadline = 0, this._isActive = false;\n    }\n    Reset() {\n      let e = C32.FastGetDateNow();\n      this._deadline = e + this._timeout, this._isActive || (activeIdleTimeouts.add(this), this._isActive = true), -1 === timerId ? (nextDeadline = this._deadline, timerId = self.setTimeout(CheckActiveIdleTimeouts, this._timeout + IDLE_CHECK_TIMER_OVERSHOOT)) : this._deadline < nextDeadline && nextDeadline > e + IDLE_CHECK_MIN_INTERVAL && (self.clearTimeout(timerId), nextDeadline = this._deadline, timerId = self.setTimeout(CheckActiveIdleTimeouts, this._timeout + IDLE_CHECK_TIMER_OVERSHOOT));\n    }\n    _CheckTimeout(e) {\n      return !(e >= this._deadline) || (this._callback() ? (this._deadline = e + this._timeout, true) : this._isActive = false);\n    }\n    _GetDeadline() {\n      return this._deadline;\n    }\n    Cancel() {\n      this._isActive && (activeIdleTimeouts.delete(this), this._isActive = false, 0 === activeIdleTimeouts.size) && -1 !== timerId && (self.clearTimeout(timerId), timerId = -1, nextDeadline = -1);\n    }\n    Release() {\n      this.Cancel(), this._callback = null;\n    }\n  };\n}\nvar ClearTimeCache2;\nvar CheckActiveIdleTimeouts2;\n{\n  const C32 = self.C3;\n  C32.Disposable = class a {\n    constructor(s) {\n      this._disposed = false, this._disposeAction = s;\n    }\n    Dispose() {\n      this._disposed || (this._disposed = true, this._disposeAction && (this._disposeAction(), this._disposeAction = null));\n    }\n    IsDisposed() {\n      return this._disposed;\n    }\n    Release() {\n      this.Dispose();\n    }\n    static Release(s) {\n      return new a(() => s.Release());\n    }\n    static From(e, i, o, t, s) {\n      if (null == t) t = false;\n      else if (\"boolean\" != typeof t && \"object\" != typeof t) throw new TypeError(\"invalid event listener options\");\n      if (s && (o = o.bind(s)), i.includes(\" \")) {\n        i = i.split(\" \");\n        const d = new C32.CompositeDisposable();\n        for (let s2 of i) e.addEventListener(s2, o, t), d.Add(C32.New(C32.Disposable, () => e.removeEventListener(s2, o, t)));\n        return d;\n      }\n      return e.addEventListener(i, o, t), C32.New(C32.Disposable, () => e.removeEventListener(i, o, t));\n    }\n  }, C32.StubDisposable = class extends C32.Disposable {\n    SetAction(s) {\n      this._disposeAction = s;\n    }\n  }, C32.CompositeDisposable = class extends C32.Disposable {\n    constructor(...e) {\n      super(), this._disposables = /* @__PURE__ */ new Set();\n      for (let s of e) this.Add(s);\n    }\n    Add(...e) {\n      if (this._disposed) throw new Error(\"already disposed\");\n      for (let s of e) this._disposables.add(s);\n    }\n    Remove(s) {\n      if (this._disposed) throw new Error(\"already disposed\");\n      this._disposables.delete(s);\n    }\n    RemoveAll() {\n      if (this._disposed) throw new Error(\"already disposed\");\n      if (this._disposables) {\n        for (let s of this._disposables) s.Dispose();\n        this._disposables.clear();\n      }\n    }\n    IsDisposed() {\n      return this._disposed;\n    }\n    Dispose() {\n      if (this._disposed) throw new Error(\"already disposed\");\n      this._disposed = true;\n      for (let s of this._disposables) s.Dispose();\n      this._disposables.clear(), this._disposables = null;\n    }\n    Release() {\n      this.Dispose();\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.KahanSum = class extends C32.DefendedBase {\n    constructor() {\n      super(), this._c = 0, this._y = 0, this._t = 0, this._sum = 0;\n    }\n    Add(s) {\n      this._y = (s = +s) - this._c, this._t = this._sum + this._y, this._c = this._t - this._sum - this._y, this._sum = this._t;\n    }\n    Subtract(s) {\n      this._sum -= +s;\n    }\n    Get() {\n      return this._sum;\n    }\n    Reset() {\n      this._c = 0, this._y = 0, this._t = 0, this._sum = 0;\n    }\n    Set(s) {\n      this._c = 0, this._y = 0, this._t = 0, this._sum = +s;\n    }\n    Copy(s) {\n      this._c = s._c, this._y = s._y, this._t = s._t, this._sum = s._sum;\n    }\n    Release() {\n    }\n  };\n}\n{\n  const C32 = self.C3, js_cols = {}, RED = true, BLACK = false;\n  js_cols.RBnode = function(t) {\n    this.tree = t, this.right = this.tree.sentinel, this.left = this.tree.sentinel, this.parent = null, this.color = false, this.key = null;\n  }, js_cols.RedBlackSet = function(t) {\n    this.size = 0, this.sentinel = new js_cols.RBnode(this), this.sentinel.color = BLACK, this.root = this.sentinel, this.root.parent = this.sentinel, this.compare = t || this.default_compare;\n  }, js_cols.RedBlackSet.prototype.default_compare = function(t, e) {\n    return t < e ? -1 : e < t ? 1 : 0;\n  }, js_cols.RedBlackSet.prototype.clone = function() {\n    var t = new js_cols.RedBlackSet(this.compare);\n    return t.insertAll(this), t;\n  }, js_cols.RedBlackSet.prototype.clear = function() {\n    this.size = 0, this.sentinel = new js_cols.RBnode(this), this.sentinel.color = BLACK, this.root = this.sentinel, this.root.parent = this.sentinel;\n  }, js_cols.RedBlackSet.prototype.leftRotate = function(t) {\n    var e = t.right;\n    t.right = e.left, e.left != this.sentinel && (e.left.parent = t), e.parent = t.parent, t.parent == this.sentinel ? this.root = e : t == t.parent.left ? t.parent.left = e : t.parent.right = e, (e.left = t).parent = e;\n  }, js_cols.RedBlackSet.prototype.rightRotate = function(t) {\n    var e = t.left;\n    t.left = e.right, e.right != this.sentinel && (e.right.parent = t), e.parent = t.parent, t.parent == this.sentinel ? this.root = e : t == t.parent.right ? t.parent.right = e : t.parent.left = e, (e.right = t).parent = e;\n  }, js_cols.RedBlackSet.prototype.insert = function(t) {\n    if (this.contains(t)) this.get_(t).key = t;\n    else {\n      for (var e = new js_cols.RBnode(this), s = (e.key = t, this.sentinel), r = this.root; r != this.sentinel; ) s = r, r = this.compare(e.key, r.key) < 0 ? r.left : r.right;\n      (e.parent = s) == this.sentinel ? this.root = e : this.compare(e.key, s.key) < 0 ? s.left = e : s.right = e, e.left = this.sentinel, e.right = this.sentinel, e.color = RED, this.insertFixup(e), this.size++;\n    }\n  }, js_cols.RedBlackSet.prototype.insertFixup = function(t) {\n    for (; t != this.sentinel && t != this.root && t.parent.color == RED; ) {\n      var e;\n      t.parent == t.parent.parent.left ? (e = t.parent.parent.right).color == RED ? (t.parent.color = BLACK, e.color = BLACK, t.parent.parent.color = RED, t = t.parent.parent) : (t == t.parent.right && (t = t.parent, this.leftRotate(t)), t.parent.color = BLACK, t.parent.parent.color = RED, t.parent.parent != this.sentinel && this.rightRotate(t.parent.parent)) : (e = t.parent.parent.left).color == RED ? (t.parent.color = BLACK, e.color = BLACK, t.parent.parent.color = RED, t = t.parent.parent) : (t == t.parent.left && (t = t.parent, this.rightRotate(t)), t.parent.color = BLACK, t.parent.parent.color = RED, t.parent.parent != this.sentinel && this.leftRotate(t.parent.parent));\n    }\n    this.root.color = BLACK;\n  }, js_cols.RedBlackSet.prototype.delete_ = function(t) {\n    var e = t.left == this.sentinel || t.right == this.sentinel ? t : this.successor_(t), s = e.left != this.sentinel ? e.left : e.right;\n    s.parent = e.parent, e.parent == this.sentinel ? this.root = s : e == e.parent.left ? e.parent.left = s : e.parent.right = s, e != t && (t.key = e.key), e.color == BLACK && this.deleteFixup(s), this.size--;\n  }, js_cols.RedBlackSet.prototype.deleteFixup = function(t) {\n    for (; t != this.root && t.color == BLACK; ) {\n      var e;\n      t = t == t.parent.left ? ((e = t.parent.right).color == RED && (e.color = BLACK, t.parent.color = RED, this.leftRotate(t.parent), e = t.parent.right), e.left.color == BLACK && e.right.color == BLACK ? (e.color = RED, t.parent) : (e.right.color == BLACK && (e.left.color = BLACK, e.color = RED, this.rightRotate(e), e = t.parent.right), e.color = t.parent.color, t.parent.color = BLACK, e.right.color = BLACK, this.leftRotate(t.parent), this.root)) : ((e = t.parent.left).color == RED && (e.color = BLACK, t.parent.color = RED, this.rightRotate(t.parent), e = t.parent.left), e.right.color == BLACK && e.left.color == BLACK ? (e.color = RED, t.parent) : (e.left.color == BLACK && (e.right.color = BLACK, e.color = RED, this.leftRotate(e), e = t.parent.left), e.color = t.parent.color, t.parent.color = BLACK, e.left.color = BLACK, this.rightRotate(t.parent), this.root));\n    }\n    t.color = BLACK;\n  }, js_cols.RedBlackSet.prototype.remove = function(t) {\n    var e, t = this.get_(t);\n    return t != this.sentinel ? (e = t.key, this.delete_(t), e) : null;\n  }, js_cols.RedBlackSet.prototype.removeSwapped = function(t, e) {\n    this.remove(e);\n  }, js_cols.RedBlackSet.prototype.min = function(t) {\n    for (; t.left != this.sentinel; ) t = t.left;\n    return t;\n  }, js_cols.RedBlackSet.prototype.max = function(t) {\n    for (; t.right != this.sentinel; ) t = t.right;\n    return t;\n  }, js_cols.RedBlackSet.prototype.successor_ = function(t) {\n    if (t.right != this.sentinel) return this.min(t.right);\n    for (var e = t.parent; e != this.sentinel && t == e.right; ) e = (t = e).parent;\n    return e;\n  }, js_cols.RedBlackSet.prototype.predeccessor_ = function(t) {\n    if (t.left != this.sentinel) return this.max(t.left);\n    for (var e = t.parent; e != this.sentinel && t == e.left; ) e = (t = e).parent;\n    return e;\n  }, js_cols.RedBlackSet.prototype.successor = function(t) {\n    if (0 < this.size) {\n      var e = this.get_(t);\n      if (e == this.sentinel) return null;\n      if (e.right != this.sentinel) return this.min(e.right).key;\n      for (var s = e.parent; s != this.sentinel && e == s.right; ) s = (e = s).parent;\n      return s != this.sentinel ? s.key : null;\n    }\n    return null;\n  }, js_cols.RedBlackSet.prototype.predecessor = function(t) {\n    if (0 < this.size) {\n      var e = this.get_(t);\n      if (e == this.sentinel) return null;\n      if (e.left != this.sentinel) return this.max(e.left).key;\n      for (var s = e.parent; s != this.sentinel && e == s.left; ) s = (e = s).parent;\n      return s != this.sentinel ? s.key : null;\n    }\n    return null;\n  }, js_cols.RedBlackSet.prototype.getMin = function() {\n    return this.min(this.root).key;\n  }, js_cols.RedBlackSet.prototype.getMax = function() {\n    return this.max(this.root).key;\n  }, js_cols.RedBlackSet.prototype.get_ = function(t) {\n    for (var e = this.root; e != this.sentinel && 0 != this.compare(e.key, t); ) e = this.compare(t, e.key) < 0 ? e.left : e.right;\n    return e;\n  }, js_cols.RedBlackSet.prototype.contains = function(t) {\n    return null != this.get_(t).key;\n  }, js_cols.RedBlackSet.prototype.getValues = function() {\n    var e = [];\n    return this.forEach(function(t) {\n      e.push(t);\n    }), e;\n  }, js_cols.RedBlackSet.prototype.insertAll = function(t) {\n    if (\"array\" == js_cols.typeOf(t)) for (var e = 0; e < t.length; e++) this.insert(t[e]);\n    else if (\"function\" == js_cols.typeOf(t.forEach)) t.forEach(this.insert, this);\n    else if (\"function\" == js_cols.typeOf(t.getValues)) for (var s = t.getValues(), e = 0; e < s.length; e++) this.insert(s[e]);\n    else if (\"object\" == js_cols.typeOf(t)) for (var r in t) this.insert(t[r]);\n  }, js_cols.RedBlackSet.prototype.removeAll = function(t) {\n    if (\"array\" == js_cols.typeOf(t)) for (var e = 0; e < t.length; e++) this.remove(t[e]);\n    else if (\"function\" == js_cols.typeOf(t.forEach)) t.forEach(this.removeSwapped, this);\n    else if (\"function\" == js_cols.typeOf(t.getValues)) for (var s = t.getValues(), e = 0; e < s.length; e++) this.remove(s[e]);\n    else if (\"object\" == js_cols.typeOf(t)) for (var r in t) this.remove(t[r]);\n  }, js_cols.RedBlackSet.prototype.containsAll = function(t) {\n    if (\"array\" == js_cols.typeOf(t)) {\n      for (var e = 0; e < t.length; e++) if (!this.contains(t[e])) return false;\n      return true;\n    }\n    if (\"function\" == js_cols.typeOf(t.forEach)) return t.every(this.contains, this);\n    if (\"function\" == js_cols.typeOf(t.getValues)) {\n      for (var s = t.getValues(), e = 0; e < s.length; e++) if (!this.contains(s[e])) return false;\n      return true;\n    }\n    if (\"object\" == js_cols.typeOf(t)) {\n      for (var r in t) if (!this.contains(t[r])) return false;\n      return true;\n    }\n  }, js_cols.RedBlackSet.prototype.range = function(t, e) {\n    var s = [];\n    return this.traverseFromTo(function(t2) {\n      s.push(t2);\n    }, t, e), s;\n  }, js_cols.RedBlackSet.prototype.traverse = function(t, e) {\n    if (!this.isEmpty()) for (var s = this.min(this.root); s != this.sentinel; ) {\n      if (t.call(e, s.key, this)) return;\n      s = this.successor_(s);\n    }\n  }, js_cols.RedBlackSet.prototype.traverseFrom = function(t, e, s) {\n    if (!this.isEmpty()) for (var r = this.get_(e); r != this.sentinel; ) {\n      if (t.call(s, r.key, this)) return;\n      r = this.successor_(r);\n    }\n  }, js_cols.RedBlackSet.prototype.traverseTo = function(t, e, s) {\n    if (!this.isEmpty()) for (var r = this.min(this.root), i = this.get_(e); r != i; ) {\n      if (t.call(s, r.key, this)) return;\n      r = this.successor_(r);\n    }\n  }, js_cols.RedBlackSet.prototype.traverseFromTo = function(t, e, s, r) {\n    if (!this.isEmpty()) for (var i = this.get_(e), o = this.get_(s); i != o; ) {\n      if (t.call(r, i.key, this)) return;\n      i = this.successor_(i);\n    }\n  }, js_cols.RedBlackSet.prototype.traverseBackwards = function(t, e) {\n    if (!this.isEmpty()) for (var s = this.max(this.root); s != this.sentinel; ) {\n      if (t.call(e, s.key, this)) return;\n      s = this.predeccessor_(s);\n    }\n  }, js_cols.RedBlackSet.prototype.forEach = function(t, e) {\n    if (!this.isEmpty()) for (var s = this.min(this.root); s != this.sentinel; s = this.successor_(s)) t.call(e, s.key, s.key, this);\n  }, js_cols.RedBlackSet.prototype.some = function(t, e) {\n    if (!this.isEmpty()) {\n      for (var s = this.min(this.root); s != this.sentinel; s = this.successor_(s)) if (t.call(e, s.key, s.key, this)) return true;\n    }\n    return false;\n  }, js_cols.RedBlackSet.prototype.every = function(t, e) {\n    if (this.isEmpty()) return false;\n    for (var s = this.min(this.root); s != this.sentinel; s = this.successor_(s)) if (!t.call(e, s.key, s.key, this)) return false;\n    return true;\n  }, js_cols.RedBlackSet.prototype.map = function(t, e) {\n    var s = [];\n    if (!this.isEmpty()) for (var r = this.min(this.root); r != this.sentinel; r = this.successor_(r)) s.push(t.call(e, r.key, r.key, this));\n    return s;\n  }, js_cols.RedBlackSet.prototype.filter = function(t, e) {\n    var s = [];\n    if (!this.isEmpty()) for (var r = this.min(this.root); r != this.sentinel; r = this.successor_(r)) t.call(e, r.key, r.key, this) && s.push(r.key);\n    return s;\n  }, js_cols.RedBlackSet.prototype.getCount = function() {\n    return this.size;\n  }, js_cols.RedBlackSet.prototype.isEmpty = function() {\n    return 0 == this.size;\n  }, js_cols.RedBlackSet.prototype.isSubsetOf = function(t) {\n    var e = js_cols.getCount(t);\n    if (this.getCount() > e) return false;\n    var s = 0;\n    if (this.isEmpty()) return true;\n    for (var r = this.min(this.root); r != this.sentinel; r = this.successor_(r)) js_cols.contains.call(t, t, r.key) && s++;\n    return s == this.getCount();\n  }, js_cols.RedBlackSet.prototype.intersection = function(t) {\n    var e = new js_cols.RedBlackSet(this.compare);\n    if (!this.isEmpty()) for (var s = this.min(this.root); s != this.sentinel; s = this.successor_(s)) t.contains.call(t, s.key, s.key, this) && e.insert(s.key);\n    return e;\n  }, C32.RedBlackSet = class extends C32.DefendedBase {\n    constructor(t) {\n      super(), this._rbSet = new js_cols.RedBlackSet(t), this._enableQueue = false, this._queueInsert = /* @__PURE__ */ new Set(), this._queueRemove = /* @__PURE__ */ new Set();\n    }\n    Add(t) {\n      this._enableQueue ? this._rbSet.contains(t) ? this._queueRemove.delete(t) : this._queueInsert.add(t) : this._rbSet.insert(t);\n    }\n    Remove(t) {\n      this._enableQueue ? this._rbSet.contains(t) ? this._queueRemove.add(t) : this._queueInsert.delete(t) : this._rbSet.remove(t);\n    }\n    Has(t) {\n      return this._enableQueue ? !!this._queueInsert.has(t) || !this._queueRemove.has(t) && this._rbSet.contains(t) : this._rbSet.contains(t);\n    }\n    Clear() {\n      this._rbSet.clear(), this._queueInsert.clear(), this._queueRemove.clear();\n    }\n    toArray() {\n      if (this._enableQueue) throw new Error(\"cannot be used in queueing mode\");\n      return this._rbSet.getValues();\n    }\n    GetSize() {\n      return this._rbSet.getCount() + this._queueInsert.size - this._queueRemove.size;\n    }\n    IsEmpty() {\n      return 0 === this.GetSize();\n    }\n    Front() {\n      if (this.IsEmpty()) throw new Error(\"empty set\");\n      if (this._enableQueue) throw new Error(\"cannot be used in queueing mode\");\n      const t = this._rbSet, e = t.min(t.root);\n      return e.key;\n    }\n    Shift() {\n      if (this.IsEmpty()) throw new Error(\"empty set\");\n      if (this._enableQueue) throw new Error(\"cannot be used in queueing mode\");\n      const t = this.Front();\n      return this.Remove(t), t;\n    }\n    SetQueueingEnabled(t) {\n      if (this._enableQueue !== (t = !!t) && !(this._enableQueue = t)) {\n        for (const e of this._queueRemove) this._rbSet.remove(e);\n        this._queueRemove.clear();\n        for (const s of this._queueInsert) this._rbSet.insert(s);\n        this._queueInsert.clear();\n      }\n    }\n    ForEach(t) {\n      this._rbSet.forEach(t);\n    }\n    *values() {\n      if (!this.IsEmpty()) {\n        const e = this._rbSet;\n        for (let t = e.min(e.root); t != e.sentinel; t = e.successor_(t)) yield t.key;\n      }\n    }\n    [Symbol.iterator]() {\n      return this.values();\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.PromiseThrottle = class {\n    constructor(e = C32.hardwareConcurrency) {\n      this._maxParallel = e, this._queue = [], this._activeCount = 0;\n    }\n    Add(s) {\n      return new Promise((e, t) => {\n        this._queue.push({ func: s, resolve: e, reject: t }), this._MaybeStartNext();\n      });\n    }\n    _FindInQueue(s) {\n      for (let e = 0, t = this._queue.length; e < t; ++e) if (this._queue[e].func === s) return e;\n      return -1;\n    }\n    RemoveAndResolve(e, t) {\n      const s = this._FindInQueue(e);\n      if (-1 === s) throw new Error(\"cannot find promise to resolve\");\n      this._queue[s].resolve(t), this._queue.splice(s, 1);\n    }\n    RemoveAndReject(e, t) {\n      const s = this._FindInQueue(e);\n      if (-1 === s) throw new Error(\"cannot find promise to reject\");\n      this._queue[s].reject(t), this._queue.splice(s, 1);\n    }\n    async _MaybeStartNext() {\n      if (this._queue.length && !(this._activeCount >= this._maxParallel)) {\n        this._activeCount++;\n        const t = this._queue.shift();\n        try {\n          const e = await t.func();\n          t.resolve(e);\n        } catch (e) {\n          t.reject(e);\n        }\n        this._activeCount--, this._MaybeStartNext();\n      }\n    }\n    static async Batch(e, t) {\n      const s = [];\n      let r = false;\n      const i = [];\n      for (; e--; ) i.push((async () => {\n        let e2;\n        for (; e2 = t.pop(); ) {\n          if (r) return;\n          try {\n            s.push(await e2());\n          } catch (e3) {\n            throw r = true, e3;\n          }\n        }\n      })());\n      return await Promise.all(i), s;\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.RateLimiter = class {\n    constructor(t, e, i) {\n      this._callback = t, this._interval = e, this._intervalOnBattery = i || 2 * e, this._timerId = -1, this._lastCallTime = -1 / 0, this._timerCallFunc = () => this._OnTimer(), this._ignoreReset = false, this._canRunImmediate = false, this._callbackArguments = null;\n    }\n    SetCanRunImmediate(t) {\n      this._canRunImmediate = !!t;\n    }\n    _GetInterval() {\n      return void 0 !== C32.Battery && C32.Battery.IsOnBatteryPower() ? this._intervalOnBattery : this._interval;\n    }\n    Call(...l) {\n      if (-1 === this._timerId) {\n        this._callbackArguments = l;\n        let t = C32.FastGetDateNow(), e = t - this._lastCallTime, i = this._GetInterval();\n        i <= e && this._canRunImmediate ? (this._lastCallTime = t, this._RunCallback()) : this._timerId = self.setTimeout(this._timerCallFunc, Math.max(i - e, 4));\n      }\n    }\n    _RunCallback() {\n      this._ignoreReset = true;\n      const t = this._callbackArguments;\n      this._callbackArguments = null, t ? this._callback(...t) : this._callback(), this._ignoreReset = false;\n    }\n    Reset() {\n      this._ignoreReset || (this._CancelTimer(), this._callbackArguments = null, this._lastCallTime = C32.FastGetDateNow());\n    }\n    _OnTimer() {\n      this._timerId = -1, this._lastCallTime = C32.FastGetDateNow(), this._RunCallback();\n    }\n    _CancelTimer() {\n      -1 !== this._timerId && (self.clearTimeout(this._timerId), this._timerId = -1);\n    }\n    Release() {\n      this._CancelTimer(), this._callback = null, this._callbackArguments = null, this._timerCallFunc = null;\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.SVGRasterManager = class {\n    constructor() {\n      this._images = /* @__PURE__ */ new Map(), this._allowNpotSurfaces = false, this._getBaseSizeCallback = null, this._rasterAtSizeCallback = null, this._releaseResultCallback = null, this._redrawCallback = null;\n    }\n    SetNpotSurfaceAllowed(e) {\n      this._allowNpotSurfaces = !!e;\n    }\n    IsNpotSurfaceAllowed() {\n      return this._allowNpotSurfaces;\n    }\n    SetGetBaseSizeCallback(e) {\n      this._getBaseSizeCallback = e;\n    }\n    GetBaseSize(e) {\n      if (this._getBaseSizeCallback) return this._getBaseSizeCallback(e);\n      throw new Error(\"no get base size callback set\");\n    }\n    SetRasterAtSizeCallback(e) {\n      this._rasterAtSizeCallback = e;\n    }\n    RasterAtSize(e, a, t, l, s, r) {\n      if (this._rasterAtSizeCallback) return this._rasterAtSizeCallback(e, a, t, l, s, r);\n      throw new Error(\"no raster at size callback set\");\n    }\n    SetReleaseResultCallback(e) {\n      this._releaseResultCallback = e;\n    }\n    ReleaseResult(e) {\n      if (!this._releaseResultCallback) throw new Error(\"no release result callback set\");\n      this._releaseResultCallback(e);\n    }\n    SetRedrawCallback(e) {\n      this._redrawCallback = e;\n    }\n    Redraw() {\n      if (!this._redrawCallback) throw new Error(\"no redraw callback set\");\n      this._redrawCallback();\n    }\n    AddImage(e) {\n      let a = this._images.get(e);\n      return a || (a = C32.New(C32.SVGRasterImage, this, e), this._images.set(e, a)), a.IncReference(), a;\n    }\n    _RemoveImage(e) {\n      this._images.delete(e.GetDataSource());\n    }\n    OnTexturesChanged() {\n      for (const e of this._images.values()) e.ReleaseRasterizedResult(), e.ForceRasterAgain();\n    }\n  };\n}\n{\n  const C32 = self.C3, MAX_SURFACE_SIZE = 4096;\n  C32.SVGRasterImage = class {\n    constructor(e, t) {\n      this._manager = e, this._dataSource = t, this._refCount = 0, this._baseWidth = 0, this._baseHeight = 0, this._getBaseSizePromise = this._manager.GetBaseSize(t).then((e2) => {\n        this._manager && (this._baseWidth = e2[0], this._baseHeight = e2[1], this._manager.Redraw());\n      }).catch((e2) => {\n        console.error(\"[SVG] Error loading SVG: \", e2), this._hadError = true, this._manager && this._manager.Redraw();\n      }), this._rasterSurfaceWidth = 0, this._rasterSurfaceHeight = 0, this._rasterImageWidth = 0, this._rasterImageHeight = 0, this._isRasterizing = false, this._rasterizedResult = null, this._forceRaster = false, this._hadError = false;\n    }\n    Release() {\n      if (this._refCount <= 0) throw new Error(\"already released\");\n      this._refCount--, 0 === this._refCount && this._Release();\n    }\n    ReleaseRasterizedResult() {\n      this._rasterizedResult && (this._manager.ReleaseResult(this._rasterizedResult), this._rasterizedResult = null);\n    }\n    _Release() {\n      this.ReleaseRasterizedResult(), this._manager._RemoveImage(this), this._manager = null;\n    }\n    GetDataSource() {\n      return this._dataSource;\n    }\n    IncReference() {\n      this._refCount++;\n    }\n    HasReferences() {\n      return 0 < this._refCount;\n    }\n    GetRasterizedResult() {\n      return this._rasterizedResult;\n    }\n    ForceRasterAgain() {\n      this._forceRaster = true;\n    }\n    async StartRasterForSize(s, r, a) {\n      if (0 !== r && 0 !== a && !this._hadError && !this._isRasterizing) {\n        let e = C32.nextHighestPowerOfTwo(Math.ceil(r)), t = C32.nextHighestPowerOfTwo(Math.ceil(a));\n        const i = Math.max(e, t);\n        if (i > MAX_SURFACE_SIZE) {\n          const h = MAX_SURFACE_SIZE / i;\n          r *= h, a *= h, e = Math.min(Math.ceil(e * h), MAX_SURFACE_SIZE), t = Math.min(Math.ceil(t * h), MAX_SURFACE_SIZE);\n        }\n        if (r < e && a < t) {\n          const _ = r / a, n = e / t;\n          a = _ < n ? (r = t * _, t) : (r = e) / _;\n        }\n        if (this._manager.IsNpotSurfaceAllowed() && (e = Math.ceil(r), t = Math.ceil(a)), !(e <= this._rasterSurfaceWidth && t <= this._rasterSurfaceHeight) || this._forceRaster) {\n          this._isRasterizing = true, this._rasterSurfaceWidth = e, this._rasterSurfaceHeight = t;\n          const R = await this._manager.RasterAtSize(this._dataSource, s, this._rasterSurfaceWidth, this._rasterSurfaceHeight, r, a);\n          this._manager && (this.ReleaseRasterizedResult(), this._rasterizedResult = R, this._rasterImageWidth = r, this._rasterImageHeight = a, this._isRasterizing = false, this._forceRaster = false, this._manager.Redraw());\n        }\n      }\n    }\n    WhenBaseSizeReady() {\n      return this._getBaseSizePromise;\n    }\n    GetBaseWidth() {\n      return this._baseWidth;\n    }\n    GetBaseHeight() {\n      return this._baseHeight;\n    }\n    GetRasterWidth() {\n      return this._rasterImageWidth;\n    }\n    GetRasterHeight() {\n      return this._rasterImageHeight;\n    }\n    HadError() {\n      return this._hadError;\n    }\n  };\n}\n{\n  let lookupHtmlEntity = function(t) {\n    return HTML_ENTITY_MAP.get(t);\n  };\n  lookupHtmlEntity2 = lookupHtmlEntity;\n  const C32 = self.C3, NUMERIC_CHARS = (C32.UTF8_BOM = \"\\uFEFF\", new Set(\"0123456789\")), WHITESPACE_CHARS = (C32.IsNumericChar = function(t) {\n    return NUMERIC_CHARS.has(t);\n  }, new Set(\" \t\\n\\r\\xA0\\x85\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u200B\\u2028\\u2029\\u202F\\u205F\\u3000\"));\n  C32.IsWhitespaceChar = function(t) {\n    return WHITESPACE_CHARS.has(t);\n  }, C32.FilterWhitespace = function(t) {\n    return [...t].filter((t2) => !C32.IsWhitespaceChar(t2)).join(\"\");\n  }, C32.IsStringAllWhitespace = function(t) {\n    for (const e of t) if (!C32.IsWhitespaceChar(e)) return false;\n    return true;\n  }, C32.IsCharArrayAllWhitespace = function(t) {\n    for (const e of t) if (!C32.IsWhitespaceChar(e)) return false;\n    return true;\n  }, C32.IsUnprintableChar = function(t) {\n    return 1 === t.length && t.charCodeAt(0) < 32;\n  }, C32.FilterUnprintableChars = function(t) {\n    return [...t].filter((t2) => !C32.IsUnprintableChar(t2)).join(\"\");\n  };\n  let cjkPunctuationRegex = null;\n  try {\n    cjkPunctuationRegex = new RegExp(\"\\\\p{P}(?<=[\\\\u3000-\\\\u303F\\\\uFF00-\\\\uFFEF])\", \"u\");\n  } catch (t) {\n    console.warn(\"Unable to detect CJK punctuation: \", t);\n  }\n  C32.IsCJKPunctuationChar = function(t) {\n    return !C32.IsWhitespaceChar(t) && cjkPunctuationRegex && cjkPunctuationRegex.test(t);\n  };\n  const NUMERIC_STRING_CHARS = new Set(\"0123456789.+-e\"), HTML_ENTITY_MAP = (C32.IsStringNumber = function(e) {\n    if (!(e = e.trim()).length) return false;\n    let t = e.charAt(0);\n    if (\"-\" !== t && !NUMERIC_CHARS.has(t)) return false;\n    for (let t2 of e) if (!NUMERIC_STRING_CHARS.has(t2)) return false;\n    return true;\n  }, C32.RemoveTrailingDigits = function(e) {\n    let n = e.length;\n    for (; 0 < n; ) {\n      let t = e.charAt(n - 1);\n      if (!C32.IsNumericChar(t)) break;\n      --n;\n    }\n    return e.substr(0, n);\n  }, C32.IncrementNumberAtEndOf = function(t) {\n    let e = C32.RemoveTrailingDigits(t), n = t.substr(e.length);\n    return e + (n = n ? (parseInt(n, 10) + 1).toString() : \"2\");\n  }, /* @__PURE__ */ new Map([[\"&\", \"&amp;\"], [\"<\", \"&lt;\"], [\">\", \"&gt;\"], ['\"', \"&quot;\"], [\"'\", \"&#39;\"]]));\n  const HTML_ENTITY_REGEX = /[&<>\"']/g, ESCAPE_REGEX = (C32.EscapeHTML = function(t) {\n    return t.replace(HTML_ENTITY_REGEX, lookupHtmlEntity);\n  }, C32.EscapeJS = function(t) {\n    let e = C32.ReplaceAll(t, \"\\\\\", \"\\\\\\\\\");\n    return e = C32.ReplaceAll(e, '\"', '\\\\\"'), e = C32.ReplaceAll(e, \"\t\", \"\\\\t\"), e = C32.ReplaceAll(e, \"\\r\", \"\"), C32.ReplaceAll(e, \"\\n\", \"\\\\n\");\n  }, C32.EscapeXML = function(t) {\n    let e = C32.ReplaceAll(t, \"&\", \"&amp;\");\n    return e = C32.ReplaceAll(e, \"<\", \"&lt;\"), e = C32.ReplaceAll(e, \">\", \"&gt;\"), C32.ReplaceAll(e, '\"', \"&quot;\");\n  }, /[-[\\]{}()*+?.,\\\\^$|#\\s]/g), intlSegmenter = (C32.EscapeRegex = function(t) {\n    return t.replace(ESCAPE_REGEX, \"\\\\$&\");\n  }, C32.CountCharsInString = function(t, e) {\n    let n = 0;\n    for (const r of t) r === e && ++n;\n    return n;\n  }, C32.FindAll = function(t, e, n = false) {\n    if (!e) return [];\n    n || (t = t.toLowerCase(), e = e.toLowerCase());\n    const r = e.length;\n    let o = 0, i, l = [];\n    for (; -1 < (i = t.indexOf(e, o)); ) l.push(i), o = i + r;\n    return l;\n  }, C32.ReplaceAll = function(t, e, n) {\n    return t.replaceAll(e, () => n);\n  }, C32.ReplaceAllCaseInsensitive = function(t, e, n) {\n    return t.replace(new RegExp(C32.EscapeRegex(e), \"gi\"), () => n);\n  }, C32.SetElementContent = function(t, e) {\n    \"string\" == typeof e ? t.textContent = e : e.isPlainText() ? t.textContent = e.toString() : (t.innerHTML = e.toHTML(), e instanceof C32.BBString && e.attachLinkHandlers(t));\n  }, C32.StringLikeEquals = function(t, e) {\n    return t instanceof C32.HtmlString || t instanceof C32.BBString ? t.equals(e) : e instanceof C32.HtmlString || e instanceof C32.BBString ? e.equals(t) : t === e;\n  }, C32.StringSubstitute = function(n, ...r) {\n    let o = n;\n    for (let t = 0, e = r.length; t < e; ++t) {\n      const i = `{${t}}`;\n      if (!n.includes(i)) throw new Error(`missing placeholder '${i}' in string substitution`);\n      o = o.replace(i, r[t].toString());\n    }\n    return o;\n  }, C32.StringSubstituteAllowMissing = function(n, ...r) {\n    let o = n, i = -1, l = -1;\n    for (let t = 0, e = r.length; t < e; ++t) {\n      const s = `{${t}}`;\n      n.includes(s) ? (l = t, o = o.replace(s, r[t].toString())) : -1 === i && (i = t);\n    }\n    if (0 <= i && 0 <= l && i < l) throw new Error(`missing placeholder '${i}' in string substitution`);\n    return o;\n  }, C32.StringSubstituteMap = function(t, n) {\n    let r = t;\n    for (let [t2, e] of Object.entries(n)) r = r.replaceAll(t2, e.toString());\n    return r;\n  }, C32.SortAZ = function(t, e) {\n    return e < t ? 1 : t < e ? -1 : 0;\n  }, C32.SortAZCaseInsensitive = function(t, e) {\n    let n = t.toLowerCase(), r = e.toLowerCase();\n    return r < n ? 1 : n < r ? -1 : 0;\n  }, new self[\"Intl\"][\"Segmenter\"]()), KILOBYTE = (C32.SplitGraphemes = function(t) {\n    const e = [];\n    for (const n of intlSegmenter[\"segment\"](t)) e.push(n[\"segment\"]);\n    return e;\n  }, C32.IterateGraphemes = function* (t) {\n    for (const e of intlSegmenter[\"segment\"](t)) yield e[\"segment\"];\n  }, C32.CountGraphemes = function(t) {\n    let e = 0;\n    for (const n of intlSegmenter[\"segment\"](t)) ++e;\n    return e;\n  }, 1024), MEGABYTE = 1024 * KILOBYTE, GIGABYTE = 1024 * MEGABYTE, TERABYTE = 1024 * GIGABYTE, DEFAULT_FORMATTIME_OPTS = { approximate: !(C32.FormatDataSize = function(e, t) {\n    let n = \"common.\" + (t ? \"dataRates\" : \"dataSizes\") + \".\";\n    const r = self.langSub;\n    if (e < KILOBYTE) return r(n + \"bytes\", e);\n    if (e < MEGABYTE) {\n      let t2 = e / KILOBYTE;\n      return t2 = t2 < 10 ? Math.round(10 * t2) / 10 : Math.round(t2), r(n + \"kilobytes\", t2);\n    }\n    if (e < GIGABYTE) {\n      let t2 = e / MEGABYTE;\n      return t2 = t2 < 10 ? Math.round(10 * t2) / 10 : Math.round(t2), r(n + \"megabytes\", t2);\n    }\n    if (e < TERABYTE) {\n      let t2 = e / GIGABYTE;\n      return t2 = t2 < 10 ? Math.round(10 * t2) / 10 : Math.round(t2), r(n + \"gigabytes\", t2);\n    }\n    {\n      let t2 = e / TERABYTE;\n      return t2 = t2 < 10 ? Math.round(10 * t2) / 10 : Math.round(t2), r(n + \"terabytes\", t2);\n    }\n  }), days: true, hours: true, minutes: true, seconds: true };\n  C32.FormatTime = function(t, e) {\n    e = Object.assign({}, DEFAULT_FORMATTIME_OPTS, e), C32.Lang.PushContext(\"common.time\");\n    const n = [], r = self.lang, o = self.langPluralSub;\n    if (e.days) {\n      const l = Math.floor(t / 86400);\n      0 < l && (t -= 24 * l * 3600, n.push(o(\".days\", null, l)));\n    }\n    if (e.hours) {\n      const s = Math.floor(t / 3600);\n      (0 < s || n.length) && (t -= 3600 * s, n.push(o(\".hours\", null, s)));\n    }\n    if (e.minutes) {\n      const a = Math.floor(t / 60);\n      (0 < a || n.length || !e.seconds) && (t -= 60 * a, n.push(o(\".minutes\", null, a)));\n    }\n    if (e.seconds) {\n      const u = Math.floor(t % 60);\n      n.push(o(\".seconds\", null, u));\n    }\n    const i = (e.approximate ? r(\".approx-prefix\") : \"\") + n.join(r(\".separator\"));\n    return C32.Lang.PopContext(), i;\n  }, C32.ZeroPad = function(t, e) {\n    let n = t < 0 ? \"-\" : \"\", r = (t = Math.abs(t)).toString(), o = e - r.length;\n    for (let t2 = 0; t2 < o; ++t2) n += \"0\";\n    return n + r;\n  }, C32.StringToTitleCase = function(t) {\n    return t.toLowerCase().replace(/\\b\\w/g, (t2) => t2.toUpperCase());\n  }, C32.CompareVersionStrings = function(t, e) {\n    let n = t.split(\".\").map((t2) => t2.trim()), r = e.split(\".\").map((t2) => t2.trim());\n    C32.resizeArray(n, 4, \"0\"), C32.resizeArray(r, 4, \"0\"), n = n.map((t2) => parseInt(t2, 10)), r = r.map((t2) => parseInt(t2, 10));\n    for (let t2 = 0; t2 < 4; ++t2) {\n      const o = n[t2] - r[t2];\n      if (0 != o) return o < 0 ? -1 : 1;\n    }\n    return 0;\n  }, C32.CreateGUID = function() {\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (t) => {\n      const e = Math.floor(16 * Math.random()), n = \"x\" === t ? e : 3 & e | 8;\n      return n.toString(16);\n    });\n  }, C32.StringHammingDistance = function(n, r) {\n    if (n.length !== r.length) throw new Error(\"strings must be same length\");\n    let o = 0;\n    for (let t = 0, e = n.length; t < e; ++t) n.charAt(t) !== r.charAt(t) && ++o;\n    return o;\n  }, C32.StringLevenshteinDistance = function(t, e) {\n    if (0 === t.length) return e.length;\n    if (0 === e.length) return t.length;\n    let n, r, o, i, l, s;\n    for (e.length < t.length && (n = t, t = e, e = n), s = Array(t.length + 1), r = 0; r <= t.length; r++) s[r] = r;\n    for (r = 1; r <= e.length; r++) {\n      for (i = r, o = 1; o <= t.length; o++) l = e[r - 1] === t[o - 1] ? s[o - 1] : Math.min(s[o - 1] + 1, Math.min(i + 1, s[o] + 1)), s[o - 1] = i, i = l;\n      s[t.length] = i;\n    }\n    return s[t.length];\n  };\n}\nvar lookupHtmlEntity2;\n{\n  let bbToHtmlReplacerFunc = function(t, i, s) {\n    const n = BB_CODE_MAP.get(s);\n    if (!n) return \"class\" === s ? i ? \"</span>\" : `<span class=\"bbclass${classIndex++}\">` : t;\n    if (\"string\" == typeof n) {\n      if (\"a\" === n && 0 === linkActions.length || \"abbr\" === n && 0 === tipList.length) return t;\n      if (\"a\" !== n || i) {\n        if (\"abbr\" !== n || i) return \"<\" + i + n + \">\";\n        {\n          const e = parseInt(s.substring(3), 10) - 1;\n          if (e < 0 || e >= tipList.length) throw new Error(\"invalid bbcode tip substitution\");\n          const r = tipList[e];\n          let t2 = \"\";\n          if (\"string\" == typeof r ? t2 = r : \"function\" == typeof r && (t2 = r()), \"string\" != typeof t2) throw new TypeError(\"invalid bbcode tip\");\n          return `<abbr title=\"${C32.ReplaceAll(t2, '\"', \"&quot;\")}\">`;\n        }\n      }\n      {\n        const a = parseInt(s.substring(1), 10) - 1;\n        if (a < 0 || a >= linkActions.length) throw new Error(\"invalid bbcode link substitution\");\n        const o = linkActions[a];\n        if (\"string\" == typeof o) return `<a href=\"${linkActions[a]}\">`;\n        if (\"function\" == typeof o) return `<a class=\"bblink${a}\">`;\n        throw new TypeError(\"invalid bbcode link action\");\n      }\n    }\n    if (Array.isArray(n)) {\n      let t2 = n[0], s2 = n[1];\n      return i ? \"</\" + t2 + \">\" : `<${t2} class=\"${s2}\">`;\n    }\n  };\n  bbToHtmlReplacerFunc2 = bbToHtmlReplacerFunc;\n  const C32 = self.C3, assert = self.assert, BB_CODE_MAP = /* @__PURE__ */ new Map([[\"b\", \"strong\"], [\"i\", \"em\"], [\"s\", \"s\"], [\"u\", \"u\"], [\"sub\", \"sub\"], [\"sup\", \"sup\"], [\"small\", \"small\"], [\"mark\", \"mark\"], [\"code\", \"code\"], [\"a1\", \"a\"], [\"a2\", \"a\"], [\"a3\", \"a\"], [\"a4\", \"a\"], [\"a5\", \"a\"], [\"a6\", \"a\"], [\"a7\", \"a\"], [\"a8\", \"a\"], [\"a9\", \"a\"], [\"tip1\", \"abbr\"], [\"tip2\", \"abbr\"], [\"tip3\", \"abbr\"], [\"tip4\", \"abbr\"], [\"tip5\", \"abbr\"], [\"tip6\", \"abbr\"], [\"tip7\", \"abbr\"], [\"tip8\", \"abbr\"], [\"tip9\", \"abbr\"], [\"bad\", [\"span\", \"bbCodeBad\"]], [\"good\", [\"span\", \"bbCodeGood\"]], [\"info\", [\"span\", \"bbCodeInfo\"]], [\"h1\", [\"span\", \"bbCodeH1\"]], [\"h2\", [\"span\", \"bbCodeH2\"]], [\"h3\", [\"span\", \"bbCodeH3\"]], [\"h4\", [\"span\", \"bbCodeH4\"]], [\"item\", [\"span\", \"bbCodeItem\"]]]), SELF_CLOSING_TAGS = /* @__PURE__ */ new Set([\"icon\"]), BBREGEX = /\\[(\\/?)([a-zA-Z0-9]+)\\]/g, CUSTOM_BBREGEX = /\\[(\\/?)([^\\[\\n]*?)\\]/g;\n  let linkActions = null, tipList = null, classIndex = 0;\n  const LINEBREAK_REGEX = /\\n/g;\n  C32.BBString = class {\n    constructor(t, s) {\n      if (this._bbstr = s && s.noEscape ? t : C32.EscapeHTML(t), this._htmlstr = \"\", this._convertLineBreaks = false, this._linkActions = [], this._tipList = [], s) {\n        if (this._convertLineBreaks = !!s.convertLineBreaks, s.links) {\n          if (9 < s.links.length) throw new Error(\"too many links\");\n          this._linkActions = s.links;\n        }\n        if (s.tips) {\n          if (9 < s.tips.length) throw new Error(\"too many tips\");\n          this._tipList = s.tips;\n        }\n      }\n      this._hasAnyBBtags = this._bbstr.includes(\"[\"), this._needsLineBreakConversion = this._convertLineBreaks && this._bbstr.includes(\"\\n\"), this._isPlain = !this._hasAnyBBtags && !this._needsLineBreakConversion && !this._bbstr.includes(\"&\"), this._hasParsedFragments = false, this._fragments = [];\n    }\n    toString() {\n      return this._bbstr;\n    }\n    valueOf() {\n      return this._bbstr;\n    }\n    isPlainText() {\n      return this._isPlain;\n    }\n    toPlainText() {\n      return this._hasAnyBBtags ? this._bbstr.replace(BBREGEX, \"\") : this._bbstr;\n    }\n    toHTML() {\n      if (this._isPlain) return this._bbstr;\n      if (!this._htmlstr && this._bbstr) {\n        let t = this._bbstr;\n        this._hasAnyBBtags && (classIndex = 0, linkActions = this._linkActions, tipList = this._tipList, t = t.replace(BBREGEX, bbToHtmlReplacerFunc), linkActions = null, tipList = null), this._needsLineBreakConversion && (t = t.replace(LINEBREAK_REGEX, \"<br>\")), this._htmlstr = t;\n      }\n      return this._htmlstr;\n    }\n    attachLinkHandlers(i) {\n      if (this._linkActions.length) for (let t = 0, s = this._linkActions.length; t < s; ++t) {\n        const n = this._linkActions[t];\n        if (\"function\" == typeof n) {\n          const e = i.querySelector(\".bblink\" + t);\n          if (!e) throw new Error(\"unable to attach BBString link handler\");\n          e.onclick = n;\n        }\n      }\n    }\n    equals(t) {\n      return t instanceof C32.HtmlString ? this.toHTML() === t.toHTML() : t instanceof C32.BBString ? this._bbstr === t._bbstr : this._bbstr === t;\n    }\n    toFragmentList() {\n      if (!this._hasParsedFragments) {\n        const i = [], n = this._bbstr, e = [];\n        let t = CUSTOM_BBREGEX.lastIndex = 0, s;\n        for (; null !== (s = CUSTOM_BBREGEX.exec(n)); ) {\n          const r = s.index;\n          if (!(0 < r && \"\\\\\" === n.charAt(r - 1))) {\n            const a = s[0], o = s[1], l = s[2], b = n.substring(t, r);\n            if (t = r + a.length, b && i.push({ text: b, styles: e.slice(0) }), l) if (o) {\n              const c = l.toLowerCase();\n              for (let t2 = e.length - 1; 0 <= t2; --t2) if (e[t2].tag === c) {\n                e.splice(t2, 1);\n                break;\n              }\n            } else {\n              let t2 = l, s2 = null;\n              const h = l.indexOf(\"=\");\n              if (-1 !== h ? (t2 = l.substring(0, h).toLowerCase(), s2 = l.substring(h + 1)) : t2 = t2.toLowerCase(), SELF_CLOSING_TAGS.has(t2)) {\n                if (\"icon\" !== t2) throw new Error(\"unknown self-closing tag \" + t2);\n                i.push({ icon: s2, styles: e.slice(0) });\n              } else e.push({ tag: t2, param: s2 });\n            }\n          }\n        }\n        t < n.length && i.push({ text: n.substring(t), styles: e.slice(0) });\n        for (const p of i) p.text && (p.text = this._ProcessBBCodeEscapeSequences(p.text));\n        this._fragments = i.map((t2) => t2.icon ? C32.New(C32.IconFragment, { icon: t2.icon, styles: t2.styles }) : C32.New(C32.TextFragment, { chArr: C32.SplitGraphemes(t2.text), styles: t2.styles })), this._hasParsedFragments = true;\n      }\n      return this._fragments;\n    }\n    _ProcessBBCodeEscapeSequences(t) {\n      return t = C32.ReplaceAll(t, \"\\\\[\", \"[\"), C32.ReplaceAll(t, \"\\\\\\\\\", \"\\\\\");\n    }\n    static StripTags(t) {\n      return C32.New(C32.BBString, t, { noEscape: true }).toPlainText();\n    }\n    static StripAnyTags(t) {\n      return t.replace(CUSTOM_BBREGEX, \"\");\n    }\n  };\n}\nvar bbToHtmlReplacerFunc2;\n{\n  let IsWordBreakWhiteSpace = function(e) {\n    return \"\\xA0\" !== e && \"\\u202F\" !== e && C32.IsWhitespaceChar(e);\n  }, IsOpeningCJKPunctiationChar = function(e) {\n    return CJK_OPEN_PUNCTUATION.has(e);\n  }, IsContinuingCJKPunctuationChar = function(e) {\n    return C32.IsCJKPunctuationChar(e) && !IsOpeningCJKPunctiationChar(e);\n  }, WordBreakTrimEnd = function(e) {\n    for (; 0 < e.length && IsWordBreakWhiteSpace(e.at(-1)); ) e.pop();\n  }, IsNewline = function(e) {\n    return \"\\n\" === e || \"\\r\\n\" === e;\n  };\n  IsWordBreakWhiteSpace2 = IsWordBreakWhiteSpace, IsOpeningCJKPunctiationChar2 = IsOpeningCJKPunctiationChar, IsContinuingCJKPunctuationChar2 = IsContinuingCJKPunctuationChar, WordBreakTrimEnd2 = WordBreakTrimEnd, IsNewline2 = IsNewline;\n  const C32 = self.C3;\n  const CJK_OPEN_PUNCTUATION = new Set(\"\\u3008\\u300A\\u300C\\u300E\\u3010\\u3014\\u3016\\u3018\\u301A\\u301D\");\n  C32.WordWrap = class {\n    constructor() {\n      this._lines = [], this._iconSet = null;\n    }\n    GetLines() {\n      return this._lines;\n    }\n    GetLineCount() {\n      return this._lines.length;\n    }\n    SetIconSet(e) {\n      this._iconSet = e;\n    }\n    _MeasureLine(e, t) {\n      let n = 0, s = 0, i = 0, o = 0, r = 0;\n      for (const h of e) {\n        if (-1 === h.GetWidth()) {\n          const a = t(h);\n          h.SetHeight(a.height), h.SetFontBoundingBoxAscent(a.fontBoundingBoxAscent || 0), h.SetFontBoundingBoxDescent(a.fontBoundingBoxDescent || 0), h.SetTopToAlphabeticDistance(a.topToAlphabeticDistance || 0), h.IsText() ? h.SetWidth(a.width) : h.IsIcon() && h.CalculateWidthFromHeight(this._iconSet);\n        }\n        n += h.GetWidth(), s = Math.max(s, h.GetHeight()), i = Math.max(i, h.GetFontBoundingBoxAscent()), o = Math.max(o, h.GetFontBoundingBoxDescent()), r = Math.max(r, h.GetTopToAlphabeticDistance());\n      }\n      return { width: n, height: s, fontBoundingBoxAscent: i, fontBoundingBoxDescent: o, topToAlphabeticDistance: r };\n    }\n    _AddLine(e, t, n, s, i, o) {\n      this._lines.push(C32.New(C32.WordWrap.Line, { fragments: e, width: t, height: n, fontBoundingBoxAscent: s, fontBoundingBoxDescent: i, topToAlphabeticDistance: o }));\n    }\n    WordWrap(t, o, r, n, h) {\n      if (\"string\" == typeof t && (t = [C32.New(C32.TextFragment, { chArr: C32.SplitGraphemes(t) })]), C32.clearArray(this._lines), !(!t.length || 1 === t.length && t[0].IsText() && t[0].IsEmpty() || r < 2)) {\n        if (1 === t.length) {\n          const a = t[0];\n          if (a.IsText() && a.GetLength() <= 100 && !a.HasNewLine()) {\n            let { width: e2, height: t2, fontBoundingBoxAscent: n2, fontBoundingBoxDescent: s, topToAlphabeticDistance: i } = o(a);\n            if (e2 += h, a.SetWidth(e2), a.SetHeight(t2), a.SetFontBoundingBoxAscent(n2 || 0), a.SetFontBoundingBoxDescent(s || 0), a.SetTopToAlphabeticDistance(i || 0), e2 <= r) return void this._AddLine([a], e2, t2, n2, s, i);\n          }\n        }\n        let e;\n        e = \"word\" === n ? this._TokeniseByWord(t) : \"cjk\" === n ? this._TokeniseByCJK(t) : this._TokeniseByChar(t), this._WrapText(e, o, r, h);\n      }\n    }\n    _TokeniseByWord(e) {\n      const t = [];\n      let n = [], s = false;\n      for (const i of e) {\n        const o = i.GetStyles();\n        if (i.IsIcon()) 0 < n.length && t.push(n), t.push([i]), n = [];\n        else for (const r of i.GetCharacterArray()) if (IsNewline(r)) 0 < n.length && t.push(n), t.push([C32.New(C32.TextFragment, { chArr: [\"\\n\"], styles: o })]), n = [];\n        else if (0 === n.length) n.push(C32.New(C32.TextFragment, { chArr: [r], styles: o })), s = IsWordBreakWhiteSpace(r);\n        else {\n          const h = IsWordBreakWhiteSpace(r);\n          if (h === s) {\n            const a = n.at(-1);\n            a.GetStyles() === o ? a._AppendChar(r) : n.push(C32.New(C32.TextFragment, { chArr: [r], styles: o }));\n          } else t.push(n), n = [C32.New(C32.TextFragment, { chArr: [r], styles: o })], s = h;\n        }\n      }\n      return 0 < n.length && t.push(n), t;\n    }\n    _TokeniseByCJK(e) {\n      const t = [];\n      let n = [], s = false;\n      for (const i of e) {\n        const o = i.GetStyles();\n        if (i.IsIcon()) 0 < n.length && t.push(n), t.push([i]), n = [];\n        else for (const r of i.GetCharacterArray()) if (IsNewline(r)) 0 < n.length && t.push(n), t.push([C32.New(C32.TextFragment, { chArr: [\"\\n\"], styles: o })]), n = [];\n        else {\n          if (0 === n.length) n.push(C32.New(C32.TextFragment, { chArr: [r], styles: o }));\n          else if (s || IsContinuingCJKPunctuationChar(r)) {\n            const h = n.at(-1);\n            h.GetStyles() === o ? h._AppendChar(r) : n.push(C32.New(C32.TextFragment, { chArr: [r], styles: o }));\n          } else t.push(n), n = [C32.New(C32.TextFragment, { chArr: [r], styles: o })];\n          s = IsOpeningCJKPunctiationChar(r);\n        }\n      }\n      return 0 < n.length && t.push(n), t;\n    }\n    _TokeniseByChar(e) {\n      const t = [];\n      for (const n of e) if (n.IsText()) {\n        const s = n.GetCharacterArray();\n        C32.appendArray(t, s.map((e2) => [C32.New(C32.TextFragment, { chArr: [e2], styles: n.GetStyles() })]));\n      } else t.push([n]);\n      return t;\n    }\n    _CopyLine(e) {\n      return e.map((e2) => e2._Clone());\n    }\n    _AddWordToLine(t, n) {\n      const e = t.length ? t.at(-1) : null;\n      let s = 0;\n      e && e.IsText() && n[0].IsText() && n[0].GetStyles() === e.GetStyles() && (e._Append(n[0].GetCharacterArray()), s = 1);\n      for (let e2 = n.length; s < e2; ++s) {\n        const i = n[s];\n        t.push(i._Clone());\n      }\n    }\n    _WrapText(e, t, n, s) {\n      let i = [], o = 0, r = 0, h = 0, a = 0, c = 0;\n      for (const l of e) if (1 === l.length && l[0].IsText() && 1 === l[0].GetLength() && IsNewline(l[0].GetCharacterArray()[0])) {\n        if (0 === r) {\n          const d = C32.New(C32.TextFragment, { chArr: [\" \"], styles: l[0].GetStyles() }), g = t(d);\n          r = g.height, h = g.fontBoundingBoxAscent || 0, a = g.fontBoundingBoxDescent || 0, c = g.topToAlphabeticDistance || 0;\n        }\n        this._AddLine(i, o, r, h, a, c), i = [], o = 0, r = 0, h = 0, a = 0, c = 0;\n      } else {\n        const u = this._CopyLine(i), p = (this._AddWordToLine(u, l), this._MeasureLine(u, t)), C = p.width;\n        if (n <= C) if (0 < i.length && this._AddLine(i, o, r, h, a, c), i = [], l[0].IsText() && C32.IsCharArrayAllWhitespace(l[0].GetCharacterArray())) o = 0, r = 0, h = 0, a = 0, c = 0;\n        else {\n          this._AddWordToLine(i, l);\n          const f = this._MeasureLine(i, t);\n          o = f.width, r = f.height, h = f.fontBoundingBoxAscent, a = f.fontBoundingBoxDescent, c = f.topToAlphabeticDistance;\n        }\n        else i = u, o = C, r = p.height, h = p.fontBoundingBoxAscent, a = p.fontBoundingBoxDescent, c = p.topToAlphabeticDistance;\n      }\n      0 < i.length && this._AddLine(i, o, r, h, a, c), this._TrimLinesTrailingWhitespace(t, s);\n    }\n    _TrimLinesTrailingWhitespace(t, n) {\n      for (const s of this._lines) {\n        const i = s._GetFragmentsArray();\n        if (i.length) {\n          let e = i.at(-1);\n          if (e.IsText()) {\n            const o = e.GetCharacterArray(), r = o.slice(0);\n            if (WordBreakTrimEnd(r), 0 === r.length) s.OffsetWidth(-e.GetWidth()), i.pop();\n            else if (r.length < o.length) {\n              e.SetCharacterArray(r);\n              const h = t(e).width, a = e.GetWidth() - h;\n              e.SetWidth(h), s.OffsetWidth(-a);\n            }\n            0 !== n && 0 < i.length && ((e = i.at(-1)).OffsetWidth(n), s.OffsetWidth(n));\n          }\n        }\n      }\n    }\n    Clear() {\n      C32.clearArray(this._lines);\n    }\n    GetMaxLineWidth() {\n      return this._lines.reduce((e, t) => Math.max(e, t.GetWidth()), 0);\n    }\n    GetTotalLineHeight() {\n      return this._lines.reduce((e, t) => e + t.GetHeight(), 0);\n    }\n  };\n}\nvar IsWordBreakWhiteSpace2;\nvar IsOpeningCJKPunctiationChar2;\nvar IsContinuingCJKPunctuationChar2;\nvar WordBreakTrimEnd2;\nvar IsNewline2;\n{\n  const C32 = self.C3;\n  C32.WordWrap.Line = class {\n    constructor(t) {\n      this._fragments = t.fragments || [], this._width = t.width || -1, this._height = t.height || -1, this._fontBoundingBoxAscent = t.fontBoundingBoxAscent || -1, this._fontBoundingBoxDescent = t.fontBoundingBoxDescent || -1, this._topToAlphabeticDistance = t.topToAlphabeticDistance || -1, this._posX = 0, this._posY = 0;\n    }\n    fragments() {\n      return this._fragments.values();\n    }\n    *fragmentsReverse() {\n      const e = this._fragments;\n      for (let t = e.length - 1; 0 <= t; --t) yield e[t];\n    }\n    _GetFragmentsArray() {\n      return this._fragments;\n    }\n    OffsetWidth(t) {\n      this._width += t;\n    }\n    GetWidth() {\n      return this._width;\n    }\n    GetHeight() {\n      return this._height;\n    }\n    GetFoundBoundingBoxAscent() {\n      return this._fontBoundingBoxAscent;\n    }\n    GetFontBoundingBoxDescent() {\n      return this._fontBoundingBoxDescent;\n    }\n    GetTopToAlphabeticDistance() {\n      return this._topToAlphabeticDistance;\n    }\n    SetPosX(t) {\n      this._posX = t;\n    }\n    GetPosX() {\n      return this._posX;\n    }\n    SetPosY(t) {\n      this._posY = t;\n    }\n    GetPosY() {\n      return this._posY;\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.FragmentBase = class {\n    constructor(t) {\n      this._styles = t.styles || [], this._width = t.width || -1, this._height = t.height || -1, this._fontBoundingBoxAscent = t.fontBoundingBoxAscent || -1, this._fontBoundingBoxDescent = t.fontBoundingBoxDescent || -1, this._topToAlphabeticDistance = t.topToAlphabeticDistance || -1, this._posX = 0, this._posY = 0;\n    }\n    IsText() {\n      return false;\n    }\n    IsIcon() {\n      return false;\n    }\n    GetStyles() {\n      return this._styles;\n    }\n    GetStyleTag(e) {\n      const s = this._styles;\n      for (let t = s.length - 1; 0 <= t; --t) {\n        const n = s[t];\n        if (n.tag === e) return n;\n      }\n      return null;\n    }\n    HasStyleTag(t) {\n      return !!this.GetStyleTag(t);\n    }\n    GetStyleMap() {\n      const t = /* @__PURE__ */ new Map();\n      for (const e of this._styles) t.set(e.tag, e.param);\n      return t;\n    }\n    OffsetWidth(t) {\n      this._width += t;\n    }\n    SetWidth(t) {\n      this._width = t;\n    }\n    GetWidth() {\n      return this._width;\n    }\n    SetHeight(t) {\n      this._height = t;\n    }\n    GetHeight() {\n      return this._height;\n    }\n    SetFontBoundingBoxAscent(t) {\n      this._fontBoundingBoxAscent = t;\n    }\n    GetFontBoundingBoxAscent() {\n      return this._fontBoundingBoxAscent;\n    }\n    SetFontBoundingBoxDescent(t) {\n      this._fontBoundingBoxDescent = t;\n    }\n    GetFontBoundingBoxDescent() {\n      return this._fontBoundingBoxDescent;\n    }\n    SetTopToAlphabeticDistance(t) {\n      this._topToAlphabeticDistance = t;\n    }\n    GetTopToAlphabeticDistance() {\n      return this._topToAlphabeticDistance;\n    }\n    SetPosX(t) {\n      this._posX = t;\n    }\n    GetPosX() {\n      return this._posX;\n    }\n    SetPosY(t) {\n      this._posY = t;\n    }\n    GetPosY() {\n      return this._posY;\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.TextFragment = class extends C32.FragmentBase {\n    constructor(t) {\n      super(t), this._chArr = t.chArr;\n    }\n    IsText() {\n      return true;\n    }\n    _Append(t) {\n      C32.appendArray(this._chArr, t), this._width = -1, this._height = -1, this._fontBoundingBoxAscent = -1, this._fontBoundingBoxDescent = -1, this._topToAlphabeticDistance = -1;\n    }\n    _AppendChar(t) {\n      this._chArr.push(t);\n    }\n    _Clone() {\n      return C32.New(C32.TextFragment, { chArr: this._chArr.slice(0), styles: this._styles, width: this._width, height: this._height, fontBoundingBoxAscent: this._fontBoundingBoxAscent, fontBoundingBoxDescent: this._fontBoundingBoxDescent, topToAlphabeticDistance: this._topToAlphabeticDistance });\n    }\n    GetCharacterArray() {\n      return this._chArr;\n    }\n    SetCharacterArray(t) {\n      this._chArr = t;\n    }\n    GetLength() {\n      return this._chArr.length;\n    }\n    IsEmpty() {\n      return 0 === this._chArr.length;\n    }\n    HasNewLine() {\n      return this._chArr.includes(\"\\n\");\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.IconFragment = class extends C32.FragmentBase {\n    constructor(t) {\n      super(t), this._icon = t.icon;\n    }\n    IsIcon() {\n      return true;\n    }\n    GetIconParameter() {\n      return this._icon;\n    }\n    _Clone() {\n      return C32.New(C32.IconFragment, { icon: this._icon, styles: this._styles, width: this._width, height: this._height, fontBoundingBoxAscent: this._fontBoundingBoxAscent, fontBoundingBoxDescent: this._fontBoundingBoxDescent, topToAlphabeticDistance: this._topToAlphabeticDistance });\n    }\n    GetTextIcon(t) {\n      if (!t) return null;\n      let e = Number(this._icon);\n      return String(e) === this._icon ? (e = Math.floor(e), t.GetTextIconByIndex(e)) : t.GetTextIconByTag(this._icon);\n    }\n    CalculateWidthFromHeight(t) {\n      const e = this.GetTextIcon(t);\n      this._width = e ? this._height * e.GetWidth() / e.GetHeight() : 0;\n    }\n    GetDrawable(t) {\n      const e = this.GetTextIcon(t);\n      return e ? e.GetDrawable() : null;\n    }\n    GetLength() {\n      return 1;\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.TextIconManager = class {\n    constructor(t) {\n      this._iconSets = /* @__PURE__ */ new Map(), this._getIconSetMetaCallback = t.getIconSetMeta, this._getIconSetContentCallback = t.getIconSetContent;\n    }\n    Release() {\n      for (const t of this._iconSets.values()) t.Release();\n      this._iconSets.clear();\n    }\n    GetIconSet(t) {\n      let e = this._iconSets.get(t);\n      if (!e) {\n        const n = this._getIconSetMetaCallback(t);\n        e = C32.New(C32.TextIconSet, this, { source: t, iconMeta: n }), this._iconSets.set(t, e);\n      }\n      return e;\n    }\n    HasIconSet(t) {\n      return this._iconSets.has(t);\n    }\n    DeleteIconSet(t) {\n      const e = this._iconSets.get(t);\n      e && e.Release(), this._iconSets.delete(t);\n    }\n    async _GetIconSetContent(t) {\n      return this._getIconSetContentCallback(t);\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.TextIconSet = class {\n    constructor(t, s) {\n      this._textIconManager = t, this._source = s.source, this._iconsArray = [], this._iconsByTag = /* @__PURE__ */ new Map(), this._hasStartedLoad = false, this._isLoading = false, this._loadPromise = null;\n      const o = s.iconMeta.icons;\n      for (let t2 = 0, s2 = o.length; t2 < s2; ++t2) {\n        const e = o[t2], a = C32.New(C32.TextIcon, this, { index: t2, tag: e.tag, source: e.source, width: e.width, height: e.height });\n        this._iconsArray.push(a), e.tag && this._iconsByTag.set(e.tag.toLowerCase(), a);\n      }\n    }\n    Release() {\n      for (const t of this._iconsArray) t.Release();\n      C32.clearArray(this._iconsArray), this._iconsByTag.clear(), this._textIconManager = null, this._source = null;\n    }\n    HasLoaded() {\n      return this._hasStartedLoad;\n    }\n    IsLoading() {\n      return this._isLoading;\n    }\n    LoadContent() {\n      return this._loadPromise || (this._loadPromise = this._DoLoadContent()), this._loadPromise;\n    }\n    async _DoLoadContent() {\n      if (!this._hasStartedLoad) {\n        this._hasStartedLoad = true, this._isLoading = true;\n        const t = await this._textIconManager._GetIconSetContent(this._source);\n        if (this._textIconManager) {\n          const o = t.icons;\n          for (let t2 = 0, s = Math.min(o.length, this._iconsArray.length); t2 < s; ++t2) {\n            const e = o[t2].drawable;\n            this._iconsArray[t2]._SetDrawable(e);\n          }\n          this._isLoading = false;\n        }\n      }\n    }\n    GetTextIconByIndex(t) {\n      return (t = Math.floor(t)) < 0 || t >= this._iconsArray.length ? null : this._iconsArray[t];\n    }\n    GetTextIconByTag(t) {\n      return this._iconsByTag.get(t.toLowerCase()) || null;\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.TextIcon = class {\n    constructor(t, e) {\n      this._textIconSet = t, this._source = e.source || null, this._index = e.index, this._tag = e.tag, this._width = e.width, this._height = e.height, this._drawable = null;\n    }\n    Release() {\n      this._width = 0, this._height = 0, this._textIconSet = null;\n    }\n    GetSource() {\n      return this._source;\n    }\n    GetWidth() {\n      return this._width;\n    }\n    GetHeight() {\n      return this._height;\n    }\n    _SetDrawable(t) {\n      this._drawable = t;\n    }\n    GetDrawable() {\n      return this._drawable;\n    }\n  };\n}\n{\n  let PlaneFromPoints = function(t, e, r, n) {\n    const a = tempVec3c;\n    vec3.subtract(tempVec3a, r, e), vec3.subtract(tempVec3b, t, e), vec3.cross(a, tempVec3a, tempVec3b), vec3.normalize(a, a), n.set(a[0], a[1], a[2], vec3.dot(t, a));\n  }, IsInFrontOfPlane = function(t, e, r, n, a, c, s) {\n    const o = s.x, i = s.y, l = s.z, f = s.w, P = s.xF, h = s.yF, m = s.zF, p = 1 - P, v = 1 - h, u = 1 - m, b = o * t * P + o * n * p + i * e * h + i * a * v + l * r * m + l * c * u;\n    if (f <= b) return true;\n    const F = o * n * P + o * t * p + i * a * h + i * e * v + l * c * m + l * r * u;\n    return f < F;\n  }, IsPointInFrontOfPlane = function(t, e, r, n) {\n    const a = n.x, c = n.y, s = n.z, o = n.w, i = a * t + c * e + s * r;\n    return o <= i;\n  };\n  PlaneFromPoints2 = PlaneFromPoints, IsInFrontOfPlane2 = IsInFrontOfPlane, IsPointInFrontOfPlane2 = IsPointInFrontOfPlane;\n  const C32 = self.C3, glMatrix = self.glMatrix, vec3 = glMatrix.vec3, vec4 = glMatrix.vec4, mat4 = glMatrix.mat4, tempVec3a = vec3.create(), tempVec3b = vec3.create(), tempVec3c = vec3.create(), tempVec4 = vec4.create(), tempMat4 = mat4.create(), neartl = vec3.create(), neartr = vec3.create(), nearbl = vec3.create(), nearbr = vec3.create(), fartl = vec3.create(), fartr = vec3.create(), farbl = vec3.create(), farbr = vec3.create(), unitViewport = vec4.fromValues(0, 0, 1, 1);\n  C32.Gfx = { Project(t, e, r, n, a, c, s) {\n    const o = n[0] * t + n[4] * e + n[8] * r + n[12], i = n[1] * t + n[5] * e + n[9] * r + n[13], l = n[2] * t + n[6] * e + n[10] * r + n[14], f = n[3] * t + n[7] * e + n[11] * r + n[15];\n    let P = a[0] * o + a[4] * i + a[8] * l + a[12] * f, h = a[1] * o + a[5] * i + a[9] * l + a[13] * f, m = a[2] * o + a[6] * i + a[10] * l + a[14] * f, p = a[3] * o + a[7] * i + a[11] * l + a[15] * f;\n    return 0 != p && (h *= p = 1 / p, m *= p, s[0] = (0.5 * (P *= p) + 0.5) * c[2] + c[0], s[1] = (0.5 * h + 0.5) * c[3] + c[1], s[2] = 0.5 * (1 + m), true);\n  }, Unproject(t, e, r, n, a, c, s) {\n    const o = tempMat4, i = tempVec4;\n    return mat4.multiply(o, a, n), null !== mat4.invert(o, o) && (i[0] = (t - c[0]) / c[2] * 2 - 1, i[1] = (e - c[1]) / c[3] * 2 - 1, i[2] = 2 * r - 1, i[3] = 1, vec4.transformMat4(i, i, o), 0 !== i[3]) && (i[3] = 1 / i[3], s[0] = i[0] * i[3], s[1] = i[1] * i[3], s[2] = i[2] * i[3], true);\n  }, UnprojectScreenToWorldZ(t, e, r, n, a, c, s) {\n    const o = tempVec3a, i = tempVec3b;\n    if (!C32.Gfx.Unproject(t, e, 0, n, a, c, o)) return false;\n    if (!C32.Gfx.Unproject(t, e, 1, n, a, c, i)) return false;\n    const l = tempVec3b, f = (vec3.subtract(l, i, o), tempVec3c), P = (vec3.set(f, 0, 0, 1), -r), h = vec3.dot(f, l);\n    let m = 0;\n    if (0 === h) {\n      const p = vec3.dot(f, o) + P;\n      if (0 !== p) return false;\n    } else if ((m = -(vec3.dot(o, f) + P) / h) < 0) return false;\n    return vec3.scaleAndAdd(s, o, l, m), true;\n  } };\n  class Plane {\n    constructor() {\n      this.x = NaN, this.y = NaN, this.z = NaN, this.w = NaN, this.xF = NaN, this.yF = NaN, this.zF = NaN;\n    }\n    set(t, e, r, n) {\n      this.x = t, this.y = e, this.z = r, this.w = n, this.xF = 0 < t ? 1 : 0, this.yF = 0 < e ? 1 : 0, this.zF = 0 < r ? 1 : 0;\n    }\n  }\n  C32.Gfx.ViewFrustum = class {\n    constructor() {\n      this._leftP = new Plane(), this._topP = new Plane(), this._rightP = new Plane(), this._bottomP = new Plane(), this._nearP = new Plane(), this._farP = new Plane();\n    }\n    CalculatePlanes(t, e) {\n      const r = unitViewport;\n      C32.Gfx.Unproject(0, 1, 0, t, e, r, neartl), C32.Gfx.Unproject(1, 1, 0, t, e, r, neartr), C32.Gfx.Unproject(0, 0, 0, t, e, r, nearbl), C32.Gfx.Unproject(1, 0, 0, t, e, r, nearbr), C32.Gfx.Unproject(0, 1, 1, t, e, r, fartl), C32.Gfx.Unproject(1, 1, 1, t, e, r, fartr), C32.Gfx.Unproject(0, 0, 1, t, e, r, farbl), C32.Gfx.Unproject(1, 0, 1, t, e, r, farbr), PlaneFromPoints(nearbl, neartl, fartl, this._leftP), PlaneFromPoints(neartl, neartr, fartr, this._topP), PlaneFromPoints(neartr, nearbr, farbr, this._rightP), PlaneFromPoints(nearbr, nearbl, farbl, this._bottomP), PlaneFromPoints(farbl, fartl, fartr, this._farP), PlaneFromPoints(nearbr, neartr, neartl, this._nearP);\n    }\n    ContainsAABB(t, e, r, n, a, c) {\n      return IsInFrontOfPlane(t, e, r, n, a, c, this._leftP) && IsInFrontOfPlane(t, e, r, n, a, c, this._topP) && IsInFrontOfPlane(t, e, r, n, a, c, this._rightP) && IsInFrontOfPlane(t, e, r, n, a, c, this._bottomP) && IsInFrontOfPlane(t, e, r, n, a, c, this._nearP) && IsInFrontOfPlane(t, e, r, n, a, c, this._farP);\n    }\n    IsBehindNearPlane(t, e, r) {\n      return !IsPointInFrontOfPlane(t, e, r, this._nearP);\n    }\n  };\n}\nvar PlaneFromPoints2;\nvar IsInFrontOfPlane2;\nvar IsPointInFrontOfPlane2;\n{\n  const C32 = self.C3, glMatrix = self.glMatrix, vec3 = glMatrix.vec3, vec4 = glMatrix.vec4, mat4 = glMatrix.mat4, tempMat4 = mat4.create(), tmpVec3a = vec3.fromValues(0, 0, 0), tmpVec3b = vec3.fromValues(0, 0, 0), tmpVec3c = vec3.fromValues(0, 0, 0), defaultUpVector = vec3.fromValues(0, 1, 0), tmpVec4 = vec4.fromValues(0, 0, 0, 0), tmpQuad = new C32.Quad(), tmpRect = new C32.Rect(), defaultTexCoordsQuad = new C32.Quad(0, 0, 1, 0, 1, 1, 0, 1), DEFAULT_RENDERERBASE_OPTS = { nearZ: 1, farZ: 1e4 }, matWebGLtoWebGPU = mat4.fromValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0.5, 0, 0, 0, 0.5, 1);\n  C32.Gfx.RendererBase = class {\n    constructor(e) {\n      e = Object.assign({}, DEFAULT_RENDERERBASE_OPTS, e), this._width = 0, this._height = 0, this._fovY = C32.toRadians(45), this._tan_fovY_2 = Math.tan(this._fovY / 2), this._matP = mat4.create(), this._matMV = mat4.create(), this._zAxisScale = false, this._nearZ = e.nearZ, this._farZ = e.farZ, this._allShaderPrograms = [], this._shaderProgramsByName = /* @__PURE__ */ new Map(), this._spTextureFill = null, this._spPoints = null, this._spTilemapFill = null, this._spTileRandomization = null, this._spColorFill = null, this._spLinearGradientFill = null, this._spPenumbraFill = null, this._spHardEllipseFill = null, this._spHardEllipseOutline = null, this._spSmoothEllipseFill = null, this._spSmoothEllipseOutline = null, this._spSmoothLineFill = null, this._stateGroups = /* @__PURE__ */ new Map(), this._currentStateGroup = null, this._blendModeTable = [], this._namedBlendModeMap = /* @__PURE__ */ new Map(), this._baseZ = 0, this._currentZ = 0, this._lineWidth = 1, this._lineWidthStack = [this._lineWidth], this._lineCap = 1, this._lineCapStack = [this._lineCap], this._lineOffset = 0.5, this._lineOffsetStack = [this._lineOffset], this._frameNumber = 0, this._enableMipmaps = true, this._hasMajorPerformanceCaveat = false;\n    }\n    FillIndexBufferData(e) {\n      let t = 0, i = e.length, a = 0;\n      for (; t < i; ) e[t++] = a, e[t++] = a + 1, e[t++] = a + 2, e[t++] = a, e[t++] = a + 2, e[t++] = a + 3, a += 4;\n    }\n    _ClearState() {\n      this._baseZ = 0, this._currentZ = 0, this._spTextureFill = null, this._spPoints = null, this._spTilemapFill = null, this._spTileRandomization = null, this._spColorFill = null, this._spLinearGradientFill = null, this._spPenumbraFill = null, this._spHardEllipseFill = null, this._spHardEllipseOutline = null, this._spSmoothEllipseFill = null, this._spSmoothEllipseOutline = null, this._spSmoothLineFill = null, this._ClearAllShaderPrograms();\n    }\n    InitState() {\n      this._ClearState(), this._currentStateGroup = null;\n    }\n    OnDeviceOrContextLost() {\n      for (const e of this._allShaderPrograms) e.Release();\n      this._ClearState();\n    }\n    GetWidth() {\n      return this._width;\n    }\n    GetHeight() {\n      return this._height;\n    }\n    GetDefaultCameraZ(e) {\n      return this.IsZAxisScaleNormalized() ? 100 : e / (2 * this._GetTanFovYDiv2());\n    }\n    GetZAxisScaleFactor(e) {\n      if (this.IsZAxisScaleNormalized()) {\n        const t = e / (2 * this._GetTanFovYDiv2());\n        return t / this.GetDefaultCameraZ(e);\n      }\n      return 1;\n    }\n    SetNearZ(e) {\n      this._nearZ = e;\n    }\n    GetNearZ() {\n      return this._nearZ;\n    }\n    SetFarZ(e) {\n      this._farZ = e;\n    }\n    GetFarZ() {\n      return this._farZ;\n    }\n    SetFovY(e) {\n      this._fovY = e, this._tan_fovY_2 = Math.tan(this._fovY / 2);\n    }\n    GetFovY() {\n      return this._fovY;\n    }\n    _GetTanFovYDiv2() {\n      return this._tan_fovY_2;\n    }\n    SetZAxisScaleNormalized() {\n      this._zAxisScale = false;\n    }\n    SetZAxisScaleRegular() {\n      this._zAxisScale = true;\n    }\n    IsZAxisScaleNormalized() {\n      return !this._zAxisScale;\n    }\n    IsZAxisScaleRegular() {\n      return this._zAxisScale;\n    }\n    CalculatePerspectiveMatrix(e, t, i = 0.5, a = 0.5) {\n      const s = this.GetNearZ(), r = this.GetFarZ(), l = this.GetFovY();\n      if (0.5 === i && 0.5 === a) this.IsWebGPU() ? mat4.perspectiveZO(e, l, t, s, r) : mat4.perspective(e, l, t, s, r);\n      else {\n        const n = 2 * (i = 1 - i) - 2, h = 2 * i, o = 2 * a - 2, p = 2 * a, _ = this._GetTanFovYDiv2() * s, c = _ * t;\n        mat4.frustum(e, n * c, h * c, o * _, p * _, s, r), this.IsWebGPU() && mat4.mul(e, matWebGLtoWebGPU, e);\n      }\n    }\n    CalculateOrthographicMatrix(e, t, i, a = 1) {\n      const s = self.devicePixelRatio, r = 2 * this.GetDefaultCameraZ(i) * s * this._GetTanFovYDiv2() / i, l = t * r / (2 * s * a), n = i * r / (2 * s * a), h = -l, o = l, p = -n, _ = n;\n      this.IsWebGPU() ? mat4.orthoZO(e, h, o, p, _, this.GetNearZ(), this.GetFarZ()) : mat4.ortho(e, h, o, p, _, this.GetNearZ(), this.GetFarZ());\n    }\n    CalculateLookAtModelView(e, t, i, a, s, r = 1) {\n      let l = 1;\n      this.IsZAxisScaleNormalized() && (l = 200 * this._GetTanFovYDiv2() / s);\n      const n = tmpVec3c, h = (vec3.set(n, l, -l, 1), tmpVec3a), o = tmpVec3b;\n      vec3.multiply(h, t, n), vec3.multiply(o, i, n), mat4.lookAt(e, h, o, a || defaultUpVector), n[2] = r, mat4.scale(e, e, n);\n    }\n    CalculateLookAtModelView2(e, t, i, a, s, r, l, n) {\n      return vec3.set(tmpVec3a, e, t, i), vec3.set(tmpVec3b, a, s, r), this.CalculateLookAtModelView(tempMat4, tmpVec3a, tmpVec3b, defaultUpVector, l, n), tempMat4;\n    }\n    _AddShaderProgram(e) {\n      this._allShaderPrograms.push(e), this._shaderProgramsByName.set(e.GetName(), e);\n    }\n    _RemoveShaderProgram(e) {\n      const t = this._allShaderPrograms.indexOf(e);\n      -1 !== t && this._allShaderPrograms.splice(t, 1), this._shaderProgramsByName.delete(e.GetName());\n    }\n    _ClearAllShaderPrograms() {\n      C32.clearArray(this._allShaderPrograms), this._shaderProgramsByName.clear();\n    }\n    GetShaderProgramByName(e) {\n      return this._shaderProgramsByName.get(e) || null;\n    }\n    GetTextureFillShaderProgram() {\n      return this._spTextureFill;\n    }\n    SetTextureFillMode() {\n      this.SetProgram(this._spTextureFill);\n    }\n    GetPointsRenderingProgram() {\n      return this._spPoints;\n    }\n    SetPointsRenderingProgram() {\n      this.SetProgram(this._spPoints);\n    }\n    SetTilemapFillMode() {\n      this.SetProgram(this._spTilemapFill);\n    }\n    SetTileRandomizationMode() {\n      this.SetProgram(this._spTileRandomization);\n    }\n    SetColorFillMode() {\n      this.SetProgram(this._spColorFill);\n    }\n    SetLinearGradientFillMode() {\n      this.SetProgram(this._spLinearGradientFill);\n    }\n    SetPenumbraFillMode() {\n      this.SetProgram(this._spPenumbraFill);\n    }\n    SetHardEllipseFillMode() {\n      this.SetProgram(this._spHardEllipseFill);\n    }\n    SetHardEllipseOutlineMode() {\n      this.SetProgram(this._spHardEllipseOutline);\n    }\n    SetSmoothEllipseFillMode() {\n      this.SetProgram(this._spSmoothEllipseFill);\n    }\n    SetSmoothEllipseOutlineMode() {\n      this.SetProgram(this._spSmoothEllipseOutline);\n    }\n    SetSmoothLineFillMode() {\n      this.SetProgram(this._spSmoothLineFill);\n    }\n    _SetCurrentStateGroup(e) {\n      this._currentStateGroup = e;\n    }\n    GetCurrentStateGroup() {\n      return this._currentStateGroup;\n    }\n    AcquireStateGroup(e, t, i, a) {\n      const s = C32.Gfx.StateGroup.MakeKey(e, t, i, a);\n      let r = this._stateGroups.get(s);\n      return r || (r = C32.New(C32.Gfx.StateGroup, this, e, t, i, a), this._stateGroups.set(s, r)), r.AddRef(), r;\n    }\n    ReleaseStateGroup(e) {\n      e.DecRef(), 0 === e._GetRefCount() && (this._currentStateGroup === e && (this._currentStateGroup = null), this._stateGroups.delete(e.GetKey()), e.Release());\n    }\n    _InitBlendModeData(e) {\n      C32.clearArray(this._blendModeTable), this._namedBlendModeMap.clear();\n      let t = 0;\n      for (const i of e) {\n        const a = i[0], s = i[1], r = i[2];\n        this._blendModeTable.push([s, r]), this._namedBlendModeMap.set(a, { number: t, srcBlend: s, destBlend: r }), t++;\n      }\n    }\n    _GetBlendByIndex(e) {\n      return this._blendModeTable[e];\n    }\n    GetSrcBlendByIndex(e) {\n      return this._GetBlendByIndex(e)[0];\n    }\n    GetDestBlendByIndex(e) {\n      return this._GetBlendByIndex(e)[1];\n    }\n    GetNamedBlend(e) {\n      const t = this._namedBlendModeMap.get(e);\n      if (void 0 === t) throw new Error(\"invalid blend name\");\n      return t;\n    }\n    NamedBlendToNumber(e) {\n      const t = this._namedBlendModeMap.get(e);\n      if (void 0 === t) throw new Error(\"invalid blend name\");\n      return t.number;\n    }\n    SetBaseZ(e) {\n      this._baseZ = e;\n    }\n    GetBaseZ() {\n      return this._baseZ;\n    }\n    SetCurrentZ(e) {\n      this._currentZ = e, this._currentStateGroup = null;\n    }\n    GetCurrentZ() {\n      return this._currentZ;\n    }\n    Line(e, t, i, a) {\n      const s = C32.angleTo(e, t, i, a), r = Math.sin(s), l = Math.cos(s), n = 0.5 * this._lineWidth, h = r * n, o = l * n, p = this._lineCap;\n      2 === p ? this.LinePreCalc_LineCap2(e, t, 0, i, a, 0, h, o) : 1 === p ? this.LinePreCalc_LineCap1(e, t, 0, i, a, 0, h, o) : this.LinePreCalc_LineCap0(e, t, 0, i, a, 0, h, o);\n    }\n    Line3D(e, t, i, a, s, r) {\n      const l = C32.angleTo(e, t, a, s), n = Math.sin(l), h = Math.cos(l), o = 0.5 * this._lineWidth, p = n * o, _ = h * o, c = this._lineCap;\n      2 === c ? this.LinePreCalc_LineCap2(e, t, i, a, s, r, p, _) : 1 === c ? this.LinePreCalc_LineCap1(e, t, i, a, s, r, p, _) : this.LinePreCalc_LineCap0(e, t, i, a, s, r, p, _);\n    }\n    LinePreCalc_LineCap2(e, t, i, a, s, r, l, n) {\n      const h = this._lineOffset, o = e + h - n, p = t + h - l, _ = a + h + n, c = s + h + l, u = 2 * n, d = 2 * l, C = o + l, m = p - n, L = o - l + u, f = p + n + d, g = _ + l, S = c - n, P = _ - l - u, G = c + n - d;\n      this.Quad3D2(C, m, i, g, S, r, P, G, r, L, f, i, defaultTexCoordsQuad);\n    }\n    LinePreCalc_LineCap1(e, t, i, a, s, r, l, n) {\n      const h = this._lineOffset, o = e + h - n, p = t + h - l, _ = a + h + n, c = s + h + l, u = o + l, d = p - n, C = o - l, m = p + n, L = _ + l, f = c - n, g = _ - l, S = c + n;\n      this.Quad3D2(u, d, i, L, f, r, g, S, r, C, m, i, defaultTexCoordsQuad);\n    }\n    LinePreCalc_LineCap0(e, t, i, a, s, r, l, n) {\n      const h = this._lineOffset, o = e + h, p = t + h, _ = a + h, c = s + h, u = o + l, d = p - n, C = o - l, m = p + n, L = _ + l, f = c - n, g = _ - l, S = c + n;\n      this.Quad3D2(u, d, i, L, f, r, g, S, r, C, m, i, defaultTexCoordsQuad);\n    }\n    TexturedLine(e, t, i, a, s, r) {\n      const l = C32.angleTo(e, t, i, a), n = Math.sin(l), h = Math.cos(l), o = 0.5 * this._lineWidth, p = n * o, _ = h * o, c = this._lineCap;\n      2 === c ? this.TexturedLinePreCalc_LineCap2(e, t, i, a, p, _, s, r) : 1 === c ? this.TexturedLinePreCalc_LineCap1(e, t, i, a, p, _, s, r) : this.TexturedLinePreCalc_LineCap0(e, t, i, a, p, _, s, r);\n    }\n    TexturedLinePreCalc_LineCap2(e, t, i, a, s, r, l, n) {\n      const h = this._lineOffset, o = e + h - r, p = t + h - s, _ = i + h + r, c = a + h + s, u = 2 * r, d = 2 * s, C = o + s, m = p - r, L = o - s + u, f = p + r + d, g = _ + s, S = c - r, P = _ - s - u, G = c + r - d;\n      tmpQuad.set(C, m, g, S, P, G, L, f), tmpRect.set(l, 0, n, 0), this.Quad3(tmpQuad, tmpRect);\n    }\n    TexturedLinePreCalc_LineCap1(e, t, i, a, s, r, l, n) {\n      const h = this._lineOffset, o = e + h - r, p = t + h - s, _ = i + h + r, c = a + h + s, u = o + s, d = p - r, C = o - s, m = p + r, L = _ + s, f = c - r, g = _ - s, S = c + r;\n      tmpQuad.set(u, d, L, f, g, S, C, m), tmpRect.set(l, 0, n, 0), this.Quad3(tmpQuad, tmpRect);\n    }\n    TexturedLinePreCalc_LineCap0(e, t, i, a, s, r, l, n) {\n      const h = this._lineOffset, o = e + h, p = t + h, _ = i + h, c = a + h, u = o + s, d = p - r, C = o - s, m = p + r, L = _ + s, f = c - r, g = _ - s, S = c + r;\n      tmpQuad.set(u, d, L, f, g, S, C, m), tmpRect.set(l, 0, n, 0), this.Quad3(tmpQuad, tmpRect);\n    }\n    LineRect(e, t, i, a) {\n      const s = 0.5 * this._lineWidth, r = this._lineCap;\n      2 === r ? this._LineRectPreCalc_LineCap2(e, t, i, a, s) : 1 === r ? this._LineRectPreCalc_LineCap1(e, t, i, a, s) : this._LineRectPreCalc_LineCap0(e, t, i, a, s);\n    }\n    _LineRectPreCalc_LineCap2(e, t, i, a, s) {\n      this.LinePreCalc_LineCap2(e, t, 0, i, t, 0, 0, s), this.LinePreCalc_LineCap2(i, t, 0, i, a, 0, s, 0), this.LinePreCalc_LineCap2(i, a, 0, e, a, 0, 0, -s), this.LinePreCalc_LineCap2(e, a, 0, e, t, 0, -s, 0);\n    }\n    _LineRectPreCalc_LineCap1(e, t, i, a, s) {\n      this.LinePreCalc_LineCap1(e, t, 0, i, t, 0, 0, s), this.LinePreCalc_LineCap1(i, t, 0, i, a, 0, s, 0), this.LinePreCalc_LineCap1(i, a, 0, e, a, 0, 0, -s), this.LinePreCalc_LineCap1(e, a, 0, e, t, 0, -s, 0);\n    }\n    _LineRectPreCalc_LineCap0(e, t, i, a, s) {\n      this.LinePreCalc_LineCap0(e, t, 0, i, t, 0, 0, s), this.LinePreCalc_LineCap0(i, t, 0, i, a, 0, s, 0), this.LinePreCalc_LineCap0(i, a, 0, e, a, 0, 0, -s), this.LinePreCalc_LineCap0(e, a, 0, e, t, 0, -s, 0);\n    }\n    LineRect2(e) {\n      this.LineRect(e.getLeft(), e.getTop(), e.getRight(), e.getBottom());\n    }\n    LineQuad(e) {\n      const t = C32.angleTo(e.getTlx(), e.getTly(), e.getTrx(), e.getTry()), i = Math.sin(t), a = Math.cos(t), s = 0.5 * this._lineWidth, r = i * s, l = a * s, n = this._lineCap;\n      2 === n ? this._LineQuadPreCalc_LineCap2(e, r, l) : 1 === n ? this._LineQuadPreCalc_LineCap1(e, r, l) : this._LineQuadPreCalc_LineCap0(e, r, l);\n    }\n    _LineQuadPreCalc_LineCap2(e, t, i) {\n      this.LinePreCalc_LineCap2(e.getTlx(), e.getTly(), 0, e.getTrx(), e.getTry(), 0, t, i), this.LinePreCalc_LineCap2(e.getTrx(), e.getTry(), 0, e.getBrx(), e.getBry(), 0, i, -t), this.LinePreCalc_LineCap2(e.getBrx(), e.getBry(), 0, e.getBlx(), e.getBly(), 0, -t, -i), this.LinePreCalc_LineCap2(e.getBlx(), e.getBly(), 0, e.getTlx(), e.getTly(), 0, -i, t);\n    }\n    _LineQuadPreCalc_LineCap1(e, t, i) {\n      this.LinePreCalc_LineCap1(e.getTlx(), e.getTly(), 0, e.getTrx(), e.getTry(), 0, t, i), this.LinePreCalc_LineCap1(e.getTrx(), e.getTry(), 0, e.getBrx(), e.getBry(), 0, i, -t), this.LinePreCalc_LineCap1(e.getBrx(), e.getBry(), 0, e.getBlx(), e.getBly(), 0, -t, -i), this.LinePreCalc_LineCap1(e.getBlx(), e.getBly(), 0, e.getTlx(), e.getTly(), 0, -i, t);\n    }\n    _LineQuadPreCalc_LineCap0(e, t, i) {\n      this.LinePreCalc_LineCap0(e.getTlx(), e.getTly(), 0, e.getTrx(), e.getTry(), 0, t, i), this.LinePreCalc_LineCap0(e.getTrx(), e.getTry(), 0, e.getBrx(), e.getBry(), 0, i, -t), this.LinePreCalc_LineCap0(e.getBrx(), e.getBry(), 0, e.getBlx(), e.getBly(), 0, -t, -i), this.LinePreCalc_LineCap0(e.getBlx(), e.getBly(), 0, e.getTlx(), e.getTly(), 0, -i, t);\n    }\n    SetLineWidth(e) {\n      this._lineWidth = e, this._lineWidthStack[this._lineWidthStack.length - 1] = e;\n    }\n    GetLineWidth() {\n      return this._lineWidth;\n    }\n    PushLineWidth(e) {\n      if (100 <= this._lineWidthStack.length) throw new Error(\"pushed too many line widths - check push/pop pairs\");\n      this._lineWidthStack.push(e), this._lineWidth = e;\n    }\n    PopLineWidth() {\n      if (this._lineWidthStack.length <= 1) throw new Error(\"cannot pop last line width - check push/pop pairs\");\n      this._lineWidthStack.pop(), this._lineWidth = this._lineWidthStack.at(-1);\n    }\n    SetLineCapButt() {\n      this._lineCap = 0, this._lineCapStack[this._lineCapStack.length - 1] = 0;\n    }\n    SetLineCapSquare() {\n      this._lineCap = 1, this._lineCapStack[this._lineCapStack.length - 1] = 0;\n    }\n    SetLineCapZag() {\n      this._lineCap = 2, this._lineCapStack[this._lineCapStack.length - 1] = 0;\n    }\n    PushLineCap(e) {\n      if (\"butt\" === e) this.PushLineCapButt();\n      else if (\"square\" === e) this.PushLineCapSquare();\n      else {\n        if (\"zag\" !== e) throw new Error(\"invalid line cap\");\n        this.PushLineCapZag();\n      }\n    }\n    PushLineCapButt() {\n      if (100 <= this._lineCapStack.length) throw new Error(\"pushed too many line caps - check push/pop pairs\");\n      this._lineCapStack.push(0), this._lineCap = 0;\n    }\n    PushLineCapSquare() {\n      if (100 <= this._lineCapStack.length) throw new Error(\"pushed too many line caps - check push/pop pairs\");\n      this._lineCapStack.push(1), this._lineCap = 1;\n    }\n    PushLineCapZag() {\n      if (100 <= this._lineCapStack.length) throw new Error(\"pushed too many line caps - check push/pop pairs\");\n      this._lineCapStack.push(2), this._lineCap = 2;\n    }\n    PopLineCap() {\n      if (this._lineCapStack.length <= 1) throw new Error(\"cannot pop last line cap - check push/pop pairs\");\n      this._lineCapStack.pop(), this._lineCap = this._lineCapStack.at(-1);\n    }\n    SetLineOffset(e) {\n      this._lineOffset = e, this._lineOffsetStack[this._lineOffsetStack.length - 1] = e;\n    }\n    GetLineOffset() {\n      return this._lineOffset;\n    }\n    PushLineOffset(e) {\n      if (100 <= this._lineOffsetStack.length) throw new Error(\"pushed too many line offsets - check push/pop pairs\");\n      this._lineOffsetStack.push(e), this._lineOffset = e;\n    }\n    PopLineOffset() {\n      if (this._lineOffsetStack.length <= 1) throw new Error(\"cannot pop last line offset - check push/pop pairs\");\n      this._lineOffsetStack.pop(), this._lineOffset = this._lineOffsetStack.at(-1);\n    }\n    ConvexPoly(t) {\n      const e = t.length / 2;\n      if (e < 3) throw new Error(\"need at least 3 points\");\n      const i = e - 2, a = i - 1, s = t[0], r = t[1];\n      for (let e2 = 0; e2 < i; e2 += 2) {\n        const l = 2 * e2, n = t[2 + l], h = t[3 + l], o = t[4 + l], p = t[5 + l];\n        if (e2 === a) this.Quad2(s, r, n, h, o, p, o, p);\n        else {\n          const _ = t[6 + l], c = t[7 + l];\n          this.Quad2(s, r, n, h, o, p, _, c);\n        }\n      }\n    }\n    GetNumVertexComponents() {\n      return 3;\n    }\n    Finish() {\n      this.EndBatch(true), this._frameNumber++;\n    }\n    GetFrameNumber() {\n      return this._frameNumber;\n    }\n    IncrementFrameNumber() {\n      this._frameNumber++;\n    }\n    SetMipmapsEnabled(e) {\n      this._enableMipmaps = !!e;\n    }\n    AreMipmapsEnabled() {\n      return this._enableMipmaps;\n    }\n    SetHasMajorPerformanceCaveat(e) {\n      this._hasMajorPerformanceCaveat = !!e;\n    }\n    HasMajorPerformanceCaveat() {\n      return this._hasMajorPerformanceCaveat;\n    }\n    IsWebGL() {\n      return false;\n    }\n    IsWebGPU() {\n      return false;\n    }\n    GetEstimatedBackBufferMemoryUsage() {\n    }\n    GetEstimatedRenderBufferMemoryUsage() {\n    }\n    GetEstimatedTextureMemoryUsage() {\n    }\n    GetEstimatedTotalMemoryUsage() {\n      return this.GetEstimatedBackBufferMemoryUsage() + this.GetEstimatedRenderBufferMemoryUsage() + this.GetEstimatedTextureMemoryUsage();\n    }\n    CreateRendererText() {\n      return C32.New(C32.Gfx.RendererText, this);\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.Gfx.ShaderProgramBase = class {\n    constructor(e, t) {\n      this._name = t.name, this._renderer = e, this._extendBoxHorizontal = t.extendBoxHorizontal || 0, this._extendBoxVertical = t.extendBoxVertical || 0, this._crossSampling = !!t.crossSampling, this._mustPreDraw = !!t.mustPreDraw, this._preservesOpaqueness = !!t.preservesOpaqueness, this._supports3dDirectRendering = !!t.supports3dDirectRendering, this._animated = !!t.animated, this._blendsBackground = !!t.blendsBackground, this._usesDepth = !!t.usesDepth, this._usesAnySrcRectOrPixelSize = false, this._needsPostDrawOrExtendBox = this._crossSampling || this._blendsBackground || 0 !== this._extendBoxHorizontal || 0 !== this._extendBoxVertical;\n    }\n    Release() {\n      this._renderer = null;\n    }\n    GetRenderer() {\n      return this._renderer;\n    }\n    GetName() {\n      return this._name;\n    }\n    ExtendsBox() {\n      return 0 !== this._extendBoxHorizontal || 0 !== this._extendBoxVertical;\n    }\n    GetBoxExtendHorizontal() {\n      return this._extendBoxHorizontal;\n    }\n    GetBoxExtendVertical() {\n      return this._extendBoxVertical;\n    }\n    UsesCrossSampling() {\n      return this._crossSampling;\n    }\n    MustPreDraw() {\n      return this._mustPreDraw;\n    }\n    PreservesOpaqueness() {\n      return this._preservesOpaqueness;\n    }\n    Supports3DDirectRendering() {\n      return this._supports3dDirectRendering;\n    }\n    IsAnimated() {\n      return this._animated;\n    }\n    BlendsBackground() {\n      return this._blendsBackground;\n    }\n    UsesDepth() {\n      return this._usesDepth;\n    }\n    UsesAnySrcRectOrPixelSize() {\n      return this._usesAnySrcRectOrPixelSize;\n    }\n    NeedsPostDrawOrExtendsBox() {\n      return this._needsPostDrawOrExtendBox;\n    }\n    UsesIsSrcTexRotated() {\n      return false;\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.Gfx.StateGroup = class {\n    constructor(e, r, t, s, o) {\n      this._renderer = e, this._refCount = 0, this._shaderProgram = null, this._shaderProgramName = \"\", this._blendMode = t, this._color = C32.New(C32.Color), this._color.set(s), this._zElevation = o, \"string\" == typeof r ? this._shaderProgramName = r : (this._shaderProgram = r, this._shaderProgramName = this._shaderProgram.GetName());\n    }\n    Release() {\n      if (0 < this._refCount) throw new Error(\"releasing state group still in use\");\n      this._renderer = null, this._shaderProgram = null, this._shaderProgramName = \"\";\n    }\n    Apply() {\n      const e = this._renderer;\n      e.SetProgram(this._shaderProgram), e.SetBlendMode(this._blendMode), e.SetColor(this._color), e.SetCurrentZ(this._zElevation), e._SetCurrentStateGroup(this);\n    }\n    GetKey() {\n      return C32.Gfx.StateGroup.MakeKey(this._shaderProgramName, this._blendMode, this._color, this._zElevation);\n    }\n    AddRef() {\n      ++this._refCount;\n    }\n    DecRef() {\n      --this._refCount;\n    }\n    _GetRefCount() {\n      return this._refCount;\n    }\n    OnContextLost() {\n      this._shaderProgram = null;\n    }\n    OnContextRestored(e) {\n      if (this._shaderProgram = e.GetShaderProgramByName(this._shaderProgramName), !this._shaderProgram) throw new Error(\"failed to restore shader program\");\n    }\n    static MakeKey(e, r, t, s) {\n      const o = \"string\" == typeof e ? e : e.GetName();\n      return o + \",\" + r + \",\" + t.getR() + \",\" + t.getG() + \",\" + t.getB() + \",\" + t.getA() + \",\" + s;\n    }\n  };\n}\n{\n  let interpolateQuad = function(t, e, s) {\n    const i = s.getTlx(), n = s.getTly(), o = s.getTrx() - i, h = s.getTry() - n, r = s.getBlx() - i, a = s.getBly() - n, l = o * t, _ = h * t, G = r * e, u = a * e;\n    return [i + l + G, n + _ + u];\n  };\n  interpolateQuad2 = interpolateQuad;\n  const C32 = self.C3, tempQuadTex = C32.New(C32.Quad);\n  C32.Gfx.MeshPoint = class {\n    constructor(t, e, s) {\n      this._mesh = t, this._col = e, this._row = s, this._x = NaN, this._y = NaN, this._zElevation = NaN, this._u = NaN, this._v = NaN, this._x = 0, this._y = 0, this._zElevation = 0, this._u = 0, this._v = 0;\n    }\n    _Init(t, e, s, i) {\n      this._x = t, this._y = e, this._u = s, this._v = i;\n    }\n    GetX() {\n      return this._x;\n    }\n    SetX(t) {\n      this._x !== t && (this._x = t, this._mesh._SetPointsChanged());\n    }\n    GetY() {\n      return this._y;\n    }\n    SetY(t) {\n      this._y !== t && (this._y = t, this._mesh._SetPointsChanged());\n    }\n    GetZElevation() {\n      return this._zElevation;\n    }\n    SetZElevation(t) {\n      this._zElevation !== t && (this._zElevation = Math.max(t, 0), this._mesh._SetPointsChanged());\n    }\n    GetU() {\n      return this._u;\n    }\n    SetU(t) {\n      this._u = t;\n    }\n    GetV() {\n      return this._v;\n    }\n    SetV(t) {\n      this._v = t;\n    }\n    _Interpolate_TexRect(t, e, s) {\n      [this._x, this._y] = interpolateQuad(t._x, t._y, e), this._zElevation = t._zElevation, this._u = C32.lerp(s.getLeft(), s.getRight(), t._u), this._v = C32.lerp(s.getTop(), s.getBottom(), t._v);\n    }\n    _Interpolate_TexQuad(t, e, s) {\n      [this._x, this._y] = interpolateQuad(t._x, t._y, e), this._zElevation = t._zElevation, [this._u, this._v] = interpolateQuad(t._u, t._v, s);\n    }\n    SaveToJson() {\n      return { \"x\": this.GetX(), \"y\": this.GetY(), \"z\": this.GetZElevation(), \"u\": this.GetU(), \"v\": this.GetV() };\n    }\n    LoadFromJson(t) {\n      this.SetX(t[\"x\"]), this.SetY(t[\"y\"]), t.hasOwnProperty(\"z\") && this.SetZElevation(t[\"z\"]), this.SetU(t[\"u\"]), this.SetV(t[\"v\"]);\n    }\n    GetMesh() {\n      return this._mesh;\n    }\n    GetColumn() {\n      return this._col;\n    }\n    GetRow() {\n      return this._row;\n    }\n  }, C32.Gfx.Mesh = class {\n    constructor(s, t, e) {\n      if (s < 2 || t < 2) throw new Error(\"invalid mesh size\");\n      this._hsize = s, this._vsize = t, this._owner = e || null, this._pts = [], this._minX = 0, this._minY = 0, this._maxX = 1, this._maxY = 1, this._maxZ = 0, this._pointsChanged = false;\n      const i = s - 1, n = t - 1;\n      for (let e2 = 0; e2 < t; ++e2) {\n        const o = [];\n        for (let t2 = 0; t2 < s; ++t2) {\n          const h = C32.New(C32.Gfx.MeshPoint, this, t2, e2), r = t2 / i, a = e2 / n;\n          h._Init(r, a, r, a), o.push(h);\n        }\n        this._pts.push(o);\n      }\n    }\n    Release() {\n      C32.clearArray(this._pts);\n    }\n    GetHSize() {\n      return this._hsize;\n    }\n    GetVSize() {\n      return this._vsize;\n    }\n    GetOwner() {\n      return this._owner;\n    }\n    _GetPoints() {\n      return this._pts;\n    }\n    _SetPointsChanged() {\n      this._pointsChanged = true;\n    }\n    _MaybeComputeBounds() {\n      if (this._pointsChanged) {\n        let t = 1 / 0, e = 1 / 0, s = -1 / 0, i = -1 / 0, n = 0;\n        for (const o of this._pts) for (const h of o) {\n          const r = h.GetX(), a = h.GetY();\n          t = Math.min(t, r), e = Math.min(e, a), s = Math.max(s, r), i = Math.max(i, a), n = Math.max(n, h.GetZElevation());\n        }\n        this._minX = t, this._minY = e, this._maxX = s, this._maxY = i, this._maxZ = n, this._pointsChanged = false;\n      }\n    }\n    GetMinX() {\n      return this._MaybeComputeBounds(), this._minX;\n    }\n    GetMinY() {\n      return this._MaybeComputeBounds(), this._minY;\n    }\n    GetMaxX() {\n      return this._MaybeComputeBounds(), this._maxX;\n    }\n    GetMaxY() {\n      return this._MaybeComputeBounds(), this._maxY;\n    }\n    GetMaxZ() {\n      return this._MaybeComputeBounds(), this._maxZ;\n    }\n    HasAnyZElevation() {\n      return 0 < this.GetMaxZ();\n    }\n    GetMeshPointAt(t, e) {\n      return t = Math.floor(t), e = Math.floor(e), t < 0 || t >= this._hsize || e < 0 || e >= this._vsize ? null : this._pts[e][t];\n    }\n    CalculateTransformedMesh(t, s, i) {\n      const n = i instanceof C32.Rect;\n      if (t.GetHSize() !== this.GetHSize() || t.GetVSize() !== this.GetVSize()) throw new Error(\"source mesh wrong size\");\n      const o = t._pts, h = this._pts;\n      for (let t2 = 0, e = h.length; t2 < e; ++t2) {\n        const r = o[t2], a = h[t2];\n        for (let t3 = 0, e2 = a.length; t3 < e2; ++t3) {\n          const l = r[t3], _ = a[t3];\n          n ? _._Interpolate_TexRect(l, s, i) : _._Interpolate_TexQuad(l, s, i);\n        }\n      }\n    }\n    Draw(n) {\n      const o = this._pts;\n      let h = o[0];\n      for (let t = 1, e = o.length; t < e; ++t) {\n        const r = o[t];\n        let s = h[0], i = r[0];\n        for (let t2 = 1, e2 = r.length; t2 < e2; ++t2) {\n          const a = h[t2], l = r[t2];\n          tempQuadTex.set(s.GetU(), s.GetV(), a.GetU(), a.GetV(), l.GetU(), l.GetV(), i.GetU(), i.GetV()), n.Quad3D2(s.GetX(), s.GetY(), s.GetZElevation(), a.GetX(), a.GetY(), a.GetZElevation(), l.GetX(), l.GetY(), l.GetZElevation(), i.GetX(), i.GetY(), i.GetZElevation(), tempQuadTex), s = a, i = l;\n        }\n        h = r;\n      }\n    }\n    Outline(h, r) {\n      r = r || ((t2, e, s) => [t2, e, s]);\n      const t = this._pts;\n      let a = t[0];\n      for (let n = 1, o = t.length; n < o; ++n) {\n        const l = t[n];\n        let s = a[0], i = l[0];\n        for (let t2 = 1, e = l.length; t2 < e; ++t2) {\n          const _ = a[t2], G = l[t2], [u, c, m] = r(s.GetX(), s.GetY(), s.GetZElevation()), [p, C, f] = r(_.GetX(), _.GetY(), _.GetZElevation()), [x, v, M] = r(G.GetX(), G.GetY(), G.GetZElevation()), [g, y, d] = r(i.GetX(), i.GetY(), i.GetZElevation());\n          h.Line3D(u, c, m, p, C, f), h.Line3D(u, c, m, x, v, M), h.Line3D(u, c, m, g, y, d), t2 === e - 1 && h.Line3D(p, C, f, x, v, M), n === o - 1 && h.Line3D(g, y, d, x, v, M), s = _, i = G;\n        }\n        a = l;\n      }\n    }\n    InsertPolyMeshVertices(t) {\n      const s = 1e-3, i = 0.99999999, n = t.pointsArr(), o = [], h = this.GetHSize() - 1, r = this.GetVSize() - 1, a = 1 / h, l = 1 / r, _ = h - 1, G = r - 1;\n      let u = n[0], c = n[1], m = C32.clamp(Math.floor(u * h), 0, _), p = C32.clamp(Math.floor(c * r), 0, G), C = true, f = 0, x = 0, v = 0;\n      let M = -1;\n      const g = () => {\n        u = C32.clamp(C32.lerp(u, f, v), 0, 1), c = C32.clamp(C32.lerp(c, x, v), 0, 1), o.push(u, c);\n      };\n      for (let t2 = 0, e = n.length; t2 < e; t2 += 2) {\n        u = n[t2], c = n[t2 + 1], o.push(u, c), m = C32.clamp(Math.floor(u * h), 0, _), p = C32.clamp(Math.floor(c * r), 0, G);\n        const y = (t2 + 2) % e;\n        for (f = n[y], x = n[1 + y], M = -1; ; ) {\n          if (1e6 < o.length) throw new Error(\"Too many mesh poly points\");\n          const d = m * a, z = p * l, E = (m + 1) * a, S = (p + 1) * l;\n          if (C = C32.isPointInTriangleInclusive(u, c, d, z, E, z, E, S), 0 !== M && 0 <= (v = C32.rayIntersectExtended(u, c, f, x, d, z, E, S, -s)) && v <= i) g(), C = !C, M = 0;\n          else if (0 < p && 2 !== M && 0 <= (v = C32.rayIntersectExtended(u, c, f, x, d, z, E, z, s)) && v <= i) g(), p--, C = false, M = 4;\n          else if (m < _ && 3 !== M && 0 <= (v = C32.rayIntersectExtended(u, c, f, x, E, z, E, S, s)) && v <= i) g(), m++, C = false, M = 1;\n          else if (0 < m && 1 !== M && 0 <= (v = C32.rayIntersectExtended(u, c, f, x, d, z, d, S, s)) && v <= i) g(), m--, C = true, M = 3;\n          else {\n            if (!(p < G && 4 !== M && 0 <= (v = C32.rayIntersectExtended(u, c, f, x, d, S, E, S, s)) && v <= i)) break;\n            g(), p++, C = true, M = 2;\n          }\n        }\n      }\n      return C32.New(C32.CollisionPoly, o);\n    }\n    TransformCollisionPoly(t, e) {\n      const s = this._TransformPolyPoints(t);\n      this._SimplifyPoly(s), e.setPoints(s);\n    }\n    _TransformPolyPoints(t) {\n      const s = [], i = t.pointsArr();\n      for (let t2 = 0, e = i.length; t2 < e; t2 += 2) {\n        const n = i[t2], o = i[t2 + 1], [h, r] = this.TransformPoint(n, o);\n        s.push(h, r);\n      }\n      return s;\n    }\n    TransformPoint(t, e) {\n      const s = this.GetHSize() - 1, i = this.GetVSize() - 1, n = 1 / s, o = 1 / i, h = C32.clamp(Math.floor(t * s), 0, s - 1), r = C32.clamp(Math.floor(e * i), 0, i - 1), a = h * n, l = r * o, _ = (h + 1) * n, G = (r + 1) * o, u = this.GetMeshPointAt(h, r), c = this.GetMeshPointAt(h + 1, r + 1), m = C32.isPointInTriangleInclusive(t, e, a, l, _, l, _, G), p = m ? a + n : a, C = m ? l : l + o, f = this.GetMeshPointAt(h + (m ? 1 : 0), r + (m ? 0 : 1)), [x, v, M] = C32.triangleCartesianToBarycentric(t, e, a, l, p, C, _, G);\n      return C32.triangleBarycentricToCartesian3d(x, v, M, u.GetX(), u.GetY(), u.GetZElevation(), f.GetX(), f.GetY(), f.GetZElevation(), c.GetX(), c.GetY(), c.GetZElevation());\n    }\n    _SimplifyPoly(s) {\n      const i = [];\n      let n = s[0], o = s[1], h = n - s.at(-2), r = o - s.at(-1);\n      for (let t = 0, e = s.length; t < e; t += 2) {\n        const a = (t + 2) % e, l = s[a], _ = s[1 + a], G = l - n, u = _ - o, c = Math.abs(G) < 1e-7 && Math.abs(h) < 1e-7 && Math.sign(u) === Math.sign(r), m = Math.abs(u) < 1e-7 && Math.abs(r) < 1e-7 && Math.sign(G) === Math.sign(h);\n        (!c && !m && 1e-3 < Math.abs(G / h - u / r) || 0 == G && 0 == u) && i.push(n, o), n = l, o = _, h = G, r = u;\n      }\n      6 <= i.length && i.length < s.length && C32.shallowAssignArray(s, i);\n    }\n    SaveToJson() {\n      return { \"cols\": this.GetHSize(), \"rows\": this.GetVSize(), \"points\": this._pts.map((t) => t.map((t2) => t2.SaveToJson())) };\n    }\n    LoadFromJson(t) {\n      const s = this.GetHSize(), i = this.GetVSize();\n      if (t[\"cols\"] !== s || t[\"rows\"] !== i) throw new Error(\"mesh data wrong size\");\n      const n = t[\"points\"];\n      for (let e = 0; e < i; ++e) {\n        const o = n[e];\n        for (let t2 = 0; t2 < s; ++t2) {\n          const h = this.GetMeshPointAt(t2, e);\n          h.LoadFromJson(o[t2]);\n        }\n      }\n    }\n  };\n}\nvar interpolateQuad2;\n{\n  let GetFormatSpecifiers = function(e, t) {\n    let i, r, a, s;\n    switch (e) {\n      case \"rgba8\":\n        i = t.RGBA8, r = t.RGBA, a = t.RGBA, s = t.UNSIGNED_BYTE;\n        break;\n      case \"rgb8\":\n        i = t.RGB8, r = t.RGB, a = t.RGB, s = t.UNSIGNED_BYTE;\n        break;\n      case \"rgba4\":\n        i = t.RGBA4, r = t.RGBA, a = t.RGBA, s = t.UNSIGNED_SHORT_4_4_4_4;\n        break;\n      case \"rgb5_a1\":\n        i = t.RGB5_A1, r = t.RGBA, a = t.RGBA, s = t.UNSIGNED_SHORT_5_5_5_1;\n        break;\n      case \"rgb565\":\n        i = t.RGB565, r = t.RGB, a = t.RGB, s = t.UNSIGNED_SHORT_5_6_5;\n        break;\n      default:\n        throw new Error(\"invalid pixel format\");\n    }\n    return { sizedinternalformat: i, internalformat: r, format: a, type: s };\n  };\n  GetFormatSpecifiers2 = GetFormatSpecifiers;\n  const C32 = self.C3, VALID_PIXEL_FORMATS = /* @__PURE__ */ new Set([\"rgba8\", \"rgb8\", \"rgba4\", \"rgb5_a1\", \"rgb565\"]), VALID_SAMPLINGS = /* @__PURE__ */ new Set([\"nearest\", \"bilinear\", \"trilinear\"]), VALID_MIPMAP_QUALITIES = /* @__PURE__ */ new Set([\"default\", \"low\", \"high\"]), VALID_WRAP_MODES = /* @__PURE__ */ new Set([\"clamp-to-edge\", \"repeat\", \"mirror-repeat\"]);\n  const CREATEFROM_DEFAULT_OPTIONS = { wrapX: \"clamp-to-edge\", wrapY: \"clamp-to-edge\", sampling: \"trilinear\", anisotropy: 0, pixelFormat: \"rgba8\", mipMap: true, mipMapQuality: \"default\", premultiplyAlpha: true, isSvg: false, width: -1, height: -1 }, UPDATE_DEFAULT_OPTIONS = { premultiplyAlpha: true, flipY: false }, allTextures = /* @__PURE__ */ new Set();\n  C32.Gfx.WebGLRendererTexture = class {\n    constructor(e) {\n      this._renderer = e, this._texture = null, this._width = 0, this._height = 0, this._isStatic = true, this._wrapX = \"clamp-to-edge\", this._wrapY = \"clamp-to-edge\", this._sampling = \"trilinear\", this._anisotropy = 0, this._pixelFormat = \"rgba8\", this._isMipMapped = false, this._mipMapQuality = \"default\", this._refCount = 0;\n    }\n    _CreateStatic(t, e) {\n      if (!(\"undefined\" != typeof HTMLImageElement && t instanceof HTMLImageElement || \"undefined\" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || \"undefined\" != typeof ImageBitmap && t instanceof ImageBitmap || \"undefined\" != typeof OffscreenCanvas && t instanceof OffscreenCanvas || t instanceof ImageData || t instanceof ArrayBuffer || null === t)) throw new Error(\"invalid texture source\");\n      if (e = Object.assign({}, CREATEFROM_DEFAULT_OPTIONS, e), this._texture) throw new Error(\"already created texture\");\n      if (this._wrapX = e.wrapX, this._wrapY = e.wrapY, this._sampling = e.sampling, this._anisotropy = e.anisotropy, this._pixelFormat = e.pixelFormat, this._isMipMapped = !!e.mipMap && this._renderer.AreMipmapsEnabled(), this._mipMapQuality = e.mipMapQuality, !VALID_WRAP_MODES.has(this._wrapX) || !VALID_WRAP_MODES.has(this._wrapY)) throw new Error(\"invalid wrap mode\");\n      if (!VALID_SAMPLINGS.has(this._sampling)) throw new Error(\"invalid sampling\");\n      if (!VALID_PIXEL_FORMATS.has(this._pixelFormat)) throw new Error(\"invalid pixel format\");\n      if (!VALID_MIPMAP_QUALITIES.has(this._mipMapQuality)) throw new Error(\"invalid mipmap quality\");\n      if (this._isStatic = true, t instanceof ArrayBuffer || null === t || e.isSvg) {\n        if (this._width = e.width, this._height = e.height, t instanceof ArrayBuffer && t.byteLength !== this._width * this._height * 4) throw new Error(\"ArrayBuffer wrong size\");\n      } else this._width = t.width, this._height = t.height;\n      if (this._width <= 0 || this._height <= 0) throw new Error(\"invalid texture data size\");\n      if (e.isSvg) {\n        const n = C32.CreateCanvas(this._width, this._height), _ = n.getContext(\"2d\");\n        _.drawImage(t, 0, 0, this._width, this._height), t = n;\n      }\n      const i = C32.isPOT(this._width) && C32.isPOT(this._height), r = this._renderer.GetMaxTextureSize();\n      if (this._width > r || this._height > r) throw new Error(\"texture data exceeds maximum texture size\");\n      const a = this._renderer.GetContext(), s = this._renderer.GetWebGLVersionNumber(), h = (this._texture = a.createTexture(), a.bindTexture(a.TEXTURE_2D, this._texture), a.pixelStorei(a[\"UNPACK_PREMULTIPLY_ALPHA_WEBGL\"], e.premultiplyAlpha), a.pixelStorei(a[\"UNPACK_FLIP_Y_WEBGL\"], false), GetFormatSpecifiers(this._pixelFormat, a));\n      if (this._renderer.SupportsNPOTTextures() || i || !this._IsTiled()) if (2 <= s) {\n        let e2;\n        e2 = this._isMipMapped ? Math.floor(Math.log2(Math.max(this._width, this._height)) + 1) : 1, a.texStorage2D(a.TEXTURE_2D, e2, h.sizedinternalformat, this._width, this._height), t instanceof ArrayBuffer ? a.texSubImage2D(a.TEXTURE_2D, 0, 0, 0, this._width, this._height, h.format, h.type, new Uint8Array(t)) : null !== t && a.texSubImage2D(a.TEXTURE_2D, 0, 0, 0, h.format, h.type, t);\n      } else t instanceof ArrayBuffer ? a.texImage2D(a.TEXTURE_2D, 0, h.internalformat, this._width, this._height, 0, h.format, h.type, new Uint8Array(t)) : null === t ? a.texImage2D(a.TEXTURE_2D, 0, h.internalformat, this._width, this._height, 0, h.format, h.type, null) : a.texImage2D(a.TEXTURE_2D, 0, h.internalformat, h.format, h.type, t);\n      else {\n        if (null === t) throw new Error(\"cannot pass null data when creating a NPOT tiled texture without NPOT support\");\n        if ((t = t instanceof ArrayBuffer ? new ImageData(new Uint8ClampedArray(t), this._width, this._height) : t) instanceof ImageData) {\n          const l = C32.CreateCanvas(this._width, this._height), T = l.getContext(\"2d\");\n          T.putImageData(t, 0, 0), t = l;\n        }\n        const o = C32.CreateCanvas(C32.nextHighestPowerOfTwo(this._width), C32.nextHighestPowerOfTwo(this._height)), p = o.getContext(\"2d\");\n        p.imageSmoothingEnabled = \"nearest\" !== this._sampling, p.drawImage(t, 0, 0, this._width, this._height, 0, 0, o.width, o.height), a.texImage2D(a.TEXTURE_2D, 0, h.internalformat, h.format, h.type, o);\n      }\n      null !== t && this._SetTextureParameters(a), a.bindTexture(a.TEXTURE_2D, null), this._renderer._ResetLastTexture(), this._refCount = 1, allTextures.add(this);\n    }\n    _CreateDynamic(e, t, i) {\n      if (i = Object.assign({}, CREATEFROM_DEFAULT_OPTIONS, i), this._texture) throw new Error(\"already created texture\");\n      if (this._wrapX = i.wrapX, this._wrapY = i.wrapY, this._sampling = i.sampling, this._pixelFormat = i.pixelFormat, this._isMipMapped = !!i.mipMap && this._renderer.AreMipmapsEnabled(), this._mipMapQuality = i.mipMapQuality, !VALID_WRAP_MODES.has(this._wrapX) || !VALID_WRAP_MODES.has(this._wrapY)) throw new Error(\"invalid wrap mode\");\n      if (!VALID_SAMPLINGS.has(this._sampling)) throw new Error(\"invalid sampling\");\n      if (!VALID_PIXEL_FORMATS.has(this._pixelFormat)) throw new Error(\"invalid pixel format\");\n      if (!VALID_MIPMAP_QUALITIES.has(this._mipMapQuality)) throw new Error(\"invalid mipmap quality\");\n      this._isStatic = false, this._width = Math.floor(e), this._height = Math.floor(t);\n      const r = C32.isPOT(this._width) && C32.isPOT(this._height), a = this._renderer.GetMaxTextureSize();\n      if (this._width <= 0 || this._height <= 0) throw new Error(\"invalid texture size\");\n      if (this._width > a || this._height > a) throw new Error(\"texture exceeds maximum texture size\");\n      if (!this._renderer.SupportsNPOTTextures() && this._IsTiled() && !r) throw new Error(\"non-power-of-two tiled textures not supported\");\n      const s = this._renderer.GetContext(), h = this._renderer.GetWebGLVersionNumber(), n = (this._texture = s.createTexture(), s.bindTexture(s.TEXTURE_2D, this._texture), s.pixelStorei(s[\"UNPACK_PREMULTIPLY_ALPHA_WEBGL\"], i.premultiplyAlpha), s.pixelStorei(s[\"UNPACK_FLIP_Y_WEBGL\"], false), GetFormatSpecifiers(this._pixelFormat, s)), _ = 2 <= h ? n.sizedinternalformat : n.internalformat;\n      s.texImage2D(s.TEXTURE_2D, 0, _, this._width, this._height, 0, n.format, n.type, null), this._SetTextureParameters(s), s.bindTexture(s.TEXTURE_2D, null), this._renderer._ResetLastTexture(), this._refCount = 1, allTextures.add(this);\n    }\n    _GetMipMapHint(e) {\n      if (\"default\" === this._mipMapQuality) return this._isStatic ? e.NICEST : e.FASTEST;\n      if (\"low\" === this._mipMapQuality) return e.FASTEST;\n      if (\"high\" === this._mipMapQuality) return e.NICEST;\n      throw new Error(\"invalid mipmap quality\");\n    }\n    _IsTiled() {\n      return \"clamp-to-edge\" !== this._wrapX || \"clamp-to-edge\" !== this._wrapY;\n    }\n    _GetTextureWrapMode(e, t) {\n      if (\"clamp-to-edge\" === t) return e.CLAMP_TO_EDGE;\n      if (\"repeat\" === t) return e.REPEAT;\n      if (\"mirror-repeat\" === t) return e.MIRRORED_REPEAT;\n      throw new Error(\"invalid wrap mode\");\n    }\n    _SetTextureParameters(e) {\n      const t = C32.isPOT(this._width) && C32.isPOT(this._height);\n      if (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, this._GetTextureWrapMode(e, this._wrapX)), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, this._GetTextureWrapMode(e, this._wrapY)), \"nearest\" === this._sampling) e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.NEAREST), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.NEAREST), this._isMipMapped = false;\n      else if (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.LINEAR), (t || this._renderer.SupportsNPOTTextures()) && this._isMipMapped) {\n        e.hint(e.GENERATE_MIPMAP_HINT, this._GetMipMapHint(e)), e.generateMipmap(e.TEXTURE_2D);\n        const r = \"trilinear\" === this._sampling && !this._renderer.HasMajorPerformanceCaveat();\n        e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, r ? e.LINEAR_MIPMAP_LINEAR : e.LINEAR_MIPMAP_NEAREST);\n      } else e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR), this._isMipMapped = false;\n      const i = this._renderer._GetAnisotropicExtension();\n      i && 0 < this._anisotropy && \"nearest\" !== this._sampling && e.texParameterf(e.TEXTURE_2D, i[\"TEXTURE_MAX_ANISOTROPY_EXT\"], Math.min(this._anisotropy, this._renderer._GetMaxAnisotropy()));\n    }\n    _Update(e, t) {\n      if (!(\"undefined\" != typeof HTMLImageElement && e instanceof HTMLImageElement || \"undefined\" != typeof HTMLVideoElement && e instanceof HTMLVideoElement || \"undefined\" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || \"undefined\" != typeof ImageBitmap && e instanceof ImageBitmap || \"undefined\" != typeof OffscreenCanvas && e instanceof OffscreenCanvas || e instanceof ImageData)) throw new Error(\"invalid texture source\");\n      if (!this._texture || this._refCount <= 0) throw new Error(\"texture not created\");\n      if (this._isStatic) throw new Error(\"cannot update static texture\");\n      t = Object.assign({}, UPDATE_DEFAULT_OPTIONS, t);\n      const i = e.width || e.videoWidth, r = e.height || e.videoHeight, a = this._renderer.GetWebGLVersionNumber(), s = this._renderer.GetContext(), h = (s.bindTexture(s.TEXTURE_2D, this._texture), s.pixelStorei(s[\"UNPACK_PREMULTIPLY_ALPHA_WEBGL\"], t.premultiplyAlpha), s.pixelStorei(s[\"UNPACK_FLIP_Y_WEBGL\"], !!t.flipY), GetFormatSpecifiers(this._pixelFormat, s)), n = 2 <= a ? h.sizedinternalformat : h.internalformat;\n      try {\n        if (this._width === i && this._height === r) {\n          const _ = C32.isPOT(this._width) && C32.isPOT(this._height);\n          s.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, h.format, h.type, e), (_ || this._renderer.SupportsNPOTTextures()) && this._isMipMapped && (s.hint(s.GENERATE_MIPMAP_HINT, this._GetMipMapHint(s)), s.generateMipmap(s.TEXTURE_2D));\n        } else {\n          this._width = i, this._height = r;\n          const o = C32.isPOT(this._width) && C32.isPOT(this._height);\n          if (!this._renderer.SupportsNPOTTextures() && this._IsTiled() && !o) throw new Error(\"non-power-of-two tiled textures not supported\");\n          s.texImage2D(s.TEXTURE_2D, 0, n, h.format, h.type, e), (o || this._renderer.SupportsNPOTTextures()) && this._isMipMapped && (s.hint(s.GENERATE_MIPMAP_HINT, this._GetMipMapHint(s)), s.generateMipmap(s.TEXTURE_2D));\n        }\n      } catch (e2) {\n        console.error(\"Error updating WebGL texture: \", e2);\n      }\n      s.bindTexture(s.TEXTURE_2D, null), this._renderer._ResetLastTexture();\n    }\n    _Delete() {\n      if (0 < this._refCount) throw new Error(\"texture still has references\");\n      if (!this._texture) throw new Error(\"already deleted texture\");\n      allTextures.delete(this);\n      const e = this._renderer.GetContext();\n      e.deleteTexture(this._texture), this._texture = null;\n    }\n    IsValid() {\n      return !!this._texture;\n    }\n    _GetTexture() {\n      return this._texture;\n    }\n    GetRenderer() {\n      return this._renderer;\n    }\n    AddReference() {\n      this._refCount++;\n    }\n    SubtractReference() {\n      if (this._refCount <= 0) throw new Error(\"no more references\");\n      this._refCount--;\n    }\n    GetReferenceCount() {\n      return this._refCount;\n    }\n    GetWidth() {\n      return this._width;\n    }\n    GetHeight() {\n      return this._height;\n    }\n    IsStatic() {\n      return this._isStatic;\n    }\n    GetEstimatedMemoryUsage() {\n      let e = this._width * this._height;\n      switch (this._pixelFormat) {\n        case \"rgba8\":\n          e *= 4;\n          break;\n        case \"rgb8\":\n          e *= 3;\n          break;\n        case \"rgba4\":\n        case \"rgb5_a1\":\n        case \"rgb565\":\n          e *= 2;\n      }\n      return this._isMipMapped && (e += Math.floor(e / 3)), e;\n    }\n    static OnContextLost() {\n      allTextures.clear();\n    }\n    static allTextures() {\n      return allTextures.values();\n    }\n  };\n}\nvar GetFormatSpecifiers2;\n{\n  const C32 = self.C3, assert = self.assert, glMatrix = self.glMatrix, vec3 = glMatrix.vec3, mat4 = glMatrix.mat4, VALID_SAMPLINGS = /* @__PURE__ */ new Set([\"nearest\", \"bilinear\", \"trilinear\"]), DEFAULT_RENDERTARGET_OPTIONS = { sampling: \"trilinear\", alpha: true, depth: false, isSampled: true, isDefaultSize: true, multisampling: 0 }, allRenderTargets = /* @__PURE__ */ new Set();\n  C32.Gfx.WebGLRenderTarget = class {\n    constructor(e) {\n      this._renderer = e, this._frameBuffer = null, this._frameBufferNoDepth = null, this._texture = null, this._renderBuffer = null, this._width = 0, this._height = 0, this._isDefaultSize = true, this._sampling = \"trilinear\", this._alpha = true, this._depth = false, this._isSampled = true, this._multisampling = 0, this._projectionMatrix = mat4.create(), this._lastFov = 0, this._lastNearZ = 0, this._lastFarZ = 0;\n    }\n    _Create(e, t, r) {\n      r = Object.assign({}, DEFAULT_RENDERTARGET_OPTIONS, r);\n      const i = this._renderer.GetWebGLVersionNumber();\n      if (this._texture || this._renderBuffer) throw new Error(\"already created render target\");\n      if (this._sampling = r.sampling, this._alpha = !!r.alpha, this._depth = !!r.depth, this._isSampled = !!r.isSampled, this._isDefaultSize = !!r.isDefaultSize, this._multisampling = r.multisampling, !VALID_SAMPLINGS.has(this._sampling)) throw new Error(\"invalid sampling\");\n      if (0 < this._multisampling && (i < 2 || this._isSampled)) throw new Error(\"invalid use of multisampling\");\n      if (i < 2 && (this._isSampled = true), this._width = e, this._height = t, this._width <= 0 || this._height <= 0) throw new Error(\"invalid render target size\");\n      this._CalculateProjection();\n      const s = this._renderer.GetContext();\n      if (this._frameBuffer = s.createFramebuffer(), this._depth && (this._frameBufferNoDepth = s.createFramebuffer()), this._isSampled) {\n        this._texture = this._renderer.CreateDynamicTexture(this._width, this._height, { sampling: this._sampling, pixelFormat: this._alpha ? \"rgba8\" : \"rgb8\", mipMap: false });\n        const a = this._texture._GetTexture();\n        s.bindFramebuffer(s.FRAMEBUFFER, this._frameBuffer), s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, a, 0), this._depth && (s.bindFramebuffer(s.FRAMEBUFFER, this._frameBufferNoDepth), s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, a, 0));\n      } else {\n        this._renderBuffer = s.createRenderbuffer(), s.bindRenderbuffer(s.RENDERBUFFER, this._renderBuffer);\n        const f = this._alpha ? s.RGBA8 : s.RGB8;\n        if (0 < this._multisampling) {\n          const n = s.getInternalformatParameter(s.RENDERBUFFER, f, s.SAMPLES);\n          if (n && n[0]) {\n            const _ = n[0];\n            this._multisampling > _ && (this._multisampling = _);\n          } else this._multisampling = 0;\n        }\n        0 === this._multisampling ? s.renderbufferStorage(s.RENDERBUFFER, f, this._width, this._height) : s.renderbufferStorageMultisample(s.RENDERBUFFER, this._multisampling, f, this._width, this._height), s.bindFramebuffer(s.FRAMEBUFFER, this._frameBuffer), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.RENDERBUFFER, this._renderBuffer), this._depth && (s.bindFramebuffer(s.FRAMEBUFFER, this._frameBufferNoDepth), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.RENDERBUFFER, this._renderBuffer)), s.bindRenderbuffer(s.RENDERBUFFER, null);\n      }\n      const h = this._renderer._GetDepthBuffer();\n      this._depth && h && (s.bindFramebuffer(s.FRAMEBUFFER, this._frameBuffer), this._renderer._CanSampleDepth() ? s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.TEXTURE_2D, h, 0) : s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.RENDERBUFFER, h)), s.bindFramebuffer(s.FRAMEBUFFER, null), allRenderTargets.add(this);\n    }\n    _Resize(e, t) {\n      if (this._width !== e || this._height !== t) {\n        this._width = e, this._height = t, this._CalculateProjection();\n        const r = this._renderer.GetContext(), i = (r.bindFramebuffer(r.FRAMEBUFFER, this._frameBuffer), this._texture ? this._texture._Update(new ImageData(this._width, this._height)) : (r.bindRenderbuffer(r.RENDERBUFFER, this._renderBuffer), r.renderbufferStorage(r.RENDERBUFFER, this._alpha ? r.RGBA8 : r.RGB8, this._width, this._height), r.bindRenderbuffer(r.RENDERBUFFER, null)), this._renderer._GetDepthBuffer());\n        this._depth && i && (this._renderer._CanSampleDepth() ? r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.TEXTURE_2D, i, 0) : r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.RENDERBUFFER, i)), r.bindFramebuffer(r.FRAMEBUFFER, null);\n      }\n    }\n    _Delete() {\n      if (!this._texture && !this._renderBuffer) throw new Error(\"already deleted render target\");\n      allRenderTargets.delete(this);\n      const e = this._renderer.GetContext(), t = (this._texture ? (e.bindFramebuffer(e.FRAMEBUFFER, this._frameBuffer), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, null, 0), this._depth && (e.bindFramebuffer(e.FRAMEBUFFER, this._frameBufferNoDepth), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, null, 0)), this._renderer.DeleteTexture(this._texture), this._texture = null) : this._renderBuffer && (e.bindFramebuffer(e.FRAMEBUFFER, this._frameBuffer), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.RENDERBUFFER, null), this._depth && (e.bindFramebuffer(e.FRAMEBUFFER, this._frameBufferNoDepth), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.RENDERBUFFER, null)), e.deleteRenderbuffer(this._renderBuffer), this._renderBuffer = null), e.bindFramebuffer(e.FRAMEBUFFER, null), 2 <= this._renderer.GetWebGLVersionNumber() && (e.bindFramebuffer(e.READ_FRAMEBUFFER, null), e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null)), e.deleteFramebuffer(this._frameBuffer), this._depth && e.deleteFramebuffer(this._frameBufferNoDepth), this._renderer.GetBatchState());\n      t.currentFramebuffer = null, this._frameBuffer = t.currentFramebufferNoDepth = null;\n    }\n    _CalculateProjection() {\n      this._renderer.CalculatePerspectiveMatrix(this._projectionMatrix, this._width / this._height), this._lastFov = this._renderer.GetFovY(), this._lastNearZ = this._renderer.GetNearZ(), this._lastFarZ = this._renderer.GetFarZ();\n    }\n    _GetFramebuffer() {\n      return this._frameBuffer;\n    }\n    _GetFramebufferNoDepth() {\n      return this._frameBufferNoDepth;\n    }\n    GetRenderer() {\n      return this._renderer;\n    }\n    GetTexture() {\n      return this._texture;\n    }\n    GetProjectionMatrix() {\n      return this._renderer.GetFovY() === this._lastFov && this._renderer.GetNearZ() === this._lastNearZ && this._renderer.GetFarZ() === this._lastFarZ || this._CalculateProjection(), this._projectionMatrix;\n    }\n    IsLinearSampling() {\n      return \"nearest\" !== this._sampling;\n    }\n    HasAlpha() {\n      return this._alpha;\n    }\n    IsSampled() {\n      return this._isSampled;\n    }\n    HasDepthBuffer() {\n      return this._depth;\n    }\n    GetWidth() {\n      return this._width;\n    }\n    GetHeight() {\n      return this._height;\n    }\n    IsDefaultSize() {\n      return this._isDefaultSize;\n    }\n    GetMultisampling() {\n      return this._multisampling;\n    }\n    GetOptions() {\n      const e = { sampling: this._sampling, alpha: this._alpha, isSampled: this._isSampled };\n      return this._isDefaultSize || (e.width = this._width, e.height = this._height), e;\n    }\n    IsCompatibleWithOptions(e) {\n      return \"nearest\" !== (e = Object.assign({}, DEFAULT_RENDERTARGET_OPTIONS, e)).sampling === this.IsLinearSampling() && !!e.alpha === this.HasAlpha() && !!e.depth === this.HasDepthBuffer() && !(2 <= this._renderer.GetWebGLVersionNumber() && !!e.isSampled !== this.IsSampled()) && (\"number\" == typeof e.width || \"number\" == typeof e.height ? !this.IsDefaultSize() && this.GetWidth() === Math.floor(e.width) && this.GetHeight() === Math.floor(e.height) : this.IsDefaultSize());\n    }\n    _GetWebGLTexture() {\n      return this._texture ? this._texture._GetTexture() : null;\n    }\n    GetEstimatedMemoryUsage() {\n      return this._texture ? this._texture.GetEstimatedMemoryUsage() : this._width * this._height * (this._alpha ? 4 : 3);\n    }\n    static async DebugReadPixelsToBlob(e, t) {\n      const r = await e.ReadBackRenderTargetToImageData(t, true);\n      return C32.ImageDataToBlob(r);\n    }\n    static OnContextLost() {\n      allRenderTargets.clear();\n    }\n    static allRenderTargets() {\n      return allRenderTargets.values();\n    }\n    static ResizeAll(e, t) {\n      for (const r of allRenderTargets) r.IsDefaultSize() && r._Resize(e, t);\n    }\n  };\n}\n{\n  const C32 = self.C3, glMatrix = self.glMatrix, vec3 = glMatrix.vec3, mat4 = glMatrix.mat4, RESERVED_UNIFORM_NAMES = /* @__PURE__ */ new Set([\"aPos\", \"aTex\", \"aPoints\", \"matP\", \"matMV\", \"samplerFront\", \"samplerBack\", \"samplerDepth\", \"destStart\", \"destEnd\", \"srcStart\", \"srcEnd\", \"srcOriginStart\", \"srcOriginEnd\", \"pixelSize\", \"seconds\", \"devicePixelRatio\", \"layerScale\", \"layerAngle\", \"layoutStart\", \"layoutEnd\", \"color\", \"color2_\", \"pointTexStart\", \"pointTexEnd\", \"zElevation\", \"tileSize\", \"tileSpacing\", \"outlineThickness\", \"zNear\", \"zFar\"]);\n  C32.Gfx.WebGLShaderProgram = class extends C32.Gfx.ShaderProgramBase {\n    static async Compile(e, t) {\n      const i = e.GetContext(), r = t.src, o = t.vertexSrc, n = t.name, a = i.createShader(i.FRAGMENT_SHADER), l = (i.shaderSource(a, r), i.compileShader(a), i.createShader(i.VERTEX_SHADER)), s = (i.shaderSource(l, o), i.compileShader(l), i.createProgram()), d = (i.attachShader(s, a), i.attachShader(s, l), i.bindAttribLocation(s, 0, \"aPos\"), i.bindAttribLocation(s, 1, \"aTex\"), i.bindAttribLocation(s, 2, \"aPoints\"), i.linkProgram(s), e._GetParallelShaderCompileExtension());\n      if (d ? await e._WaitForObjectReady(() => i.getProgramParameter(s, d[\"COMPLETION_STATUS_KHR\"])) : await C32.Wait(5), !i.getShaderParameter(a, i.COMPILE_STATUS)) {\n        const m = i.getShaderInfoLog(a);\n        throw i.deleteShader(a), i.deleteShader(l), i.deleteProgram(s), new Error(\"Error compiling fragment shader: \" + m);\n      }\n      if (!i.getShaderParameter(l, i.COMPILE_STATUS)) {\n        const h = i.getShaderInfoLog(l);\n        throw i.deleteShader(a), i.deleteShader(l), i.deleteProgram(s), new Error(\"Error compiling vertex shader: \" + h);\n      }\n      if (!i.getProgramParameter(s, i.LINK_STATUS)) {\n        const u = i.getProgramInfoLog(s);\n        throw i.deleteShader(a), i.deleteShader(l), i.deleteProgram(s), new Error(\"Error linking shader program: \" + u);\n      }\n      const c = C32.FilterUnprintableChars(i.getProgramInfoLog(s) || \"\").trim();\n      return c && !C32.IsStringAllWhitespace(c) && console.info(`[WebGL] Shader program '${n}' compilation log: `, c), i.deleteShader(a), i.deleteShader(l), s;\n    }\n    static async Create(e, t) {\n      const i = await C32.Gfx.WebGLShaderProgram.Compile(e, t);\n      return new C32.Gfx.WebGLShaderProgram(e, i, t);\n    }\n    constructor(e, t, i) {\n      super(e, i);\n      const r = e.GetContext(), o = e.GetBatchState(), n = (e.EndBatch(), r.useProgram(t), this._gl = r, this._shaderProgram = t, this._isDeviceTransform = \"<default-device-transform>\" === i.name, r.getAttribLocation(t, \"aPos\")), a = r.getAttribLocation(t, \"aTex\"), l = (this._locAPoints = r.getAttribLocation(t, \"aPoints\"), -1 !== n && (r.bindBuffer(r.ARRAY_BUFFER, e._vertexBuffer), r.vertexAttribPointer(n, e.GetNumVertexComponents(), r.FLOAT, false, 0, 0), r.enableVertexAttribArray(n)), -1 !== a && (r.bindBuffer(r.ARRAY_BUFFER, e._texcoordBuffer), r.vertexAttribPointer(a, 2, r.FLOAT, false, 0, 0), r.enableVertexAttribArray(a)), -1 !== this._locAPoints && (r.bindBuffer(r.ARRAY_BUFFER, e._pointBuffer), r.vertexAttribPointer(this._locAPoints, 4, r.FLOAT, false, 0, 0), r.enableVertexAttribArray(this._locAPoints)), r.bindBuffer(r.ARRAY_BUFFER, null), this._uMatP = new C32.Gfx.WebGLShaderUniform(this, \"matP\", \"mat4\"), this._uMatMV = new C32.Gfx.WebGLShaderUniform(this, \"matMV\", \"mat4\"), this._uColor = new C32.Gfx.WebGLShaderUniform(this, \"color\", \"vec4\"), this._uSamplerFront = new C32.Gfx.WebGLShaderUniform(this, \"samplerFront\", \"sampler\"), this._uPointTexStart = new C32.Gfx.WebGLShaderUniform(this, \"pointTexStart\", \"vec2\"), this._uPointTexEnd = new C32.Gfx.WebGLShaderUniform(this, \"pointTexEnd\", \"vec2\"), this._uZElevation = new C32.Gfx.WebGLShaderUniform(this, \"zElevation\", \"float\"), this._uTileSize = new C32.Gfx.WebGLShaderUniform(this, \"tileSize\", \"vec2\"), this._uTileSpacing = new C32.Gfx.WebGLShaderUniform(this, \"tileSpacing\", \"vec2\"), this._uColor2 = new C32.Gfx.WebGLShaderUniform(this, \"color2_\", \"vec4\"), this._uOutlineThickness = new C32.Gfx.WebGLShaderUniform(this, \"outlineThickness\", \"float\"), this._uSamplerBack = new C32.Gfx.WebGLShaderUniform(this, \"samplerBack\", \"sampler\"), this._uSamplerDepth = new C32.Gfx.WebGLShaderUniform(this, \"samplerDepth\", \"sampler\"), this._uDestStart = new C32.Gfx.WebGLShaderUniform(this, \"destStart\", \"vec2\"), this._uDestEnd = new C32.Gfx.WebGLShaderUniform(this, \"destEnd\", \"vec2\"), this._uSrcStart = new C32.Gfx.WebGLShaderUniform(this, \"srcStart\", \"vec2\"), this._uSrcEnd = new C32.Gfx.WebGLShaderUniform(this, \"srcEnd\", \"vec2\"), this._uSrcOriginStart = new C32.Gfx.WebGLShaderUniform(this, \"srcOriginStart\", \"vec2\"), this._uSrcOriginEnd = new C32.Gfx.WebGLShaderUniform(this, \"srcOriginEnd\", \"vec2\"), this._uPixelSize = new C32.Gfx.WebGLShaderUniform(this, \"pixelSize\", \"vec2\"), this._uSeconds = new C32.Gfx.WebGLShaderUniform(this, \"seconds\", \"float\"), this._uDevicePixelRatio = new C32.Gfx.WebGLShaderUniform(this, \"devicePixelRatio\", \"float\"), this._uLayerScale = new C32.Gfx.WebGLShaderUniform(this, \"layerScale\", \"float\"), this._uLayerAngle = new C32.Gfx.WebGLShaderUniform(this, \"layerAngle\", \"float\"), this._uLayoutStart = new C32.Gfx.WebGLShaderUniform(this, \"layoutStart\", \"vec2\"), this._uLayoutEnd = new C32.Gfx.WebGLShaderUniform(this, \"layoutEnd\", \"vec2\"), this._uZNear = new C32.Gfx.WebGLShaderUniform(this, \"zNear\", \"float\"), this._uZFar = new C32.Gfx.WebGLShaderUniform(this, \"zFar\", \"float\"), this._hasAnyOptionalUniforms = !!(this._uPixelSize.IsUsed() || this._uSeconds.IsUsed() || this._uSamplerBack.IsUsed() || this._uDestStart.IsUsed() || this._uDestEnd.IsUsed() || this._uSrcStart.IsUsed() || this._uSrcEnd.IsUsed() || this._uSrcOriginStart.IsUsed() || this._uSrcOriginEnd.IsUsed() || this._uDevicePixelRatio.IsUsed() || this._uLayerScale.IsUsed() || this._uLayerAngle.IsUsed() || this._uLayoutStart.IsUsed() || this._uLayoutEnd.IsUsed()), i.parameters || []);\n      this._uCustomParameters = [], this._usesAnySrcRectOrPixelSize = this._uPixelSize.IsUsed() || this._uSrcStart.IsUsed() || this._uSrcEnd.IsUsed() || this._uSrcOriginStart.IsUsed() || this._uSrcOriginEnd.IsUsed(), this._hasCurrentMatP = false, this._hasCurrentMatMV = false, this._uColor.Init4f(1, 1, 1, 1), this._uColor2.Init4f(1, 1, 1, 1), this._uSamplerFront.Init1i(0), this._uSamplerBack.Init1i(1), this._uSamplerDepth.Init1i(2), this._uPointTexStart.Init2f(0, 0), this._uPointTexEnd.Init2f(1, 1), this._uZElevation.Init1f(0), this._uTileSize.Init2f(0, 0), this._uTileSpacing.Init2f(0, 0), this._uDestStart.Init2f(0, 0), this._uDestEnd.Init2f(1, 1), this._uSrcStart.Init2f(0, 0), this._uSrcEnd.Init2f(0, 0), this._uSrcOriginStart.Init2f(0, 0), this._uSrcOriginEnd.Init2f(0, 0), this._uPixelSize.Init2f(0, 0), this._uDevicePixelRatio.Init1f(1), this._uZNear.Init1f(e.GetNearZ()), this._uZFar.Init1f(e.GetFarZ()), this._uLayerScale.Init1f(1), this._uLayerAngle.Init1f(0), this._uSeconds.Init1f(0), this._uLayoutStart.Init2f(0, 0), this._uLayoutEnd.Init2f(0, 0), this._uOutlineThickness.Init1f(1);\n      for (const d of l) {\n        const c = d[0], m = d[2], h = new C32.Gfx.WebGLShaderUniform(this, c, m);\n        \"color\" === m ? h.Init3f(0, 0, 0) : h.Init1f(0), this._uCustomParameters.push(h);\n      }\n      this._isDeviceTransform ? this._UpdateDeviceTransformUniforms(o.currentMatP) : (this.UpdateMatP(o.currentMatP, true), this.UpdateMatMV(o.currentMV, true));\n      const s = o.currentShader;\n      r.useProgram(s ? s._shaderProgram : null);\n    }\n    Release() {\n      this._gl.deleteProgram(this._shaderProgram), this._shaderProgram = null, this._renderer._RemoveShaderProgram(this), this._gl = null, super.Release();\n    }\n    GetWebGLContext() {\n      return this._gl;\n    }\n    GetShaderProgram() {\n      return this._shaderProgram;\n    }\n    GetParameterCount() {\n      return this._uCustomParameters.length;\n    }\n    GetParameterType(e) {\n      return e < 0 || e >= this._uCustomParameters.length ? null : this._uCustomParameters[e].GetType();\n    }\n    AreCustomParametersAlreadySetInBatch(i) {\n      for (let e = 0, t = i.length; e < t; ++e) if (!this._uCustomParameters[e].IsSetToCustomInBatch(i[e])) return false;\n      return true;\n    }\n    SetCustomParametersInBatch(i) {\n      for (let e = 0, t = i.length; e < t; ++e) this._uCustomParameters[e].SetBatchValueCustom(i[e]);\n    }\n    AreOptionalUniformsAlreadySetInBatch(e, t, i, r, o, n, a, l, s, d) {\n      return !this._uSamplerBack.IsUsed() && !(this._uPixelSize.IsUsed() && !this._uPixelSize.IsSetTo2InBatch(o, n) || this._uDestStart.IsUsed() && !this._uDestStart.IsSetTo2InBatch(e.getLeft(), e.getTop()) || this._uDestEnd.IsUsed() && !this._uDestEnd.IsSetTo2InBatch(e.getRight(), e.getBottom()) || this._uDevicePixelRatio.IsUsed() && !this._uDevicePixelRatio.IsSetTo1InBatch(a) || this._uLayerScale.IsUsed() && !this._uLayerScale.IsSetTo1InBatch(l) || this._uLayerAngle.IsUsed() && !this._uLayerAngle.IsSetTo1InBatch(s) || this._uSrcStart.IsUsed() && !this._uSrcStart.IsSetTo2InBatch(t.getLeft(), t.getTop()) || this._uSrcEnd.IsUsed() && !this._uSrcEnd.IsSetTo2InBatch(t.getRight(), t.getBottom()) || this._uSrcOriginStart.IsUsed() && !this._uSrcOriginStart.IsSetTo2InBatch(i.getLeft(), i.getTop()) || this._uSrcOriginEnd.IsUsed() && !this._uSrcOriginEnd.IsSetTo2InBatch(i.getRight(), i.getBottom()) || this._uLayoutStart.IsUsed() && !this._uLayoutStart.IsSetTo2InBatch(r.getLeft(), r.getTop()) || this._uLayoutEnd.IsUsed() && !this._uLayoutEnd.IsSetTo2InBatch(r.getTop(), r.getBottom()) || this._uSeconds.IsUsed() && !this._uSeconds.IsSetTo1InBatch(d));\n    }\n    SetOptionalUniformsInBatch(e, t, i, r, o, n, a, l, s, d) {\n      this._uSamplerBack.IsUsed() || (this._uPixelSize.IsUsed() && this._uPixelSize.SetBatch2(o, n), this._uDestStart.IsUsed() && this._uDestStart.SetBatch2(e.getLeft(), e.getTop()), this._uDestEnd.IsUsed() && this._uDestEnd.SetBatch2(e.getRight(), e.getBottom()), this._uDevicePixelRatio.IsUsed() && this._uDevicePixelRatio.SetBatch1(a), this._uLayerScale.IsUsed() && this._uLayerScale.SetBatch1(l), this._uLayerAngle.IsUsed() && this._uLayerAngle.SetBatch1(s), this._uSrcStart.IsUsed() && this._uSrcStart.SetBatch2(t.getLeft(), t.getTop()), this._uSrcEnd.IsUsed() && this._uSrcEnd.SetBatch2(t.getRight(), t.getBottom()), this._uSrcOriginStart.IsUsed() && this._uSrcOriginStart.SetBatch2(i.getLeft(), i.getTop()), this._uSrcOriginEnd.IsUsed() && this._uSrcOriginEnd.SetBatch2(i.getRight(), i.getBottom()), this._uLayoutStart.IsUsed() && this._uLayoutStart.SetBatch2(r.getLeft(), r.getTop()), this._uLayoutEnd.IsUsed() && this._uLayoutEnd.SetBatch2(r.getTop(), r.getBottom()), this._uSeconds.IsUsed() && this._uSeconds.SetBatch1(d));\n    }\n    UpdateMatP(e, t) {\n      this._hasCurrentMatP && !t || this._isDeviceTransform || (this._uMatP.IsUsed() && this._uMatP.UpdateMatrix4fv(e), this._hasCurrentMatP = true);\n    }\n    SetMatPStale() {\n      this._hasCurrentMatP = false;\n    }\n    UpdateMatMV(e, t) {\n      this._hasCurrentMatMV && !t || this._isDeviceTransform || (this._uMatMV.IsUsed() && this._uMatMV.UpdateMatrix4fv(e), this._hasCurrentMatMV = true);\n    }\n    SetMatMVStale() {\n      this._hasCurrentMatMV = false;\n    }\n    _UpdateDeviceTransformUniforms(e) {\n      if (!this._isDeviceTransform) throw new Error(\"not device transform shader\");\n      this._uMatP.UpdateMatrix4fv(e);\n      const t = this._renderer, i = t.GetWidth() / 2, r = t.GetHeight() / 2, o = t.CalculateLookAtModelView2(i, r, t.GetDefaultCameraZ(t.GetHeight()), i, r, 0, t.GetHeight());\n      this._uMatMV.UpdateMatrix4fv(o);\n    }\n    UpdateColor(e) {\n      this._uColor.IsUsed() && this._uColor.Update4f(e[0], e[1], e[2], e[3]);\n    }\n    static GetReservedUniformNames() {\n      return RESERVED_UNIFORM_NAMES;\n    }\n    static GetDefaultVertexShaderSource(e) {\n      const t = e ? \"highmedp\" : \"mediump\";\n      return [\"#ifdef GL_FRAGMENT_PRECISION_HIGH\", \"#define highmedp highp\", \"#else\", \"#define highmedp mediump\", \"#endif\", \"attribute highp vec3 aPos;\", `attribute ${t} vec2 aTex;`, `varying ${t} vec2 vTex;`, \"uniform highp mat4 matP;\", \"uniform highp mat4 matMV;\", \"void main(void) {\", `\tgl_Position = matP * matMV * vec4(aPos, 1.0);`, `\tvTex = aTex;`, \"}\"].join(\"\\n\");\n    }\n    static GetDefaultVertexShaderSource_WebGL2(e) {\n      const t = e ? \"highp\" : \"mediump\";\n      return [\"#version 300 es\", \"in highp vec3 aPos;\", `in ${t} vec2 aTex;`, `out ${t} vec2 vTex;`, \"uniform highp mat4 matP;\", \"uniform highp mat4 matMV;\", \"void main(void) {\", `\tgl_Position = matP * matMV * vec4(aPos, 1.0);`, `\tvTex = aTex;`, \"}\"].join(\"\\n\");\n    }\n    static GetTextureFillFragmentShaderSource_WebGL1_NoFragDepth() {\n      return [\"varying mediump vec2 vTex;\", \"uniform lowp vec4 color;\", \"uniform lowp sampler2D samplerFront;\", \"void main(void) {\", \"\tgl_FragColor = texture2D(samplerFront, vTex) * color;\", \"}\"].join(\"\\n\");\n    }\n    static GetTextureFillFragmentShaderSource_WebGL1_FragDepthEXT() {\n      return [\"#extension GL_EXT_frag_depth : enable\", \"varying mediump vec2 vTex;\", \"uniform lowp vec4 color;\", \"uniform lowp sampler2D samplerFront;\", \"void main(void) {\", \"\tgl_FragColor = texture2D(samplerFront, vTex) * color;\", \"\tgl_FragDepthEXT = (gl_FragColor.a == 0.0 ? 1.0 : gl_FragCoord.z);\", \"}\"].join(\"\\n\");\n    }\n    static GetTextureFillFragmentShaderSource_WebGL2() {\n      return [\"#version 300 es\", \"in mediump vec2 vTex;\", \"out lowp vec4 outColor;\", \"uniform lowp vec4 color;\", \"uniform lowp sampler2D samplerFront;\", \"void main(void) {\", \"\toutColor = texture(samplerFront, vTex) * color;\", \"\tgl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);\", \"}\"].join(\"\\n\");\n    }\n    static GetTilemapFragmentShaderSource_WebGL1_NoFragDepth() {\n      return [\"#ifdef GL_FRAGMENT_PRECISION_HIGH\", \"#define highmedp highp\", \"#else\", \"#define highmedp mediump\", \"#endif\", \"varying highmedp vec2 vTex;\", \"uniform lowp vec4 color;\", \"uniform lowp sampler2D samplerFront;\", \"uniform highmedp vec2 srcStart;\", \"uniform highmedp vec2 pixelSize;\", \"uniform highmedp vec2 tileSize;\", \"uniform highmedp vec2 tileSpacing;\", \"void main(void) {\", \"\thighmedp vec2 tile = floor(vTex);\", \"\thighmedp vec2 tex = fract(vTex);\", \"\thighmedp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);\", \"\thighmedp vec2 lowerBound = tileOrigin + pixelSize / 2.0;\", \"\thighmedp vec2 upperBound = tileOrigin + tileSize - pixelSize / 2.0;\", \"\tgl_FragColor = texture2D(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * color;\", \"}\"].join(\"\\n\");\n    }\n    static GetTilemapFragmentShaderSource_WebGL1_FragDepthEXT() {\n      return [\"#extension GL_EXT_frag_depth : enable\", \"#ifdef GL_FRAGMENT_PRECISION_HIGH\", \"#define highmedp highp\", \"#else\", \"#define highmedp mediump\", \"#endif\", \"varying highmedp vec2 vTex;\", \"uniform lowp vec4 color;\", \"uniform lowp sampler2D samplerFront;\", \"uniform highmedp vec2 srcStart;\", \"uniform highmedp vec2 pixelSize;\", \"uniform highmedp vec2 tileSize;\", \"uniform highmedp vec2 tileSpacing;\", \"void main(void) {\", \"\thighmedp vec2 tile = floor(vTex);\", \"\thighmedp vec2 tex = fract(vTex);\", \"\thighmedp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);\", \"\thighmedp vec2 lowerBound = tileOrigin + pixelSize / 2.0;\", \"\thighmedp vec2 upperBound = tileOrigin + tileSize - pixelSize / 2.0;\", \"\tgl_FragColor = texture2D(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * color;\", \"\tgl_FragDepthEXT = (gl_FragColor.a == 0.0 ? 1.0 : gl_FragCoord.z);\", \"}\"].join(\"\\n\");\n    }\n    static GetTilemapFragmentShaderSource_WebGL2() {\n      return [\"#version 300 es\", \"in highp vec2 vTex;\", \"out lowp vec4 outColor;\", \"uniform lowp vec4 color;\", \"uniform lowp sampler2D samplerFront;\", \"uniform highp vec2 srcStart;\", \"uniform highp vec2 pixelSize;\", \"uniform highp vec2 tileSize;\", \"uniform highp vec2 tileSpacing;\", \"void main(void) {\", \"\thighp vec2 tile = floor(vTex);\", \"\thighp vec2 tex = fract(vTex);\", \"\thighp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);\", \"\thighp vec2 lowerBound = tileOrigin + pixelSize / 2.0;\", \"\thighp vec2 upperBound = tileOrigin + tileSize - pixelSize / 2.0;\", \"\toutColor = texture(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * color;\", \"\tgl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);\", \"}\"].join(\"\\n\");\n    }\n    static GetTileRandomizationFragmentShaderSource(e, t, i) {\n      let r = \"\";\n      return 2 <= e ? r = \"#version 300 es\\n\" : (t && (r = \"#extension GL_EXT_frag_depth : enable\\n\"), i && (r += \"#extension GL_EXT_shader_texture_lod : enable\\n#extension GL_OES_standard_derivatives : enable\\n\")), r + `\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n#define highmedp highp\n#else\n#define highmedp mediump\n#endif\nprecision highmedp float;\n${2 <= e ? \"in\" : \"varying\"} vec2 vTex;\n${2 <= e ? \"out lowp vec4 outColor;\" : \"\"}\nuniform lowp vec4 color;\nuniform lowp sampler2D samplerFront;\nuniform vec2 pixelSize;\n\nuniform vec2 tileSize;\nuniform vec2 tileSpacing;\nuniform float outlineThickness;\n\nconst float PI = 3.1415926;\n\nlowp vec4 cospVec4(lowp vec4 a, lowp vec4 b, float x)\n{\n\treturn (a + b + (a - b) * cos(x * PI)) / 2.0;\n}\n\nvec3 randVec3(vec2 seed)\n{\n\treturn vec3(fract(sin(dot(seed.xy + vec2(0.1, 0.1), vec2(12.9898,78.233))) * 43758.5453),\n\t\t\t\tfract(sin(dot(seed.yx + vec2(0.1, 0.1), vec2(12.9898,-78.233))) * 43758.5453),\n\t\t\t\tfract(sin(dot(seed.xy + vec2(0.1, 0.1), vec2(-12.9898,-78.233))) * 43758.5453));\n}\n\nlowp vec4 sampleTile(vec2 tile, vec2 uv, vec2 ddx, vec2 ddy)\n{\n\tvec2 posRandom = tileSize;\n\tfloat angleRandom = outlineThickness;\n\t\n\tvec3 rand = (randVec3(floor(tile + 0.5)) - 0.5) * 2.0;\n\t\n\tfloat angle = angleRandom * rand.z * PI;\n\tfloat sin_a = sin(angle);\n\tfloat cos_a = cos(angle);\n\tfloat aspect = pixelSize.x / pixelSize.y;\n\n\tvec2 mid = tile + vec2(0.5, 0.5);\n\tvec2 dp = uv - mid;\n\tdp.x /= aspect;\n\tvec2 r = vec2(dp.x * cos_a - dp.y * sin_a,\n\t\t\t\t  dp.y * cos_a + dp.x * sin_a);\n\tr.x *= aspect;\n\n\tvec2 p = mid + r + (posRandom * rand.xy / 2.0);\n\t\n\t${2 <= e ? \"return textureGrad(samplerFront, p, ddx, ddy);\" : \"\"}\n\t${e < 2 && i ? \"return texture2DGradEXT(samplerFront, p, ddx, ddy);\" : \"\"}\n\t${e < 2 && !i ? \"return texture2D(samplerFront, p);\" : \"\"}\n}\n\nvoid main(void) {\n\t\n\t${e < 2 ? \"lowp vec4 outColor;\" : \"\"}\n\t\n\tfloat blendMarginX = tileSpacing.x;\n\tfloat blendMarginY = tileSpacing.y;\n\t\n\tvec2 tile = floor(vTex);\n\tvec2 tex = fract(vTex);\n\tvec2 ddx = ${2 <= e || i ? \"dFdx(vTex)\" : \"vec2(0.0, 0.0)\"};\n\tvec2 ddy = ${2 <= e || i ? \"dFdy(vTex)\" : \"vec2(0.0, 0.0)\"};\n\t\n\tvec4 curTile = sampleTile(tile, vTex, ddx, ddy);\n\t\n\tbool inLeftMargin = (tex.x < blendMarginX);\n\tbool inRightMargin = (tex.x > 1.0 - blendMarginX);\n\tbool inTopMargin = (tex.y < blendMarginY);\n\tbool inBottomMargin = (tex.y > 1.0 - blendMarginY);\n\t\n\tif (inLeftMargin)\n\t{\n\t\tlowp vec4 leftTile = sampleTile(tile + vec2(-1.0, 0.0), vTex, ddx, ddy);\n\t\tfloat leftMix = (tex.x / (blendMarginX * 2.0)) + 0.5;\n\t\tlowp vec4 leftMixedTile = cospVec4(leftTile, curTile, leftMix);\n\t\t\n\t\tif (inTopMargin)\n\t\t{\n\t\t\tlowp vec4 topTile =     sampleTile(tile + vec2(0.0,  -1.0), vTex, ddx, ddy);\n\t\t\tlowp vec4 topLeftTile = sampleTile(tile + vec2(-1.0, -1.0), vTex, ddx, ddy);\n\t\t\tlowp vec4 topLeftMixedTile = cospVec4(topLeftTile, topTile, leftMix);\n\t\t\t\n\t\t\toutColor = cospVec4(topLeftMixedTile, leftMixedTile, (tex.y / (blendMarginY * 2.0)) + 0.5);\n\t\t}\n\t\telse if (inBottomMargin)\n\t\t{\n\t\t\tlowp vec4 bottomTile =     sampleTile(tile + vec2(0.0,  1.0), vTex, ddx, ddy);\n\t\t\tlowp vec4 bottomLeftTile = sampleTile(tile + vec2(-1.0, 1.0), vTex, ddx, ddy);\n\t\t\tlowp vec4 bottomLeftMixedTile = cospVec4(bottomLeftTile, bottomTile, leftMix);\n\t\t\t\n\t\t\toutColor = cospVec4(leftMixedTile, bottomLeftMixedTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));\n\t\t}\n\t\telse\n\t\t{\n\t\t\toutColor = leftMixedTile;\n\t\t}\n\t}\n\telse if (inRightMargin)\n\t{\n\t\tlowp vec4 rightTile = sampleTile(tile + vec2(1.0, 0.0), vTex, ddx, ddy);\n\t\tfloat rightMix = (tex.x - (1.0 - blendMarginX)) / (blendMarginX * 2.0);\n\t\tlowp vec4 rightMixedTile = cospVec4(curTile, rightTile, rightMix);\n\t\t\n\t\tif (inTopMargin)\n\t\t{\n\t\t\tlowp vec4 topTile =      sampleTile(tile + vec2(0.0, -1.0), vTex, ddx, ddy);\n\t\t\tlowp vec4 topRightTile = sampleTile(tile + vec2(1.0, -1.0), vTex, ddx, ddy);\n\t\t\tlowp vec4 topRightMixedTile = cospVec4(topTile, topRightTile, rightMix);\n\t\t\t\n\t\t\toutColor = cospVec4(topRightMixedTile, rightMixedTile, (tex.y / (blendMarginY * 2.0)) + 0.5);\n\t\t}\n\t\telse if (inBottomMargin)\n\t\t{\n\t\t\tlowp vec4 bottomTile =      sampleTile(tile + vec2(0.0, 1.0), vTex, ddx, ddy);\n\t\t\tlowp vec4 bottomRightTile = sampleTile(tile + vec2(1.0, 1.0), vTex, ddx, ddy);\n\t\t\tlowp vec4 bottomRightMixedTile = cospVec4(bottomTile, bottomRightTile, rightMix);\n\t\t\t\n\t\t\toutColor = cospVec4(rightMixedTile, bottomRightMixedTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));\n\t\t}\n\t\telse\n\t\t{\n\t\t\toutColor = rightMixedTile;\n\t\t}\n\t}\n\telse if (inTopMargin)\n\t{\n\t\tlowp vec4 topTile = sampleTile(tile + vec2(0.0, -1.0), vTex, ddx, ddy);\n\t\toutColor = cospVec4(topTile, curTile, (tex.y / (blendMarginY * 2.0)) + 0.5);\n\t}\n\telse if (inBottomMargin)\n\t{\n\t\tlowp vec4 bottomTile = sampleTile(tile + vec2(0.0, 1.0), vTex, ddx, ddy);\n\t\toutColor = cospVec4(curTile, bottomTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));\n\t}\n\telse\n\t{\n\t\toutColor = curTile;\n\t}\n\t\n\toutColor *= color;\n\t${e < 2 ? \"gl_FragColor = outColor;\" : \"\"}\n\t${2 <= e ? \"gl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);\" : \"\"}\n\t${e < 2 && t ? \"gl_FragDepthEXT = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);\" : \"\"}\n}\n`;\n    }\n    static GetPointVertexShaderSource_WebGL1() {\n      return [\"attribute vec4 aPoints;\", \"varying float pointOpacity;\", \"uniform float zElevation;\", \"uniform mat4 matP;\", \"uniform mat4 matMV;\", \"void main(void) {\", \"\tgl_Position = matP * matMV * vec4(aPoints.xy, zElevation, 1.0);\", \"\tgl_PointSize = aPoints.z;\", \"\tpointOpacity = aPoints.w;\", \"}\"].join(\"\\n\");\n    }\n    static GetPointVertexShaderSource_WebGL2() {\n      return [\"#version 300 es\", \"in vec4 aPoints;\", \"out float pointOpacity;\", \"uniform float zElevation;\", \"uniform mat4 matP;\", \"uniform mat4 matMV;\", \"void main(void) {\", \"\tgl_Position = matP * matMV * vec4(aPoints.xy, zElevation, 1.0);\", \"\tgl_PointSize = aPoints.z;\", \"\tpointOpacity = aPoints.w;\", \"}\"].join(\"\\n\");\n    }\n    static GetPointFragmentShaderSource_WebGL1_NoFragDepth() {\n      return [\"uniform lowp sampler2D samplerFront;\", \"varying lowp float pointOpacity;\", \"uniform mediump vec2 pointTexStart;\", \"uniform mediump vec2 pointTexEnd;\", \"uniform lowp vec4 color;\", \"void main(void) {\", \"\tmediump vec2 pointTexMin = min(pointTexStart, pointTexEnd);\", \"\tmediump vec2 pointTexMax = max(pointTexStart, pointTexEnd);\", \"\tmediump vec2 pointCoord = (pointTexEnd.x > pointTexStart.x ? gl_PointCoord : vec2(1.0 - gl_PointCoord.y, gl_PointCoord.x));\", \"\tgl_FragColor = texture2D(samplerFront, mix(pointTexMin, pointTexMax, pointCoord)) * color * pointOpacity;\", \"}\"].join(\"\\n\");\n    }\n    static GetPointFragmentShaderSource_WebGL1_FragDepthEXT() {\n      return [\"#extension GL_EXT_frag_depth : enable\", \"uniform lowp sampler2D samplerFront;\", \"varying lowp float pointOpacity;\", \"uniform mediump vec2 pointTexStart;\", \"uniform mediump vec2 pointTexEnd;\", \"uniform lowp vec4 color;\", \"void main(void) {\", \"\tmediump vec2 pointTexMin = min(pointTexStart, pointTexEnd);\", \"\tmediump vec2 pointTexMax = max(pointTexStart, pointTexEnd);\", \"\tmediump vec2 pointCoord = (pointTexEnd.x > pointTexStart.x ? gl_PointCoord : vec2(1.0 - gl_PointCoord.y, gl_PointCoord.x));\", \"\tgl_FragColor = texture2D(samplerFront, mix(pointTexMin, pointTexMax, pointCoord)) * color * pointOpacity;\", \"\tgl_FragDepthEXT = (gl_FragColor.a == 0.0 ? 1.0 : gl_FragCoord.z);\", \"}\"].join(\"\\n\");\n    }\n    static GetPointFragmentShaderSource_WebGL2() {\n      return [\"#version 300 es\", \"uniform lowp sampler2D samplerFront;\", \"in lowp float pointOpacity;\", \"uniform mediump vec2 pointTexStart;\", \"uniform mediump vec2 pointTexEnd;\", \"uniform lowp vec4 color;\", \"out lowp vec4 outColor;\", \"void main(void) {\", \"\tmediump vec2 pointTexMin = min(pointTexStart, pointTexEnd);\", \"\tmediump vec2 pointTexMax = max(pointTexStart, pointTexEnd);\", \"\tmediump vec2 pointCoord = (pointTexEnd.x > pointTexStart.x ? gl_PointCoord : vec2(1.0 - gl_PointCoord.y, gl_PointCoord.x));\", \"\toutColor = texture(samplerFront, mix(pointTexMin, pointTexMax, pointCoord)) * color * pointOpacity;\", \"\tgl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);\", \"}\"].join(\"\\n\");\n    }\n    static GetColorFillFragmentShaderSource() {\n      return [\"uniform lowp vec4 color;\", \"void main(void) {\", \"\tgl_FragColor = color;\", \"}\"].join(\"\\n\");\n    }\n    static GetLinearGradientFillFragmentShaderSource() {\n      return [\"precision lowp float;\", \"varying mediump vec2 vTex;\", \"uniform vec4 color;\", \"uniform vec4 color2_;\", \"vec3 fromLinear(vec3 linearRGB)\", \"{\", \"\tbvec3 cutoff = lessThan(linearRGB, vec3(0.0031308));\", \"\tvec3 higher = vec3(1.055) * pow(abs(linearRGB), vec3(1.0/2.4)) - vec3(0.055);\", \"\tvec3 lower = linearRGB * vec3(12.92);\", \"\treturn mix(higher, lower, vec3(cutoff));\", \"}\", \"vec3 toLinear(vec3 sRGB)\", \"{\", \"\tbvec3 cutoff = lessThan(sRGB, vec3(0.04045));\", \"\tvec3 higher = pow(abs((sRGB + vec3(0.055))/vec3(1.055)), vec3(2.4));\", \"\tvec3 lower = sRGB/vec3(12.92);\", \"\treturn mix(higher, lower, vec3(cutoff));\", \"}\", \"void main(void) {\", \"\tvec3 linearGrad = mix(toLinear(color.rgb), toLinear(color2_.rgb), vTex.x);\", \"\tfloat a = mix(color.a, color2_.a, vTex.x);\", \"\tgl_FragColor = vec4(fromLinear(linearGrad) * a, a);\", \"}\"].join(\"\\n\");\n    }\n    static GetPenumbraFillFragmentShaderSource() {\n      return [\"#ifdef GL_FRAGMENT_PRECISION_HIGH\", \"#define highmedp highp\", \"#else\", \"#define highmedp mediump\", \"#endif\", \"precision lowp float;\", \"varying highmedp vec2 vTex;\", \"uniform vec4 color;\", \"void main(void) {\", `\thighmedp float grad = vTex.x / (1.0 - vTex.y);`, `\tgl_FragColor = color * (1.0 - (cos(grad * 3.141592653589793) + 1.0) / 2.0);`, \"}\"].join(\"\\n\");\n    }\n    static GetSmoothLineFillFragmentShaderSource() {\n      return [\"varying mediump vec2 vTex;\", \"uniform lowp vec4 color;\", \"void main(void) {\", \"\tlowp float f = 1.0 - abs(vTex.y - 0.5) * 2.0;\", \"\tgl_FragColor = color * f;\", \"}\"].join(\"\\n\");\n    }\n    static GetHardEllipseFillFragmentShaderSource() {\n      return [\"varying mediump vec2 vTex;\", \"uniform lowp vec4 color;\", \"void main(void) {\", \"\tmediump vec2 diff = vTex - vec2(0.5, 0.5);\", \"\tmediump vec2 diffSq = diff * diff;\", \"\tmediump float f = step(diffSq.x + diffSq.y, 0.25);\", \"\tgl_FragColor = color * f;\", \"}\"].join(\"\\n\");\n    }\n    static GetHardEllipseOutlineFragmentShaderSource() {\n      return [\"varying mediump vec2 vTex;\", \"uniform lowp vec4 color;\", \"uniform mediump vec2 pixelSize;\", \"uniform mediump float outlineThickness;\", \"void main(void) {\", \"\tmediump vec2 diff = vTex - vec2(0.5, 0.5);\", \"\tmediump vec2 diffSq = diff * diff;\", \"\tmediump float distSq = diffSq.x + diffSq.y;\", \"\tmediump vec2 norm = normalize(diff);\", \"\tmediump vec2 halfNorm = norm * 0.5;\", \"\tmediump float innerF = step(distSq, 0.25);\", \"\tmediump vec2 innerEdge = halfNorm - pixelSize * norm * outlineThickness;\", \"\tmediump vec2 innerEdgeSq = innerEdge * innerEdge;\", \"\tmediump float outerF = step(innerEdgeSq.x + innerEdgeSq.y, distSq);\", \"\tgl_FragColor = color * innerF * outerF;\", \"}\"].join(\"\\n\");\n    }\n    static GetSmoothEllipseFillFragmentShaderSource() {\n      return [\"varying mediump vec2 vTex;\", \"uniform lowp vec4 color;\", \"uniform mediump vec2 pixelSize;\", \"void main(void) {\", \"\tmediump vec2 diff = vTex - vec2(0.5, 0.5);\", \"\tmediump vec2 diffSq = diff * diff;\", \"\tmediump vec2 norm = normalize(diff);\", \"\tmediump vec2 halfNorm = norm * 0.5;\", \"\tmediump vec2 halfNormSq = halfNorm * halfNorm;\", \"\tmediump vec2 innerEdge = halfNorm - pixelSize * norm;\", \"\tmediump vec2 innerEdgeSq = innerEdge * innerEdge;\", \"\tmediump float f = smoothstep(halfNormSq.x + halfNormSq.y, innerEdgeSq.x + innerEdgeSq.y, diffSq.x + diffSq.y);\", \"\tgl_FragColor = color * f;\", \"}\"].join(\"\\n\");\n    }\n    static GetSmoothEllipseOutlineFragmentShaderSource() {\n      return [\"varying mediump vec2 vTex;\", \"uniform lowp vec4 color;\", \"uniform mediump vec2 pixelSize;\", \"uniform mediump float outlineThickness;\", \"void main(void) {\", \"\tmediump vec2 diff = vTex - vec2(0.5, 0.5);\", \"\tmediump vec2 diffSq = diff * diff;\", \"\tmediump float distSq = diffSq.x + diffSq.y;\", \"\tmediump vec2 norm = normalize(diff);\", \"\tmediump vec2 halfNorm = norm * 0.5;\", \"\tmediump vec2 halfNormSq = halfNorm * halfNorm;\", \"\tmediump vec2 pxNorm = pixelSize * norm;\", \"\tmediump vec2 innerEdge1 = halfNorm - pxNorm;\", \"\tmediump vec2 innerEdge1Sq = innerEdge1 * innerEdge1;\", \"\tmediump float innerF = smoothstep(halfNormSq.x + halfNormSq.y, innerEdge1Sq.x + innerEdge1Sq.y, distSq);\", \"\tmediump vec2 innerEdge2 = halfNorm - pxNorm * outlineThickness;\", \"\tmediump vec2 innerEdge2Sq = innerEdge2 * innerEdge2;\", \"\tmediump vec2 innerEdge3 = halfNorm - pxNorm * (outlineThickness + 1.0);\", \"\tmediump vec2 innerEdge3Sq = innerEdge3 * innerEdge3;\", \"\tmediump float outerF = smoothstep(innerEdge3Sq.x + innerEdge3Sq.y, innerEdge2Sq.x + innerEdge2Sq.y, distSq);\", \"\tgl_FragColor = color * innerF * outerF;\", \"}\"].join(\"\\n\");\n    }\n  };\n}\n{\n  const C32 = self.C3, glMatrix = self.glMatrix, mat4 = glMatrix.mat4, TYPE_SIZES = /* @__PURE__ */ new Map([[\"float\", 1], [\"percent\", 1], [\"sampler\", 1], [\"vec2\", 2], [\"vec3\", 3], [\"color\", 3], [\"vec4\", 4], [\"mat4\", 16]]);\n  C32.Gfx.WebGLShaderUniform = class {\n    constructor(t, s, a) {\n      if (!TYPE_SIZES.has(a)) throw new Error(\"invalid uniform type\");\n      this._owner = t, this._gl = this._owner.GetWebGLContext(), this._name = s, this._type = a, this._isColorType = \"color\" === this._type, this._location = this._gl.getUniformLocation(this._owner.GetShaderProgram(), s), this._isUsed = !!this._location;\n      const i = TYPE_SIZES.get(a);\n      this._lastValue = new Float32Array(i), this._lastBatchValue = new Float32Array(i);\n    }\n    Release() {\n      this._owner = null, this._gl = null, this._location = null;\n    }\n    IsUsed() {\n      return this._isUsed;\n    }\n    GetType() {\n      return this._type;\n    }\n    IsColorType() {\n      return this._isColorType;\n    }\n    Init1f(t) {\n      this.IsUsed() && (this._lastValue[0] = t, this._lastBatchValue.set(this._lastValue), this._gl.uniform1f(this._location, t));\n    }\n    Init1i(t) {\n      this.IsUsed() && (this._lastValue[0] = t, this._lastBatchValue.set(this._lastValue), this._gl.uniform1i(this._location, t));\n    }\n    Init2f(t, s) {\n      this.IsUsed() && (this._lastValue[0] = t, this._lastValue[1] = s, this._lastBatchValue.set(this._lastValue), this._gl.uniform2f(this._location, t, s));\n    }\n    Init3f(t, s, a) {\n      this.IsUsed() && (this._lastValue[0] = t, this._lastValue[1] = s, this._lastValue[2] = a, this._lastBatchValue.set(this._lastValue), this._gl.uniform3f(this._location, t, s, a));\n    }\n    Init4f(t, s, a, i) {\n      this.IsUsed() && (this._lastValue[0] = t, this._lastValue[1] = s, this._lastValue[2] = a, this._lastValue[3] = i, this._lastBatchValue.set(this._lastValue), this._gl.uniform4f(this._location, t, s, a, i));\n    }\n    Update1f(t) {\n      t = Math.fround(t);\n      const s = this._lastValue;\n      s[0] !== t && (s[0] = t, this._gl.uniform1f(this._location, t));\n    }\n    Update1i(t) {\n      const s = this._lastValue;\n      s[0] !== t && this._gl.uniform1i(this._location, s[0] = t);\n    }\n    Update2f(t, s) {\n      t = Math.fround(t), s = Math.fround(s);\n      const a = this._lastValue;\n      a[0] === t && a[1] === s || (a[0] = t, a[1] = s, this._gl.uniform2f(this._location, t, s));\n    }\n    Update3f(t, s, a) {\n      t = Math.fround(t), s = Math.fround(s), a = Math.fround(a);\n      const i = this._lastValue;\n      i[0] === t && i[1] === s && i[2] === a || (i[0] = t, i[1] = s, i[2] = a, this._gl.uniform3f(this._location, t, s, a));\n    }\n    Update4f(t, s, a, i) {\n      t = Math.fround(t), s = Math.fround(s), a = Math.fround(a), i = Math.fround(i);\n      const l = this._lastValue;\n      l[0] === t && l[1] === s && l[2] === a && l[3] === i || (l[0] = t, l[1] = s, l[2] = a, l[3] = i, this._gl.uniform4f(this._location, t, s, a, i));\n    }\n    UpdateMatrix4fv(t) {\n      const s = this._lastValue;\n      mat4.exactEquals(s, t) || (C32.typedArraySet16(s, t, 0), this._gl.uniformMatrix4fv(this._location, false, t));\n    }\n    IsSetToCustomInBatch(t) {\n      const s = this._lastBatchValue;\n      return this.IsColorType() ? s[0] === Math.fround(t.getR()) && s[1] === Math.fround(t.getG()) && s[2] === Math.fround(t.getB()) : s[0] === Math.fround(t);\n    }\n    SetBatchValueCustom(t) {\n      const s = this._lastBatchValue;\n      this.IsColorType() ? (s[0] = t.getR(), s[1] = t.getG(), s[2] = t.getB()) : s[0] = t;\n    }\n    IsSetTo1InBatch(t) {\n      return this._lastBatchValue[0] === Math.fround(t);\n    }\n    IsSetTo2InBatch(t, s) {\n      const a = this._lastBatchValue;\n      return a[0] === Math.fround(t) && a[1] === Math.fround(s);\n    }\n    SetBatch1(t) {\n      this._lastBatchValue[0] = t;\n    }\n    SetBatch2(t, s) {\n      const a = this._lastBatchValue;\n      a[0] = t, a[1] = s;\n    }\n  };\n}\n{\n  const C32 = self.C3, glMatrix = self.glMatrix, vec4 = glMatrix.vec4, mat4 = glMatrix.mat4, BATCH_NULL = 0, BATCH_QUAD = 1, BATCH_SETTEXTURE = 2, BATCH_SETCOLOR = 3, BATCH_SETBLEND = 4, BATCH_SETVIEWPORT = 5, BATCH_SETPROJECTION = 6, BATCH_SETMODELVIEW = 7, BATCH_SETRENDERTARGET = 8, BATCH_CLEARSURFACE = 9, BATCH_POINTS = 10, BATCH_SETPROGRAM = 11, BATCH_SETPROGRAMPARAMETERS = 12, BATCH_SETPROGRAMCUSTOMPARAMETERS = 13, BATCH_INVALIDATEFRAMEBUFFER = 14, BATCH_SETPOINTTEXCOORDS = 15, BATCH_SETTILEMAPINFO = 16, BATCH_BLITFRAMEBUFFER = 17, BATCH_STARTQUERY = 18, BATCH_ENDQUERY = 19, BATCH_SETELLIPSEPARAMS = 20, BATCH_SETGRADIENTCOLOR = 21, BATCH_CLEARDEPTH = 22, BATCH_SETDEPTHENABLED = 23, BATCH_SETDEPTHSAMPLINGENABLED = 24, BATCH_COPLANAR_STARTSTENCILPASS = 25, BATCH_COPLANAR_STARTCOLORPASS = 26, BATCH_COPLANAR_RESTORE = 27, BATCH_SET_SCISSOR = 28, BATCH_SETTILERANDOMIZATIONINFO = 29;\n  C32.Gfx.BatchState = class {\n    constructor(t) {\n      this.renderer = t, this.currentMV = mat4.create(), this.currentMatP = mat4.create(), this.currentFramebuffer = null, this.currentFramebufferNoDepth = null, this.isDepthSamplingEnabled = false, this.currentColor = vec4.fromValues(1, 1, 1, 1), this.currentShader = null, this.pointTexCoords = new C32.Rect(), this.clearColor = C32.New(C32.Color, 0, 0, 0, 0);\n    }\n  }, C32.Gfx.WebGLBatchJob = class {\n    constructor(t) {\n      const e = new ArrayBuffer(96);\n      this._type = 0, this._batchState = t, this._gl = t.renderer.GetContext(), this._startIndex = 0, this._indexCount = 0, this._texParam = null, this._mat4param = new Float32Array(e, 0, 16), this._colorParam = new Float32Array(e, 64, 4), this._srcOriginRect = new Float32Array(e, 80, 4), this._shaderParams = [];\n    }\n    InitQuad(t, e) {\n      this._type = BATCH_QUAD, this._startIndex = t, this._indexCount = e;\n    }\n    DoQuad() {\n      const t = this._gl;\n      t.drawElements(t.TRIANGLES, this._indexCount, t.UNSIGNED_SHORT, this._startIndex);\n    }\n    InitSetTexture(t) {\n      this._type = BATCH_SETTEXTURE, this._texParam = t;\n    }\n    DoSetTexture() {\n      const t = this._gl, e = this._texParam;\n      t.bindTexture(t.TEXTURE_2D, e ? e._GetTexture() : null);\n    }\n    InitSetColor(t) {\n      this._type = BATCH_SETCOLOR, t.writeToTypedArray(this._colorParam, 0);\n    }\n    DoSetColor() {\n      const t = this._colorParam, e = this._batchState;\n      vec4.copy(e.currentColor, t), e.currentShader.UpdateColor(t);\n    }\n    InitSetGradientColor(t) {\n      this._type = BATCH_SETGRADIENTCOLOR, t.writeToTypedArray(this._colorParam, 0);\n    }\n    DoSetGradientColor() {\n      const t = this._colorParam, e = this._batchState.currentShader;\n      e._uColor2.IsUsed() && e._uColor2.Update4f(t[0], t[1], t[2], t[3]);\n    }\n    InitSetBlend(t, e) {\n      this._type = BATCH_SETBLEND, this._startIndex = t, this._indexCount = e;\n    }\n    DoSetBlend() {\n      this._gl.blendFunc(this._startIndex, this._indexCount);\n    }\n    InitSetViewport(t, e, r, a) {\n      this._type = BATCH_SETVIEWPORT;\n      const s = this._colorParam;\n      s[0] = t, s[1] = e, s[2] = r, s[3] = a;\n    }\n    DoSetViewport() {\n      const t = this._colorParam;\n      this._gl.viewport(t[0], t[1], t[2], t[3]);\n    }\n    InitSetProjection(t) {\n      this._type = BATCH_SETPROJECTION, mat4.copy(this._mat4param, t);\n    }\n    DoSetProjection() {\n      const t = this._batchState, r = t.renderer._allShaderPrograms, a = t.currentShader, s = this._mat4param;\n      for (let t2 = 0, e = r.length; t2 < e; ++t2) {\n        const i = r[t2];\n        i === a ? i.UpdateMatP(s, true) : i.SetMatPStale();\n      }\n      mat4.copy(t.currentMatP, s);\n    }\n    InitSetModelView(t) {\n      this._type = BATCH_SETMODELVIEW, mat4.copy(this._mat4param, t);\n    }\n    DoSetModelView() {\n      const t = this._batchState, r = t.renderer._allShaderPrograms, a = t.currentShader, s = this._mat4param;\n      for (let t2 = 0, e = r.length; t2 < e; ++t2) {\n        const i = r[t2];\n        i === a ? i.UpdateMatMV(s, true) : i.SetMatMVStale();\n      }\n      mat4.copy(t.currentMV, s);\n    }\n    InitSetRenderTarget(t) {\n      this._type = BATCH_SETRENDERTARGET, this._texParam = t;\n    }\n    DoSetRenderTarget() {\n      const t = this._gl, e = this._texParam, r = this._batchState;\n      e ? (r.currentFramebuffer = e._GetFramebuffer(), r.currentFramebufferNoDepth = e._GetFramebufferNoDepth(), r.isDepthSamplingEnabled && r.currentFramebufferNoDepth ? t.bindFramebuffer(t.FRAMEBUFFER, r.currentFramebufferNoDepth) : t.bindFramebuffer(t.FRAMEBUFFER, r.currentFramebuffer)) : (r.currentFramebuffer = null, r.currentFramebufferNoDepth = null, t.bindFramebuffer(t.FRAMEBUFFER, null));\n    }\n    InitClearSurface(t) {\n      this._type = BATCH_CLEARSURFACE, t.writeToTypedArray(this._mat4param, 0);\n    }\n    InitClearSurface2(t, e, r, a) {\n      this._type = BATCH_CLEARSURFACE;\n      const s = this._mat4param;\n      s[0] = t, s[1] = e, s[2] = r, s[3] = a;\n    }\n    DoClearSurface() {\n      const t = this._gl, e = this._mat4param, r = this._batchState, a = r.clearColor, s = e[0], i = e[1], n = e[2], o = e[3];\n      a.equalsRgba(s, i, n, o) || (t.clearColor(s, i, n, o), a.setRgba(s, i, n, o)), t.clear(t.COLOR_BUFFER_BIT);\n    }\n    InitSetPointTexCoords(t) {\n      this._type = BATCH_SETPOINTTEXCOORDS, t.writeToTypedArray(this._mat4param, 0);\n    }\n    DoSetPointTextureCoords() {\n      const t = this._mat4param;\n      this._batchState.pointTexCoords.set(t[0], t[1], t[2], t[3]);\n    }\n    InitPoints(t, e) {\n      this._type = BATCH_POINTS, this._startIndex = t, this._indexCount = 1, this._mat4param[0] = e;\n    }\n    DoPoints() {\n      const t = this._gl, e = this._batchState, r = e.renderer, a = r._spPoints, s = (t.useProgram(a._shaderProgram), a.UpdateMatP(e.currentMatP, false), a.UpdateMatMV(e.currentMV, false), e.pointTexCoords), i = (a._uPointTexStart.IsUsed() && a._uPointTexStart.Update2f(s.getLeft(), s.getTop()), a._uPointTexEnd.IsUsed() && a._uPointTexEnd.Update2f(s.getRight(), s.getBottom()), this._mat4param[0]);\n      if (a._uZElevation.IsUsed() && a._uZElevation.Update1f(i), a._uColor.IsUsed()) {\n        const n = e.currentColor;\n        a._uColor.Update4f(n[0], n[1], n[2], n[3]);\n      }\n      t.drawArrays(t.POINTS, this._startIndex / 4, this._indexCount), t.useProgram(e.currentShader._shaderProgram);\n    }\n    InitSetProgram(t) {\n      this._type = BATCH_SETPROGRAM, this._texParam = t;\n    }\n    DoSetProgram() {\n      const t = this._gl, e = this._batchState, r = this._texParam;\n      if (e.currentShader = r, t.useProgram(r._shaderProgram), r.UpdateMatP(e.currentMatP, false), r.UpdateMatMV(e.currentMV, false), r._uColor.IsUsed()) {\n        const a = e.currentColor;\n        r._uColor.Update4f(a[0], a[1], a[2], a[3]);\n      }\n    }\n    InitSetProgramParameters() {\n      this._type = BATCH_SETPROGRAMPARAMETERS;\n    }\n    DoSetProgramParameters() {\n      const t = this._batchState.currentShader, e = this._gl, r = this._mat4param, a = this._colorParam, s = this._srcOriginRect;\n      if (t._uSamplerBack.IsUsed()) {\n        const i = this._batchState.renderer, n = this._texParam;\n        i._lastTexture1 !== n && (e.activeTexture(e.TEXTURE1), e.bindTexture(e.TEXTURE_2D, n ? n._GetTexture() : null), i._lastTexture1 = n, e.activeTexture(e.TEXTURE0));\n      }\n      t._uPixelSize.IsUsed() && t._uPixelSize.Update2f(r[0], r[1]), t._uDestStart.IsUsed() && t._uDestStart.Update2f(r[2], r[3]), t._uDestEnd.IsUsed() && t._uDestEnd.Update2f(r[4], r[5]), t._uDevicePixelRatio.IsUsed() && t._uDevicePixelRatio.Update1f(this._indexCount), t._uLayerScale.IsUsed() && t._uLayerScale.Update1f(r[6]), t._uLayerAngle.IsUsed() && t._uLayerAngle.Update1f(r[7]), t._uSrcStart.IsUsed() && t._uSrcStart.Update2f(r[12], r[13]), t._uSrcEnd.IsUsed() && t._uSrcEnd.Update2f(r[14], r[15]), t._uSrcOriginStart.IsUsed() && t._uSrcOriginStart.Update2f(s[0], s[1]), t._uSrcOriginEnd.IsUsed() && t._uSrcOriginEnd.Update2f(s[2], s[3]), t._uLayoutStart.IsUsed() && t._uLayoutStart.Update2f(a[0], a[1]), t._uLayoutEnd.IsUsed() && t._uLayoutEnd.Update2f(a[2], a[3]), t._uSeconds.IsUsed() && t._uSeconds.Update1f(this._startIndex);\n    }\n    InitSetProgramCustomParameters() {\n      this._type = BATCH_SETPROGRAMCUSTOMPARAMETERS;\n    }\n    DoSetProgramCustomParameters() {\n      const t = this._batchState.currentShader, r = t._uCustomParameters, a = this._shaderParams;\n      for (let t2 = 0, e = r.length; t2 < e; ++t2) {\n        const s = r[t2], i = a[t2];\n        s.IsColorType() ? s.Update3f(i.getR(), i.getG(), i.getB()) : s.Update1f(i);\n      }\n    }\n    InitInvalidateFramebuffer(t) {\n      this._type = BATCH_INVALIDATEFRAMEBUFFER, this._texParam = t;\n    }\n    DoInvalidateFramebuffer() {\n      const t = this._gl, e = this._texParam, r = this._batchState.currentFramebuffer;\n      e !== r && t.bindFramebuffer(t.FRAMEBUFFER, e), t.invalidateFramebuffer(t.FRAMEBUFFER, [t.COLOR_ATTACHMENT0]), e !== r && t.bindFramebuffer(t.FRAMEBUFFER, r);\n    }\n    InitBlitFramebuffer(t, e, r) {\n      this._type = BATCH_BLITFRAMEBUFFER;\n      const a = this._mat4param, s = this._batchState.renderer, i = (a[0] = t.GetWidth(), a[1] = t.GetHeight(), a[2] = (e || s).GetWidth(), a[3] = (e || s).GetHeight(), a[4] = t.IsLinearSampling() ? 1 : 0, a[5] = \"stretch\" === r, this._shaderParams);\n      C32.clearArray(i), i.push(t._GetFramebuffer()), i.push(e ? e._GetFramebuffer() : null);\n    }\n    DoBlitFramebuffer() {\n      const t = this._mat4param, e = this._shaderParams, r = this._gl, a = t[0], s = t[1], i = t[2], n = t[3], o = 0 !== t[4], _ = 0 !== t[5], h = e[0], S = e[1];\n      if (r.bindFramebuffer(r.READ_FRAMEBUFFER, h), r.bindFramebuffer(r.DRAW_FRAMEBUFFER, S), _) r.blitFramebuffer(0, 0, a, s, 0, 0, i, n, r.COLOR_BUFFER_BIT, o ? r.LINEAR : r.NEAREST);\n      else {\n        const T = Math.min(a, i), u = Math.min(s, n), d = Math.max(s - n, 0), E = Math.max(n - s, 0);\n        r.blitFramebuffer(0, d, T, u + d, 0, E, T, u + E, r.COLOR_BUFFER_BIT, r.NEAREST);\n      }\n    }\n    InitStartQuery(t) {\n      this._type = BATCH_STARTQUERY, this._texParam = t;\n    }\n    DoStartQuery() {\n      this._texParam.BeginTimeElapsed(), this._texParam = null;\n    }\n    InitEndQuery(t) {\n      this._type = BATCH_ENDQUERY, this._texParam = t;\n    }\n    DoEndQuery() {\n      this._texParam.EndTimeElapsed(), this._texParam = null;\n    }\n    InitSetEllipseParams(t, e, r) {\n      this._type = BATCH_SETELLIPSEPARAMS;\n      const a = this._mat4param;\n      a[0] = t, a[1] = e, a[2] = r;\n    }\n    DoSetEllipseParams() {\n      const t = this._batchState.currentShader, e = this._mat4param;\n      t._uPixelSize.IsUsed() && t._uPixelSize.Update2f(e[0], e[1]), t._uOutlineThickness.IsUsed() && t._uOutlineThickness.Update1f(e[2]);\n    }\n    InitSetTilemapInfo(t, e, r, a, s, i, n) {\n      this._type = BATCH_SETTILEMAPINFO;\n      const o = this._mat4param;\n      t.writeToTypedArray(o, 0), o[4] = 1 / e, o[5] = 1 / r, o[6] = a / e, o[7] = s / r, o[8] = i / e, o[9] = n / r;\n    }\n    DoSetTilemapInfo() {\n      const t = this._batchState.currentShader, e = this._mat4param;\n      t._uSrcStart.IsUsed() && t._uSrcStart.Update2f(e[0], e[1]), t._uPixelSize.IsUsed() && t._uPixelSize.Update2f(e[4], e[5]), t._uTileSize.IsUsed() && t._uTileSize.Update2f(e[6], e[7]), t._uTileSpacing.IsUsed() && t._uTileSpacing.Update2f(e[8], e[9]);\n    }\n    InitSetTileRandomizationInfo(t, e, r, a, s, i, n) {\n      this._type = BATCH_SETTILERANDOMIZATIONINFO;\n      const o = this._mat4param;\n      o[0] = 1 / t, o[1] = 1 / e, o[2] = r, o[3] = a, o[4] = s, o[5] = i, o[6] = n;\n    }\n    DoSetTileRandomizationInfo() {\n      const t = this._batchState.currentShader, e = this._mat4param;\n      t._uPixelSize.IsUsed() && t._uPixelSize.Update2f(e[0], e[1]), t._uTileSize.IsUsed() && t._uTileSize.Update2f(e[2], e[3]), t._uOutlineThickness.IsUsed() && t._uOutlineThickness.Update1f(e[4]), t._uTileSpacing.IsUsed() && t._uTileSpacing.Update2f(e[5], e[6]);\n    }\n    InitClearDepth(t) {\n      this._type = BATCH_CLEARDEPTH, this._startIndex = t ? 1 : 0;\n    }\n    DoClearDepth() {\n      const t = this._gl, e = 0 !== this._startIndex;\n      e || t.depthMask(true), t.clear(t.DEPTH_BUFFER_BIT), e || t.depthMask(false);\n    }\n    InitSetDepthEnabled(t) {\n      this._type = BATCH_SETDEPTHENABLED, this._startIndex = t ? 1 : 0;\n    }\n    DoSetDepthEnabled() {\n      const t = this._gl;\n      0 === this._startIndex ? (t.disable(t.DEPTH_TEST), t.depthMask(false)) : (t.enable(t.DEPTH_TEST), t.depthMask(true));\n    }\n    InitSetDepthSamplingEnabled(t) {\n      this._type = BATCH_SETDEPTHSAMPLINGENABLED, this._startIndex = t ? 1 : 0;\n    }\n    DoSetDepthSamplingEnabled() {\n      const t = this._gl, e = this._batchState, r = e.renderer, a = 0 !== this._startIndex;\n      e.isDepthSamplingEnabled = a, t.activeTexture(t.TEXTURE2), a ? (e.currentFramebufferNoDepth && t.bindFramebuffer(t.FRAMEBUFFER, e.currentFramebufferNoDepth), t.bindTexture(t.TEXTURE_2D, r._GetDepthBuffer())) : (t.bindTexture(t.TEXTURE_2D, null), e.currentFramebufferNoDepth && t.bindFramebuffer(t.FRAMEBUFFER, e.currentFramebuffer)), t.activeTexture(t.TEXTURE0);\n    }\n    InitCoplanarStartStencilPass() {\n      this._type = BATCH_COPLANAR_STARTSTENCILPASS;\n    }\n    DoCoplanarStartStencilPass() {\n      const t = this._gl;\n      t.clear(t.STENCIL_BUFFER_BIT), t.enable(t.STENCIL_TEST), t.stencilFunc(t.ALWAYS, 1, 1), t.stencilOp(t.KEEP, t.KEEP, t.REPLACE), t.colorMask(false, false, false, false);\n    }\n    InitCoplanarStartColorPass() {\n      this._type = BATCH_COPLANAR_STARTCOLORPASS;\n    }\n    DoCoplanarStartColorPass() {\n      const t = this._gl;\n      t.colorMask(true, true, true, true), t.stencilFunc(t.EQUAL, 1, 1), t.stencilOp(t.KEEP, t.KEEP, t.KEEP);\n    }\n    InitCoplanarRestore() {\n      this._type = BATCH_COPLANAR_RESTORE;\n    }\n    DoCoplanarRestore() {\n      const t = this._gl;\n      t.disable(t.STENCIL_TEST);\n    }\n    InitSetScissor(t, e, r, a, s) {\n      this._type = BATCH_SET_SCISSOR, this._startIndex = t ? 1 : 0;\n      const i = this._mat4param;\n      i[0] = e, i[1] = r, i[2] = a, i[3] = s;\n    }\n    DoSetScissor() {\n      const t = this._gl, e = this._mat4param;\n      1 === this._startIndex ? (t.enable(t.SCISSOR_TEST), t.scissor(e[0], e[1], e[2], e[3])) : t.disable(t.SCISSOR_TEST);\n    }\n    Run() {\n      switch (this._type) {\n        case 1:\n          return void this.DoQuad();\n        case 2:\n          return void this.DoSetTexture();\n        case 3:\n          return void this.DoSetColor();\n        case 4:\n          return void this.DoSetBlend();\n        case 5:\n          return void this.DoSetViewport();\n        case 6:\n          return void this.DoSetProjection();\n        case 7:\n          return void this.DoSetModelView();\n        case 8:\n          return void this.DoSetRenderTarget();\n        case 9:\n          return void this.DoClearSurface();\n        case 10:\n          return void this.DoPoints();\n        case 11:\n          return void this.DoSetProgram();\n        case 12:\n          return void this.DoSetProgramParameters();\n        case 13:\n          return void this.DoSetProgramCustomParameters();\n        case 14:\n          return void this.DoInvalidateFramebuffer();\n        case 15:\n          return void this.DoSetPointTextureCoords();\n        case 16:\n          return void this.DoSetTilemapInfo();\n        case 17:\n          return void this.DoBlitFramebuffer();\n        case 18:\n          return void this.DoStartQuery();\n        case 19:\n          return void this.DoEndQuery();\n        case 20:\n          return void this.DoSetEllipseParams();\n        case 21:\n          return void this.DoSetGradientColor();\n        case 22:\n          return void this.DoClearDepth();\n        case 23:\n          return void this.DoSetDepthEnabled();\n        case 24:\n          return void this.DoSetDepthSamplingEnabled();\n        case 25:\n          return void this.DoCoplanarStartStencilPass();\n        case 26:\n          return void this.DoCoplanarStartColorPass();\n        case 27:\n          return void this.DoCoplanarRestore();\n        case 28:\n          return void this.DoSetScissor();\n        case 29:\n          return void this.DoSetTileRandomizationInfo();\n      }\n    }\n  };\n}\n{\n  let fillOrStrokeRect = function(t, e, i, s, a, n) {\n    e ? t.strokeRect(i, s, a, n) : t.fillRect(i, s, a, n);\n  }, ptToPx = function(t) {\n    return t * (4 / 3);\n  }, getOffsetParam = function(t, e) {\n    t = t.trim();\n    const i = parseFloat(t);\n    return isFinite(i) ? t.endsWith(\"%\") ? e * i / 100 : i : 0;\n  };\n  fillOrStrokeRect2 = fillOrStrokeRect, ptToPx2 = ptToPx, getOffsetParam2 = getOffsetParam;\n  const C32 = self.C3, MAX_TEXTURE_SIZE = 4096, EXTRA_LINE_HEIGHT = 4, GENERIC_FONT_FAMILIES = /* @__PURE__ */ new Set([\"serif\", \"sans-serif\", \"monospace\", \"cursive\", \"fantasy\", \"system-ui\", \"ui-serif\", \"ui-sans-serif\", \"ui-monospace\", \"ui-rounded\", \"math\", \"emoji\", \"fangsong\"]), DEFAULT_OPTS = { timeout: 60 }, tempColor = new C32.Color(0, 0, 0, 1), VALID_HORIZ_ALIGNMENTS = /* @__PURE__ */ new Set([\"left\", \"center\", \"right\"]), VALID_VERT_ALIGNMENTS = /* @__PURE__ */ new Set([\"top\", \"center\", \"bottom\"]), VALID_WORD_WRAP_MODES = /* @__PURE__ */ new Set([\"word\", \"cjk\", \"character\"]), VALID_TEXT_DIRECTIONS = /* @__PURE__ */ new Set([\"ltr\", \"rtl\"]), allRendererTexts = /* @__PURE__ */ new Set();\n  C32.FontManager && C32.FontManager.addEventListener(\"fontload\", (t) => {\n    const e = t.font.GetName();\n    for (const i of allRendererTexts) (i.IsBBCodeEnabled() || C32.equalsNoCase(i.GetFontName(), e)) && i._SetWordWrapChanged();\n  });\n  let didCheckFoundBoundingBoxSupport = false, supportsFontBoundingBoxMeasurements = false;\n  C32.Gfx.RendererText = class {\n    constructor(t, e) {\n      e = Object.assign({}, DEFAULT_OPTS, e), this._renderer = t, this._fontName = \"Arial\", this._fontSize = 16, this._fontSizeScale = 1, this._lineHeight = 0, this._isBold = false, this._isItalic = false, this._colorStr = \"black\", this._isBBcodeEnabled = false, this._iconSet = null, this._iconSmoothing = true, this.onloadfont = null, this._alreadyLoadedFonts = /* @__PURE__ */ new Set(), this._horizontalAlign = \"left\", this._verticalAlign = \"top\", this._text = \"\", this._bbString = null, this._wrappedText = C32.New(C32.WordWrap), this._wrapMode = \"word\", this._textDirection = \"ltr\", this._wordWrapChanged = false, this._textLayoutChanged = false, this._drawChanged = false, this._drawMaxCharCount = -1, this._drawCharCount = 0, this._cssWidth = 0, this._cssHeight = 0, this._width = 0, this._height = 0, this._zoom = 1, this._textCanvas = null, this._textContext = null, this._measureContext = null, this._measureContextTop = null, this._lastCanvasWidth = -1, this._lastCanvasHeight = -1, this._lastTextCanvasFont = \"\", this._lastMeasureCanvasFont = \"\", this._lastTextCanvasFillStyle = \"\", this._lastTextCanvasOpacity = 1, this._lastTextCanvasLineWidth = 1, this._measureTextCallback = (t2) => this._MeasureText(t2), this._texture = null, this._rcTex = new C32.Rect(), this._scaleFactor = 1, this._textureTimeout = new C32.IdleTimeout(() => {\n        this.ReleaseTexture(), this._SetTextCanvasSize(8, 8);\n      }, e.timeout), this.ontextureupdate = null, this._wasReleased = false, allRendererTexts.add(this);\n    }\n    Release() {\n      this.onloadfont = null, this._alreadyLoadedFonts.clear(), this._iconSet = null, this._bbString = null, this._textCanvas = null, this._textContext = null, this._measureContext = null, this._measureContextTop = null, this._measureTextCallback = null, this._textureTimeout.Release(), this.ontextureupdate = null, this.ReleaseTexture(), this._wrappedText.Clear(), this._wrappedText = null, this._renderer = null, this._wasReleased = true, allRendererTexts.delete(this);\n    }\n    _SetDrawChanged() {\n      this._drawChanged = true;\n    }\n    _SetTextLayoutChanged() {\n      this._SetDrawChanged(), this._textLayoutChanged = true;\n    }\n    _SetWordWrapChanged() {\n      this._SetTextLayoutChanged(), this._wordWrapChanged = true;\n    }\n    SetBBCodeEnabled(t) {\n      if (this._isBBcodeEnabled !== (t = !!t)) {\n        this._isBBcodeEnabled = t;\n        const e = this._isBBcodeEnabled ? \"alphabetic\" : \"top\";\n        this._textContext && (this._textContext.textBaseline = e), this._measureContext && (this._measureContext.textBaseline = e), this._SetWordWrapChanged();\n      }\n    }\n    IsBBCodeEnabled() {\n      return this._isBBcodeEnabled;\n    }\n    SetIconSet(t) {\n      this._iconSet !== t && (this._iconSet = t, this._wrappedText.SetIconSet(t), this._iconSet && this._iconSet.IsLoading() && this._iconSet.LoadContent().then(() => this._SetDrawChanged()), this._SetWordWrapChanged());\n    }\n    SetIconSmoothing(t) {\n      this._iconSmoothing !== (t = !!t) && (this._iconSmoothing = t, this._SetDrawChanged());\n    }\n    SetFontName(t) {\n      this._fontName !== (t = t || \"serif\") && (this._fontName = t, this._SetWordWrapChanged());\n    }\n    GetFontName() {\n      return this._fontName;\n    }\n    SetFontSize(t) {\n      this._fontSize !== (t = t < 0.1 ? 0.1 : t) && (this._fontSize = t, this._SetWordWrapChanged());\n    }\n    GetFontSize() {\n      return this._fontSize;\n    }\n    SetFontSizeScale(t) {\n      this._fontSizeScale !== t && (this._fontSizeScale = t, this._SetWordWrapChanged());\n    }\n    SetLineHeight(t) {\n      this._lineHeight !== t && (this._lineHeight = t, this._SetTextLayoutChanged());\n    }\n    GetLineHeight() {\n      return this._lineHeight;\n    }\n    SetBold(t) {\n      this._isBold !== (t = !!t) && (this._isBold = t, this._SetWordWrapChanged());\n    }\n    IsBold() {\n      return this._isBold;\n    }\n    SetItalic(t) {\n      this._isItalic !== (t = !!t) && (this._isItalic = t, this._SetWordWrapChanged());\n    }\n    IsItalic() {\n      return this._isItalic;\n    }\n    SetDrawMaxCharacterCount(t) {\n      t = Math.floor(t), this._drawMaxCharCount !== t && (this._drawMaxCharCount = t, this._SetDrawChanged());\n    }\n    GetDrawMaxCharacterCount() {\n      return this._drawMaxCharCount;\n    }\n    _GetFontString(t, e) {\n      let i = [];\n      (this._isBold || e.HasStyleTag(\"b\")) && i.push(\"bold\"), (this._isItalic || e.HasStyleTag(\"i\")) && i.push(\"italic\");\n      const s = e.GetStyleTag(\"size\"), a = (s ? parseFloat(s.param) : this._fontSize) * this._fontSizeScale;\n      i.push(t ? a + \"pt\" : a * this.GetDrawScale() + \"pt\");\n      let n = this._fontName;\n      const h = e.GetStyleTag(\"font\");\n      return h && h.param && (n = h.param, this.onloadfont) && !this._alreadyLoadedFonts.has(n) && (this.onloadfont(n), this._alreadyLoadedFonts.add(n)), n && (GENERIC_FONT_FAMILIES.has(n) ? i.push(n) : i.push('\"' + n + '\"')), i.join(\" \");\n    }\n    SetColor(t) {\n      t instanceof C32.Color && (t = t.getCssRgb()), this._colorStr !== t && (this._colorStr = t, this._SetDrawChanged());\n    }\n    SetColorRgb(t, e, i) {\n      tempColor.setRgb(t, e, i), this.SetColor(tempColor);\n    }\n    SetHorizontalAlignment(t) {\n      if (!VALID_HORIZ_ALIGNMENTS.has(t)) throw new Error(\"invalid horizontal alignment\");\n      this._horizontalAlign !== t && (this._horizontalAlign = t, this._SetTextLayoutChanged());\n    }\n    GetHorizontalAlignment() {\n      return this._horizontalAlign;\n    }\n    SetVerticalAlignment(t) {\n      if (!VALID_VERT_ALIGNMENTS.has(t)) throw new Error(\"invalid vertical alignment\");\n      this._verticalAlign !== t && (this._verticalAlign = t, this._SetTextLayoutChanged());\n    }\n    GetVerticalAlignment() {\n      return this._verticalAlign;\n    }\n    SetWordWrapMode(t) {\n      if (!VALID_WORD_WRAP_MODES.has(t)) throw new Error(\"invalid word wrap mode\");\n      this._wrapMode !== t && (this._wrapMode = t, this._SetWordWrapChanged());\n    }\n    GetWordWrapMode() {\n      return this._wrapMode;\n    }\n    SetTextDirection(t) {\n      if (!VALID_TEXT_DIRECTIONS.has(t)) throw new Error(\"invalid text direction\");\n      this._textDirection !== t && (this._textDirection = t, this._textContext && (this._textContext.direction = this._textDirection), this._measureContext && (this._measureContext.direction = this._textDirection), this._SetWordWrapChanged());\n    }\n    GetTextDirection() {\n      return this._textDirection;\n    }\n    SetText(t) {\n      this._text !== t && (this._text = t, this._SetWordWrapChanged());\n    }\n    GetText() {\n      return this._text;\n    }\n    GetDrawScale() {\n      return this._scaleFactor * this._zoom * self.devicePixelRatio;\n    }\n    SetSize(e, i, s) {\n      if (void 0 === s && (s = 1), !(e <= 0 || this._cssWidth === e && this._cssHeight === i && this._zoom === s)) {\n        const a = this._cssWidth, n = (this._cssWidth = e, this._cssHeight = i, this._zoom = s, self.devicePixelRatio), h = (this._width = this._cssWidth * this._zoom * n, this._height = this._cssHeight * this._zoom * n, Math.max(this._width, this._height)), o = Math.min(this._renderer.GetMaxTextureSize(), MAX_TEXTURE_SIZE);\n        let t = 1;\n        o < h && (t = o / h, this._width = Math.min(this._width * t, o), this._height = Math.min(this._height * t, o)), this._scaleFactor = t, this._cssWidth !== a ? this._SetWordWrapChanged() : this._SetTextLayoutChanged();\n      }\n    }\n    GetWidth() {\n      return this._width;\n    }\n    GetHeight() {\n      return this._height;\n    }\n    GetZoom() {\n      return this._zoom;\n    }\n    GetTextWidth() {\n      return this._UpdateTextMeasurements(), this._wrappedText.GetMaxLineWidth();\n    }\n    GetTextHeight() {\n      return this._UpdateTextMeasurements(), this._wrappedText.GetTotalLineHeight() + this._wrappedText.GetLineCount() * (this._lineHeight + EXTRA_LINE_HEIGHT) - this._lineHeight;\n    }\n    GetLengthInGraphemes() {\n      this._UpdateTextMeasurements();\n      let t = 0;\n      for (const e of this._wrappedText.GetLines()) for (const i of e.fragments()) t += i.GetLength();\n      return t;\n    }\n    GetTexture() {\n      return this._textureTimeout.Reset(), this._MaybeUpdate(), this._texture;\n    }\n    HitTestFragment(t, e) {\n      this._UpdateTextMeasurements();\n      const i = this.GetDrawScale(), s = this._wrappedText.GetLines();\n      for (const a of s) {\n        const n = a.GetFontBoundingBoxDescent() * i;\n        if (e >= a.GetPosY() - a.GetHeight() * i + n && e < a.GetPosY() + n) {\n          for (const h of a.fragments()) if (t >= h.GetPosX() && t < h.GetPosX() + h.GetWidth() * i) return h;\n        }\n      }\n      return null;\n    }\n    *fragmentsWithTag(t) {\n      this._UpdateTextMeasurements();\n      const e = this._wrappedText.GetLines();\n      for (const i of e) for (const s of i.fragments()) {\n        const a = s.GetStyleTag(\"tag\");\n        a && C32.equalsNoCase(a.param, t) && (yield s);\n      }\n    }\n    FindFragmentWithTag(t, e) {\n      for (const i of this.fragmentsWithTag(t)) {\n        if (0 === e) return i;\n        --e;\n      }\n      return null;\n    }\n    CountFragmentsWithTag(t) {\n      let e = 0;\n      for (const i of this.fragmentsWithTag(t)) ++e;\n      return e;\n    }\n    _MaybeUpdate() {\n      this._texture && !this._drawChanged && !this._textLayoutChanged && !this._wordWrapChanged || this._wasReleased || this._width <= 0 || this._height <= 0 || (this._drawChanged = false, this._DoUpdate());\n    }\n    _DoUpdate() {\n      this._wasReleased || (this._UpdateTextMeasurements(), this._SetTextCanvasSize(Math.max(C32.nextHighestPowerOfTwo(Math.ceil(this._width)), 128), Math.max(C32.nextHighestPowerOfTwo(Math.ceil(this._height)), 64)), this._DrawTextToCanvas(), this._UpdateTexture(), this._textureTimeout.Reset());\n    }\n    _SetTextCanvasSize(t, e) {\n      this._textCanvas || (this._textCanvas = C32.CreateCanvas(16, 16));\n      let i = false;\n      this._lastCanvasWidth === t && this._lastCanvasHeight === e || (this._lastCanvasWidth = t, this._lastCanvasHeight = e, this._textCanvas.width = t, this._textCanvas.height = e, i = true), this._textContext || (this._textContext = this._textCanvas.getContext(\"2d\"), i = true), i ? (this._textContext.textBaseline = this._isBBcodeEnabled ? \"alphabetic\" : \"top\", this._textContext.direction = this._textDirection, this._textContext.font = this._lastTextCanvasFont, this._textContext.fillStyle = this._lastTextCanvasFillStyle, this._textContext.strokeStyle = this._lastTextCanvasFillStyle, this._textContext.globalAlpha = this._lastTextCanvasOpacity, this._textContext.lineWidth = this._lastTextCanvasLineWidth) : this._textContext.clearRect(0, 0, t, e);\n    }\n    _MaybeCreateMeasureContext() {\n      this._measureContext || (this._measureContext = C32.CreateCanvas(16, 16).getContext(\"2d\"), this._measureContextTop = C32.CreateCanvas(16, 16).getContext(\"2d\"), this._measureContext.textBaseline = this._isBBcodeEnabled ? \"alphabetic\" : \"top\", this._measureContextTop.textBaseline = \"top\", this._measureContext.direction = this._textDirection, this._measureContextTop.direction = this._textDirection);\n    }\n    _SetMeasureFontString(t) {\n      this._lastMeasureCanvasFont !== t && (this._lastMeasureCanvasFont = t, this._measureContext.font = t, this._measureContextTop.font = t);\n    }\n    _SupportsFontBoundingBoxMeasurements() {\n      if (!didCheckFoundBoundingBoxSupport) {\n        didCheckFoundBoundingBoxSupport = true, this._MaybeCreateMeasureContext();\n        const t = this._measureContext.measureText(\"test\");\n        supportsFontBoundingBoxMeasurements = \"number\" == typeof t[\"fontBoundingBoxAscent\"] && \"number\" == typeof t[\"fontBoundingBoxDescent\"];\n      }\n      return supportsFontBoundingBoxMeasurements;\n    }\n    _UpdateTextMeasurements() {\n      this._UpdateWordWrap(), this._UpdateTextLayout();\n    }\n    _UpdateWordWrap() {\n      this._wordWrapChanged && (this._MaybeCreateMeasureContext(), !this._isBBcodeEnabled || this._bbString && this._bbString.toString() === this._text || (this._bbString = new C32.BBString(this._text, { noEscape: true })), this._wrappedText.WordWrap(this._isBBcodeEnabled ? this._bbString.toFragmentList() : this._text, this._measureTextCallback, this._cssWidth, this._wrapMode, 0), this._wordWrapChanged = false);\n    }\n    _UpdateTextLayout() {\n      this._textLayoutChanged && (this._LayoutText(), this._textLayoutChanged = false);\n    }\n    _MeasureText(t) {\n      const e = t.IsText() ? t.GetCharacterArray().join(\"\") : \" \", i = (this._SetMeasureFontString(this._GetFontString(true, t)), t.GetStyleTag(\"size\")), s = (i ? parseFloat(i.param) : this._fontSize) * this._fontSizeScale, a = this._measureContext.measureText(e);\n      let n = 0;\n      if (this._isBBcodeEnabled && this._SupportsFontBoundingBoxMeasurements()) {\n        const h = this._measureContextTop.measureText(e);\n        n = a[\"fontBoundingBoxAscent\"] - h[\"fontBoundingBoxAscent\"];\n      }\n      return { width: a.width, height: ptToPx(s), fontBoundingBoxAscent: a[\"fontBoundingBoxAscent\"] || 0, fontBoundingBoxDescent: a[\"fontBoundingBoxDescent\"] || 0, topToAlphabeticDistance: n };\n    }\n    _SetDrawFontString(t) {\n      this._lastTextCanvasFont !== t && (this._lastTextCanvasFont = t, this._textContext.font = t);\n    }\n    _SetDrawCanvasColor(t) {\n      this._lastTextCanvasFillStyle !== t && (this._lastTextCanvasFillStyle = t, this._textContext.fillStyle = t, this._textContext.strokeStyle = t);\n    }\n    _SetDrawCanvasOpacity(t) {\n      this._lastTextCanvasOpacity !== t && (this._lastTextCanvasOpacity = t, this._textContext.globalAlpha = t);\n    }\n    _SetDrawCanvasLineWith(t) {\n      this._lastTextCanvasLineWidth !== t && (this._lastTextCanvasLineWidth = t, this._textContext.lineWidth = t);\n    }\n    _LayoutText() {\n      const s = this.GetDrawScale(), a = (EXTRA_LINE_HEIGHT + this._lineHeight) * s;\n      let n = 0;\n      const h = this._wrappedText.GetLines();\n      if (0 !== h.length) {\n        for (const e of h) {\n          e.SetPosX(NaN), e.SetPosY(NaN);\n          for (const o of e.fragments()) o.SetPosX(NaN), o.SetPosY(NaN);\n        }\n        const t = this._isBBcodeEnabled && this._SupportsFontBoundingBoxMeasurements();\n        let i = h[0].GetHeight() * s;\n        if (\"center\" === this._verticalAlign) {\n          const r = h.reduce((t2, e) => t2 + e.GetHeight() * s + a, 0) - a;\n          n = Math.max(this._height / 2 - r / 2, 0), t && (i = h[0].GetTopToAlphabeticDistance() * s);\n        } else if (\"bottom\" === this._verticalAlign) {\n          const _ = h.reduce((t2, e) => t2 + e.GetHeight() * s + a, 0) - this._lineHeight * s, l = t ? h.at(-1).GetFontBoundingBoxDescent() * s : 0;\n          n = this._height - _ - l - 2;\n        }\n        for (let t2 = 0, e = h.length; t2 < e; ++t2) {\n          const d = h[t2], x = d.GetHeight() * s, C = n;\n          if (this._isBBcodeEnabled) {\n            if (n += 0 === t2 ? i : x, 0 < t2 && n > this._height - EXTRA_LINE_HEIGHT * s) break;\n          } else if (0 < t2 && n >= this._height - x) break;\n          0 <= C && this._LayoutTextLine(d, n, s), this._isBBcodeEnabled || (n += x), n += a;\n        }\n      }\n    }\n    _LayoutTextLine(t, e, i) {\n      let s = 0;\n      \"center\" === this._horizontalAlign ? s = Math.floor((this._width - t.GetWidth() * i) / 2) : \"right\" === this._horizontalAlign && (s = this._width - t.GetWidth() * i), t.SetPosX(s), t.SetPosY(e);\n      for (const a of \"ltr\" === this._textDirection ? t.fragments() : t.fragmentsReverse()) this._LayoutFragment(a, s, e, i), s += a.GetWidth() * i;\n    }\n    _LayoutFragment(t, e, i, s) {\n      const a = t.GetStyleTag(\"offsetx\"), n = (e += a ? getOffsetParam(a.param, t.GetHeight()) * s : 0, t.GetStyleTag(\"offsety\"));\n      if (i += n ? getOffsetParam(n.param, t.GetHeight()) * s : 0, t.IsIcon()) {\n        const h = t.GetStyleTag(\"iconoffsety\");\n        i += h ? getOffsetParam(h.param, t.GetHeight()) * s : 0.2 * t.GetHeight() * s;\n      }\n      t.SetPosX(e), t.SetPosY(i);\n    }\n    _DrawTextToCanvas() {\n      this._textContext.imageSmoothingEnabled = this._iconSmoothing, this._textContext.imageSmoothingQuality = \"high\", this._drawCharCount = 0;\n      const t = this.GetDrawScale(), e = this._wrappedText.GetLines();\n      for (const i of e) this._DrawTextLine(i, t);\n    }\n    _DrawTextLine(t, e) {\n      const i = t.GetPosX(), s = t.GetPosY();\n      if (Number.isFinite(i) && Number.isFinite(s)) for (const a of \"ltr\" === this._textDirection ? t.fragments() : t.fragmentsReverse()) this._DrawFragment(a, e, t.GetHeight());\n    }\n    _DrawFragment(i, s, a) {\n      const n = this._textContext, h = i.GetPosX(), o = i.GetPosY();\n      if (Number.isFinite(h) && Number.isFinite(o)) {\n        const r = a / 16;\n        let t = i.GetWidth() * s;\n        const _ = i.GetHeight() * s, l = i.GetHeight() / 16, d = (EXTRA_LINE_HEIGHT + this._lineHeight) * s;\n        let e = i.IsText() ? i.GetCharacterArray() : null;\n        if (-1 !== this._drawMaxCharCount) {\n          if (this._drawCharCount >= this._drawMaxCharCount) return;\n          i.IsText() && this._drawCharCount + e.length > this._drawMaxCharCount && (e = e.slice(0, this._drawMaxCharCount - this._drawCharCount), t = this._MeasureText(i).width * s), this._drawCharCount += i.GetLength();\n        }\n        const x = i.GetStyleTag(\"background\"), C = i.HasStyleTag(\"u\"), u = i.HasStyleTag(\"s\");\n        if ((!i.IsText() || !C32.IsCharArrayAllWhitespace(e) || x || C || u) && !i.HasStyleTag(\"hide\")) {\n          const c = i.GetStyleTag(\"color\"), g = i.GetStyleTag(\"opacity\"), S = (this._SetDrawCanvasOpacity(g ? parseFloat(g.param) / 100 : 1), x && (this._SetDrawCanvasColor(x.param), n.fillRect(h, o - _, t, _ + d)), i.GetStyleTag(\"linethickness\")), T = S ? parseFloat(S.param) : 1, p = i.HasStyleTag(\"stroke\");\n          if (p && this._SetDrawCanvasLineWith(0.5 * l * T * this.GetDrawScale()), i.IsText()) {\n            const f = e.join(\"\");\n            if (this._SetDrawFontString(this._GetFontString(false, i)), !p) {\n              this._SetDrawCanvasLineWith(0.5 * l * T * this.GetDrawScale());\n              const m = i.GetStyleTag(\"outlineback\");\n              m && (this._SetDrawCanvasColor(m.param), this._FillOrStrokeText(true, f, h, o, t));\n            }\n            if (this._SetDrawCanvasColor(c ? c.param : this._colorStr), this._FillOrStrokeText(p, f, h, o, t), !p) {\n              this._SetDrawCanvasLineWith(0.5 * l * T * this.GetDrawScale());\n              const w = i.GetStyleTag(\"outline\");\n              w && (this._SetDrawCanvasColor(w.param), this._FillOrStrokeText(true, f, h, o, t));\n            }\n          } else if (i.IsIcon() && 0 < i.GetWidth()) {\n            const G = i.GetDrawable(this._iconSet);\n            G && n.drawImage(G, h, o - _, t, _);\n          }\n          if (this._SetDrawCanvasColor(c ? c.param : this._colorStr), C && fillOrStrokeRect(n, p, h, o + s * r, t, s * r * T), u) {\n            const B = o - _ / 4, W = s * l, D = B + W / 2;\n            n.fillRect(h, D - W * T / 2, t, W * T);\n          }\n        }\n      }\n    }\n    _FillOrStrokeText(t, e, i, s, a) {\n      \"rtl\" === this._textDirection && (i += a), t ? \"Gecko\" === C32.Platform.BrowserEngine ? this._textContext.strokeText(e, i, s, a) : this._textContext.strokeText(e, i, s) : \"Gecko\" === C32.Platform.BrowserEngine ? this._textContext.fillText(e, i, s, a) : this._textContext.fillText(e, i, s);\n    }\n    _UpdateTexture() {\n      this._renderer.IsContextLost() || (this._texture || (this._texture = this._renderer.CreateDynamicTexture(this._textCanvas.width, this._textCanvas.height, { mipMap: true, mipMapQuality: \"high\" })), this._renderer.UpdateTexture(this._textCanvas, this._texture), this._rcTex.set(0, 0, this._width / this._texture.GetWidth(), this._height / this._texture.GetHeight()), this.ontextureupdate && this.ontextureupdate());\n    }\n    GetTexRect() {\n      return this._rcTex;\n    }\n    ReleaseTexture() {\n      this._texture && (this._renderer.IsContextLost() || this._renderer.DeleteTexture(this._texture), this._texture = null);\n    }\n    static OnContextLost() {\n      for (const t of allRendererTexts) t.ReleaseTexture();\n    }\n    static GetAll() {\n      return allRendererTexts.values();\n    }\n  };\n}\nvar fillOrStrokeRect2;\nvar ptToPx2;\nvar getOffsetParam2;\n{\n  const C32 = self.C3;\n  class WebGLRealTimeElapsedQuery {\n    constructor(e) {\n      this._gl = e.GetContext(), this._version = e.GetWebGLVersionNumber(), this._timerExt = e._GetDisjointTimerQueryExtension(), this._query = null, this._isActive = false, this._hasResult = false, this._result = 0, 1 === this._version ? this._query = this._timerExt[\"createQueryEXT\"]() : this._query = this._gl[\"createQuery\"]();\n    }\n    Release() {\n      this._DeleteQueryObject(), this._gl = null, this._timerExt = null, this._hasResult = false;\n    }\n    _DeleteQueryObject() {\n      this._query && (1 === this._version ? this._timerExt[\"deleteQueryEXT\"](this._query) : this._gl[\"deleteQuery\"](this._query), this._query = null);\n    }\n    BeginTimeElapsed() {\n      if (this._isActive) throw new Error(\"query already active\");\n      1 === this._version ? this._timerExt[\"beginQueryEXT\"](this._timerExt[\"TIME_ELAPSED_EXT\"], this._query) : this._gl[\"beginQuery\"](this._timerExt[\"TIME_ELAPSED_EXT\"], this._query), this._isActive = true;\n    }\n    EndTimeElapsed() {\n      if (!this._isActive) throw new Error(\"query not active\");\n      1 === this._version ? this._timerExt[\"endQueryEXT\"](this._timerExt[\"TIME_ELAPSED_EXT\"]) : this._gl[\"endQuery\"](this._timerExt[\"TIME_ELAPSED_EXT\"]), this._isActive = false;\n    }\n    CheckForResult() {\n      if (this._query && !this._hasResult && !this._isActive) {\n        let e = false;\n        e = 1 === this._version ? this._timerExt[\"getQueryObjectEXT\"](this._query, this._timerExt[\"QUERY_RESULT_AVAILABLE_EXT\"]) : this._gl[\"getQueryParameter\"](this._query, this._gl[\"QUERY_RESULT_AVAILABLE\"]);\n        const t = this._gl.getParameter(this._timerExt[\"GPU_DISJOINT_EXT\"]);\n        e && !t && (1 === this._version ? this._result = this._timerExt[\"getQueryObjectEXT\"](this._query, this._timerExt[\"QUERY_RESULT_EXT\"]) : this._result = this._gl[\"getQueryParameter\"](this._query, this._gl[\"QUERY_RESULT\"]), this._result /= 1e9, this._hasResult = true), (e || t) && this._DeleteQueryObject();\n      }\n    }\n    HasResult() {\n      return this._hasResult;\n    }\n    GetResult() {\n      if (this._hasResult) return this._result;\n      throw new Error(\"no result available\");\n    }\n  }\n  C32.Gfx.WebGLTimeElapsedQuery = class {\n    constructor(e) {\n      this._renderer = e, this._frameNumber = e.GetFrameNumber(), this._isActive = false, this._parentQuery = null, this._isNested = false, this._realQuery = null, this._queries = [];\n    }\n    Release() {\n      for (const e of this._queries) e instanceof WebGLRealTimeElapsedQuery && e.Release();\n      C32.clearArray(this._queries), this._parentQuery = null, this._realQuery = null, this._renderer = null;\n    }\n    BeginTimeElapsed() {\n      if (this._isActive) throw new Error(\"query already active\");\n      const e = this._renderer._GetTimeQueryStack();\n      0 < e.length ? (this._isNested = true, this._parentQuery = e.at(-1), this._parentQuery._EndReal(), this._parentQuery._queries.push(this)) : (this._isNested = false, this._parentQuery = null), this._isActive = true, e.push(this), this._StartReal();\n    }\n    EndTimeElapsed() {\n      if (!this._isActive) throw new Error(\"query not active\");\n      const e = this._renderer._GetTimeQueryStack().pop();\n      if (e !== this) throw new Error(\"can only end most nested query\");\n      this._isActive = false, this._EndReal(), this._parentQuery && (this._parentQuery._StartReal(), this._parentQuery = null);\n    }\n    _StartReal() {\n      this._realQuery = C32.New(WebGLRealTimeElapsedQuery, this._renderer), this._queries.push(this._realQuery), this._realQuery.BeginTimeElapsed();\n    }\n    _EndReal() {\n      this._realQuery.EndTimeElapsed(), this._realQuery = null;\n    }\n    CheckForResult() {\n      for (const e of this._queries) e.CheckForResult();\n    }\n    IsNested() {\n      return this._isNested;\n    }\n    HasResult() {\n      return this._queries.every((e) => e.HasResult());\n    }\n    GetResult() {\n      return this._queries.reduce((e, t) => e + t.GetResult(), 0);\n    }\n    GetFrameNumber() {\n      return this._frameNumber;\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.Gfx.WebGLQueryResultBuffer = class {\n    constructor(e, r = 1e3) {\n      this._renderer = e, this._maxQueries = r, this._buffer = [], this._renderer._AddQueryResultBuffer(this);\n    }\n    Release() {\n      this.Clear(), this._renderer._RemoveQueryResultBuffer(this), this._renderer = null;\n    }\n    Clear() {\n      for (const e of this._buffer) e.Release();\n      C32.clearArray(this._buffer);\n    }\n    AddTimeElapsedQuery() {\n      const e = new C32.Gfx.WebGLTimeElapsedQuery(this._renderer);\n      if (this._buffer.push(e), this._buffer.length > this._maxQueries) {\n        const r = this._buffer.shift();\n        r.Release();\n      }\n      return e;\n    }\n    CheckForResults(e) {\n      for (const r of this._buffer) {\n        if (r.GetFrameNumber() >= e) return;\n        if (r.IsNested()) return;\n        r.CheckForResult();\n      }\n    }\n    GetFrameRangeResultSum(e, r) {\n      if (r <= e) return NaN;\n      let t = 0;\n      for (const s of this._buffer) {\n        if (s.GetFrameNumber() >= r) break;\n        if (!(s.GetFrameNumber() < e)) {\n          if (!s.HasResult()) return NaN;\n          t += s.GetResult();\n        }\n      }\n      return t;\n    }\n    DeleteAllBeforeFrameNumber(t) {\n      for (let e = 0, r = this._buffer.length; e < r; ++e) {\n        const s = this._buffer[e];\n        if (!(s.GetFrameNumber() < t)) return void (0 < e && this._buffer.splice(0, e));\n        s.Release();\n      }\n    }\n  };\n}\n{\n  let CheckPendingPolls = function() {\n    pollRafId = -1;\n    for (const t of pendingPolls) t.checkFunc() && (t.resolve(), pendingPolls.delete(t));\n    0 < pendingPolls.size && (pollRafId = self.requestAnimationFrame(CheckPendingPolls));\n  };\n  CheckPendingPolls2 = CheckPendingPolls;\n  const C32 = self.C3, assert = self.assert, glMatrix = self.glMatrix, vec3 = glMatrix.vec3, vec4 = glMatrix.vec4, mat4 = glMatrix.mat4, DEFAULT_WEBGLRENDERER_OPTS = { powerPreference: \"default\", enableGpuProfiling: true, alpha: false, depth: false, canSampleDepth: false, maxWebGLVersion: 2, failIfMajorPerformanceCaveat: false }, VALID_POWER_PREFERENCES = /* @__PURE__ */ new Set([\"default\", \"low-power\", \"high-performance\"]), MAX_VERTICES = 8e3, MAX_INDICES = MAX_VERTICES / 2 * 3, MAX_POINTS = 8e3, LAST_POINT = MAX_POINTS - 4, PARTIAL_TEXTURE_UPLOAD_CHUNK_SIZE = 262144, defaultTexCoordsQuad = new C32.Quad(0, 0, 1, 0, 1, 1, 0, 1), tmpProjection = mat4.create(), tmpModelView = mat4.create(), tmpQuad = new C32.Quad(), tmpRect = new C32.Rect();\n  let loseContextExtension = null;\n  C32.isDebug && (self.debug_lose_webgl_context = function() {\n    loseContextExtension ? loseContextExtension.loseContext() : console.warn(\"WEBGL_lose_context not supported\");\n  }, self.debug_restore_webgl_context = function() {\n    loseContextExtension ? loseContextExtension.restoreContext() : console.warn(\"WEBGL_lose_context not supported\");\n  });\n  const pendingPolls = /* @__PURE__ */ new Set();\n  let pollRafId = -1;\n  C32.Gfx.WebGLRenderer = class extends C32.Gfx.RendererBase {\n    constructor(t, e) {\n      if (super(e), e = Object.assign({}, DEFAULT_WEBGLRENDERER_OPTS, e), !VALID_POWER_PREFERENCES.has(e.powerPreference)) throw new Error(\"invalid power preference\");\n      const r = { \"alpha\": !!e.alpha, \"depth\": false, \"antialias\": false, \"powerPreference\": e.powerPreference, \"failIfMajorPerformanceCaveat\": !!e.failIfMajorPerformanceCaveat };\n      let i = null, s = 0;\n      if (2 <= e.maxWebGLVersion && (i = t.getContext(\"webgl2\", r), s = 2), i || (i = t.getContext(\"webgl\", r), s = 1), !i) throw new Error(\"renderer-unavailable (could not get WebGL context)\");\n      this._gl = i, this._attribs = i.getContextAttributes(), this._versionString = i.getParameter(i.VERSION), this._version = s, this._viewport = vec4.create(), this._didChangeTransform = false, this._bbProjectionMatrix = mat4.create(), this._usesDepthBuffer = !!e.depth, this._canSampleDepth = !(!e.depth || !e.canSampleDepth), this._isDepthEnabled = this._usesDepthBuffer, this._isDepthSamplingEnabled = false, this._depthBuffer = null, this._isAutoSizeDepthBuffer = true, this._depthBufferWidth = 0, this._depthBufferHeight = 0, this._vertexBuffer = null, this._texcoordBuffer = null, this._indexBuffer = null, this._pointBuffer = null, this._vertexData = new Float32Array(MAX_VERTICES * this.GetNumVertexComponents()), this._indexData = new Uint16Array(MAX_INDICES), this._texcoordData = new Float32Array(2 * MAX_VERTICES), this._pointData = new Float32Array(4 * MAX_POINTS), this._vertexPtr = 0, this._texPtr = 0, this._pointPtr = 0, this._lastVertexPtr = 0, this._lastProgram = null, this._spDeviceTransformTextureFill = null, this._batch = [], this._batchPtr = 0, this._topOfBatch = 0, this._currentRenderTarget = null, this._lastPointZ = 0, this._batchState = C32.New(C32.Gfx.BatchState, this), this._lastColor = C32.New(C32.Color, 1, 1, 1, 1), this._lastTexture0 = null, this._lastTexture1 = null, this._lastSrcBlend = 0, this._lastDestBlend = 0, this._lastPointTexCoords = new C32.Rect(), this._lastScissorRect = C32.New(C32.Rect, 0, 0, -1, -1), this._coplanarMode = 0, this._maxTextureSize = -1, this._minPointSize = 0, this._maxPointSize = 0, this._highpPrecision = 0, this._unmaskedVendor = \"(unavailable)\", this._unmaskedRenderer = \"(unavailable)\", this._extensions = [], this._isInitialisingAfterContextRestored = false, this._parallelShaderCompileExt = null, this._anisotropicExt = null, this._depthTextureExt = null, this._fragDepthExt = null, this._stdDerivativesExt = null, this._textureLodExt = null, this._maxAnisotropy = 0, this._isGpuProfilingEnabled = !!e.enableGpuProfiling, this._timerExt = null, this._allQueryResultBuffers = /* @__PURE__ */ new Set(), this._timeQueryStack = [], this.FillIndexBufferData(this._indexData);\n    }\n    IsWebGL() {\n      return true;\n    }\n    async InitState() {\n      super.InitState();\n      const t = this._gl, e = this.GetNumVertexComponents(), r = (this._lastColor.setRgba(1, 1, 1, 1), this._lastTexture0 = null, this._lastTexture1 = null, this._vertexPtr = 0, this._pointPtr = 0, this._lastVertexPtr = MAX_VERTICES * e - 4 * e, C32.clearArray(this._batch), this._batchPtr = 0, this._topOfBatch = 0, this._lastProgram = null, this._currentRenderTarget = null, this._lastPointTexCoords.set(0, 0, 1, 1), this._lastPointZ = 0, this._batchState), i = (r.currentShader = null, r.currentFramebuffer = null, r.currentFramebufferNoDepth = null, vec4.set(r.currentColor, 1, 1, 1, 1), r.clearColor.setRgba(0, 0, 0, 0), r.pointTexCoords.set(0, 0, 1, 1), t.clearColor(0, 0, 0, 0), t.clear(t.COLOR_BUFFER_BIT), t.enable(t.BLEND), t.blendFunc(t.ONE, t.ONE_MINUS_SRC_ALPHA), this._lastSrcBlend = t.ONE, this._lastDestBlend = t.ONE_MINUS_SRC_ALPHA, this._InitBlendModes(t), t.disable(t.CULL_FACE), t.disable(t.STENCIL_TEST), t.disable(t.DITHER), this._usesDepthBuffer ? (t.enable(t.DEPTH_TEST), t.depthMask(true), t.depthFunc(t.LEQUAL)) : (t.disable(t.DEPTH_TEST), t.depthMask(false)), this._isDepthEnabled = this._usesDepthBuffer, this._isDepthSamplingEnabled = false, this._pointBuffer = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, this._pointBuffer), t.bufferData(t.ARRAY_BUFFER, this._pointData.byteLength, t.DYNAMIC_DRAW), this._vertexBuffer = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, this._vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this._vertexData.byteLength, t.DYNAMIC_DRAW), this._texcoordBuffer = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, this._texcoordBuffer), t.bufferData(t.ARRAY_BUFFER, this._texcoordData.byteLength, t.DYNAMIC_DRAW), this._indexBuffer = t.createBuffer(), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this._indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this._indexData, t.STATIC_DRAW), t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, null), this._maxTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE), t.getParameter(t.ALIASED_POINT_SIZE_RANGE)), s = (this._minPointSize = i[0], this._maxPointSize = i[1], t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT)), a = t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT), h = (this._highpPrecision = s && a ? Math.min(s[\"precision\"], a[\"precision\"]) : 0, 2048 < this._maxPointSize && (this._maxPointSize = 2048), this._extensions = t.getSupportedExtensions(), t.getExtension(\"WEBGL_debug_renderer_info\"));\n      if (h && (this._unmaskedVendor = t.getParameter(h[\"UNMASKED_VENDOR_WEBGL\"]), this._unmaskedRenderer = t.getParameter(h[\"UNMASKED_RENDERER_WEBGL\"])), this._parallelShaderCompileExt = t.getExtension(\"KHR_parallel_shader_compile\"), C32.isDebug && (loseContextExtension = t.getExtension(\"WEBGL_lose_context\")), this._isGpuProfilingEnabled && (1 === this.GetWebGLVersionNumber() ? this._timerExt = t.getExtension(\"EXT_disjoint_timer_query\") : this._timerExt = t.getExtension(\"EXT_disjoint_timer_query_webgl2\") || t.getExtension(\"EXT_disjoint_timer_query\")), this._anisotropicExt = t.getExtension(\"EXT_texture_filter_anisotropic\"), this._anisotropicExt ? this._maxAnisotropy = t.getParameter(this._anisotropicExt[\"MAX_TEXTURE_MAX_ANISOTROPY_EXT\"]) : this._maxAnisotropy = 0, this.GetWebGLVersionNumber() < 2 && this._usesDepthBuffer && this._canSampleDepth && (this._depthTextureExt = t.getExtension(\"WEBGL_depth_texture\"), !this._depthTextureExt)) throw new Error(\"no depth texture support\");\n      this.GetWebGLVersionNumber() < 2 && (this._fragDepthExt = t.getExtension(\"EXT_frag_depth\"), this._stdDerivativesExt = t.getExtension(\"OES_standard_derivatives\"), this._textureLodExt = t.getExtension(\"EXT_shader_texture_lod\"));\n      const n = C32.Gfx.WebGLShaderProgram, o = n.GetDefaultVertexShaderSource(false);\n      let l = n.GetTextureFillFragmentShaderSource_WebGL1_NoFragDepth(), _ = o, u = n.GetPointFragmentShaderSource_WebGL1_NoFragDepth(), d = n.GetPointVertexShaderSource_WebGL1(), c = n.GetTilemapFragmentShaderSource_WebGL1_NoFragDepth(), f = n.GetDefaultVertexShaderSource(true), p = false;\n      this._usesDepthBuffer && (this.GetWebGLVersionNumber() < 2 ? this._fragDepthExt && (l = n.GetTextureFillFragmentShaderSource_WebGL1_FragDepthEXT(), u = n.GetPointFragmentShaderSource_WebGL1_FragDepthEXT(), c = n.GetTilemapFragmentShaderSource_WebGL1_FragDepthEXT(), p = true) : (_ = n.GetDefaultVertexShaderSource_WebGL2(), l = n.GetTextureFillFragmentShaderSource_WebGL2(), u = n.GetPointFragmentShaderSource_WebGL2(), d = n.GetPointVertexShaderSource_WebGL2(), c = n.GetTilemapFragmentShaderSource_WebGL2(), f = n.GetDefaultVertexShaderSource_WebGL2(true)));\n      const x = n.GetTileRandomizationFragmentShaderSource(this.GetWebGLVersionNumber(), p, this._stdDerivativesExt && this._textureLodExt), E = 2 <= this.GetWebGLVersionNumber() ? n.GetDefaultVertexShaderSource_WebGL2() : o, S = [[l, _, \"<default>\"], [l, _, \"<default-device-transform>\"], [u, d, \"<point>\"], [n.GetColorFillFragmentShaderSource(), o, \"<fill>\"], [n.GetLinearGradientFillFragmentShaderSource(), o, \"<lineargradient>\"], [n.GetPenumbraFillFragmentShaderSource(), o, \"<penumbra>\"], [n.GetHardEllipseFillFragmentShaderSource(), o, \"<hardellipse>\"], [n.GetHardEllipseOutlineFragmentShaderSource(), o, \"<hardellipseoutline>\"], [n.GetSmoothEllipseFillFragmentShaderSource(), o, \"<smoothellipse>\"], [n.GetSmoothEllipseOutlineFragmentShaderSource(), o, \"<smoothellipseoutline>\"], [n.GetSmoothLineFillFragmentShaderSource(), o, \"<smoothline>\"], [c, f, \"<tilemap>\"], [x, E, \"<tilerandomization>\"]], T = await Promise.all(S.map((t2) => this.CreateShaderProgram({ src: t2[0], vertexSrc: t2[1], name: t2[2] })));\n      this._spTextureFill = T[0], this._spDeviceTransformTextureFill = T[1], this._spPoints = T[2], this._spColorFill = T[3], this._spLinearGradientFill = T[4], this._spPenumbraFill = T[5], this._spHardEllipseFill = T[6], this._spHardEllipseOutline = T[7], this._spSmoothEllipseFill = T[8], this._spSmoothEllipseOutline = T[9], this._spSmoothLineFill = T[10], this._spTilemapFill = T[11], this._spTileRandomization = T[12], this.SetTextureFillMode();\n    }\n    async CreateShaderProgram(t) {\n      const e = await C32.Gfx.WebGLShaderProgram.Create(this, t);\n      return this._AddShaderProgram(e), e;\n    }\n    ResetLastProgram() {\n      this._lastProgram = null;\n    }\n    SetSize(t, e, r) {\n      if (this._width !== t || this._height !== e || r) {\n        this.EndBatch();\n        const i = this._gl, s = this._batchState;\n        this._width = t, this._height = e, this._SetViewport(0, 0, t, e), this.CalculatePerspectiveMatrix(this._bbProjectionMatrix, t / e), this.SetProjectionMatrix(this._bbProjectionMatrix), this._spDeviceTransformTextureFill && (i.useProgram(this._spDeviceTransformTextureFill.GetShaderProgram()), this._spDeviceTransformTextureFill._UpdateDeviceTransformUniforms(this._matP), this._lastProgram = this._spDeviceTransformTextureFill, this._batchState.currentShader = this._spDeviceTransformTextureFill), i.bindTexture(i.TEXTURE_2D, null), i.activeTexture(i.TEXTURE1), i.bindTexture(i.TEXTURE_2D, null), i.activeTexture(i.TEXTURE0), this._lastTexture0 = null, this._lastTexture1 = null, this._usesDepthBuffer && this._isAutoSizeDepthBuffer && this._SetDepthBufferSize(this._width, this._height), this._currentRenderTarget && this._currentRenderTarget._Resize(this._width, this._height), i.bindFramebuffer(i.FRAMEBUFFER, null), this._currentRenderTarget = null, s.currentFramebuffer = null, s.currentFramebufferNoDepth = null;\n      }\n    }\n    _SetDepthBufferSize(t, e) {\n      const r = this._gl;\n      this._depthBuffer && this._depthBufferWidth === t && this._depthBufferHeight === e || (this._canSampleDepth ? (this._depthBuffer && r.deleteTexture(this._depthBuffer), this._depthBuffer = r.createTexture(), r.bindTexture(r.TEXTURE_2D, this._depthBuffer), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, r.NEAREST), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, r.NEAREST), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE), 2 <= this.GetWebGLVersionNumber() ? r.texImage2D(r.TEXTURE_2D, 0, r.DEPTH24_STENCIL8, t, e, 0, r.DEPTH_STENCIL, r.UNSIGNED_INT_24_8, null) : this._depthTextureExt && r.texImage2D(r.TEXTURE_2D, 0, r.DEPTH_STENCIL, t, e, 0, r.DEPTH_STENCIL, this._depthTextureExt[\"UNSIGNED_INT_24_8_WEBGL\"], null), r.bindTexture(r.TEXTURE_2D, null)) : (this._depthBuffer && r.deleteRenderbuffer(this._depthBuffer), this._depthBuffer = r.createRenderbuffer(), r.bindRenderbuffer(r.RENDERBUFFER, this._depthBuffer), r.renderbufferStorage(r.RENDERBUFFER, 2 <= this._version ? r.DEPTH24_STENCIL8 : r.DEPTH_STENCIL, t, e), r.bindRenderbuffer(r.RENDERBUFFER, null)), this._depthBufferWidth = t, this._depthBufferHeight = e);\n    }\n    SetFixedSizeDepthBuffer(t, e) {\n      this._usesDepthBuffer && (this._isAutoSizeDepthBuffer = false, this._SetDepthBufferSize(t, e));\n    }\n    SetAutoSizeDepthBuffer() {\n      this._usesDepthBuffer && (this._isAutoSizeDepthBuffer = true, this._SetDepthBufferSize(this._width, this._height));\n    }\n    _SetViewport(t, e, r, i) {\n      const s = this._viewport;\n      if (s[0] !== t || s[1] !== e || s[2] !== r || s[3] !== i) {\n        const a = this.PushBatch();\n        a.InitSetViewport(t, e, r, i), vec4.set(s, t, e, r, i), this._topOfBatch = 0;\n      }\n    }\n    SetFovY(t) {\n      super.SetFovY(t), this.CalculatePerspectiveMatrix(this._bbProjectionMatrix, this._width / this._height);\n    }\n    SetNearZ(t) {\n      super.SetNearZ(t), this.CalculatePerspectiveMatrix(this._bbProjectionMatrix, this._width / this._height);\n    }\n    SetFarZ(t) {\n      super.SetFarZ(t), this.CalculatePerspectiveMatrix(this._bbProjectionMatrix, this._width / this._height);\n    }\n    SetProjectionMatrix(t) {\n      if (!mat4.exactEquals(this._matP, t)) {\n        const e = this.PushBatch();\n        e.InitSetProjection(t), mat4.copy(this._matP, t), this._topOfBatch = 0, this._didChangeTransform = true;\n      }\n    }\n    SetDefaultRenderTargetProjectionState() {\n      let t, e, r;\n      const i = this._currentRenderTarget;\n      r = (null === i ? (t = this._bbProjectionMatrix, e = this.GetWidth(), this) : (t = i.GetProjectionMatrix(), e = i.GetWidth(), i)).GetHeight(), this.SetProjectionMatrix(t), this._SetViewport(0, 0, e, r);\n    }\n    SetModelViewMatrix(t) {\n      if (!mat4.exactEquals(this._matMV, t)) {\n        const e = this.PushBatch();\n        e.InitSetModelView(t), mat4.copy(this._matMV, t), this._topOfBatch = 0, this._didChangeTransform = true;\n      }\n    }\n    ResetDidChangeTransformFlag() {\n      this._didChangeTransform = false;\n    }\n    DidChangeTransform() {\n      return this._didChangeTransform;\n    }\n    GetBatchState() {\n      return this._batchState;\n    }\n    PushBatch() {\n      const t = this._batch;\n      return this._batchPtr === t.length && t.push(new C32.Gfx.WebGLBatchJob(this._batchState)), t[this._batchPtr++];\n    }\n    EndBatch() {\n      0 === this._batchPtr || this.IsContextLost() || (this._WriteBuffers(), this._ExecuteBatch(), this._batchPtr = 0, this._vertexPtr = 0, this._texPtr = 0, this._pointPtr = 0, this._topOfBatch = 0);\n    }\n    _WriteBuffers() {\n      const t = this._gl;\n      0 < this._pointPtr && (t.bindBuffer(t.ARRAY_BUFFER, this._pointBuffer), t.bufferSubData(t.ARRAY_BUFFER, 0, this._pointData.subarray(0, this._pointPtr))), 0 < this._vertexPtr && (t.bindBuffer(t.ARRAY_BUFFER, this._vertexBuffer), t.bufferSubData(t.ARRAY_BUFFER, 0, this._vertexData.subarray(0, this._vertexPtr)), t.bindBuffer(t.ARRAY_BUFFER, this._texcoordBuffer), t.bufferSubData(t.ARRAY_BUFFER, 0, this._texcoordData.subarray(0, this._texPtr)));\n    }\n    _ExecuteBatch() {\n      const r = this._batch;\n      for (let t = 0, e = this._batchPtr; t < e; ++t) r[t].Run();\n    }\n    GetOpacity() {\n      return this._lastColor.getA();\n    }\n    SetColorRgba(t, e, r, i) {\n      const s = this._lastColor;\n      if (!s.equalsRgba(t, e, r, i)) {\n        s.setRgba(t, e, r, i);\n        const a = this.PushBatch();\n        a.InitSetColor(s), this._topOfBatch = 0, this._currentStateGroup = null;\n      }\n    }\n    SetOpacity(t) {\n      const e = this._lastColor;\n      if (e.getA() !== t) {\n        e.setA(t);\n        const r = this.PushBatch();\n        r.InitSetColor(e), this._topOfBatch = 0, this._currentStateGroup = null;\n      }\n    }\n    SetColor(t) {\n      const e = this._lastColor;\n      if (!e.equals(t)) {\n        e.set(t);\n        const r = this.PushBatch();\n        r.InitSetColor(e), this._topOfBatch = 0, this._currentStateGroup = null;\n      }\n    }\n    ResetColor() {\n      this.SetColorRgba(1, 1, 1, 1);\n    }\n    GetColor() {\n      return this._lastColor;\n    }\n    SetTexture(t) {\n      if (t !== this._lastTexture0) {\n        const e = this.PushBatch();\n        e.InitSetTexture(t), this._lastTexture0 = t, this._topOfBatch = 0;\n      }\n    }\n    _ResetLastTexture() {\n      this._lastTexture0 = null;\n    }\n    SetBlendMode(t) {\n      const e = this._GetBlendByIndex(t);\n      this._SetBlend(e[0], e[1]);\n    }\n    SetNamedBlendMode(t) {\n      const e = this.GetNamedBlend(t);\n      this._SetBlend(e.srcBlend, e.destBlend);\n    }\n    _SetBlend(t, e) {\n      if (t !== this._lastSrcBlend || e !== this._lastDestBlend) {\n        const r = this.PushBatch();\n        r.InitSetBlend(t, e), this._lastSrcBlend = t, this._lastDestBlend = e, this._topOfBatch = 0, this._currentStateGroup = null;\n      }\n    }\n    IsPremultipliedAlphaBlend() {\n      return this._lastSrcBlend === this._gl.ONE && this._lastDestBlend === this._gl.ONE_MINUS_SRC_ALPHA;\n    }\n    SetAlphaBlend() {\n      this._SetBlend(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA);\n    }\n    SetNoPremultiplyAlphaBlend() {\n      this._SetBlend(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA);\n    }\n    SetCopyBlend() {\n      this._SetBlend(this._gl.ONE, this._gl.ZERO);\n    }\n    Rect(t) {\n      this.Rect2(t.getLeft(), t.getTop(), t.getRight(), t.getBottom());\n    }\n    Rect2(t, e, r, i) {\n      this.Quad2(t, e, r, e, r, i, t, i);\n    }\n    _ExtendQuadBatch() {\n      let t = this._vertexPtr;\n      if (t >= this._lastVertexPtr && (this.EndBatch(), t = 0), 1 === this._topOfBatch) this._batch[this._batchPtr - 1]._indexCount += 6;\n      else {\n        const e = this.PushBatch();\n        e.InitQuad(t, 6), this._topOfBatch = 1;\n      }\n    }\n    _WriteQuadToVertexBuffer(t) {\n      t.writeToTypedArray3D(this._vertexData, this._vertexPtr, this._baseZ + this._currentZ), this._vertexPtr += 12;\n    }\n    Quad(t) {\n      this._ExtendQuadBatch(), this._WriteQuadToVertexBuffer(t), defaultTexCoordsQuad.writeToTypedArray(this._texcoordData, this._texPtr), this._texPtr += 8;\n    }\n    Quad2(t, e, r, i, s, a, h, n) {\n      this._ExtendQuadBatch();\n      const o = this._vertexData;\n      let l = this._vertexPtr;\n      const _ = this._baseZ + this._currentZ;\n      o[l++] = t, o[l++] = e, o[l++] = _, o[l++] = r, o[l++] = i, o[l++] = _, o[l++] = s, o[l++] = a, o[l++] = _, o[l++] = h, o[l++] = n, o[l++] = _, this._vertexPtr = l, defaultTexCoordsQuad.writeToTypedArray(this._texcoordData, this._texPtr), this._texPtr += 8;\n    }\n    Quad3(t, e) {\n      this._ExtendQuadBatch(), this._WriteQuadToVertexBuffer(t), e.writeAsQuadToTypedArray(this._texcoordData, this._texPtr), this._texPtr += 8;\n    }\n    Quad4(t, e) {\n      this._ExtendQuadBatch(), this._WriteQuadToVertexBuffer(t), e.writeToTypedArray(this._texcoordData, this._texPtr), this._texPtr += 8;\n    }\n    Quad3D(t, e, r, i, s, a, h, n, o, l, _, u, d) {\n      this._ExtendQuadBatch();\n      const c = this._vertexData;\n      let f = this._vertexPtr;\n      const p = this._baseZ + this._currentZ;\n      c[f++] = t, c[f++] = e, c[f++] = p + r, c[f++] = i, c[f++] = s, c[f++] = p + a, c[f++] = h, c[f++] = n, c[f++] = p + o, c[f++] = l, c[f++] = _, c[f++] = p + u, this._vertexPtr = f, d.writeAsQuadToTypedArray(this._texcoordData, this._texPtr), this._texPtr += 8;\n    }\n    Quad3D2(t, e, r, i, s, a, h, n, o, l, _, u, d) {\n      this._ExtendQuadBatch();\n      const c = this._vertexData;\n      let f = this._vertexPtr;\n      const p = this._baseZ + this._currentZ;\n      c[f++] = t, c[f++] = e, c[f++] = p + r, c[f++] = i, c[f++] = s, c[f++] = p + a, c[f++] = h, c[f++] = n, c[f++] = p + o, c[f++] = l, c[f++] = _, c[f++] = p + u, this._vertexPtr = f, d.writeToTypedArray(this._texcoordData, this._texPtr), this._texPtr += 8;\n    }\n    DrawMesh(i, s, a) {\n      const h = this._vertexData, n = this._texcoordData;\n      if (a.length % 3 != 0) throw new Error(\"invalid index buffer length\");\n      for (let r = 0, t = a.length; r < t; ) {\n        const o = a[r++], l = a[r++], _ = a[r++], u = 3 * o, d = 3 * l, c = 3 * _, f = 2 * o, p = 2 * l, x = 2 * _;\n        this._ExtendQuadBatch();\n        let t2 = this._vertexPtr, e = this._texPtr;\n        h[t2++] = i[0 + u], h[t2++] = i[1 + u], h[t2++] = i[2 + u], h[t2++] = i[0 + d], h[t2++] = i[1 + d], h[t2++] = i[2 + d], h[t2++] = i[0 + c], h[t2++] = i[1 + c], h[t2++] = i[2 + c], h[t2++] = i[0 + c], h[t2++] = i[1 + c], h[t2++] = i[2 + c], n[e++] = s[0 + f], n[e++] = s[1 + f], n[e++] = s[0 + p], n[e++] = s[1 + p], n[e++] = s[0 + x], n[e++] = s[1 + x], n[e++] = s[0 + x], n[e++] = s[1 + x], this._vertexPtr = t2, this._texPtr = e;\n      }\n    }\n    FullscreenQuad(t, e) {\n      this.SetCurrentZ(0), mat4.copy(tmpProjection, this._matP), mat4.copy(tmpModelView, this._matMV), this.SetDefaultRenderTargetProjectionState();\n      const [r, i] = this.GetRenderTargetSize(this._currentRenderTarget), s = this.CalculateLookAtModelView2(0, 0, this.GetDefaultCameraZ(i), 0, 0, 0, i);\n      if (this.SetModelViewMatrix(s), \"crop\" === t && this._currentRenderTarget && e) {\n        const a = this._width / 2, h = this._height / 2, n = e.GetWidth(), o = e.GetHeight(), l = this._currentRenderTarget.GetWidth(), _ = this._currentRenderTarget.GetHeight(), u = Math.min(l, n), d = Math.min(_, o), c = Math.max(o - _, 0), f = Math.max(_ - o, 0);\n        tmpRect.set(-a, h - f, -a + u, h - d - f), tmpQuad.setFromRect(tmpRect), tmpRect.set(0, c, u, d + c), tmpRect.divide(n, o), this.Quad3(tmpQuad, tmpRect);\n      } else {\n        const p = r / 2, x = i / 2;\n        this.Rect2(-p, x, p, -x);\n      }\n      this.SetProjectionMatrix(tmpProjection), this.SetModelViewMatrix(tmpModelView);\n    }\n    StartRenderingPoints(t) {\n      if (!this._lastPointTexCoords.equals(t)) {\n        this._lastPointTexCoords.copy(t);\n        const e = this.PushBatch();\n        e.InitSetPointTexCoords(t), this._topOfBatch = 0;\n      }\n    }\n    FinishRenderingPoints() {\n    }\n    Point(t, e, r, i) {\n      this._pointPtr >= LAST_POINT && this.EndBatch();\n      let s = this._pointPtr;\n      const a = this._baseZ + this._currentZ;\n      if (2 === this._topOfBatch && this._lastPointZ === a) this._batch[this._batchPtr - 1]._indexCount++;\n      else {\n        const n = this.PushBatch();\n        n.InitPoints(s, a), this._topOfBatch = 2, this._lastPointZ = a;\n      }\n      const h = this._pointData;\n      h[s++] = t, h[s++] = e, h[s++] = r, h[s++] = i, this._pointPtr = s;\n    }\n    SetProgram(t) {\n      if (this._lastProgram !== t) {\n        const e = this.PushBatch();\n        e.InitSetProgram(t), this._lastProgram = t, this._topOfBatch = 0, this._currentStateGroup = null;\n      }\n    }\n    GetProgram() {\n      return this._lastProgram;\n    }\n    SetDeviceTransformTextureFillMode() {\n      this.SetProgram(this._spDeviceTransformTextureFill);\n    }\n    SetGradientColor(t) {\n      const e = this.PushBatch();\n      e.InitSetGradientColor(t), this._topOfBatch = 0;\n    }\n    SetEllipseParams(t, e, r = 1) {\n      const i = this.PushBatch();\n      i.InitSetEllipseParams(t, e, r), this._topOfBatch = 0;\n    }\n    SetTilemapInfo(t, e, r, i, s, a, h) {\n      if (this._lastProgram !== this._spTilemapFill) throw new Error(\"must set tilemap fill mode first\");\n      const n = this.PushBatch();\n      n.InitSetTilemapInfo(t, e, r, i, s, a, h), this._topOfBatch = 0;\n    }\n    SetTileRandomizationInfo(t, e, r, i, s, a, h) {\n      if (this._lastProgram !== this._spTileRandomization) throw new Error(\"must set tile randomization mode first\");\n      const n = this.PushBatch();\n      n.InitSetTileRandomizationInfo(t, e, r, i, s, a, h), this._topOfBatch = 0;\n    }\n    SetProgramParameters(t, e, r, i, s, a, h, n, o, l, _) {\n      const u = this._lastProgram;\n      if (_ %= 10800, u._hasAnyOptionalUniforms && !u.AreOptionalUniformsAlreadySetInBatch(e, r, i, s, a, h, n, o, l, _)) {\n        const d = this.PushBatch(), c = (d.InitSetProgramParameters(), u.SetOptionalUniformsInBatch(e, r, i, s, a, h, n, o, l, _), d._mat4param), f = (c[0] = a, c[1] = h, e.writeToTypedArray(c, 2), c[6] = o, c[7] = l, r.writeToTypedArray(c, 12), d._colorParam), p = (s.writeToTypedArray(f, 0), f[1]);\n        f[1] = f[3], f[3] = p, i.writeToTypedArray(d._srcOriginRect, 0), d._startIndex = _, d._indexCount = n, u._uSamplerBack.IsUsed() ? d._texParam = t ? t.GetTexture() : null : d._texParam = null, this._topOfBatch = 0;\n      }\n    }\n    SetProgramCustomParameters(t) {\n      const e = this._lastProgram;\n      if (0 !== t.length && !e.AreCustomParametersAlreadySetInBatch(t)) {\n        const r = this.PushBatch();\n        r.InitSetProgramCustomParameters(), e.SetCustomParametersInBatch(t), C32.shallowAssignArray(r._shaderParams, t), this._topOfBatch = 0;\n      }\n    }\n    ClearRgba(t, e, r, i) {\n      const s = this.PushBatch();\n      s.InitClearSurface2(t, e, r, i), this._topOfBatch = 0;\n    }\n    Clear(t) {\n      const e = this.PushBatch();\n      e.InitClearSurface(t), this._topOfBatch = 0;\n    }\n    Start() {\n    }\n    Finish() {\n      super.Finish(), this._gl.flush();\n    }\n    ClearDepth() {\n      if (this._usesDepthBuffer && this._currentRenderTarget && this._currentRenderTarget.HasDepthBuffer()) {\n        const t = this.PushBatch();\n        t.InitClearDepth(this._isDepthEnabled), this._topOfBatch = 0;\n      }\n    }\n    SetDepthEnabled(t) {\n      if (this._isDepthEnabled !== (t = !!t) && this._usesDepthBuffer) {\n        this._isDepthEnabled = t;\n        const e = this.PushBatch();\n        e.InitSetDepthEnabled(t), this._topOfBatch = 0;\n      }\n    }\n    IsDepthEnabled() {\n      return this._isDepthEnabled;\n    }\n    _GetDepthBuffer() {\n      return this._depthBuffer;\n    }\n    _CanSampleDepth() {\n      return this._canSampleDepth;\n    }\n    SetDepthSamplingEnabled(t) {\n      if (t = !!t, this._canSampleDepth && this._isDepthSamplingEnabled !== t) {\n        if (t && this.IsDepthEnabled()) throw new Error(\"depth still enabled\");\n        this._isDepthSamplingEnabled = t;\n        const e = this.PushBatch();\n        e.InitSetDepthSamplingEnabled(t), this._topOfBatch = 0;\n      }\n    }\n    SetScissorRect(t, e, r, i, s = 0) {\n      if (t = Math.floor(t), e = Math.floor(e), r = Math.floor(r), i = Math.floor(i), !this._lastScissorRect.equalsWH(t, e, r, i)) {\n        this._lastScissorRect.setWH(t, e, r, i);\n        const a = s || this.GetRenderTargetSize(this.GetRenderTarget())[1], h = (e = a - e - i, this.PushBatch());\n        h.InitSetScissor(true, t, e, r, i), this._topOfBatch = 0;\n      }\n    }\n    RemoveScissorRect() {\n      if (-1 !== this._lastScissorRect.getRight()) {\n        this._lastScissorRect.set(0, 0, -1, -1);\n        const t = this.PushBatch();\n        t.InitSetScissor(false, 0, 0, 0, 0), this._topOfBatch = 0;\n      }\n    }\n    CheckForQueryResults() {\n      for (const t of this._allQueryResultBuffers) t.CheckForResults(this._frameNumber);\n    }\n    IsContextLost() {\n      return !this._gl || this._gl.isContextLost() || this._isInitialisingAfterContextRestored;\n    }\n    OnContextLost() {\n      super.OnDeviceOrContextLost(), C32.Gfx.WebGLRendererTexture.OnContextLost(), C32.Gfx.WebGLRenderTarget.OnContextLost(), C32.Gfx.RendererText.OnContextLost();\n      for (const t of this._allQueryResultBuffers) t.Clear();\n      this._extensions = [], this._timerExt = null, this._parallelShaderCompileExt = null, this._anisotropicExt = null, this._depthTextureExt = null, this._fragDepthExt = null, this._stdDerivativesExt = null, this._textureLodExt = null, this._maxAnisotropy = 0, this._unmaskedVendor = \"(unavailable)\", this._unmaskedRenderer = \"(unavailable)\", this._lastProgram = null, this._spDeviceTransformTextureFill = null, this._depthBuffer = null;\n      for (const e of this._stateGroups.values()) e.OnContextLost();\n    }\n    async OnContextRestored() {\n      this._isInitialisingAfterContextRestored = true, await this.InitState(), this._isInitialisingAfterContextRestored = false;\n      for (const t of this._stateGroups.values()) t.OnContextRestored(this);\n      this.SetSize(this._width, this._height, true);\n    }\n    CreateStaticTexture(t, e) {\n      if (this.IsContextLost()) throw new Error(\"context lost\");\n      this.EndBatch();\n      const r = C32.New(C32.Gfx.WebGLRendererTexture, this);\n      return r._CreateStatic(t, e), r;\n    }\n    async CreateStaticTextureAsync(e, r) {\n      if (this.IsContextLost()) throw new Error(\"context lost\");\n      if (r = Object.assign({}, r), C32.Supports.ImageBitmapOptions) {\n        let t = await createImageBitmap(e, { \"premultiplyAlpha\": \"premultiply\" });\n        const i = r.wrapX && \"clamp-to-edge\" !== r.wrapX || r.wrapY && \"clamp-to-edge\" !== r.wrapY, s = C32.isPOT(t.width) && C32.isPOT(t.height);\n        return this.SupportsNPOTTextures() || s || !i ? r.premultiplyAlpha = false : C32.Supports.ImageBitmapOptionsResize ? (t = await createImageBitmap(e, { \"premultiplyAlpha\": \"premultiply\", \"resizeWidth\": C32.nextHighestPowerOfTwo(t.width), \"resizeHeight\": C32.nextHighestPowerOfTwo(t.height) }), r.premultiplyAlpha = false) : t = await createImageBitmap(e, { \"premultiplyAlpha\": \"none\" }), C32.Asyncify(() => this.CreateStaticTexture(t, r));\n      }\n      if (e instanceof Blob) {\n        if (\"undefined\" == typeof Image) throw new Error(\"texture upload variant not supported in worker\");\n        const t = await C32.BlobToImage(e);\n        e = t;\n      }\n      return C32.Asyncify(() => this.CreateStaticTexture(e, r));\n    }\n    CreateDynamicTexture(t, e, r) {\n      this.EndBatch();\n      const i = C32.New(C32.Gfx.WebGLRendererTexture, this);\n      return i._CreateDynamic(t, e, r), i;\n    }\n    UpdateTexture(t, e, r) {\n      this.EndBatch(), e._Update(t, r);\n    }\n    DeleteTexture(t) {\n      t && (t.SubtractReference(), 0 < t.GetReferenceCount() || (this.EndBatch(), t === this._lastTexture0 && (this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._lastTexture0 = null), t === this._lastTexture1 && (this._gl.activeTexture(this._gl.TEXTURE1), this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._gl.activeTexture(this._gl.TEXTURE0), this._lastTexture1 = null), t._Delete()));\n    }\n    CreateRenderTarget(t) {\n      let e = this._width, r = this._height, i = true;\n      if (t && (\"number\" == typeof t.width && (e = Math.floor(t.width), i = false), \"number\" == typeof t.height) && (r = Math.floor(t.height), i = false), e <= 0 || r <= 0) throw new Error(\"invalid size\");\n      this.EndBatch();\n      const s = C32.New(C32.Gfx.WebGLRenderTarget, this);\n      return s._Create(e, r, Object.assign({ isDefaultSize: i }, t)), this._currentRenderTarget = null, this._batchState.currentFramebuffer = null, this._batchState.currentFramebufferNoDepth = null, s;\n    }\n    SetRenderTarget(t, e = true) {\n      if (t !== this._currentRenderTarget) {\n        t && t.IsDefaultSize() && t._Resize(this._width, this._height);\n        const r = this.PushBatch();\n        r.InitSetRenderTarget(t), this._currentRenderTarget = t, this._topOfBatch = 0, e && this.SetDefaultRenderTargetProjectionState();\n      }\n    }\n    GetRenderTarget() {\n      return this._currentRenderTarget;\n    }\n    GetRenderTargetSize(t) {\n      return t ? [t.GetWidth(), t.GetHeight()] : [this._width, this._height];\n    }\n    CopyRenderTarget(t, e = \"stretch\") {\n      if (this._version < 2 || this._currentRenderTarget && 0 < this._currentRenderTarget.GetMultisampling()) this.SetCopyBlend(), this.ResetColor(), this.DrawRenderTarget(t, e);\n      else {\n        const r = this.PushBatch();\n        r.InitBlitFramebuffer(t, this._currentRenderTarget, e), this._topOfBatch = 0;\n      }\n    }\n    DrawRenderTarget(t, e = \"stretch\") {\n      const r = t.GetTexture();\n      if (!r) throw new Error(\"not a texture-backed render target\");\n      this.SetTexture(r), this.FullscreenQuad(e, r);\n    }\n    InvalidateRenderTarget(t) {\n      if (!(this._version < 2)) {\n        const e = this.PushBatch();\n        e.InitInvalidateFramebuffer(t._GetFramebuffer()), this._topOfBatch = 0;\n      }\n    }\n    DeleteRenderTarget(t) {\n      this.SetRenderTarget(null), this.EndBatch();\n      const e = t.GetTexture();\n      e === this._lastTexture0 && (this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._lastTexture0 = null), e === this._lastTexture1 && (this._gl.activeTexture(this._gl.TEXTURE1), this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._gl.activeTexture(this._gl.TEXTURE0), this._lastTexture1 = null), t._Delete();\n    }\n    async ReadBackRenderTargetToImageData(t, e, r) {\n      this.EndBatch();\n      const i = this._currentRenderTarget;\n      let s, a, h, n = (h = t ? (s = t.GetWidth(), a = t.GetHeight(), t._GetFramebuffer()) : (s = this.GetWidth(), a = this.GetHeight(), null), 0), o = 0, l = s, _ = a;\n      if (r) {\n        n = C32.clamp(Math.floor(r.getLeft()), 0, s - 1), o = C32.clamp(Math.floor(r.getTop()), 0, a - 1);\n        let t2 = r.width(), e2 = (t2 = 0 === t2 ? s - n : C32.clamp(Math.floor(t2), 0, s - n), r.height());\n        e2 = 0 === e2 ? a - o : C32.clamp(Math.floor(e2), 0, a - o), l = t2, _ = e2, o = a - (o + _);\n      }\n      const u = this._gl, d = (u.bindFramebuffer(u.FRAMEBUFFER, h), () => {\n        u.bindFramebuffer(u.FRAMEBUFFER, null), this._currentRenderTarget = null, this._batchState.currentFramebuffer = null, this._batchState.currentFramebufferNoDepth = null, this.SetRenderTarget(i);\n      });\n      let c;\n      if (!e && 2 <= this.GetWebGLVersionNumber()) {\n        u.bindFramebuffer(u.READ_FRAMEBUFFER, h);\n        const f = u.createBuffer(), p = l * _ * 4, x = u[\"PIXEL_PACK_BUFFER\"], E = (u.bindBuffer(x, f), u.bufferData(x, p, u[\"STREAM_READ\"]), u.readPixels(n, o, l, _, u.RGBA, u.UNSIGNED_BYTE, 0), u.bindFramebuffer(u.READ_FRAMEBUFFER, null), u.bindBuffer(x, null), d(), u[\"fenceSync\"](u[\"SYNC_GPU_COMMANDS_COMPLETE\"], 0));\n        await this._WaitForObjectReady(() => u[\"getSyncParameter\"](E, u[\"SYNC_STATUS\"]) === u[\"SIGNALED\"]), u[\"deleteSync\"](E), c = new ImageData(l, _), u.bindBuffer(x, f), u[\"getBufferSubData\"](x, 0, new Uint8Array(c.data.buffer), 0, p), u.bindBuffer(x, null), u.deleteBuffer(f);\n      } else c = new ImageData(l, _), u.readPixels(n, o, l, _, u.RGBA, u.UNSIGNED_BYTE, new Uint8Array(c.data.buffer)), d();\n      return c;\n    }\n    CoplanarStartStencilPass() {\n      this.SetDepthEnabled(true);\n      const t = this.PushBatch();\n      t.InitCoplanarStartStencilPass(), this._topOfBatch = 0, this._coplanarMode = 1;\n    }\n    CoplanarStartColorPass() {\n      this.SetDepthEnabled(false);\n      const t = this.PushBatch();\n      t.InitCoplanarStartColorPass(), this._topOfBatch = 0, this._coplanarMode = 2;\n    }\n    IsCoplanarColorPass() {\n      return 2 === this._coplanarMode;\n    }\n    CoplanarRestoreStandardRendering() {\n      this.SetDepthEnabled(true);\n      const t = this.PushBatch();\n      t.InitCoplanarRestore(), this._topOfBatch = 0, this._coplanarMode = 0;\n    }\n    StartQuery(t) {\n      if (this.SupportsGPUProfiling()) {\n        const e = this.PushBatch();\n        e.InitStartQuery(t), this._topOfBatch = 0;\n      }\n    }\n    EndQuery(t) {\n      if (this.SupportsGPUProfiling()) {\n        const e = this.PushBatch();\n        e.InitEndQuery(t), this._topOfBatch = 0;\n      }\n    }\n    _WaitForObjectReady(e) {\n      const t = new Promise((t2) => pendingPolls.add({ resolve: t2, checkFunc: e }));\n      return -1 === pollRafId && (pollRafId = self.requestAnimationFrame(CheckPendingPolls)), t;\n    }\n    GetEstimatedBackBufferMemoryUsage() {\n      return this._width * this._height * (this._attribs[\"alpha\"] ? 4 : 3);\n    }\n    GetEstimatedRenderBufferMemoryUsage() {\n      let t = 0;\n      for (const e of C32.Gfx.WebGLRenderTarget.allRenderTargets()) e.GetTexture() || (t += e.GetEstimatedMemoryUsage());\n      return t;\n    }\n    GetEstimatedTextureMemoryUsage() {\n      let t = 0;\n      for (const e of C32.Gfx.WebGLRendererTexture.allTextures()) t += e.GetEstimatedMemoryUsage();\n      return t;\n    }\n    GetWebGLVersionString() {\n      return this._versionString;\n    }\n    GetWebGLVersionNumber() {\n      return this._version;\n    }\n    GetDisplayName() {\n      return \"webgl\" + this.GetWebGLVersionNumber();\n    }\n    SupportsNPOTTextures() {\n      return 2 <= this.GetWebGLVersionNumber();\n    }\n    GetMaxTextureSize() {\n      return this._maxTextureSize;\n    }\n    GetMinPointSize() {\n      return this._minPointSize;\n    }\n    GetMaxPointSize() {\n      return this._maxPointSize;\n    }\n    SupportsHighP() {\n      return 0 !== this._highpPrecision;\n    }\n    GetHighPPrecision() {\n      return this._highpPrecision;\n    }\n    GetUnmaskedVendor() {\n      return this._unmaskedVendor;\n    }\n    GetUnmaskedRenderer() {\n      return this._unmaskedRenderer;\n    }\n    GetWebGLExtensionsAnalyticsString() {\n      if (2 <= this.GetWebGLVersionNumber()) return \"webgl2\";\n      {\n        const t = [];\n        return this._fragDepthExt && t.push(\"EXT_frag_depth\"), this._stdDerivativesExt && t.push(\"OES_standard_derivatives\"), this._textureLodExt && t.push(\"EXT_shader_texture_lod\"), 0 < t.length ? \"webgl1:\" + t.join(\",\") : \"webgl1:none\";\n      }\n    }\n    GetExtensions() {\n      return this._extensions;\n    }\n    SupportsGPUProfiling() {\n      return !!this._timerExt;\n    }\n    _GetDisjointTimerQueryExtension() {\n      return this._timerExt;\n    }\n    _GetParallelShaderCompileExtension() {\n      return this._parallelShaderCompileExt;\n    }\n    _GetAnisotropicExtension() {\n      return this._anisotropicExt;\n    }\n    _GetMaxAnisotropy() {\n      return this._maxAnisotropy;\n    }\n    _AddQueryResultBuffer(t) {\n      this._allQueryResultBuffers.add(t);\n    }\n    _RemoveQueryResultBuffer(t) {\n      this._allQueryResultBuffers.delete(t);\n    }\n    _GetTimeQueryStack() {\n      return this._timeQueryStack;\n    }\n    GetContext() {\n      return this._gl;\n    }\n    _InitBlendModes(t) {\n      this._InitBlendModeData([[\"normal\", t.ONE, t.ONE_MINUS_SRC_ALPHA], [\"additive\", t.ONE, t.ONE], [\"xor\", t.ONE, t.ONE_MINUS_SRC_ALPHA], [\"copy\", t.ONE, t.ZERO], [\"destination-over\", t.ONE_MINUS_DST_ALPHA, t.ONE], [\"source-in\", t.DST_ALPHA, t.ZERO], [\"destination-in\", t.ZERO, t.SRC_ALPHA], [\"source-out\", t.ONE_MINUS_DST_ALPHA, t.ZERO], [\"destination-out\", t.ZERO, t.ONE_MINUS_SRC_ALPHA], [\"source-atop\", t.DST_ALPHA, t.ONE_MINUS_SRC_ALPHA], [\"destination-atop\", t.ONE_MINUS_DST_ALPHA, t.SRC_ALPHA]]);\n    }\n    CreateWebGLText() {\n      return this.CreateRendererText();\n    }\n  };\n}\nvar CheckPendingPolls2;\n{\n  const C32 = self.C3, DEFAULT_CTOR_OPTS = { getDrawSize: null, getRenderTarget: null, releaseRenderTarget: null, getTime: null, redraw: null };\n  C32.Gfx.EffectChainManager = class {\n    constructor(e) {\n      e = Object.assign({}, DEFAULT_CTOR_OPTS, e), this._cbGetDrawSize = e.getDrawSize, this._cbGetRenderTarget = e.getRenderTarget, this._cbReleaseRenderTarget = e.releaseRenderTarget, this._cbGetTime = e.getTime, this._cbRedraw = e.redraw, this._webgpuBackTexture = null, this._allEffectChains = /* @__PURE__ */ new Set();\n    }\n    _AddEffectChain(e) {\n      this._allEffectChains.add(e);\n    }\n    _RemoveEffectChain(e) {\n      this._allEffectChains.delete(e);\n    }\n    OnContextLost() {\n      this._webgpuBackTexture = null;\n      for (const e of this._allEffectChains) e.OnContextLost();\n    }\n    GetDrawSize(e) {\n      return this._cbGetDrawSize ? this._cbGetDrawSize(e) : [e.GetWidth(), e.GetHeight()];\n    }\n    GetRenderTarget(e) {\n      return this._cbGetRenderTarget(e);\n    }\n    ReleaseRenderTarget(e, t) {\n      this._cbReleaseRenderTarget(e, t);\n    }\n    GetTime() {\n      return this._cbGetTime();\n    }\n    Redraw(e) {\n      this._cbRedraw(e);\n    }\n    _GetWebGPUBackTexture(e, t, r) {\n      return t = Math.floor(t), r = Math.floor(r), !this._webgpuBackTexture || this._webgpuBackTexture.GetWidth() === t && this._webgpuBackTexture.GetHeight() === r || (e.DeleteTexture(this._webgpuBackTexture), this._webgpuBackTexture = null), null === this._webgpuBackTexture && (this._webgpuBackTexture = e.CreateStaticTexture(null, { width: t, height: r, sampling: \"nearest\", mipMap: false })), this._webgpuBackTexture;\n    }\n  };\n}\n{\n  const C32 = self.C3, assert = self.assert, glMatrix = self.glMatrix, mat4 = glMatrix.mat4, tempRect = C32.New(C32.Rect), tempRect2 = C32.New(C32.Rect), tempRect3 = C32.New(C32.Rect), tempRect4 = C32.New(C32.Rect), tempMat4a = mat4.create(), tempMat4b = mat4.create(), DEFAULT_CTOR_OPTS = { drawContent: null, getSourceTextureInfo: null, getShaderParameters: null, invalidateRenderTargets: false }, DEFAULT_BUILDSTEPS_OPTS = { indexMap: null, forcePreDraw: false, forcePostDraw: false, is3D: false, isSourceTextureRotated: false, isRotatedOrNegativeSizeInstance: false, useFullSurface: false };\n  C32.Gfx.EffectChain = class {\n    constructor(e, t) {\n      t = Object.assign({}, DEFAULT_CTOR_OPTS, t), this._manager = e, this._cbDrawContent = t.drawContent, this._cbGetSourceTextureInfo = t.getSourceTextureInfo, this._cbGetShaderParameters = t.getShaderParameters, this._cbDrawContentHook = null, this._shaderProgramList = [], this._shaderProgramIndices = [], this._steps = [], this._needsRebuild = false, this._blendMode = 0, this._isAnyShaderAnimated = false, this._isAnyShaderDepthSampling = false, this._isAnyShaderBackgroundBlending = false, this._isAnyShaderCrossSampling = false, this._isAnyIsSrcTexRotated = false, this._useCopyTextureBackgroundSampling = false, this._didChangeTransform = false, this._depthEnabledAtStart = false, this._coplanarColorPassAtStart = false, this._canUseFastPath = false, this._useFullSurface = false, this._isSourceTextureRotated = false, this._numTempSurfacesRequired = 0, this._renderTargets = [null, null, null], this._invalidateRenderTargets = !!t.invalidateRenderTargets, this._boxExtendHorizontal = 0, this._boxExtendVertical = 0, this._drawWidth = 0, this._drawHeight = 0, this._contentObject = null, this._contextObject = null, this._layoutRect = C32.New(C32.Rect), this._drawSurfaceRect = C32.New(C32.Rect), this._rcTexOriginal = C32.New(C32.Rect), this._rcTexBounce = C32.New(C32.Rect), this._rcTexDest = C32.New(C32.Rect), this._devicePixelRatio = 1, this._layerScale = 1, this._layerAngle = 0, this._time = 0, this._destRenderTarget = null, this._backTex = null, this._compositOffX = 0, this._compositOffY = 0, this._updateOwnProjection = false, this._projectionMatrix = mat4.create(), this._modelViewMatrix = mat4.create(), this._manager._AddEffectChain(this);\n    }\n    Release() {\n      this._manager._RemoveEffectChain(this), C32.clearArray(this._steps), C32.clearArray(this._shaderProgramList), C32.clearArray(this._shaderProgramIndices), this._contentObject = null, this._contextObject = null, this._cbDrawContent = null, this._cbGetSourceTextureInfo = null, this._cbGetShaderParameters = null;\n    }\n    OnContextLost() {\n      this._needsRebuild = true, C32.clearArray(this._steps), C32.clearArray(this._shaderProgramList), C32.clearArray(this._shaderProgramIndices);\n    }\n    NeedsRebuild() {\n      return this._needsRebuild;\n    }\n    BuildSteps(i, e) {\n      if (e = Object.assign({}, DEFAULT_BUILDSTEPS_OPTS, e), C32.clearArray(this._steps), this._boxExtendHorizontal = 0, this._boxExtendVertical = 0, this._isAnyShaderAnimated = false, this._isAnyShaderDepthSampling = false, this._isAnyShaderBackgroundBlending = false, this._isAnyShaderCrossSampling = false, this._isAnyIsSrcTexRotated = false, this._useCopyTextureBackgroundSampling = false, this._numTempSurfacesRequired = 0, this._isSourceTextureRotated = !!e.isSourceTextureRotated, this._useFullSurface = !!e.useFullSurface, this._needsRebuild = false, C32.shallowAssignArray(this._shaderProgramList, i), 0 !== i.length) {\n        if (e.indexMap) {\n          if (e.indexMap.length !== i.length) throw new Error(\"incorrect indexMap length\");\n          C32.shallowAssignArray(this._shaderProgramIndices, e.indexMap);\n        } else {\n          C32.clearArray(this._shaderProgramIndices);\n          for (let e2 = 0, t = i.length; e2 < t; ++e2) this._shaderProgramIndices.push(e2);\n        }\n        for (const t of i) this._boxExtendHorizontal += t.GetBoxExtendHorizontal(), this._boxExtendVertical += t.GetBoxExtendVertical(), t.IsAnimated() && (this._isAnyShaderAnimated = true), t.UsesDepth() && (this._isAnyShaderDepthSampling = true), t.BlendsBackground() && (this._isAnyShaderBackgroundBlending = true), t.UsesCrossSampling() && (this._isAnyShaderCrossSampling = true), t.UsesIsSrcTexRotated() && (this._isAnyIsSrcTexRotated = true);\n        this._useCopyTextureBackgroundSampling = this._ShouldUseCopyTextureBackgroundSampling(i[0].GetRenderer());\n        const a = this._ShouldPreDraw(i[0], e), n = this._ShouldPostDraw(i.at(-1), e);\n        if (1 !== i.length || a || n) {\n          this._canUseFastPath = false;\n          let s = 0;\n          a && (this._numTempSurfacesRequired = 1, this._steps.push(C32.New(C32.Gfx.EffectChain.Step.PreDraw, this, -1, 1)), s = 1);\n          for (let t = 0, r = i.length; t < r; ++t) if (0 !== t || a) {\n            let e2 = 1 === s ? 2 : 1;\n            t !== r - 1 || n || (e2 = 0), this._numTempSurfacesRequired = Math.max(this._numTempSurfacesRequired, e2), this._steps.push(C32.New(C32.Gfx.EffectChain.Step.Bounce, this, s, e2, t)), s = e2;\n          } else this._numTempSurfacesRequired = 1, this._steps.push(C32.New(C32.Gfx.EffectChain.Step.FirstBounce, this, -1, 1, t)), s = 1;\n          n && this._steps.push(C32.New(C32.Gfx.EffectChain.Step.PostDraw, this, s, 0));\n        } else this._canUseFastPath = true;\n      }\n    }\n    _ShouldPreDraw(e, t) {\n      return !!(t.forcePreDraw || e.MustPreDraw() || t.is3D && !e.Supports3DDirectRendering() || e.UsesDepth() && !this._useFullSurface || 0 !== this._boxExtendHorizontal || 0 !== this._boxExtendVertical) || (e.GetRenderer().IsWebGL() ? e.BlendsBackground() && (t.isRotatedOrNegativeSizeInstance || t.isSourceTextureRotated) || e.UsesAnySrcRectOrPixelSize() && t.isSourceTextureRotated : e.BlendsBackground() && !this._useCopyTextureBackgroundSampling && t.isRotatedOrNegativeSizeInstance);\n    }\n    _ShouldPostDraw(e, t) {\n      return !!t.forcePostDraw || (e.GetRenderer().IsWebGL() ? e.BlendsBackground() || e.UsesCrossSampling() : (e.BlendsBackground() || e.UsesCrossSampling()) && this._UseRenderTargetBackgroundSampling());\n    }\n    _ShouldUseCopyTextureBackgroundSampling(e) {\n      return e.IsWebGPU() && this._isAnyShaderBackgroundBlending && !this._isAnyShaderCrossSampling;\n    }\n    Render(e, t, r) {\n      e.IsWebGPU() && null === t && (t = e.GetBackbufferRenderTarget()), this._destRenderTarget = t, this._contentObject = r.contentObject || null, this._contextObject = r.contextObject || null, this._blendMode = r.blendMode || 0, this._devicePixelRatio = r.devicePixelRatio || 1, this._layerScale = r.layerScale || 1, this._layerAngle = r.layerAngle || 0, this._time = \"number\" == typeof r.time ? r.time : this._manager.GetTime(), this._didChangeTransform = false, e.ResetDidChangeTransformFlag(), this._isAnyShaderAnimated && this._Redraw();\n      let s = false;\n      if (this._UseCopyTextureBackgroundSampling() && (this._CalculateDrawSizeAndRectangles(e, r), s = true, this._backTex = this._manager._GetWebGPUBackTexture(e, this._drawWidth, this._drawHeight), tempRect.copy(this._drawSurfaceRect), tempRect.roundOuter(), e.IsWebGPU() && e._MaybeDoPendingClearRenderPass(this._destRenderTarget), e.CopyTextureToTexture(this._destRenderTarget.GetTexture(), this._backTex, tempRect.getLeft(), tempRect.getTop(), tempRect.width(), tempRect.height())), this._canUseFastPath) this._Render_FastPath(e, r);\n      else if (s || this._CalculateDrawSizeAndRectangles(e, r), 0 !== this._rcTexOriginal.width() || 0 !== this._rcTexOriginal.height()) {\n        e.SetAlphaBlend(), e.ResetColor(), e.SetBaseZ(0), e.SetCurrentZ(0), this._cbDrawContentHook = r.drawContentHook || null, this._compositOffX = r.compositOffX || 0, this._compositOffY = r.compositOffY || 0, this._updateOwnProjection = !!r.updateOwnProjection, this._OnBeforeStartEffectChain(e), this._renderTargets[0] = t, this._renderTargets[1] = 1 <= this._numTempSurfacesRequired ? this._GetRenderTarget() : null, this._renderTargets[2] = 2 === this._numTempSurfacesRequired ? this._GetRenderTarget() : null;\n        for (const i of this._steps) {\n          const a = this._GetRenderTargetForId(i.GetSrcTargetId()), n = this._GetRenderTargetForId(i.GetDestTargetId());\n          e.IsWebGPU() ? i.Run_WebGPU(e, a, n) : i.Run_WebGL(e, a, n);\n        }\n        e.SetTexture(null), this._renderTargets[1] && this._ReleaseRenderTarget(this._renderTargets[1]), this._renderTargets[2] && this._ReleaseRenderTarget(this._renderTargets[2]), this._renderTargets.fill(null), this._OnAfterEndEffectChain(e), this._destRenderTarget = null, this._backTex = null, this._contentObject = null, this._contextObject = null, this._cbDrawContentHook = null;\n      }\n    }\n    _CalculateDrawSizeAndRectangles(e, t) {\n      const [r, s] = this._manager.GetDrawSize(e);\n      this._SetDrawSize(e, r, s), this._CalculateRectangles(t);\n    }\n    _SetDrawSize(e, t, r) {\n      if (t <= 0 || r <= 0) throw new Error(\"invalid draw size\");\n      this._drawWidth === t && this._drawHeight === r || this._CalculateDeviceTransformMatrices(e, t, r, 0, 0, this._projectionMatrix, this._modelViewMatrix), this._drawWidth = t, this._drawHeight = r;\n    }\n    _CalculateDeviceTransformMatrices(e, t, r, s, i, a, n) {\n      const h = t / 2 + s, c = r / 2 + i, o = (e.CalculatePerspectiveMatrix(a, t / r), e.CalculateLookAtModelView2(h, c, e.GetDefaultCameraZ(r), h, c, 0, r));\n      mat4.copy(n, o);\n    }\n    _CalculateRectangles(e) {\n      this._layoutRect.copy(e.layoutRect), e.drawSurfaceRect ? this._drawSurfaceRect.copy(e.drawSurfaceRect) : this._drawSurfaceRect.set(0, 0, this._drawWidth, this._drawHeight), this._rcTexOriginal.copy(this._drawSurfaceRect), this._rcTexOriginal.divide(this._drawWidth, this._drawHeight);\n      const t = this._layerScale * this._devicePixelRatio;\n      this._drawSurfaceRect.inflate(this._boxExtendHorizontal * t, this._boxExtendVertical * t), this._rcTexDest.copy(this._drawSurfaceRect), this._rcTexDest.divide(this._drawWidth, this._drawHeight), this._drawSurfaceRect.clampBoth(0, 0, this._drawWidth, this._drawHeight), this._rcTexBounce.copy(this._drawSurfaceRect), this._rcTexBounce.divide(this._drawWidth, this._drawHeight);\n    }\n    _OnBeforeStartEffectChain(e) {\n      if (this._depthEnabledAtStart = e.IsDepthEnabled(), this._coplanarColorPassAtStart = e.IsCoplanarColorPass(), this._useFullSurface) e.SetDepthEnabled(false), this._isAnyShaderDepthSampling && e.SetDepthSamplingEnabled(true);\n      else {\n        if (tempRect.copy(this._drawSurfaceRect), e.IsWebGL()) {\n          const t = this._layerScale * this._devicePixelRatio;\n          tempRect.inflate(Math.max(this._boxExtendHorizontal, 1) * t, Math.max(this._boxExtendVertical, 1) * t), tempRect.roundOuter(), tempRect.clamp(0, 0, this._drawWidth, this._drawHeight);\n        } else tempRect.roundOuter();\n        e.SetScissorRect(tempRect.getLeft(), tempRect.getTop(), tempRect.width(), tempRect.height(), this._drawHeight);\n      }\n    }\n    _OnAfterEffectChainDrawContent(e) {\n      e.ResetColor(), this._useFullSurface || (this._coplanarColorPassAtStart && e.CoplanarRestoreStandardRendering(), e.SetDepthEnabled(false), this._isAnyShaderDepthSampling && e.SetDepthSamplingEnabled(true)), e.IsWebGPU() && e.SetNormalizedCoordsProgramVariant(true);\n    }\n    _OnAfterEndEffectChain(e) {\n      e.SetDepthSamplingEnabled(false), this._coplanarColorPassAtStart && e.CoplanarStartColorPass(), e.SetDepthEnabled(this._depthEnabledAtStart), this._useFullSurface || e.RemoveScissorRect(), e.IsWebGPU() && e.SetNormalizedCoordsProgramVariant(false), this._didChangeTransform = e.DidChangeTransform();\n    }\n    _ClampRcTexDest() {\n      this._rcTexDest.clamp(0, 0, 1, 1);\n    }\n    _GetRenderTargetForId(e) {\n      return e < 0 ? null : this._renderTargets[e];\n    }\n    _GetRenderTarget() {\n      return this._manager.GetRenderTarget(this);\n    }\n    _GetDestRenderTarget() {\n      return this._destRenderTarget;\n    }\n    _ReleaseRenderTarget(e) {\n      this._manager.ReleaseRenderTarget(e, this);\n    }\n    _GetShaderProgramAt(e) {\n      return this._shaderProgramList[e];\n    }\n    _DrawContent(e) {\n      this._cbDrawContentHook ? this._cbDrawContentHook(this, e, () => this._cbDrawContent(e, this)) : this._cbDrawContent(e, this), this._canUseFastPath || this._OnAfterEffectChainDrawContent(e);\n    }\n    _IsRenderTargetSameSizeAndOffset(e) {\n      if (this._useFullSurface) return true;\n      if (0 !== this._compositOffX || 0 !== this._compositOffY) return false;\n      const [t, r] = e.GetRenderTargetSize(e.GetRenderTarget());\n      return t === this._drawWidth && r === this._drawHeight;\n    }\n    _SetDeviceTransform(e, t) {\n      let r = this._projectionMatrix, s = this._modelViewMatrix;\n      if (t && !this._IsRenderTargetSameSizeAndOffset(e)) {\n        r = tempMat4a, s = tempMat4b;\n        const [i, a] = e.GetRenderTargetSize(e.GetRenderTarget());\n        this._CalculateDeviceTransformMatrices(e, i, a, this._compositOffX, this._compositOffY, r, s), this._useFullSurface || e.RemoveScissorRect();\n      }\n      e.SetProjectionMatrix(r), e.SetModelViewMatrix(s);\n    }\n    _Redraw() {\n      this._manager.Redraw(this);\n    }\n    _GetShaderParameters(e, t) {\n      return this._cbGetShaderParameters(this._shaderProgramIndices[e], t);\n    }\n    _SetProgramParameters(e, t) {\n      let r = this._rcTexDest, s = this._rcTexBounce, i = this._rcTexOriginal;\n      e.IsWebGL() && (tempRect2.copy(r), tempRect2.flipAround(1), r = tempRect2, tempRect3.copy(s), tempRect3.flipAround(1), s = tempRect3, tempRect4.copy(i), tempRect4.flipAround(1), i = tempRect4), this._DoSetProgramParameters(e, t, s, i, r, 1 / this._drawWidth, 1 / this._drawHeight);\n    }\n    _SetFirstBounceProgramParameters(e, t) {\n      let s = this._rcTexBounce, i = this._rcTexOriginal, a = 1 / this._drawWidth, n = 1 / this._drawHeight;\n      if (this._cbGetSourceTextureInfo) {\n        let { srcTexRect: e2, srcWidth: t2, srcHeight: r2 } = this._cbGetSourceTextureInfo(this._contentObject);\n        e2 || (tempRect.set(0, 0, 0, 0), e2 = tempRect), t2 = t2 || this._drawWidth, r2 = r2 || this._drawHeight, s = e2, i = e2, a = 1 / t2, n = 1 / r2;\n      } else e.IsWebGL() && (tempRect3.copy(s), tempRect3.flipAround(1), s = tempRect3, tempRect4.copy(i), tempRect4.flipAround(1), i = tempRect4);\n      let r = this._rcTexDest;\n      e.IsWebGL() && ((r = tempRect2).copy(this._rcTexDest), r.flipAround(1)), this._DoSetProgramParameters(e, t, s, i, r, a, n), e.IsWebGPU() && this._isAnyIsSrcTexRotated && e.SetProgramParameter_IsSrcTexRotated(this._isSourceTextureRotated);\n    }\n    _GetBackTex(e) {\n      return this._isAnyShaderBackgroundBlending ? e.IsWebGPU() ? this._UseCopyTextureBackgroundSampling() ? this._backTex : this._destRenderTarget.GetTexture() : this._destRenderTarget : null;\n    }\n    _DoSetProgramParameters(e, t, r, s, i, a, n) {\n      e.SetProgramParameters(this._GetBackTex(e), i, r, s, this._layoutRect, a, n, this._devicePixelRatio, this._layerScale, this._layerAngle, this._time), e.SetProgramCustomParameters(this._GetShaderParameters(t, e));\n    }\n    _Render_FastPath(e, t) {\n      const r = this._shaderProgramList[0], s = e.IsDepthEnabled(), i = r.UsesDepth();\n      i && (e.SetDepthEnabled(false), e.SetDepthSamplingEnabled(true), this._rcTexDest.set(0, 0, 1, 1), this._rcTexOriginal.set(0, 0, 1, 1)), e.SetProgram(r), e.SetBlendMode(this._blendMode), e.SetRenderTarget(this._destRenderTarget);\n      let a = 0, n = 1;\n      if (this._rcTexOriginal.set(0, 0, 1, 1), r.UsesAnySrcRectOrPixelSize() && this._cbGetSourceTextureInfo) {\n        const { srcTexRect: h, srcWidth: c, srcHeight: o } = this._cbGetSourceTextureInfo(this._contentObject);\n        h && this._rcTexOriginal.copy(h), a = Number.isFinite(c) ? 1 / c : 0, n = Number.isFinite(o) ? 1 / o : 0;\n      } else {\n        const [d, _] = this._manager.GetDrawSize(e);\n        a = 1 / d, n = 1 / _;\n      }\n      t.layoutRect ? this._layoutRect.copy(t.layoutRect) : this._layoutRect.set(0, 0, 0, 0), e.SetProgramParameters(this._GetBackTex(e), this._rcTexDest, this._rcTexOriginal, this._rcTexOriginal, this._layoutRect, a, n, this._devicePixelRatio, this._layerScale, this._layerAngle, this._time), e.SetProgramCustomParameters(this._GetShaderParameters(0, e)), e.IsWebGPU() && this._isAnyIsSrcTexRotated && e.SetProgramParameter_IsSrcTexRotated(this._isSourceTextureRotated), e.SetBaseZ(0), this._DrawContent(e), i && (e.SetDepthSamplingEnabled(false), e.SetDepthEnabled(s));\n    }\n    _UseCopyTextureBackgroundSampling() {\n      return this._useCopyTextureBackgroundSampling;\n    }\n    _UseRenderTargetBackgroundSampling() {\n      return !this._useCopyTextureBackgroundSampling;\n    }\n    IsAnyShaderBackgroundBlending() {\n      return this._isAnyShaderBackgroundBlending;\n    }\n    CanSkipCalculatingDrawSurfaceRect() {\n      return !!this._canUseFastPath && !this._UseCopyTextureBackgroundSampling();\n    }\n    UseFullSurface() {\n      return this._useFullSurface;\n    }\n    GetContentObject() {\n      return this._contentObject;\n    }\n    GetContextObject() {\n      return this._contextObject;\n    }\n    _GetBlendMode() {\n      return this._blendMode;\n    }\n    _UpdateOwnProjection() {\n      return this._updateOwnProjection;\n    }\n    DidChangeTransform() {\n      return this._didChangeTransform;\n    }\n    _GetDrawSurfaceRect() {\n      return this._drawSurfaceRect;\n    }\n    _GetRcTexBounce() {\n      return this._rcTexBounce;\n    }\n    _ShouldInvalidateRenderTargets() {\n      return this._invalidateRenderTargets;\n    }\n    async DebugLogRenderTargetContents(e, t, r) {\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.Gfx.EffectChain.Step = class {\n    constructor(t, e, r, s = -1) {\n      this._effectChain = t, this._srcTargetId = e, this._destTargetId = r, this._index = s;\n    }\n    GetEffectChain() {\n      return this._effectChain;\n    }\n    GetSrcTargetId() {\n      return this._srcTargetId;\n    }\n    GetDestTargetId() {\n      return this._destTargetId;\n    }\n    GetIndex() {\n      return this._index;\n    }\n    GetShaderProgram() {\n      return this.GetEffectChain()._GetShaderProgramAt(this.GetIndex());\n    }\n    Run_WebGL(t, e, r) {\n    }\n    Run_WebGPU(t, e, r) {\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.Gfx.EffectChain.Step.PreDraw = class extends C32.Gfx.EffectChain.Step {\n    constructor(e, t, n, a) {\n      super(e, t, n, a);\n    }\n    Run_WebGL(e, t, n) {\n      const a = this.GetEffectChain();\n      e.SetAlphaBlend(), e.SetTextureFillMode(), e.SetRenderTarget(n, a._UpdateOwnProjection()), e.ClearRgba(0, 0, 0, 0), a._DrawContent(e), a._ClampRcTexDest();\n    }\n    Run_WebGPU(e, t, n) {\n      const a = this.GetEffectChain();\n      e.SetAlphaBlend(), e.SetTextureFillMode(), e.SetRenderTarget(n, false), e.ClearRgba(0, 0, 0, 0), a._DrawContent(e), a._ClampRcTexDest();\n    }\n  };\n}\n{\n  const C32 = self.C3, tempRect = C32.New(C32.Rect), tempQuad = C32.New(C32.Quad);\n  C32.Gfx.EffectChain.Step.PostDraw = class extends C32.Gfx.EffectChain.Step {\n    constructor(e, t, r, a) {\n      super(e, t, r, a);\n    }\n    Run_WebGL(e, t, r) {\n      const a = this.GetEffectChain();\n      e.SetTextureFillMode(), e.SetRenderTarget(r), a._SetDeviceTransform(e, true), e.SetBlendMode(a._GetBlendMode()), e.SetTexture(t.GetTexture()), tempQuad.setFromRect(a._GetDrawSurfaceRect()), tempRect.copy(a._GetRcTexBounce()), tempRect.flipAround(1), e.Quad3(tempQuad, tempRect), a._ShouldInvalidateRenderTargets() && e.InvalidateRenderTarget(t);\n    }\n    Run_WebGPU(e, t, r) {\n      const a = this.GetEffectChain();\n      e.SetTextureFillMode(), e.SetRenderTarget(r, false), a._IsRenderTargetSameSizeAndOffset(e) ? tempQuad.setFromRect(a._GetRcTexBounce()) : (e.SetNormalizedCoordsProgramVariant(false), a._SetDeviceTransform(e, true), tempQuad.setFromRect(a._GetDrawSurfaceRect())), e.SetBackTexture(null), e.SetBlendMode(a._GetBlendMode()), e.SetTexture(t.GetTexture()), a.UseFullSurface() ? e.FullscreenQuad() : e.Quad3(tempQuad, a._GetRcTexBounce());\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.Gfx.EffectChain.Step.FirstBounce = class extends C32.Gfx.EffectChain.Step {\n    constructor(e, t, r, a) {\n      super(e, t, r, a);\n    }\n    Run_WebGL(e, t, r) {\n      const a = this.GetEffectChain();\n      e.SetRenderTarget(r, a._UpdateOwnProjection()), e.ClearRgba(0, 0, 0, 0), e.SetCopyBlend(), e.SetProgram(this.GetShaderProgram()), a._SetFirstBounceProgramParameters(e, this.GetIndex()), a._DrawContent(e), a._ClampRcTexDest();\n    }\n    Run_WebGPU(e, t, r) {\n      const a = this.GetEffectChain();\n      e.SetRenderTarget(r, false), e.ClearRgba(0, 0, 0, 0), e.SetCopyBlend(), e.SetProgram(this.GetShaderProgram()), a._SetFirstBounceProgramParameters(e, this.GetIndex()), a._DrawContent(e), a._ClampRcTexDest();\n    }\n  };\n}\n{\n  const C32 = self.C3, tempRect = C32.New(C32.Rect), tempQuad = C32.New(C32.Quad);\n  C32.Gfx.EffectChain.Step.Bounce = class extends C32.Gfx.EffectChain.Step {\n    constructor(e, t, r, a) {\n      super(e, t, r, a);\n    }\n    Run_WebGL(e, t, r) {\n      const a = this.GetEffectChain(), d = (e.SetRenderTarget(r), 0 === this.GetDestTargetId());\n      d ? e.SetBlendMode(a._GetBlendMode()) : (e.ClearRgba(0, 0, 0, 0), e.SetCopyBlend()), e.SetProgram(this.GetShaderProgram()), a._SetProgramParameters(e, this.GetIndex()), e.SetTexture(t.GetTexture()), a._SetDeviceTransform(e, d), tempQuad.setFromRect(a._GetDrawSurfaceRect()), tempRect.copy(a._GetRcTexBounce()), tempRect.flipAround(1), e.Quad3(tempQuad, tempRect), a._ShouldInvalidateRenderTargets() && e.InvalidateRenderTarget(t);\n    }\n    Run_WebGPU(e, t, r) {\n      const a = this.GetEffectChain(), d = (e.SetRenderTarget(r, false), 0 === this.GetDestTargetId());\n      d ? (e.SetBlendMode(a._GetBlendMode()), e.SetBackTexture(null), a._IsRenderTargetSameSizeAndOffset(e) ? tempQuad.setFromRect(a._GetRcTexBounce()) : (e.SetNormalizedCoordsProgramVariant(false), a._SetDeviceTransform(e, true), tempQuad.setFromRect(a._GetDrawSurfaceRect()))) : (e.ClearRgba(0, 0, 0, 0), e.SetCopyBlend(), tempQuad.setFromRect(a._GetRcTexBounce())), e.SetProgram(this.GetShaderProgram()), a._SetProgramParameters(e, this.GetIndex()), e.SetTexture(t.GetTexture()), a.UseFullSurface() ? e.FullscreenQuad() : e.Quad3(tempQuad, a._GetRcTexBounce());\n    }\n  };\n}\n{\n  let SortZOrderList = function(e, t) {\n    const r = e[0], n = t[0], i = r - n;\n    if (0 != i) return i;\n    const o = e[1], a = t[1];\n    return o - a;\n  };\n  SortZOrderList2 = SortZOrderList;\n  const C32 = self.C3, C3X = self.C3X;\n  let runtime = null;\n  const keysDownByKey = /* @__PURE__ */ new Set();\n  const tempZOrderList = [], tempInstances = [];\n  let didWarnInAlertPolyfill = false, didWarnFpsDeprecated = false;\n  const VALID_FRAMERATE_MODES = /* @__PURE__ */ new Set([\"vsync\", \"unlimited-tick\", \"unlimited-frame\"]);\n  self.IRuntime = class {\n    constructor(e) {\n      runtime = e, Object.defineProperties(this, { assets: { value: runtime.GetAssetManager().GetIAssetManager(), writable: false }, collisions: { value: runtime.GetCollisionEngine().GetICollisionEngine(), writable: false }, objects: { value: {}, writable: false }, globalVars: { value: {}, writable: false }, projectName: { value: runtime.GetProjectName(), writable: false }, projectVersion: { value: runtime.GetProjectVersion(), writable: false }, exportDate: { value: new Date(runtime.GetExportTimestamp()), writable: false }, storage: { value: new self.IStorage(runtime), writable: false }, isInWorker: { value: runtime.IsInWorker(), writable: false }, viewportWidth: { value: runtime.GetOriginalViewportWidth(), writable: false }, viewportHeight: { value: runtime.GetOriginalViewportHeight(), writable: false }, sampling: { value: runtime.GetSampling(), writable: false }, isPixelRoundingEnabled: { value: runtime.IsPixelRoundingEnabled(), writable: false }, platformInfo: { value: new self.IPlatformInfo(e), writable: false }, sdk: { value: new self.ISDKUtils(e), writable: false } }), runtime.UserScriptDispatcher().addEventListener(\"keydown\", (e2) => {\n        keysDownByKey.has(e2[\"key\"]) ? e2.stopPropagation() : keysDownByKey.add(e2[\"key\"]);\n      }), runtime.UserScriptDispatcher().addEventListener(\"keyup\", (e2) => keysDownByKey.delete(e2[\"key\"])), runtime.Dispatcher().addEventListener(\"window-blur\", () => keysDownByKey.clear()), runtime.IsInWorker() && (self[\"alert\"] = (e2) => (didWarnInAlertPolyfill || (didWarnInAlertPolyfill = true, console.warn(\"[Construct] alert() was called from a Web Worker, because the project 'Use worker' setting is enabled. This method is not normally available in a Web Worker. Construct has implemented the alert for you, but note that other features may be missing in worker mode. You may wish to disable 'Use worker', or use a more convenient function like console.log(). For more information please refer to the scripting section of the manual.\")), this.alert(e2)));\n    }\n    _InitObjects(e) {\n      Object.defineProperties(this.objects, e);\n    }\n    _InitGlobalVars(e) {\n      Object.defineProperties(this.globalVars, e);\n    }\n    addEventListener(e, t) {\n      runtime.UserScriptDispatcher().addEventListener(e, t);\n    }\n    removeEventListener(e, t) {\n      runtime.UserScriptDispatcher().removeEventListener(e, t);\n    }\n    callFunction(e, ...t) {\n      C3X.RequireString(e);\n      const r = runtime.GetEventSheetManager(), n = r.GetFunctionBlockByName(e);\n      if (!n) throw new Error(`cannot find function name '${e}'`);\n      if (!n.IsEnabled()) return n.GetDefaultReturnValue();\n      if (t.length < n.GetFunctionParameterCount()) throw new Error(`not enough function parameters passed for '${e}' (${t.length} passed, ${n.GetFunctionParameterCount()} expected)`);\n      const i = n.GetEventBlock();\n      let o = i.GetSolModifiersIncludingParents();\n      const a = r.GetCurrentEvent();\n      if (a) {\n        o = o.slice(0);\n        const u = new Set(o);\n        for (const l of a.GetSolModifiersIncludingParents()) u.has(l) || (o.push(l), u.add(l));\n        for (const m of r.GetDynamicSolModifiersSet()) u.has(m) || (o.push(m), u.add(m));\n      }\n      const s = i.RunAsExpressionFunctionCall(o, n.IsCopyPicked(), n.GetReturnType(), n.GetDefaultReturnValue(), ...t);\n      return s;\n    }\n    setReturnValue(e) {\n      const t = runtime.GetEventStack().GetCurrentExpFuncStackFrame();\n      if (!t) throw new Error(\"not in a function which returns a value\");\n      switch (t.GetFunctionReturnType()) {\n        case 1:\n          \"number\" == typeof e && t.SetFunctionReturnValue(e);\n          break;\n        case 2:\n          \"string\" == typeof e && t.SetFunctionReturnValue(e);\n          break;\n        case 3:\n          \"number\" != typeof e && \"string\" != typeof e || t.SetFunctionReturnValue(e);\n      }\n    }\n    signal(e) {\n      C3X.RequireString(e), runtime.GetEventSheetManager().Signal(e);\n    }\n    waitForSignal(e) {\n      return C3X.RequireString(e), runtime.GetEventSheetManager().WaitForSignal(e);\n    }\n    getViewportSize() {\n      return [runtime.GetOriginalViewportWidth(), runtime.GetOriginalViewportHeight()];\n    }\n    get isSuspended() {\n      return runtime.IsSuspended();\n    }\n    get dt() {\n      return runtime.GetDt();\n    }\n    get dtRaw() {\n      return runtime.GetDtRaw();\n    }\n    get gameTime() {\n      return runtime.GetGameTime();\n    }\n    get wallTime() {\n      return runtime.GetWallTime();\n    }\n    get timeScale() {\n      return runtime.GetTimeScale();\n    }\n    set timeScale(e) {\n      C3X.RequireFiniteNumber(e), runtime.SetTimeScale(e);\n    }\n    get fps() {\n      return didWarnFpsDeprecated || (console.warn(\"IRuntime.fps is deprecated. Use IRuntime.framesPerSecond instead.\"), didWarnFpsDeprecated = true), runtime.GetFramesPerSecond();\n    }\n    get framesPerSecond() {\n      return runtime.GetFramesPerSecond();\n    }\n    get ticksPerSecond() {\n      return runtime.GetTicksPerSecond();\n    }\n    get cpuUtilisation() {\n      return runtime.GetMainThreadTime();\n    }\n    get gpuUtilisation() {\n      return runtime.GetGPUUtilisation();\n    }\n    get framerateMode() {\n      return runtime.GetFramerateMode();\n    }\n    set framerateMode(e) {\n      if (!VALID_FRAMERATE_MODES.has(e)) throw new Error(\"invalid framerate mode\");\n      runtime._SetFramerateMode(e);\n    }\n    get minDt() {\n      return runtime.GetMinDt();\n    }\n    set minDt(e) {\n      C3X.RequireFiniteNumber(e), runtime.SetMinDt(e);\n    }\n    get maxDt() {\n      return runtime.GetMaxDt();\n    }\n    set maxDt(e) {\n      runtime.SetMaxDt(e);\n    }\n    get loadingProgress() {\n      return runtime.GetAssetManager().GetLoadProgress();\n    }\n    get imageLoadingProgress() {\n      return runtime.GetAssetManager().GetImageLoadProgress();\n    }\n    random() {\n      return runtime.Random();\n    }\n    get layout() {\n      const e = runtime.GetMainRunningLayout();\n      if (e) return e.GetILayout();\n      throw new Error(\"no layout is running - make sure a layout is loaded before accessing\");\n    }\n    getLayout(e) {\n      const t = runtime.GetLayoutManager();\n      let r = null;\n      if (\"number\" != typeof e && \"string\" != typeof e) throw new TypeError(\"expected string or number\");\n      if (r = t.GetLayout(e)) return r.GetILayout();\n      throw new Error(\"invalid layout\");\n    }\n    getAllLayouts() {\n      return runtime.GetLayoutManager().GetAllLayouts().map((e) => e.GetILayout());\n    }\n    goToLayout(e) {\n      const t = runtime.GetLayoutManager();\n      let r = null;\n      if (\"number\" != typeof e && \"string\" != typeof e) throw new TypeError(\"expected string or number\");\n      if (!(r = t.GetLayout(e))) throw new Error(\"invalid layout\");\n      t.IsPendingChangeMainLayout() || t.ChangeMainLayout(r);\n    }\n    get keyboard() {\n      const e = runtime._GetCommonScriptInterfaces().keyboard;\n      if (e) return e;\n      throw new Error(\"runtime.keyboard used but Keyboard object missing - add it to your project first\");\n    }\n    get mouse() {\n      const e = runtime._GetCommonScriptInterfaces().mouse;\n      if (e) return e;\n      throw new Error(\"runtime.mouse used but Mouse object missing - add it to your project first\");\n    }\n    get touch() {\n      const e = runtime._GetCommonScriptInterfaces().touch;\n      if (e) return e;\n      throw new Error(\"runtime.touch used but Touch object missing - add it to your project first\");\n    }\n    get timelineController() {\n      const e = runtime._GetCommonScriptInterfaces().timelineController;\n      if (e) return e;\n      throw new Error(\"runtime.timelineController used but Timeline Controller object missing - add it to your project first\");\n    }\n    invokeDownload(e, t) {\n      C3X.RequireString(e), C3X.RequireString(t), runtime.InvokeDownload(e, t);\n    }\n    getInstanceByUid(e) {\n      C3X.RequireFiniteNumber(e);\n      const t = runtime.GetInstanceByUID(e);\n      return t ? t.GetInterfaceClass() : null;\n    }\n    sortZOrder(e, n) {\n      C3X.RequireFunction(n);\n      const i = runtime.GetCurrentLayout();\n      for (const t of e) {\n        const r = runtime._UnwrapIWorldInstance(t), o = r.GetWorldInfo();\n        tempZOrderList.push([o.GetLayer().GetIndex(), o.GetZIndex()]), tempInstances.push(r);\n      }\n      if (0 !== tempZOrderList.length) {\n        tempZOrderList.sort(SortZOrderList), tempInstances.sort((e2, t) => n(e2.GetInterfaceClass(), t.GetInterfaceClass()));\n        let r = false;\n        for (let e2 = 0, t = tempZOrderList.length; e2 < t; ++e2) {\n          const a = tempInstances[e2], s = i.GetLayerByIndex(tempZOrderList[e2][0]), u = tempZOrderList[e2][1], l = s._GetInstances();\n          l[u] !== a && ((l[u] = a).GetWorldInfo()._SetLayer(s, true), s.SetZIndicesChanged(a), r = true);\n        }\n        r && runtime.UpdateRender(), C32.clearArray(tempZOrderList), C32.clearArray(tempInstances);\n      }\n    }\n    async createWorker(e, t) {\n      const r = new MessageChannel(), n = r.port1, i = r.port2;\n      return await runtime.PostComponentMessageToDOMAsync(\"runtime\", \"script-create-worker\", { \"url\": e, \"opts\": t, \"port2\": i }, [i]), n;\n    }\n    alert(e) {\n      return runtime.PostComponentMessageToDOMAsync(\"runtime\", \"alert\", { \"message\": e + (runtime.IsInWorker() ? \" [via Web Worker]\" : \"\") });\n    }\n    getHTMLLayer(e) {\n      return C3X.RequireFiniteNumber(e), runtime._GetHTMLLayerWrapElement(e);\n    }\n    addLoadPromise(e) {\n      runtime.AddLoadPromise(e);\n    }\n  };\n}\nvar SortZOrderList2;\n{\n  const C32 = self.C3, C3X = self.C3X;\n  let assetManager = null;\n  self.IAssetManager = class {\n    constructor(e) {\n      assetManager = e, Object.defineProperties(this, { isWebMOpusSupported: { value: true, writable: false } });\n    }\n    loadImageAsset(e) {\n      const t = self.IImageInfo._Unwrap(e);\n      if (!t) throw new Error(\"invalid IImageInfo\");\n      t.LoadAsset(assetManager.GetRuntime());\n    }\n    fetchText(e) {\n      return assetManager.FetchText(e);\n    }\n    fetchJson(e) {\n      return assetManager.FetchJson(e);\n    }\n    fetchBlob(e) {\n      return assetManager.FetchBlob(e);\n    }\n    fetchArrayBuffer(e) {\n      return assetManager.FetchArrayBuffer(e);\n    }\n    getProjectFileUrl(e) {\n      return assetManager.GetProjectFileUrl(e);\n    }\n    getMediaFileUrl(e) {\n      return \"flat\" === assetManager.GetFileStructure() && C32.IsRelativeURL(e) && (e = e.toLowerCase()), assetManager.GetMediaFileUrl(e);\n    }\n    get mediaFolder() {\n      return assetManager.GetMediaSubfolder();\n    }\n    async decodeWebMOpus(e, t) {\n      throw new Error(\"decodeWebMOpus() is no longer supported - use Web Audio's decodeAudioData() directly as all supported platforms now support WebM Opus\");\n    }\n    loadScripts(...e) {\n      return assetManager.LoadScripts(...e);\n    }\n    compileWebAssembly(e) {\n      return assetManager.CompileWebAssembly(e);\n    }\n    loadStyleSheet(e) {\n      return assetManager.LoadStyleSheet(e);\n    }\n  };\n}\n{\n  const C32 = self.C3, C3X = self.C3X;\n  let collisionEngine = null;\n  self.ICollisionEngine = class {\n    constructor(n) {\n      collisionEngine = n, Object.defineProperties(this, { runtime: { value: collisionEngine.GetRuntime(), writable: false } });\n    }\n    testOverlap(n, e) {\n      const l = collisionEngine.GetRuntime(), i = l._UnwrapIWorldInstance(n), t = l._UnwrapIWorldInstance(e);\n      return collisionEngine.TestOverlap(i, t);\n    }\n    testOverlapAny(n, e) {\n      const l = collisionEngine.GetRuntime(), i = l._UnwrapIWorldInstance(n);\n      for (const t of e) {\n        const o = l._UnwrapIWorldInstance(t);\n        if (collisionEngine.TestOverlap(i, o)) return t;\n      }\n      return null;\n    }\n    testOverlapSolid(n) {\n      const e = collisionEngine.GetRuntime()._UnwrapIWorldInstance(n), l = collisionEngine.TestOverlapSolid(e);\n      return l ? l.GetInterfaceClass() : null;\n    }\n    setCollisionCellSize(n, e) {\n      if (C3X.RequireFiniteNumber(n), C3X.RequireFiniteNumber(e), n = Math.floor(n), e = Math.floor(e), n <= 0 || e <= 0) throw new Error(\"invalid cell size\");\n      collisionEngine.SetCollisionCellSize(n, e);\n    }\n    getCollisionCellSize() {\n      return collisionEngine.GetCollisionCellSize();\n    }\n    getCollisionCandidates(n, e) {\n      const l = collisionEngine.GetRuntime();\n      let i;\n      i = Array.isArray(n) ? n.map((n2) => l._UnwrapIObjectClass(n2)) : [l._UnwrapIObjectClass(n)];\n      const t = C32.Rect.FromObject(e), o = [];\n      return collisionEngine.GetObjectClassesCollisionCandidates(null, i, t, o), o.map((n2) => n2.GetInterfaceClass());\n    }\n  };\n}\n{\n  const C32 = self.C3, C3X = self.C3X;\n  let runtime = null;\n  const osMap = /* @__PURE__ */ new Map([[\"Windows\", \"windows\"], [\"macOS\", \"macos\"], [\"Linux\", \"linux\"], [\"Chrome OS\", \"chrome-os\"], [\"Android\", \"android\"], [\"iOS\", \"ios\"]]), browserMap = /* @__PURE__ */ new Map([[\"Chrome\", \"chrome\"], [\"Chromium\", \"chromium\"], [\"Edge\", \"edge\"], [\"Opera\", \"opera\"], [\"NW.js\", \"nwjs\"], [\"Firefox\", \"firefox\"], [\"Safari\", \"safari\"]]), browserEngineMap = /* @__PURE__ */ new Map([[\"Chromium\", \"chromium\"], [\"Gecko\", \"gecko\"], [\"WebKit\", \"webkit\"]]);\n  self.IPlatformInfo = class {\n    constructor(e) {\n      runtime = e, Object.defineProperties(this, { isMobile: { value: C32.Platform.IsMobile, writable: false }, os: { value: osMap.get(C32.Platform.OS) || \"unknown\", writable: false }, osVersion: { value: C32.Platform.OSVersion, writable: false }, browser: { value: browserMap.get(C32.Platform.Browser) || \"unknown\", writable: false }, browserVersion: { value: C32.Platform.BrowserVersion, writable: false }, browserEngine: { value: browserEngineMap.get(C32.Platform.BrowserEngine) || \"unknown\", writable: false } });\n    }\n    get exportType() {\n      let e = runtime.GetExportType();\n      return runtime.IsNWjs() ? e = \"nwjs\" : runtime.IsWindowsWebView2() ? e = \"windows-webview2\" : \"cordova\" === e ? e = \"Android\" === C32.Platform.OS ? \"cordova-android\" : \"cordova-ios\" : \"playable-ad-single-file\" !== e && \"playable-ad-zip\" !== e || (e = \"playable-ad\"), e;\n    }\n    get renderer() {\n      return runtime.GetCanvasManager().GetRendererString();\n    }\n    get rendererDetail() {\n      return runtime.GetCanvasManager().GetRendererDetailString();\n    }\n    get canvasCssWidth() {\n      return runtime.GetCanvasManager().GetCssWidth();\n    }\n    get canvasCssHeight() {\n      return runtime.GetCanvasManager().GetCssHeight();\n    }\n    get canvasDeviceWidth() {\n      return runtime.GetCanvasManager().GetDeviceWidth();\n    }\n    get canvasDeviceHeight() {\n      return runtime.GetCanvasManager().GetDeviceHeight();\n    }\n    get devicePixelRatio() {\n      return runtime.GetDevicePixelRatio();\n    }\n  };\n}\n{\n  const C32 = self.C3, C3X = self.C3X;\n  self.IStorage = class {\n    constructor(e) {\n      this._storage = e._GetProjectStorage();\n    }\n    getItem(e) {\n      return C3X.RequireString(e), this._storage.getItem(e);\n    }\n    setItem(e, t) {\n      return C3X.RequireString(e), this._storage.setItem(e, t);\n    }\n    removeItem(e) {\n      return C3X.RequireString(e), this._storage.removeItem(e);\n    }\n    clear() {\n      return this._storage.clear();\n    }\n    keys() {\n      return this._storage.keys();\n    }\n  };\n}\n{\n  const C32 = self.C3, C3X = self.C3X, internalApiToken = C32._GetInternalAPIToken();\n  self.IPlugin = class {\n    #private;\n    constructor() {\n      const e = C32.AddonManager._GetInitObject2(internalApiToken);\n      this.#private = e, Object.defineProperties(this, { runtime: { value: e.GetRuntime().GetIRuntime(), writable: false }, isSingleGlobal: { value: e.IsSingleGlobal(), writable: false }, isWorldType: { value: e.IsWorldType(), writable: false }, isHTMLElementType: { value: e.IsHTMLElementType(), writable: false }, isRotatable: { value: e.IsRotatable(), writable: false }, hasEffects: { value: e.HasEffects(), writable: false }, is3d: { value: e.Is3D(), writable: false }, supportsHierarchies: { value: e.SupportsSceneGraph(), writable: false }, supportsMesh: { value: e.SupportsMesh(), writable: false } }), e.GetRuntime()._MapScriptInterface(this, e);\n    }\n    static getByConstructor(e) {\n      if (!e) return null;\n      const t = C32.AddonManager.GetPluginByConstructorFunction(e);\n      return t ? t.GetIPlugin() : null;\n    }\n    getSingleGlobalObjectType() {\n      return this.#private.GetSingleGlobalObjectClass().GetIObjectClass();\n    }\n    getSingleGlobalInstance() {\n      return this.#private.GetSingleGlobalInstance().GetInterfaceClass();\n    }\n  };\n}\n{\n  const C32 = self.C3, C3X = self.C3X, internalApiToken = C32._GetInternalAPIToken();\n  self.IObjectClass = class {\n    #private;\n    constructor() {\n      const e = C32.AddonManager._GetInitObject2(internalApiToken);\n      this.#private = e, Object.defineProperties(this, { name: { value: e.GetName(), writable: false }, runtime: { value: e.GetRuntime().GetIRuntime(), writable: false }, plugin: { value: e.GetPlugin().GetIPlugin(), writable: false } }), e.GetRuntime()._MapScriptInterface(this, e);\n    }\n    addEventListener(e, t) {\n      C3X.RequireString(e), C3X.RequireFunction(t), this.#private.UserScriptDispatcher().addEventListener(e, t);\n    }\n    removeEventListener(e, t) {\n      C3X.RequireString(e), C3X.RequireFunction(t), this.#private.UserScriptDispatcher().removeEventListener(e, t);\n    }\n    getAllInstances() {\n      return [...this.instances()];\n    }\n    getFirstInstance() {\n      return C32.first(this.instances());\n    }\n    getPickedInstances() {\n      return [...this.pickedInstances()];\n    }\n    getFirstPickedInstance() {\n      return C32.first(this.pickedInstances());\n    }\n    getPairedInstance(e) {\n      const t = this.#private, n = t.GetRuntime()._UnwrapIInstance(e), s = t.GetPairedInstance(n);\n      return s ? s.GetInterfaceClass() : null;\n    }\n    *instances() {\n      for (const e of this.#private.instancesIncludingPendingCreate()) yield e.GetInterfaceClass();\n    }\n    *pickedInstances() {\n      for (const e of this.#private.GetCurrentSol().GetInstances()) yield e.GetInterfaceClass();\n    }\n    setInstanceClass(e) {\n      C3X.RequireFunction(e);\n      const t = this.#private;\n      if (0 < t.GetInstanceCount()) throw new Error(\"setInstanceClass() called too late, because instances have already been created - call in runOnStartup\");\n      t._SetUserScriptInstanceClass(e);\n    }\n    createInstance(e, t, n, s, r) {\n      if (C3X.RequireNumber(t), C3X.RequireNumber(n), \"number\" != typeof e && \"string\" != typeof e) throw new TypeError(\"invalid layer parameter\");\n      const i = this.#private, a = i.GetRuntime(), c = a.GetMainRunningLayout().GetLayer(e);\n      if (!c) throw new Error(\"invalid layer\");\n      const l = a.CreateInstance(i, c, t, n, s, r), u = (s && c.SortAndAddInstancesByZIndex(l), a.GetEventSheetManager());\n      return u.BlockFlushingInstances(true), l._TriggerOnCreatedOnSelfAndRelated(), u.BlockFlushingInstances(false), u.IsInEventEngine() || a.GetLayoutManager().IsEndingLayout() || a.FlushPendingInstances(), l.GetInterfaceClass();\n    }\n  };\n}\n{\n  const C32 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap(), VALID_WHERE_STRINGS = [\"above\", \"below\", \"top-sublayer\", \"bottom-sublayer\"];\n  self.ILayout = class {\n    constructor(e) {\n      map.set(this, e);\n      const t = [], r = e.GetEffectList(), i = r.GetAllEffectTypes().length;\n      for (let e2 = 0; e2 < i; ++e2) t.push(new self.IEffectInstance(r, e2));\n      Object.defineProperties(this, { name: { value: e.GetName(), writable: false }, index: { value: e.GetIndex(), writable: false }, effects: { value: t, writable: false } });\n    }\n    addEventListener(e, t) {\n      C3X.RequireString(e), C3X.RequireFunction(t), map.get(this).UserScriptDispatcher().addEventListener(e, t);\n    }\n    removeEventListener(e, t) {\n      C3X.RequireString(e), C3X.RequireFunction(t), map.get(this).UserScriptDispatcher().removeEventListener(e, t);\n    }\n    get width() {\n      return map.get(this).GetWidth();\n    }\n    set width(e) {\n      C3X.RequireFiniteNumber(e), map.get(this).SetWidth(e);\n    }\n    get height() {\n      return map.get(this).GetHeight();\n    }\n    set height(e) {\n      C3X.RequireFiniteNumber(e), map.get(this).SetHeight(e);\n    }\n    setSize(e, t) {\n      C3X.RequireFiniteNumber(e), C3X.RequireFiniteNumber(t);\n      const r = map.get(this);\n      r.SetWidth(e), r.SetHeight(t);\n    }\n    getSize() {\n      const e = map.get(this);\n      return [e.GetWidth(), e.GetHeight()];\n    }\n    set scale(e) {\n      C3X.RequireFiniteNumber(e), map.get(this).SetScale(e);\n    }\n    get scale() {\n      return map.get(this).GetScale();\n    }\n    set angle(e) {\n      C3X.RequireFiniteNumber(e), map.get(this).SetAngle(e);\n    }\n    get angle() {\n      return map.get(this).GetAngle();\n    }\n    set scrollX(e) {\n      C3X.RequireNumber(e), map.get(this).SetScrollX(e);\n    }\n    get scrollX() {\n      return map.get(this).GetScrollX();\n    }\n    set scrollY(e) {\n      C3X.RequireNumber(e), map.get(this).SetScrollY(e);\n    }\n    get scrollY() {\n      return map.get(this).GetScrollY();\n    }\n    scrollTo(e, t) {\n      C3X.RequireNumber(e), C3X.RequireNumber(t);\n      const r = map.get(this);\n      r.SetScrollX(e), r.SetScrollY(t);\n    }\n    getScrollPosition() {\n      const e = map.get(this);\n      return [e.GetScrollX(), e.GetScrollY()];\n    }\n    getLayer(e) {\n      const t = map.get(this);\n      let r = null;\n      if (\"number\" != typeof e && \"string\" != typeof e) throw new TypeError(\"expected string or number\");\n      return (r = t.GetLayer(e)) ? r.GetILayer() : null;\n    }\n    getAllLayers() {\n      return map.get(this).GetLayers().map((e) => e.GetILayer());\n    }\n    *allLayers() {\n      for (const e of map.get(this).allLayers()) yield e.GetILayer();\n    }\n    addLayer(e, t, r) {\n      const i = map.get(this), n = self.ILayer, a = (C3X.RequireString(e), C3X.RequireOptionalInstanceOf(t, n), t ? i.GetRuntime()._UnwrapScriptInterface(t) : null), s = VALID_WHERE_STRINGS.indexOf(r);\n      if (s < 0) throw new Error(\"invalid location\");\n      i.AddLayer(e, a, s);\n    }\n    moveLayer(e, t, r) {\n      const i = map.get(this), n = i.GetRuntime(), a = self.ILayer, s = (C3X.RequireInstanceOf(e, a), n._UnwrapScriptInterface(e));\n      if (!s) throw new Error(\"invalid layer\");\n      C3X.RequireOptionalInstanceOf(t, a);\n      const o = t ? n._UnwrapScriptInterface(t) : null, l = VALID_WHERE_STRINGS.indexOf(r);\n      if (l < 0) throw new Error(\"invalid location\");\n      i.MoveLayer(s, o, l);\n    }\n    removeLayer(e) {\n      const t = map.get(this), r = self.ILayer, i = (C3X.RequireInstanceOf(e, r), t.GetRuntime()._UnwrapScriptInterface(e));\n      if (!i) throw new Error(\"invalid layer\");\n      const n = i.GetRuntime();\n      t.RemoveLayer(i), n.GetEventSheetManager().IsInEventEngine() || n.FlushPendingInstances();\n    }\n    removeAllDynamicLayers() {\n      const e = map.get(this), t = e.GetRuntime();\n      e.RemoveAllDynamicLayers(), t.GetEventSheetManager().IsInEventEngine() || t.FlushPendingInstances();\n    }\n    setVanishingPoint(e, t) {\n      C3X.RequireFiniteNumber(e), C3X.RequireFiniteNumber(t), map.get(this).SetVanishingPointXY(e, t);\n    }\n    getVanishingPoint() {\n      return map.get(this)._GetVanishingPoint();\n    }\n    set projection(e) {\n      C3X.RequireString(e);\n      const t = map.get(this);\n      if (\"perspective\" === e) t.SetPerspectiveProjection();\n      else {\n        if (\"orthographic\" !== e) throw new Error(\"invalid projection\");\n        t.SetOrthographicProjection();\n      }\n    }\n    get projection() {\n      return map.get(this).IsOrthographicProjection() ? \"orthographic\" : \"perspective\";\n    }\n  };\n}\n{\n  const C32 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap(), BLEND_MODE_TO_INDEX = /* @__PURE__ */ new Map([[\"normal\", 0], [\"additive\", 1], [\"copy\", 3], [\"destination-over\", 4], [\"source-in\", 5], [\"destination-in\", 6], [\"source-out\", 7], [\"destination-out\", 8], [\"source-atop\", 9], [\"destination-atop\", 10]]), INDEX_TO_BLEND_MODE = new Map([...BLEND_MODE_TO_INDEX.entries()].map((e) => [e[1], e[0]])), tempColor = C32.New(C32.Color);\n  self.ILayer = class {\n    constructor(e) {\n      map.set(this, e);\n      const t = [], r = e.GetEffectList(), a = r.GetAllEffectTypes().length;\n      for (let e2 = 0; e2 < a; ++e2) t.push(new self.IEffectInstance(r, e2));\n      Object.defineProperties(this, { name: { value: e.GetName(), writable: false }, layout: { value: e.GetLayout().GetILayout(), writable: false }, effects: { value: t, writable: false } }), e.GetRuntime()._MapScriptInterface(this, e);\n    }\n    get parentLayer() {\n      const e = map.get(this).GetParentLayer();\n      return e ? e.GetILayer() : null;\n    }\n    *parentLayers() {\n      for (const e of map.get(this).parentLayers()) yield e.GetILayer();\n    }\n    *subLayers() {\n      for (const e of map.get(this).GetSubLayers()) yield e.GetILayer();\n    }\n    *allSubLayers() {\n      for (const e of map.get(this).GetSubLayers()) for (const t of e.selfAndAllSubLayers()) yield t.GetILayer();\n    }\n    get index() {\n      return map.get(this).GetIndex();\n    }\n    get isVisible() {\n      return map.get(this)._IsVisibleFlagSet();\n    }\n    set isVisible(e) {\n      map.get(this).SetVisible(e);\n    }\n    get isSelfAndParentsVisible() {\n      return map.get(this).IsVisible();\n    }\n    get isInteractive() {\n      return map.get(this).IsInteractive();\n    }\n    set isInteractive(e) {\n      map.get(this).SetInteractive(e);\n    }\n    get isHTMLElementsLayer() {\n      return map.get(this).IsHTMLElementsLayer();\n    }\n    set isHTMLElementsLayer(e) {\n      map.get(this).SetIsHTMLElementsLayer(!!e);\n    }\n    get isSelfAndParentsInteractive() {\n      return map.get(this).IsSelfAndParentsInteractive();\n    }\n    get opacity() {\n      return map.get(this).GetOpacity();\n    }\n    set opacity(e) {\n      e = C32.clamp(+e, 0, 1), isNaN(e) || map.get(this).SetOpacity(e);\n    }\n    set scale(e) {\n      C3X.RequireFiniteNumber(e), map.get(this).SetOwnScale(e);\n    }\n    get scale() {\n      return map.get(this).GetOwnScale();\n    }\n    set scaleRate(e) {\n      C3X.RequireFiniteNumber(e), map.get(this).SetScaleRate(e);\n    }\n    get scaleRate() {\n      return map.get(this).GetScaleRate();\n    }\n    set angle(e) {\n      C3X.RequireFiniteNumber(e), map.get(this).SetAngle(e);\n    }\n    get angle() {\n      return map.get(this).GetOwnAngle();\n    }\n    set parallaxX(e) {\n      C3X.RequireFiniteNumber(e), map.get(this).SetParallaxX(e);\n    }\n    get parallaxX() {\n      return map.get(this).GetParallaxX();\n    }\n    set parallaxY(e) {\n      C3X.RequireFiniteNumber(e), map.get(this).SetParallaxY(e);\n    }\n    get parallaxY() {\n      return map.get(this).GetParallaxY();\n    }\n    set zElevation(e) {\n      C3X.RequireFiniteNumber(e), map.get(this).SetZElevation(e);\n    }\n    get zElevation() {\n      return map.get(this).GetZElevation();\n    }\n    set isTransparent(e) {\n      map.get(this).SetTransparent(e);\n    }\n    get isTransparent() {\n      return map.get(this).IsTransparent();\n    }\n    set isForceOwnTexture(e) {\n      map.get(this).SetForceOwnTexture(e);\n    }\n    get isForceOwnTexture() {\n      return map.get(this).IsForceOwnTexture();\n    }\n    set blendMode(e) {\n      C3X.RequireString(e);\n      const t = BLEND_MODE_TO_INDEX.get(e);\n      if (\"number\" != typeof t) throw new Error(\"invalid blend mode\");\n      map.get(this).SetBlendMode(t);\n    }\n    get blendMode() {\n      return INDEX_TO_BLEND_MODE.get(map.get(this).GetBlendMode());\n    }\n    set backgroundColor(e) {\n      if (C3X.RequireArray(e), e.length < 3) throw new Error(\"expected 3 elements\");\n      tempColor.setRgb(e[0], e[1], e[2]);\n      const t = map.get(this), r = t.GetBackgroundColor();\n      r.equalsIgnoringAlpha(tempColor) || (r.copyRgb(tempColor), t.GetRuntime().UpdateRender());\n    }\n    get backgroundColor() {\n      const e = map.get(this).GetBackgroundColor();\n      return [e.getR(), e.getG(), e.getB()];\n    }\n    set scrollX(e) {\n      C3X.RequireNumber(e);\n      const t = map.get(this);\n      t.SetOwnScrollPositionEnabled(true), t.SetScrollX(e);\n    }\n    get scrollX() {\n      return map.get(this).GetScrollX();\n    }\n    set scrollY(e) {\n      C3X.RequireNumber(e);\n      const t = map.get(this);\n      t.SetOwnScrollPositionEnabled(true), t.SetScrollY(e);\n    }\n    get scrollY() {\n      return map.get(this).GetScrollY();\n    }\n    scrollTo(e, t) {\n      C3X.RequireNumber(e), C3X.RequireNumber(t);\n      const r = map.get(this);\n      r.SetOwnScrollPositionEnabled(true), r.SetScrollX(e), r.SetScrollY(t);\n    }\n    getScrollPosition() {\n      const e = map.get(this);\n      return [e.GetScrollX(), e.GetScrollY()];\n    }\n    restoreScrollPosition() {\n      map.get(this).SetOwnScrollPositionEnabled(false);\n    }\n    getViewport() {\n      return map.get(this).GetViewport().toDOMRect();\n    }\n    cssPxToLayer(e, t, r = 0) {\n      C3X.RequireNumber(e), C3X.RequireNumber(t), C3X.RequireNumber(r);\n      const a = map.get(this), s = a.GetRuntime();\n      return a.CanvasCssToLayer(e - s.GetCanvasClientX(), t - s.GetCanvasClientY(), r);\n    }\n    layerToCssPx(e, t, r = 0) {\n      C3X.RequireNumber(e), C3X.RequireNumber(t), C3X.RequireNumber(r);\n      const a = map.get(this), s = a.GetRuntime(), [i, n] = a.LayerToCanvasCss(e, t, r);\n      return [i + s.GetCanvasClientX(), n + s.GetCanvasClientY()];\n    }\n    drawSurfaceToLayer(e, t, r = 0) {\n      return C3X.RequireNumber(e), C3X.RequireNumber(t), C3X.RequireNumber(r), map.get(this).DrawSurfaceToLayer(e, t, r);\n    }\n    layerToDrawSurface(e, t, r = 0) {\n      return C3X.RequireNumber(e), C3X.RequireNumber(t), C3X.RequireNumber(r), map.get(this).LayerToDrawSurface(e, t, r);\n    }\n    get renderScale() {\n      return map.get(this).GetRenderScale();\n    }\n  };\n}\n{\n  let GetDispatcher = function(e) {\n    let t = dispatchers.get(e);\n    return t || (t = C32.New(C32.Event.Dispatcher), dispatchers.set(e, t)), t;\n  };\n  GetDispatcher2 = GetDispatcher;\n  const C32 = self.C3, C3X = self.C3X, dispatchers = /* @__PURE__ */ new WeakMap(), internalApiToken = C32._GetInternalAPIToken();\n  self.IInstance = class {\n    #private;\n    constructor() {\n      const e = C32.AddonManager._GetInitObject2(internalApiToken), t = { runtime: { value: (this.#private = e).GetRuntime().GetIRuntime(), writable: false }, objectType: { value: e.GetObjectClass().GetIObjectClass(), writable: false }, plugin: { value: e.GetPlugin().GetIPlugin(), writable: false } };\n      e._GetInstVarsScriptDescriptor(t), e._GetBehaviorsScriptDescriptor(t), Object.defineProperties(this, t), e.GetRuntime()._MapScriptInterface(this, e);\n    }\n    static _GetInitInst() {\n      return C32.AddonManager._GetInitObject();\n    }\n    _release() {\n      const e = dispatchers.get(this);\n      e && (e.Release(), dispatchers.delete(this));\n    }\n    addEventListener(e, t, i) {\n      C3X.RequireString(e), C3X.RequireFunction(t), GetDispatcher(this).addEventListener(e, t, i);\n    }\n    removeEventListener(e, t, i) {\n      C3X.RequireString(e), C3X.RequireFunction(t), GetDispatcher(this).removeEventListener(e, t, i);\n    }\n    dispatchEvent(e) {\n      GetDispatcher(this).dispatchEvent(e);\n    }\n    destroy() {\n      const e = this.#private, t = e.GetRuntime();\n      t.DestroyInstance(e), t.GetEventSheetManager().IsInEventEngine() || t.GetLayoutManager().IsEndingLayout() || t.GetEventSheetManager().IsFlushingBlocked() || t.FlushPendingInstances();\n    }\n    getOtherContainerInstances() {\n      const e = this.#private.GetSiblings();\n      return e ? e.map((e2) => e2.GetInterfaceClass()) : [];\n    }\n    *otherContainerInstances() {\n      const e = this.#private;\n      if (e.IsInContainer()) for (const t of e.siblings()) yield t.GetInterfaceClass();\n    }\n    get uid() {\n      return this.#private.GetUID();\n    }\n    get iid() {\n      return this.#private.GetIID();\n    }\n    get templateName() {\n      return this.#private.GetTemplateName();\n    }\n    set timeScale(e) {\n      C3X.RequireFiniteNumber(e), this.#private.SetTimeScale(e);\n    }\n    get timeScale() {\n      return this.#private.GetActiveTimeScale();\n    }\n    restoreTimeScale() {\n      this.#private.RestoreTimeScale();\n    }\n    get dt() {\n      const e = this.#private;\n      return e.GetRuntime().GetDt(e);\n    }\n    hasTags(...e) {\n      C3X.RequireArray(e);\n      const t = new Set(e), i = this.#private.GetTagsSet();\n      return t.isSubsetOf(i);\n    }\n    setAllTags(e) {\n      C3X.RequireInstanceOf(e, Set), this.#private.SetTagsSet(e);\n    }\n    getAllTags() {\n      return new Set(this.#private.GetTagsSet());\n    }\n    signal(e) {\n      C3X.RequireString(e);\n      const t = this.#private;\n      t.GetRuntime().GetEventSheetManager().InstanceSignal(t, e);\n    }\n    waitForSignal(e) {\n      C3X.RequireString(e);\n      const t = this.#private;\n      return t.GetRuntime().GetEventSheetManager().WaitForInstanceSignal(t, e);\n    }\n  };\n}\nvar GetDispatcher2;\n{\n  const C32 = self.C3, C3X = self.C3X, internalApiToken = C32._GetInternalAPIToken();\n  self.ISDKInstanceBase = class extends self.IInstance {\n    #private;\n    #isTicking = false;\n    #tickFunc = null;\n    #isTicking2 = false;\n    #tickFunc2 = null;\n    #domComponentId;\n    #wrapperComponentId;\n    constructor(e) {\n      super(), this.#private = C32.AddonManager._GetInitObject2(internalApiToken), this.#isTicking = false, this.#tickFunc = null, this.#isTicking2 = false, this.#tickFunc2 = null, this.#domComponentId = e?.domComponentId, this.#wrapperComponentId = e?.wrapperComponentId;\n    }\n    _release() {\n      this._setTicking(false), this._setTicking2(false), super._release();\n    }\n    _getInitProperties() {\n      return C32.AddonManager._GetInitProperties();\n    }\n    _trigger(e) {\n      const t = this.#private;\n      t.GetRuntime().Trigger(e, t);\n    }\n    _triggerAsync(e) {\n      const t = this.#private;\n      return t.GetRuntime().TriggerAsync(e, t);\n    }\n    _addDOMMessageHandler(e, t) {\n      if (C3X.RequireString(e), C3X.RequireFunction(t), !this.#domComponentId) throw new Error(\"no DOM component id set\");\n      const n = this.#private.GetRuntime();\n      n.AddDOMComponentMessageHandler(this.#domComponentId, e, t);\n    }\n    _addDOMMessageHandlers(e) {\n      C3X.RequireArray(e);\n      for (const [t, n] of e) this._addDOMMessageHandler(t, n);\n    }\n    _postToDOM(e, t) {\n      if (C3X.RequireString(e), !this.#domComponentId) throw new Error(\"no DOM component id set\");\n      const n = this.#private.GetRuntime();\n      n.PostComponentMessageToDOM(this.#domComponentId, e, t);\n    }\n    _postToDOMAsync(e, t) {\n      if (C3X.RequireString(e), !this.#domComponentId) throw new Error(\"no DOM component id set\");\n      const n = this.#private.GetRuntime();\n      return n.PostComponentMessageToDOMAsync(this.#domComponentId, e, t);\n    }\n    _postToDOMMaybeSync(e, t) {\n      const n = this.#private.GetRuntime();\n      if (!n.IsInWorker()) return window[\"c3_runtimeInterface\"][\"_OnMessageFromRuntime\"]({ \"type\": \"event\", \"component\": this.#domComponentId, \"handler\": e, \"data\": t, \"responseId\": null });\n      this._postToDOM(e, t);\n    }\n    _setTicking(e) {\n      if (this.#isTicking !== (e = !!e)) {\n        this.#isTicking = e;\n        const t = this.#private.GetRuntime();\n        if (e) {\n          if (!this.#tickFunc) if (this.#private.GetRuntime().IsDebug()) {\n            const n = globalThis.C3Debugger, i = this.plugin;\n            this.#tickFunc = () => {\n              const e2 = performance.now();\n              this._tick(), n.AddIndividualPluginTickTime(i, performance.now() - e2);\n            };\n          } else this.#tickFunc = () => this._tick();\n          t.Dispatcher().addEventListener(\"tick\", this.#tickFunc);\n        } else t.Dispatcher().removeEventListener(\"tick\", this.#tickFunc);\n      }\n    }\n    _isTicking() {\n      return this.#isTicking;\n    }\n    _tick() {\n    }\n    _setTicking2(e) {\n      if (this.#isTicking2 !== (e = !!e)) {\n        this.#isTicking2 = e;\n        const t = this.#private.GetRuntime();\n        if (e) {\n          if (!this.#tickFunc2) if (this.#private.GetRuntime().IsDebug()) {\n            const n = globalThis.C3Debugger, i = this.plugin;\n            this.#tickFunc2 = () => {\n              const e2 = performance.now();\n              this._tick2(), n.AddIndividualPluginTickTime(i, performance.now() - e2);\n            };\n          } else this.#tickFunc2 = () => this._tick2();\n          t.Dispatcher().addEventListener(\"tick2\", this.#tickFunc2);\n        } else t.Dispatcher().removeEventListener(\"tick2\", this.#tickFunc2);\n      }\n    }\n    _isTicking2() {\n      return this.#isTicking2;\n    }\n    _tick2() {\n    }\n    _getDebuggerProperties() {\n      return [];\n    }\n    _saveToJson() {\n      return null;\n    }\n    _loadFromJson(e) {\n    }\n    _isWrapperExtensionAvailable() {\n      if (!this.#wrapperComponentId) throw new Error(\"no wrapper component id set\");\n      const e = this.#private.GetRuntime();\n      return e.HasWrapperComponentId(this.#wrapperComponentId);\n    }\n    _addWrapperExtensionMessageHandler(e, t) {\n      if (C3X.RequireString(e), C3X.RequireFunction(t), !this.#wrapperComponentId) throw new Error(\"no wrapper component id set\");\n      const n = this.#private.GetRuntime();\n      n.AddWrapperExtensionMessageHandler(this.#wrapperComponentId, e, t);\n    }\n    _addWrapperMessageHandlers(e) {\n      C3X.RequireArray(e);\n      for (const [t, n] of e) this._addWrapperExtensionMessageHandler(t, n);\n    }\n    _sendWrapperExtensionMessage(e, t) {\n      if (!this.#wrapperComponentId) throw new Error(\"no wrapper component id set\");\n      this.runtime.sdk.sendWrapperExtensionMessage(this.#wrapperComponentId, e, t);\n    }\n    _sendWrapperExtensionMessageAsync(e, t) {\n      if (this.#wrapperComponentId) return this.runtime.sdk.sendWrapperExtensionMessageAsync(this.#wrapperComponentId, e, t);\n      throw new Error(\"no wrapper component id set\");\n    }\n  };\n}\n{\n  let MakeIWorldInstanceClass = function(e) {\n    return class r extends e {\n      #privateInst;\n      #privateWi;\n      constructor(e2) {\n        super(e2);\n        const t = C32.AddonManager._GetInitObject2(internalApiToken), i = t.GetWorldInfo(), n = (this.#privateInst = t, this.#privateWi = i, map.set(this, t), []), r2 = i.GetInstanceEffectList();\n        if (r2) {\n          const a = i.GetObjectClass().GetEffectList().GetAllEffectTypes().length;\n          for (let e3 = 0; e3 < a; ++e3) n.push(new self.IEffectInstance(r2, e3));\n        }\n        const s = { effects: { value: n, writable: false } };\n        Object.defineProperties(this, s);\n      }\n      get layout() {\n        return this.#privateWi.GetLayout().GetILayout();\n      }\n      get layer() {\n        return this.#privateWi.GetLayer().GetILayer();\n      }\n      get x() {\n        return this.#privateWi.GetX();\n      }\n      set x(e2) {\n        e2 = +e2;\n        const t = this.#privateWi;\n        isNaN(e2) || t.GetX() === e2 || (t.SetX(e2), t.SetBboxChanged());\n      }\n      get y() {\n        return this.#privateWi.GetY();\n      }\n      set y(e2) {\n        e2 = +e2;\n        const t = this.#privateWi;\n        isNaN(e2) || t.GetY() === e2 || (t.SetY(e2), t.SetBboxChanged());\n      }\n      setPosition(e2, t) {\n        e2 = +e2, t = +t;\n        const i = this.#privateWi;\n        isNaN(e2) || isNaN(t) || i.GetX() === e2 && i.GetY() === t || (i.SetXY(e2, t), i.SetBboxChanged());\n      }\n      getPosition() {\n        const e2 = this.#privateWi;\n        return [e2.GetX(), e2.GetY()];\n      }\n      offsetPosition(e2, t) {\n        if (e2 = +e2, t = +t, !(isNaN(e2) || isNaN(t) || 0 === e2 && 0 === t)) {\n          const i = this.#privateWi;\n          i.OffsetXY(e2, t), i.SetBboxChanged();\n        }\n      }\n      get zElevation() {\n        return this.#privateWi.GetZElevation();\n      }\n      set zElevation(e2) {\n        e2 = +e2;\n        const t = this.#privateInst, i = this.#privateWi;\n        isNaN(e2) || i.GetZElevation() === e2 || (i.SetZElevation(e2), t.GetRuntime().UpdateRender());\n      }\n      get totalZElevation() {\n        return this.#privateWi.GetTotalZElevation();\n      }\n      get width() {\n        return this.#privateWi.GetWidth();\n      }\n      set width(e2) {\n        e2 = +e2;\n        const t = this.#privateWi;\n        isNaN(e2) || t.GetWidth() === e2 || (t.SetWidth(e2), t.SetBboxChanged());\n      }\n      get height() {\n        return this.#privateWi.GetHeight();\n      }\n      set height(e2) {\n        e2 = +e2;\n        const t = this.#privateWi;\n        isNaN(e2) || t.GetHeight() === e2 || (t.SetHeight(e2), t.SetBboxChanged());\n      }\n      setSize(e2, t) {\n        e2 = +e2, t = +t;\n        const i = this.#privateWi;\n        isNaN(e2) || isNaN(t) || i.GetWidth() === e2 && i.GetHeight() === t || (i.SetSize(e2, t), i.SetBboxChanged());\n      }\n      getSize() {\n        const e2 = this.#privateWi;\n        return [e2.GetWidth(), e2.GetHeight()];\n      }\n      get angle() {\n        return this.#privateWi.GetAngle();\n      }\n      set angle(e2) {\n        e2 = C32.clampAngle(+e2);\n        const t = this.#privateWi;\n        isNaN(e2) || t.GetAngle() === e2 || (t.SetAngle(e2), t.SetBboxChanged());\n      }\n      get angleDegrees() {\n        return C32.toDegrees(this.angle);\n      }\n      set angleDegrees(e2) {\n        this.angle = C32.toRadians(e2);\n      }\n      getBoundingBox() {\n        return this.#privateWi.GetBoundingBox().toDOMRect();\n      }\n      getBoundingQuad() {\n        return this.#privateWi.GetBoundingQuad().toDOMQuad();\n      }\n      isOnScreen() {\n        return this.#privateWi.IsInViewport2();\n      }\n      get isVisible() {\n        return this.#privateWi.IsVisible();\n      }\n      set isVisible(e2) {\n        e2 = !!e2;\n        const t = this.#privateInst, i = this.#privateWi;\n        i.IsVisible() !== e2 && (i.SetVisible(e2), t.GetRuntime().UpdateRender());\n      }\n      get opacity() {\n        return this.#privateWi.GetOpacity();\n      }\n      set opacity(e2) {\n        e2 = C32.clamp(+e2, 0, 1);\n        const t = this.#privateInst, i = this.#privateWi;\n        isNaN(e2) || i.GetOpacity() === e2 || (i.SetOpacity(e2), t.GetRuntime().UpdateRender());\n      }\n      set colorRgb(e2) {\n        if (C3X.RequireArray(e2), e2.length < 3) throw new Error(\"expected 3 elements\");\n        tempColor.setRgb(e2[0], e2[1], e2[2]);\n        const t = this.#privateInst, i = this.#privateWi;\n        i.GetUnpremultipliedColor().equalsIgnoringAlpha(tempColor) || (i.SetUnpremultipliedColor(tempColor), t.GetRuntime().UpdateRender());\n      }\n      get colorRgb() {\n        const e2 = this.#privateWi.GetUnpremultipliedColor();\n        return [e2.getR(), e2.getG(), e2.getB()];\n      }\n      set blendMode(e2) {\n        C3X.RequireString(e2);\n        const t = BLEND_MODE_TO_INDEX.get(e2);\n        if (\"number\" != typeof t) throw new Error(\"invalid blend mode\");\n        const i = this.#privateInst, n = this.#privateWi;\n        n.SetBlendMode(t), i.GetRuntime().UpdateRender();\n      }\n      get blendMode() {\n        return INDEX_TO_BLEND_MODE.get(this.#privateWi.GetBlendMode());\n      }\n      moveToTop() {\n        this.#privateWi.ZOrderMoveToTop();\n      }\n      moveToBottom() {\n        this.#privateWi.ZOrderMoveToBottom();\n      }\n      moveToLayer(e2) {\n        C3X.RequireInstanceOf(e2, ILayer);\n        const t = this.#privateInst, i = t.GetRuntime()._UnwrapScriptInterface(e2);\n        if (!i) throw new Error(\"invalid layer\");\n        t.GetWorldInfo().ZOrderMoveToLayer(i);\n      }\n      moveAdjacentToInstance(e2, t) {\n        C3X.RequireInstanceOf(e2, r), this.#privateWi.ZOrderMoveAdjacentToInstance(map.get(e2), t);\n      }\n      get zIndex() {\n        return this.#privateWi.GetZIndex();\n      }\n      get isCollisionEnabled() {\n        return this.#privateWi.IsCollisionEnabled();\n      }\n      set isCollisionEnabled(e2) {\n        this.#privateWi.SetCollisionEnabled(!!e2);\n      }\n      containsPoint(e2, t) {\n        return C3X.RequireNumber(e2), C3X.RequireNumber(t), this.#privateWi.ContainsPoint(+e2, +t);\n      }\n      testOverlap(e2) {\n        C3X.RequireInstanceOf(e2, r);\n        const t = this.#privateInst, i = map.get(e2);\n        return t.GetRuntime().GetCollisionEngine().TestOverlap(t, i);\n      }\n      testOverlapSolid() {\n        const e2 = this.#privateInst, t = e2.GetRuntime().GetCollisionEngine().TestOverlapSolid(e2);\n        return t ? t.GetInterfaceClass() : null;\n      }\n      getParent() {\n        const e2 = this.#privateInst.GetParent();\n        return e2 ? e2.GetInterfaceClass() : null;\n      }\n      getTopParent() {\n        const e2 = this.#privateInst.GetTopParent();\n        return e2 ? e2.GetInterfaceClass() : null;\n      }\n      *parents() {\n        for (const e2 of this.#privateInst.parents()) yield e2.GetInterfaceClass();\n      }\n      getChildCount() {\n        return this.#privateInst.GetChildCount();\n      }\n      getChildAt(e2) {\n        const t = this.#privateInst.GetChildAt(e2);\n        return t ? t.GetInterfaceClass() : null;\n      }\n      *children() {\n        for (const e2 of this.#privateInst.children()) yield e2.GetInterfaceClass();\n      }\n      *allChildren() {\n        for (const e2 of this.#privateInst.allChildren()) yield e2.GetInterfaceClass();\n      }\n      addChild(e2, t) {\n        C3X.RequireInstanceOf(e2, r), C3X.RequireOptionalObject(t), t = t || {};\n        const i = this.#privateInst, n = map.get(e2);\n        i.AddChild(n, t);\n      }\n      removeChild(e2) {\n        C3X.RequireInstanceOf(e2, r);\n        const t = this.#privateInst, i = map.get(e2);\n        t.RemoveChild(i);\n      }\n      removeFromParent() {\n        const e2 = this.#privateInst;\n        if (e2.HasParent()) {\n          const t = e2.GetParent();\n          t.RemoveChild(e2);\n        }\n      }\n      getHierarchyOpts() {\n        const e2 = this.#privateWi;\n        return { transformX: e2.GetTransformWithParentX(), transformY: e2.GetTransformWithParentY(), transformWidth: e2.GetTransformWithParentWidth(), transformHeight: e2.GetTransformWithParentHeight(), transformAngle: e2.GetTransformWithParentAngle(), transformZElevation: e2.GetTransformWithParentZElevation(), transformOpacity: e2.GetTransformWithParentOpacity(), transformVisibility: e2.GetTransformWithParentVisibility(), destroyWithParent: e2.GetDestroyWithParent() };\n      }\n      createMesh(e2, t) {\n        C3X.RequireFiniteNumber(e2), C3X.RequireFiniteNumber(t), this.#privateWi.CreateMesh(e2, t);\n      }\n      releaseMesh() {\n        const e2 = this.#privateWi;\n        e2.ReleaseMesh(), e2.SetBboxChanged();\n      }\n      setMeshPoint(e2, t, i) {\n        C3X.RequireFiniteNumber(e2), C3X.RequireFiniteNumber(t), C3X.RequireObject(i);\n        const n = this.#privateWi;\n        n.SetMeshPoint(e2, t, i) && n.SetBboxChanged();\n      }\n      getMeshPoint(e2, t) {\n        let i = NaN, n = NaN, r2 = NaN, s = NaN, a = NaN;\n        const o = this.#privateWi;\n        if (o.HasMesh()) {\n          const l = o.GetSourceMesh(), h = l.GetMeshPointAt(e2, t);\n          null !== h && (i = h.GetX(), n = h.GetY(), r2 = h.GetZElevation(), s = h.GetU(), a = h.GetV());\n        }\n        return { x: i, y: n, zElevation: r2, u: s, v: a };\n      }\n      getMeshSize() {\n        const e2 = this.#privateWi;\n        if (!e2.HasMesh()) return [0, 0];\n        const t = e2.GetSourceMesh();\n        return [t.GetHSize(), t.GetVSize()];\n      }\n    };\n  };\n  MakeIWorldInstanceClass2 = MakeIWorldInstanceClass;\n  const C32 = self.C3, C3X = self.C3X, IInstance = self.IInstance, ILayer = self.ILayer, map = /* @__PURE__ */ new WeakMap(), internalApiToken = C32._GetInternalAPIToken(), BLEND_MODE_TO_INDEX = /* @__PURE__ */ new Map([[\"normal\", 0], [\"additive\", 1], [\"copy\", 3], [\"destination-over\", 4], [\"source-in\", 5], [\"destination-in\", 6], [\"source-out\", 7], [\"destination-out\", 8], [\"source-atop\", 9], [\"destination-atop\", 10]]), INDEX_TO_BLEND_MODE = new Map([...BLEND_MODE_TO_INDEX.entries()].map((e) => [e[1], e[0]])), tempColor = C32.New(C32.Color);\n  self.IWorldInstance = MakeIWorldInstanceClass(self.IInstance), self.IWorldInstanceSDKBase = MakeIWorldInstanceClass(self.ISDKInstanceBase);\n}\nvar MakeIWorldInstanceClass2;\n{\n  const C32 = self.C3, C3X = self.C3X;\n  self.IDOMInstance = class extends self.IWorldInstance {\n    #private;\n    constructor() {\n      super(), this.#private = self.IInstance._GetInitInst();\n    }\n    getElement() {\n      return this.#private.GetSdkInstance()._GetElementInDOMMode();\n    }\n    focus() {\n      this.#private.GetSdkInstance().FocusElement();\n    }\n    blur() {\n      this.#private.GetSdkInstance().BlurElement();\n    }\n    setCssStyle(e, t) {\n      C3X.RequireString(e), this.#private.GetSdkInstance().SetElementCSSStyle(e, t);\n    }\n  };\n}\n{\n  let GetDispatcher = function(e) {\n    let t = dispatchers.get(e);\n    return t || (t = C32.New(C32.Event.Dispatcher), dispatchers.set(e, t)), t;\n  };\n  GetDispatcher2 = GetDispatcher;\n  const C32 = self.C3, C3X = self.C3X, dispatchers = /* @__PURE__ */ new WeakMap(), internalApiToken = C32._GetInternalAPIToken();\n  self.IBehaviorInstance = class {\n    #private;\n    constructor() {\n      const e = C32.AddonManager._GetInitObject2(internalApiToken), t = { runtime: { value: (this.#private = e).GetRuntime().GetIRuntime(), writable: false }, behavior: { value: e.GetBehavior().GetIBehavior(), writable: false }, behaviorType: { value: e.GetBehaviorType().GetIBehaviorType(), writable: false } };\n      Object.defineProperties(this, t), e.GetRuntime()._MapScriptInterface(this, e);\n    }\n    static _GetInitInst() {\n      return C32.AddonManager._GetInitObject();\n    }\n    get instance() {\n      return this.#private.GetObjectInstance().GetInterfaceClass();\n    }\n    _release() {\n      const e = dispatchers.get(this);\n      e && (e.Release(), dispatchers.delete(this));\n    }\n    addEventListener(e, t, i) {\n      C3X.RequireString(e), C3X.RequireFunction(t), GetDispatcher(this).addEventListener(e, t, i);\n    }\n    removeEventListener(e, t, i) {\n      C3X.RequireString(e), C3X.RequireFunction(t), GetDispatcher(this).removeEventListener(e, t, i);\n    }\n    dispatchEvent(e) {\n      GetDispatcher(this).dispatchEvent(e);\n    }\n  };\n}\nvar GetDispatcher2;\n{\n  const C32 = self.C3, C3X = self.C3X, internalApiToken = C32._GetInternalAPIToken();\n  self.IBehaviorType = class {\n    constructor() {\n      const e = C32.AddonManager._GetInitObject2(internalApiToken), t = { runtime: { value: e.GetRuntime().GetIRuntime(), writable: false }, behavior: { value: e.GetBehavior().GetIBehavior(), writable: false }, name: { value: e.GetName(), writable: false } };\n      Object.defineProperties(this, t);\n    }\n  };\n}\n{\n  const C32 = self.C3, C3X = self.C3X, internalApiToken = C32._GetInternalAPIToken();\n  self.IBehavior = class {\n    #private;\n    constructor() {\n      const t = C32.AddonManager._GetInitObject2(internalApiToken), e = { runtime: { value: (this.#private = t).GetRuntime().GetIRuntime(), writable: false } };\n      Object.defineProperties(this, e), t.GetRuntime()._MapScriptInterface(this, t);\n    }\n    getAllInstances() {\n      return this.#private.GetInstances().map((t) => t.GetInterfaceClass());\n    }\n    static getByConstructor(t) {\n      if (!t) return null;\n      const e = C32.AddonManager.GetBehaviorByConstructorFunction(t);\n      return e ? e.GetIBehavior() : null;\n    }\n  };\n}\n{\n  const C32 = self.C3, C3X = self.C3X, tempColor = C32.New(C32.Color);\n  self.IEffectInstance = class {\n    #private;\n    constructor(e, t) {\n      this.#private = e;\n      const i = { index: { value: t, writable: false } };\n      Object.defineProperties(this, i);\n    }\n    get name() {\n      const e = this.#private.GetAllEffectTypes();\n      return e[this.index].GetName();\n    }\n    get isActive() {\n      return this.#private.IsEffectIndexActive(this.index);\n    }\n    set isActive(e) {\n      e = !!e;\n      const t = this.#private;\n      t.IsEffectIndexActive(this.index) !== e && (t.SetEffectIndexActive(this.index, e), t.UpdateActiveEffects(), t.GetRuntime().UpdateRender());\n    }\n    setParameter(e, t) {\n      C3X.RequireFiniteNumber(e), e = Math.floor(+e);\n      const i = this.#private, r = i.GetEffectParameter(this.index, e);\n      if (null === r) throw new RangeError(\"invalid index\");\n      if (r instanceof C32.Color) {\n        if (!Array.isArray(t) || t.length < 3) throw new TypeError(\"expected array with 3 elements\");\n        tempColor.setRgb(t[0], t[1], t[2]), t = tempColor;\n      } else if (\"number\" != typeof t) throw new TypeError(\"expected number\");\n      const n = i.SetEffectParameter(this.index, e, t);\n      n && i.IsEffectIndexActive(this.index) && i.GetRuntime().UpdateRender();\n    }\n    getParameter(e) {\n      C3X.RequireFiniteNumber(e), e = Math.floor(+e);\n      const t = this.#private, i = t.GetEffectParameter(this.index, e);\n      if (null === i) throw new RangeError(\"invalid index\");\n      return i instanceof C32.Color ? [i.getR(), i.getG(), i.getB()] : i;\n    }\n  };\n}\n{\n  const C32 = self.C3, C3X = self.C3X;\n  self.IAnimation = class {\n    #private;\n    constructor(e) {\n      this.#private = e, Object.defineProperties(this, { name: { value: e.GetName(), writable: false } });\n    }\n    get speed() {\n      return this.#private.GetSpeed();\n    }\n    get isLooping() {\n      return this.#private.IsLooping();\n    }\n    get repeatCount() {\n      return this.#private.GetRepeatCount();\n    }\n    get repeatTo() {\n      return this.#private.GetRepeatTo();\n    }\n    get isPingPong() {\n      return this.#private.IsPingPong();\n    }\n    get frameCount() {\n      return this.#private.GetFrameCount();\n    }\n    getFrames() {\n      return this.#private.GetFrames().map((e) => e.GetIAnimationFrame());\n    }\n    *frames() {\n      for (const e of this.#private.GetFrames()) yield e.GetIAnimationFrame();\n    }\n  };\n}\n{\n  const C32 = self.C3, C3X = self.C3X;\n  self.IImageInfo = class {\n    #private;\n    constructor(t) {\n      this.#private = t;\n    }\n    static _Unwrap(t) {\n      return t.#private;\n    }\n    get width() {\n      return this.#private.GetWidth();\n    }\n    get height() {\n      return this.#private.GetHeight();\n    }\n    getSize() {\n      const t = this.#private;\n      return [t.GetWidth(), t.GetHeight()];\n    }\n    getTexture(t) {\n      return t.getTextureForImageInfo(this);\n    }\n    getTexRect() {\n      return this.#private.GetTexRect().toDOMRect();\n    }\n  };\n}\n{\n  const C32 = self.C3, C3X = self.C3X;\n  self.IAnimationFrame = class extends self.IImageInfo {\n    #private;\n    constructor(t) {\n      super(t.GetImageInfo()), this.#private = t, Object.defineProperties(this, { duration: { value: t.GetDuration(), writable: false }, originX: { value: t.GetOriginX(), writable: false }, originY: { value: t.GetOriginY(), writable: false } });\n    }\n    getOrigin() {\n      const t = this.#private;\n      return [t.GetOriginX(), t.GetOriginY()];\n    }\n    getImagePointCount() {\n      return this.#private.GetImagePointCount();\n    }\n    getImagePointX(t) {\n      return this.getImagePoint(t)[0];\n    }\n    getImagePointY(t) {\n      return this.getImagePoint(t)[1];\n    }\n    getImagePoint(t) {\n      const e = this.#private;\n      let i = null;\n      if (\"number\" == typeof t) i = e.GetImagePointByIndex(Math.floor(t));\n      else {\n        if (\"string\" != typeof t) throw new TypeError(\"expected string or number\");\n        i = e.GetImagePointByName(t);\n      }\n      return i ? [i.GetX(), i.GetY()] : this.getOrigin();\n    }\n    getPolyPointCount() {\n      const t = this.#private.GetCollisionPoly();\n      return t ? t.pointCount() : 0;\n    }\n    getPolyPointX(t) {\n      return this.getPolyPoint(t)[0];\n    }\n    getPolyPointY(t) {\n      return this.getPolyPoint(t)[1];\n    }\n    getPolyPoint(t) {\n      C3X.RequireFiniteNumber(t), t = Math.floor(t);\n      const e = this.#private.GetCollisionPoly();\n      if (!e || t < 0 || t >= e.pointCount()) return [0, 0];\n      const i = e.pointsArr(), n = i[2 * t], r = i[2 * t + 1];\n      return [n, r];\n    }\n    get tag() {\n      return this.#private.GetTag();\n    }\n  };\n}\n{\n  let GetTimelineState = function(e) {\n    const t = map.get(e);\n    if (t.IsReleased()) throw new Error(\"timeline/tween was released and is no longer valid\");\n    return t;\n  };\n  GetTimelineState2 = GetTimelineState;\n  const C32 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap();\n  self.ITimelineStateBase = class {\n    constructor(e) {\n      map.set(this, e), e.GetRuntime()._MapScriptInterface(this, e);\n    }\n    pause() {\n      GetTimelineState(this).Stop();\n    }\n    resume() {\n      GetTimelineState(this).Resume();\n    }\n    stop() {\n      GetTimelineState(this).Reset();\n    }\n    hasTags(e) {\n      return GetTimelineState(this).HasTags(e);\n    }\n    set time(e) {\n      C3X.RequireFiniteNumber(e), GetTimelineState(this).SetTime(e);\n    }\n    get time() {\n      return GetTimelineState(this).GetTime();\n    }\n    set totalTime(e) {\n      C3X.RequireFiniteNumber(e), GetTimelineState(this).SetTotalTime(e);\n    }\n    get totalTime() {\n      return GetTimelineState(this).GetTotalTime();\n    }\n    set isLooping(e) {\n      GetTimelineState(this).SetLoop(!!e);\n    }\n    get isLooping() {\n      return GetTimelineState(this).GetLoop();\n    }\n    set isPingPong(e) {\n      GetTimelineState(this).SetPingPong(!!e);\n    }\n    get isPingPong() {\n      return GetTimelineState(this).GetPingPong();\n    }\n    set playbackRate(e) {\n      C3X.RequireFiniteNumber(e), GetTimelineState(this).SetPlaybackRate(e);\n    }\n    get playbackRate() {\n      return GetTimelineState(this).GetPlaybackRate();\n    }\n    get progress() {\n      const e = GetTimelineState(this);\n      return e.GetTime() / e.GetTotalTime();\n    }\n    get tags() {\n      return GetTimelineState(this).GetTags();\n    }\n    get finished() {\n      return GetTimelineState(this).GetPlayPromise();\n    }\n    get isPlaying() {\n      return GetTimelineState(this).IsPlaying();\n    }\n    get isPaused() {\n      return GetTimelineState(this).IsPaused();\n    }\n    get isReleased() {\n      return map.get(this).IsReleased();\n    }\n  };\n}\nvar GetTimelineState2;\n{\n  let GetTimelineState = function(e) {\n    const t = map.get(e);\n    if (t.IsReleased()) throw new Error(\"timeline was released and is no longer valid\");\n    return t;\n  };\n  GetTimelineState2 = GetTimelineState;\n  const C32 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap();\n  let easeToIndexFunc = null;\n  self.ITimelineState = class extends self.ITimelineStateBase {\n    constructor(e) {\n      super(e), map.set(this, e);\n      const t = { name: { value: e.GetName(), writable: false } };\n      Object.defineProperties(this, t);\n    }\n  };\n}\nvar GetTimelineState2;\n{\n  let GetTweenState = function(e) {\n    const t = map.get(e);\n    if (t.IsReleased()) throw new Error(\"tween was released and is no longer valid\");\n    return t;\n  };\n  GetTweenState2 = GetTweenState;\n  const C32 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap(), behInstMap = /* @__PURE__ */ new WeakMap();\n  let easeToIndexFunc = null;\n  self.ITweenState = class extends self.ITimelineStateBase {\n    constructor(e, t, n) {\n      super(e), easeToIndexFunc = easeToIndexFunc || n.easeToIndexFunc, map.set(this, e), t && behInstMap.set(this, t);\n    }\n    stop() {\n      const e = GetTweenState(this), t = behInstMap.get(this);\n      t.ReleaseTween(e);\n    }\n    setEase(e) {\n      C3X.RequireString(e);\n      const t = self.Ease.GetEaseFromIndex(easeToIndexFunc(e));\n      GetTweenState(this).SetEase(t);\n    }\n    get instance() {\n      const e = GetTweenState(this).GetInstance();\n      return e ? e.GetInterfaceClass() : null;\n    }\n    get isDestroyOnComplete() {\n      return GetTweenState(this).GetDestroyInstanceOnComplete();\n    }\n    set isDestroyOnComplete(e) {\n      GetTweenState(this).SetDestroyInstanceOnComplete(!!e);\n    }\n    get value() {\n      const e = GetTweenState(this);\n      if (\"value\" !== e.GetId()) throw new Error(\"not a value tween\");\n      return e.GetPropertyTrack(\"value\").GetSourceAdapterValue();\n    }\n  };\n}\nvar GetTweenState2;\n{\n  const C32 = self.C3, C3X = self.C3X;\n  self.ISDKPluginBase = class extends self.IPlugin {\n    constructor() {\n      super();\n    }\n  };\n}\n{\n  const C32 = self.C3, C3X = self.C3X, internalApiToken = C32._GetInternalAPIToken();\n  self.ISDKDOMPluginBase = class extends self.ISDKPluginBase {\n    #private;\n    #domComponentId;\n    #nextElementId = 0;\n    #instMap = /* @__PURE__ */ new Map();\n    constructor(e) {\n      if (super(), this.#private = C32.AddonManager._GetInitObject2(internalApiToken), !e?.domComponentId) throw new Error(\"no DOM component ID specified\");\n      this.#domComponentId = e.domComponentId, this._addElementMessageHandler(\"elem-focused\", (e2) => e2._onElemFocused()), this._addElementMessageHandler(\"elem-blurred\", (e2) => {\n        e2 && e2._onElemBlurred();\n      });\n    }\n    _addElement(e) {\n      const n = this.#nextElementId++;\n      return this.#instMap.set(n, e), n;\n    }\n    _removeElement(e) {\n      this.#instMap.delete(e);\n    }\n    _addElementMessageHandler(e, t) {\n      const n = this.#private.GetRuntime();\n      n.AddDOMComponentMessageHandler(this.#domComponentId, e, (e2) => {\n        const n2 = this.#instMap.get(e2[\"elementId\"]);\n        t(n2, e2);\n      });\n    }\n    _addElementMessageHandlers(e) {\n      C3X.RequireArray(e);\n      for (const [n, t] of e) this._addElementMessageHandlers(n, t);\n    }\n  };\n}\n{\n  const C32 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap(), internalApiToken = C32._GetInternalAPIToken();\n  self.ISDKObjectTypeBase = class extends self.IObjectClass {\n    #private;\n    constructor() {\n      super(), this.#private = C32.AddonManager._GetInitObject2(internalApiToken);\n    }\n    _onCreate() {\n    }\n    getImageInfo() {\n      return this.#private.GetImageInfo().GetIImageInfo();\n    }\n    _loadTextures(e) {\n    }\n    _releaseTextures(e) {\n    }\n    _onDynamicTextureLoadComplete() {\n    }\n    _preloadTexturesWithInstances(e) {\n    }\n  };\n}\n{\n  const C32 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap(), internalApiToken = C32._GetInternalAPIToken();\n  self.ISDKWorldInstanceBase = class extends self.IWorldInstanceSDKBase {\n    #private;\n    #renderercontextlost_handler = null;\n    #renderercontextrestored_handler = null;\n    constructor(e) {\n      super(e), this.#private = C32.AddonManager._GetInitObject2(internalApiToken);\n    }\n    _release() {\n      if (super._release(), this.#renderercontextlost_handler) {\n        const e = this.#private.GetRuntime().Dispatcher();\n        e.removeEventListener(\"renderercontextlost\", this.#renderercontextlost_handler), e.removeEventListener(\"renderercontextrestored\", this.#renderercontextrestored_handler), this.#renderercontextlost_handler = null, this.#renderercontextrestored_handler = null;\n      }\n    }\n    _handleRendererContextLoss() {\n      if (!this.#renderercontextlost_handler) {\n        this.#renderercontextlost_handler = () => this._onRendererContextLost(), this.#renderercontextrestored_handler = () => this._onRendererContextRestored();\n        const e = this.#private.GetRuntime().Dispatcher();\n        e.addEventListener(\"renderercontextlost\", this.#renderercontextlost_handler), e.addEventListener(\"renderercontextrestored\", this.#renderercontextrestored_handler);\n      }\n    }\n    _onRendererContextLost() {\n    }\n    _onRendererContextRestored() {\n    }\n    _draw(e) {\n    }\n  };\n}\n{\n  const C32 = self.C3, C3X = self.C3X, tempRect = C32.New(C32.Rect), map = /* @__PURE__ */ new WeakMap(), internalApiToken = C32._GetInternalAPIToken();\n  self.ISDKDOMInstanceBase = class extends self.ISDKWorldInstanceBase {\n    #elementId = -1;\n    #isElementShowing = true;\n    #elemHasFocus = false;\n    #autoFontSize = false;\n    #autoFontSizeOffset = -0.2;\n    #lastRect = C32.New(C32.Rect, 0, 0, -1, -1);\n    #lastWindowWidth = 0;\n    #lastWindowHeight = 0;\n    #lastHTMLIndex = -1;\n    #lastHTMLZIndex = -1;\n    #isPendingUpdateState = false;\n    constructor(e) {\n      if (!e?.domComponentId) throw new Error(\"no DOM component ID specified\");\n      super(e);\n      const t = C32.AddonManager._GetInitObject2(internalApiToken), s = (map.set(this, t), this.#elementId = this.plugin._addElement(this), t.GetRuntime().GetCanvasManager());\n      this.#lastWindowWidth = s.GetLastWidth(), this.#lastWindowHeight = s.GetLastHeight(), this._setTicking(true);\n    }\n    _release() {\n      super._release(), this.plugin._removeElement(this.#elementId), this._postToDOMElement(\"destroy\"), this.#elementId = -1, map.delete(this);\n    }\n    _getElementInDOMMode() {\n      const e = map.get(this).GetRuntime();\n      if (e.IsInWorker()) throw new Error(\"not valid in worker mode\");\n      return this._postToDOMElementMaybeSync(\"get-element\");\n    }\n    _postToDOMElement(e, t) {\n      (t = t || {})[\"elementId\"] = this.#elementId, this._postToDOM(e, t);\n    }\n    _postToDOMElementMaybeSync(e, t) {\n      return (t = t || {})[\"elementId\"] = this.#elementId, this._postToDOMMaybeSync(e, t);\n    }\n    _postToDOMElementAsync(e, t) {\n      return (t = t || {})[\"elementId\"] = this.#elementId, this._postToDOMAsync(e, t);\n    }\n    _createElement(e) {\n      e = e || {};\n      const t = map.get(this).GetWorldInfo();\n      e[\"elementId\"] = this.#elementId, e[\"isVisible\"] = t.IsVisible(), e[\"htmlIndex\"] = t.GetLayer().GetHTMLIndex(), e[\"htmlZIndex\"] = t.GetHTMLZIndex(), Object.assign(e, this._getElementState()), this.#isElementShowing = !!e[\"isVisible\"], this._postToDOMMaybeSync(\"create\", e), this._updatePosition(true);\n    }\n    setElementVisible(e) {\n      this.#isElementShowing !== (e = !!e) && (this.#isElementShowing = e, this._postToDOMElement(\"set-visible\", { \"isVisible\": e }));\n    }\n    _tick() {\n      this._updatePosition(false);\n    }\n    _shouldPreserveElement() {\n      const e = map.get(this).GetRuntime(), t = e.GetCanvasManager().GetFullscreenMode();\n      return \"Android\" === C32.Platform.OS && (\"scale-inner\" === t || \"scale-outer\" === t || \"crop\" === t);\n    }\n    _updatePosition(n) {\n      const o = map.get(this);\n      if (!o.IsDestroyed()) {\n        const l = o.GetWorldInfo(), a = l.GetLayer(), h = l.GetBoundingBox();\n        let [e, t] = a.LayerToCanvasCss(h.getLeft(), h.getTop()), [s, i] = a.LayerToCanvasCss(h.getRight(), h.getBottom());\n        const m = o.GetRuntime().GetCanvasManager(), d = m.GetCssWidth(), r = m.GetCssHeight();\n        if (l.IsVisible() && a.IsVisible()) if (!this._shouldPreserveElement() && (s <= 0 || i <= 0 || d <= e || r <= t)) this.setElementVisible(false);\n        else {\n          tempRect.set(e, t, s, i);\n          const c = m.GetLastWidth(), p = m.GetLastHeight(), u = a.GetHTMLIndex(), M = l.GetHTMLZIndex();\n          if (!n && tempRect.equals(this.#lastRect) && this.#lastWindowWidth === c && this.#lastWindowHeight === p && this.#lastHTMLIndex === u && this.#lastHTMLZIndex === M) this.setElementVisible(true);\n          else {\n            this.#lastRect.copy(tempRect), this.#lastWindowWidth = c, this.#lastWindowHeight = p, this.#lastHTMLIndex = u, this.#lastHTMLZIndex = M, this.setElementVisible(true);\n            let e2 = null;\n            this.#autoFontSize && (e2 = a.GetDisplayScale() + this.#autoFontSizeOffset), this._postToDOMElement(\"update-position\", { \"left\": Math.round(this.#lastRect.getLeft()), \"top\": Math.round(this.#lastRect.getTop()), \"width\": Math.round(this.#lastRect.width()), \"height\": Math.round(this.#lastRect.height()), \"htmlIndex\": u, \"htmlZIndex\": M, \"fontSize\": e2 });\n          }\n        }\n        else this.setElementVisible(false);\n      }\n    }\n    focusElement() {\n      this._postToDOMElementMaybeSync(\"focus\", { \"focus\": true });\n    }\n    blurElement() {\n      this._postToDOMElementMaybeSync(\"focus\", { \"focus\": false });\n    }\n    _onElemFocused() {\n      this.#elemHasFocus = true;\n    }\n    _onElemBlurred() {\n      this.#elemHasFocus = false;\n    }\n    isElementFocused() {\n      return this.#elemHasFocus;\n    }\n    setElementCSSStyle(e, t) {\n      this.postToDOMElement(\"set-css-style\", { \"prop\": C32.CSSToCamelCase(e), \"val\": t });\n    }\n    setElementAttribute(e, t) {\n      this.postToDOMElement(\"set-attribute\", { \"name\": e, \"val\": t });\n    }\n    removeElementAttribute(e) {\n      this.postToDOMElement(\"remove-attribute\", { \"name\": e });\n    }\n    _updateElementState() {\n      this.#isPendingUpdateState || (this.#isPendingUpdateState = true, Promise.resolve().then(() => {\n        this.#isPendingUpdateState = false, this._postToDOMElement(\"update-state\", this._getElementState());\n      }));\n    }\n    _getElementState() {\n    }\n    _getElementId() {\n      return this.#elementId;\n    }\n  };\n}\n{\n  const C32 = self.C3, C3X = self.C3X;\n  self.ISDKBehaviorBase = class extends self.IBehavior {\n    constructor() {\n      super();\n    }\n  };\n}\n{\n  const C32 = self.C3, C3X = self.C3X;\n  self.ISDKBehaviorTypeBase = class extends globalThis.IBehaviorType {\n    constructor() {\n      super();\n    }\n    _onCreate() {\n    }\n  };\n}\n{\n  const C32 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap(), internalApiToken = C32._GetInternalAPIToken();\n  self.ISDKBehaviorInstanceBase = class extends self.IBehaviorInstance {\n    #isTicking = false;\n    #isTicking2 = false;\n    #isPostTicking = false;\n    constructor() {\n      super(), map.set(this, C32.AddonManager._GetInitObject2(internalApiToken));\n    }\n    _release() {\n      super._release(), this._setTicking(false), this._setTicking2(false), this._setPostTicking(false), map.delete(this);\n    }\n    _getInitProperties() {\n      return C32.AddonManager._GetInitProperties();\n    }\n    _postCreate() {\n    }\n    _trigger(i) {\n      const t = map.get(this);\n      t.GetRuntime().Trigger(i, t.GetObjectInstance(), t.GetBehaviorType());\n    }\n    _triggerAsync(i) {\n      const t = map.get(this);\n      return t.GetRuntime().TriggerAsync(i, t.GetObjectInstance(), t.GetBehaviorType());\n    }\n    _setTicking(i) {\n      if (this.#isTicking !== (i = !!i)) {\n        this.#isTicking = i;\n        const t = map.get(this).GetRuntime();\n        i ? t._AddBehInstToTick(this) : t._RemoveBehInstToTick(this);\n      }\n    }\n    _isTicking() {\n      return this.#isTicking;\n    }\n    _tick() {\n    }\n    _setTicking2(i) {\n      if (this.#isTicking2 !== (i = !!i)) {\n        this.#isTicking2 = i;\n        const t = map.get(this).GetRuntime();\n        i ? t._AddBehInstToTick2(this) : t._RemoveBehInstToTick2(this);\n      }\n    }\n    _isTicking2() {\n      return this.#isTicking2;\n    }\n    _tick2() {\n    }\n    _setPostTicking(i) {\n      if (this.#isPostTicking !== (i = !!i)) {\n        this.#isPostTicking = i;\n        const t = map.get(this).GetRuntime();\n        i ? t._AddBehInstToPostTick(this) : t._RemoveBehInstToPostTick(this);\n      }\n    }\n    _isPostTicking() {\n      return this.#isPostTicking;\n    }\n    _postTick() {\n    }\n    _getDebuggerProperties() {\n      return [];\n    }\n    _saveToJson() {\n      return null;\n    }\n    _loadFromJson(i) {\n    }\n  };\n}\n{\n  const C32 = self.C3, C3X = self.C3X;\n  let runtime = null;\n  self.ISDKUtils = class {\n    constructor(e) {\n      runtime = e;\n    }\n    addLoadPromise(e) {\n      runtime.AddLoadPromise(e);\n    }\n    sendWrapperExtensionMessage(e, n, t) {\n      C3X.RequireString(e), C3X.RequireString(n), C3X.RequireOptionalArray(t), runtime.SendWrapperExtensionMessage(e, n, t);\n    }\n    sendWrapperExtensionMessageAsync(e, n, t) {\n      return C3X.RequireString(e), C3X.RequireString(n), C3X.RequireOptionalArray(t), runtime.SendWrapperExtensionMessageAsync(e, n, t);\n    }\n    createLoopingConditionContext(e) {\n      return C3X.RequireOptionalString(e), new self.ILoopingConditionContext(runtime, e);\n    }\n    set isAutoSuspendEnabled(e) {\n      runtime._SetAutoSuspendEnabled(!!e);\n    }\n    get isAutoSuspendEnabled() {\n      return runtime._IsAutoSuspendEnabled();\n    }\n    setSuspended(e) {\n      runtime.SetSuspended(!!e);\n    }\n    getObjectClassBySid(e) {\n      C3X.RequireNumber(e);\n      const n = runtime.GetObjectClassBySID(e);\n      return n ? n.GetIObjectClass() : null;\n    }\n  };\n}\n{\n  const C32 = self.C3, C3X = self.C3X;\n  self.ILoopingConditionContext = class {\n    #runtime;\n    #currentEvent;\n    #solModifiers;\n    #oldFrame;\n    #newFrame;\n    #loop;\n    constructor(e, t) {\n      const o = (this.#runtime = e).GetEventSheetManager(), n = e.GetCurrentEvent(), r = (this.#currentEvent = n, this.#solModifiers = n.GetSolModifiers(), e.GetEventStack()), s = (this.#oldFrame = r.GetCurrentStackFrame(), this.#newFrame = r.Push(n), o.GetLoopStack()), i = s.Push();\n      this.#loop = i, t && i.SetName(t), e.SetDebuggingEnabled(false);\n    }\n    retrigger() {\n      const e = this.#runtime.GetEventSheetManager(), t = this.#solModifiers, o = this.#loop;\n      e.PushCopySol(t), this.#currentEvent.Retrigger(this.#oldFrame, this.#newFrame), e.PopSol(t), o.SetIndex(o.GetIndex() + 1);\n    }\n    get isStopped() {\n      return this.#loop.IsStopped();\n    }\n    release() {\n      const e = this.#runtime, t = e.GetEventStack(), o = e.GetEventSheetManager().GetLoopStack();\n      e.SetDebuggingEnabled(true), o.Pop(), t.Pop();\n    }\n  };\n}\n{\n  const C32 = self.C3, C3X = self.C3X;\n  let renderer = null, runtime = null;\n  self.IRenderer = class {\n    constructor(e, r) {\n      runtime = e, renderer = r;\n    }\n    setAlphaBlendMode() {\n      renderer.SetAlphaBlend();\n    }\n    setBlendMode(e) {\n      renderer.SetNamedBlendMode(e);\n    }\n    setColorFillMode() {\n      renderer.SetColorFillMode();\n    }\n    setTextureFillMode() {\n      renderer.SetTextureFillMode();\n    }\n    setSmoothLineFillMode() {\n      renderer.SetSmoothLineFillMode();\n    }\n    setColor(e) {\n      renderer.SetColorRgba(e[0], e[1], e[2], e[3]);\n    }\n    setColorRgba(e, r, n, t) {\n      renderer.SetColorRgba(e, r, n, t);\n    }\n    resetColor() {\n      renderer.ResetColor();\n    }\n    setOpacity(e) {\n      renderer.SetOpacity(e);\n    }\n    setCurrentZ(e) {\n      renderer.SetCurrentZ(e);\n    }\n    getCurrentZ() {\n      renderer.GetCurrentZ();\n    }\n    rect(e) {\n      renderer.Rect2(e.left, e.top, e.right, e.bottom);\n    }\n    rect2(e, r, n, t) {\n      renderer.Rect2(e, r, n, t);\n    }\n    quad(e) {\n      renderer.Quad(C32.Quad.fromDOMQuad(e));\n    }\n    quad2(e, r, n, t, a, d, o, i) {\n      renderer.Quad2(e, r, n, t, a, d, o, i);\n    }\n    quad3(e, r) {\n      renderer.Quad3(C32.Quad.fromDOMQuad(e), C32.Rect.fromDOMRect(r));\n    }\n    quad4(e, r) {\n      renderer.Quad4(C32.Quad.fromDOMQuad(e), C32.Quad.fromDOMQuad(r));\n    }\n    quad3D(e, r, n, t, a, d, o, i, u, l, s, p, c) {\n      renderer.Quad3D(e, r, n, t, a, d, o, i, u, l, s, p, C32.Rect.fromDOMRect(c));\n    }\n    quad3D2(e, r, n, t, a, d, o, i, u, l, s, p, c) {\n      renderer.Quad3D2(e, r, n, t, a, d, o, i, u, l, s, p, C32.Quad.fromDOMQuad(c));\n    }\n    drawMesh(e, r, n) {\n      renderer.DrawMesh(e, r, n);\n    }\n    convexPoly(e) {\n      renderer.ConvexPoly(e);\n    }\n    line(e, r, n, t) {\n      renderer.Line(e, r, n, t);\n    }\n    texturedLine(e, r, n, t, a, d) {\n      renderer.TexturedLine(e, r, n, t, a, d);\n    }\n    lineRect(e, r, n, t) {\n      renderer.LineRect(e, r, n, t);\n    }\n    lineRect2(e) {\n      renderer.LineRect2(C32.Rect.fromDOMRect(e));\n    }\n    lineQuad(e) {\n      renderer.LineQuad(C32.Quad.fromDOMQuad(e));\n    }\n    pushLineWidth(e) {\n      renderer.PushLineWidth(e);\n    }\n    popLineWidth() {\n      renderer.PopLineWidth();\n    }\n    pushLineCap(e) {\n      renderer.PushLineCap(e);\n    }\n    popLineCap() {\n      renderer.PopLineCap();\n    }\n    setTexture(e) {\n      C3X.RequireOptionalInstanceOf(e, self.ITexture);\n      const r = e ? runtime._UnwrapScriptInterface(e) : null;\n      renderer.SetTexture(r);\n    }\n    loadTextureForImageInfo(e, r) {\n      const n = self.IImageInfo._Unwrap(e);\n      if (n) return n.LoadStaticTexture(renderer, { wrapX: r?.wrapX ?? \"clamp-to-edge\", wrapY: r?.wrapY ?? \"clamp-to-edge\", sampling: r?.sampling ?? \"trilinear\", mipMap: r?.mipMap ?? true });\n      throw new Error(\"invalid IImageInfo\");\n    }\n    releaseTextureForImageInfo(e) {\n      const r = self.IImageInfo._Unwrap(e);\n      if (!r) throw new Error(\"invalid IImageInfo\");\n      r.ReleaseTexture();\n    }\n    getTextureForImageInfo(e) {\n      const r = self.IImageInfo._Unwrap(e);\n      if (!r) throw new Error(\"invalid IImageInfo\");\n      const n = r.GetTexture();\n      return self.ITexture.GetInterface(runtime, n);\n    }\n    createDynamicTexture(e, r, n) {\n      C3X.RequireFiniteNumber(e), C3X.RequireFiniteNumber(r);\n      const t = renderer.CreateDynamicTexture(e, r, { wrapX: n?.wrapX ?? \"clamp-to-edge\", wrapY: n?.wrapY ?? \"clamp-to-edge\", sampling: n?.sampling ?? \"trilinear\", mipMap: n?.mipMap ?? true });\n      return self.ITexture.GetInterface(runtime, t);\n    }\n    updateTexture(e, r, n) {\n      C3X.RequireInstanceOf(r, self.ITexture);\n      const t = runtime._UnwrapScriptInterface(r);\n      renderer.UpdateTexture(e, t, { premultiplyAlpha: n?.premultiplyAlpha ?? true });\n    }\n    deleteTexture(e) {\n      C3X.RequireInstanceOf(e, self.ITexture);\n      const r = runtime._UnwrapScriptInterface(e);\n      renderer.DeleteTexture(r);\n    }\n    createRendererText() {\n      const e = renderer.CreateRendererText();\n      return new self.IRendererText(runtime, e);\n    }\n    setDeviceTransform() {\n      runtime.GetCanvasManager().SetDeviceTransform(renderer);\n    }\n    setLayerTransform(e) {\n      C3X.RequireInstanceOf(e, globalThis.ILayer);\n      const r = runtime._UnwrapScriptInterface(e);\n      r._SetTransform(renderer);\n    }\n  };\n}\n{\n  const C32 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap(), reverseMap = /* @__PURE__ */ new WeakMap();\n  self.ITexture = class {\n    constructor(e, t) {\n      map.set(this, { runtime: e, texture: t }), reverseMap.set(t, this), e._MapScriptInterface(this, t), Object.defineProperties(this, { width: { value: t.GetWidth(), writable: false }, height: { value: t.GetHeight(), writable: false } });\n    }\n    static GetInterface(e, t) {\n      if (!t) return null;\n      const r = reverseMap.get(t);\n      return r || new self.ITexture(e, t);\n    }\n  };\n}\n{\n  let getActual = function(t) {\n    return map.get(t).rendererText;\n  };\n  getActual2 = getActual;\n  const C32 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap();\n  self.IRendererText = class {\n    constructor(t, e) {\n      map.set(this, { runtime: t, rendererText: e }), t._MapScriptInterface(this, e);\n    }\n    release() {\n      getActual(this).Release();\n    }\n    set fontFace(t) {\n      C3X.RequireString(t), getActual(this).SetFontName(t);\n    }\n    get fontFace() {\n      return getActual(this).GetFontName();\n    }\n    set sizePt(t) {\n      C3X.RequireFiniteNumber(t), getActual(this).SetFontSize(t);\n    }\n    get sizePt() {\n      return getActual(this).GetFontSize();\n    }\n    set lineHeight(t) {\n      C3X.RequireFiniteNumber(t), getActual(this).SetLineHeight(t);\n    }\n    get lineHeight() {\n      return getActual(this).GetLineHeight();\n    }\n    set isBold(t) {\n      getActual(this).SetBold(t);\n    }\n    get isBold() {\n      return getActual(this).IsBold();\n    }\n    set isItalic(t) {\n      getActual(this).SetItalic(t);\n    }\n    get isItalic() {\n      return getActual(this).IsItalic();\n    }\n    setColor(t) {\n      C3X.RequireArray(t), this.setColorRgb(t[0], t[1], t[2]);\n    }\n    setColorRgb(t, e, i) {\n      getActual(this).SetColorRgb(t, e, i);\n    }\n    setCssColor(t) {\n      C3X.RequireString(t), getActual(this).SetColor(t);\n    }\n    set horizontalAlign(t) {\n      getActual(this).SetHorizontalAlignment(t);\n    }\n    get horizontalAlign() {\n      return getActual(this).GetHorizontalAlignment();\n    }\n    set verticalAlign(t) {\n      getActual(this).SetVerticalAlignment(t);\n    }\n    get verticalAlign() {\n      return getActual(this).GetVerticalAlignment();\n    }\n    set wordWrapMode(t) {\n      getActual(this).SetWordWrapMode(t);\n    }\n    get wordWrapMode() {\n      return getActual(this).GetWordWrapMode();\n    }\n    set textDirection(t) {\n      getActual(this).SetTextDirection(t);\n    }\n    get textDirection() {\n      return getActual(this).GetTextDirection();\n    }\n    set text(t) {\n      C3X.RequireString(t), getActual(this).SetText(t);\n    }\n    get text() {\n      return getActual(this).GetText();\n    }\n    setSize(t, e, i) {\n      C3X.RequireFiniteNumber(t), C3X.RequireFiniteNumber(e), C3X.RequireFiniteNumber(i), getActual(this).SetSize(t, e, i);\n    }\n    getTexture() {\n      const { runtime: t, rendererText: e } = map.get(this), i = e.GetTexture();\n      return self.ITexture.GetInterface(t, i);\n    }\n    getTexRect() {\n      return getActual(this).GetTexRect().toDOMRect();\n    }\n    setTextureUpdateCallback(t) {\n      C3X.RequireFunction(t), getActual(this).ontextureupdate = t;\n    }\n    releaseTexture() {\n      getActual(this).ReleaseTexture();\n    }\n    get textWidth() {\n      return getActual(this).GetTextWidth();\n    }\n    get textHeight() {\n      return getActual(this).GetTextHeight();\n    }\n  };\n}\nvar getActual2;\n{\n  let GetTypeFromFileExtension = function(e) {\n    if (!e) return \"\";\n    const t = e.split(\".\");\n    if (t.length < 2) return \"\";\n    const i = t.at(-1).toLowerCase();\n    return EXT_TO_TYPE.get(i) || \"\";\n  }, AddScript = function(o) {\n    return new Promise((e, t) => {\n      const i = document.createElement(\"script\");\n      i.onload = e, i.onerror = t, i.async = false, i.type = \"module\", i.src = o, document.head.appendChild(i);\n    });\n  };\n  GetTypeFromFileExtension2 = GetTypeFromFileExtension, AddScript2 = AddScript;\n  const C32 = self.C3, VALID_LOAD_POLICIES = /* @__PURE__ */ new Set([\"local\", \"remote\"]), EXT_TO_TYPE = /* @__PURE__ */ new Map([[\"mp4\", \"video/mp4\"], [\"webm\", \"video/webm\"], [\"m4a\", \"audio/mp4\"], [\"mp3\", \"audio/mpeg\"], [\"js\", \"application/javascript\"], [\"wasm\", \"application/wasm\"], [\"svg\", \"image/svg+xml\"], [\"html\", \"text/html\"]]);\n  C32.AssetManager = class extends C32.DefendedBase {\n    constructor(e, t) {\n      super();\n      const i = t[\"exportType\"], o = (this._runtime = e, this._fileStructure = \"folders\", this._cordovaBlobUrlCache = /* @__PURE__ */ new Map(), this._isCordova = \"cordova\" === i, this._isiOSCordova = !!t[\"isiOSCordova\"], this._isFileProtocol = !!t[\"isFileProtocol\"], this._swClientId = t[\"swClientId\"], this._supportedAudioFormats = t[\"supportedAudioFormats\"] || {}, this._audioFiles = /* @__PURE__ */ new Map(), this._preloadSounds = false, this._scriptSubfolder = t[\"scriptFolder\"], this._mediaSubfolder = \"\", this._fontsSubfolder = \"\", this._iconsSubfolder = \"\", this._fileMap = t[\"fileMap\"] || /* @__PURE__ */ new Map(), this._fileMapBlobUrls = /* @__PURE__ */ new Map(), \"html5\" === i || \"scirra-arcade\" === i || \"instant-games\" === i);\n      this._defaultLoadPolicy = o ? \"remote\" : \"local\", this._assetsByUrl = /* @__PURE__ */ new Map(), this._webFonts = [], this._loadPromises = [], this._hasFinishedInitialLoad = false, this._totalAssetSizeToLoad = 0, this._assetSizeLoaded = 0, this._lastLoadProgress = 0, this._hasHadErrorLoading = false, this._loadingRateLimiter = C32.New(C32.RateLimiter, () => this._FireLoadingProgressEvent(), 50), this._localPromiseThrottle = C32.New(C32.PromiseThrottle, Math.max(C32.hardwareConcurrency, 8)), this._remotePromiseThrottle = C32.New(C32.PromiseThrottle, 20), this._iAssetManager = new self.IAssetManager(this);\n    }\n    Release() {\n      for (const e of this._assetsByUrl.values()) e.Release();\n      this._assetsByUrl.clear(), C32.clearArray(this._loadPromises), this._runtime = null;\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    _SetFileStructure(e) {\n      this._fileStructure = e;\n    }\n    GetFileStructure() {\n      return this._fileStructure;\n    }\n    GetScriptSubfolder() {\n      return this._scriptSubfolder;\n    }\n    _SetMediaSubfolder(e) {\n      this._mediaSubfolder = e;\n    }\n    GetMediaSubfolder() {\n      return this._mediaSubfolder;\n    }\n    _SetFontsSubfolder(e) {\n      this._fontsSubfolder = e;\n    }\n    GetFontsSubfolder() {\n      return this._fontsSubfolder;\n    }\n    _SetIconsSubfolder(e) {\n      this._iconsSubfolder = e;\n    }\n    GetIconsSubfolder() {\n      return this._iconsSubfolder;\n    }\n    IsFileProtocol() {\n      return this._isFileProtocol;\n    }\n    FetchBlob(e, t) {\n      return t = t || this._defaultLoadPolicy, C32.IsRelativeURL(e) ? (\"flat\" === this._fileStructure && (e = e.toLowerCase()), this._isCordova && this._isFileProtocol ? this.CordovaFetchLocalFileAsBlob(e) : \"playable-ad-single-file\" === this._runtime.GetExportType() ? self[\"c3_runtimeInterface\"][\"_PlayableAdFetchBlob\"](e) : (\"local\" === t ? this._localPromiseThrottle : this._remotePromiseThrottle).Add(() => C32.FetchBlob(e))) : C32.FetchBlob(e);\n    }\n    FetchArrayBuffer(e) {\n      return C32.IsRelativeURL(e) ? (\"flat\" === this._fileStructure && (e = e.toLowerCase()), this._isCordova && this._isFileProtocol ? this.CordovaFetchLocalFileAsArrayBuffer(e) : \"playable-ad-single-file\" === this._runtime.GetExportType() ? C32.BlobToArrayBuffer(self[\"c3_runtimeInterface\"][\"_PlayableAdFetchBlob\"](e)) : (\"local\" === this._defaultLoadPolicy ? this._localPromiseThrottle : this._remotePromiseThrottle).Add(() => C32.FetchArrayBuffer(e))) : C32.FetchArrayBuffer(e);\n    }\n    FetchText(e) {\n      return C32.IsRelativeURL(e) ? (\"flat\" === this._fileStructure && (e = e.toLowerCase()), this._isCordova && this._isFileProtocol ? this.CordovaFetchLocalFileAsText(e) : \"playable-ad-single-file\" === this._runtime.GetExportType() ? C32.BlobToString(self[\"c3_runtimeInterface\"][\"_PlayableAdFetchBlob\"](e)) : (\"local\" === this._defaultLoadPolicy ? this._localPromiseThrottle : this._remotePromiseThrottle).Add(() => C32.FetchText(e))) : C32.FetchText(e);\n    }\n    async FetchJson(e) {\n      const t = await this.FetchText(e);\n      return JSON.parse(t);\n    }\n    _CordovaFetchLocalFileAs(e, t) {\n      return \"flat\" === this._fileStructure && (e = e.toLowerCase()), this._runtime.PostComponentMessageToDOMAsync(\"runtime\", \"cordova-fetch-local-file\", { \"filename\": e, \"as\": t });\n    }\n    CordovaFetchLocalFileAsText(e) {\n      return this._CordovaFetchLocalFileAs(e, \"text\");\n    }\n    async CordovaFetchLocalFileAsBlob(e) {\n      const t = await this._CordovaFetchLocalFileAs(e, \"buffer\"), i = GetTypeFromFileExtension(e);\n      return new Blob([t], { \"type\": i });\n    }\n    async CordovaFetchLocalFileAsBlobURL(e) {\n      \"flat\" === this._fileStructure && (e = e.toLowerCase());\n      let t = this._cordovaBlobUrlCache.get(e);\n      if (!t) {\n        const i = await this.CordovaFetchLocalFileAsBlob(e);\n        t = URL.createObjectURL(i), this._cordovaBlobUrlCache.set(e, t);\n      }\n      return t;\n    }\n    CordovaFetchLocalFileAsArrayBuffer(e) {\n      return this._CordovaFetchLocalFileAs(e, \"buffer\");\n    }\n    GetMediaFileUrl(e) {\n      \"flat\" === this._fileStructure && (e = e.toLowerCase());\n      let t = this._mediaSubfolder + e;\n      return t = \"Gecko\" === C32.Platform.BrowserEngine && \"preview\" === this._runtime.GetExportType() ? this._GetLocalBlobURLFromFileMap(t) : t;\n    }\n    GetProjectFileUrl(e) {\n      return C32.IsAbsoluteURL(e) ? Promise.resolve(e) : this._isCordova && this._isFileProtocol ? this.CordovaFetchLocalFileAsBlobURL(e) : \"playable-ad-single-file\" === this._runtime.GetExportType() ? URL.createObjectURL(self[\"c3_runtimeInterface\"][\"_PlayableAdFetchBlob\"](e)) : (\"flat\" === this._fileStructure && (e = e.toLowerCase()), Promise.resolve(e));\n    }\n    GetProjectFileIframeUrl(t) {\n      if (C32.IsAbsoluteURL(t) || \"preview\" !== this._runtime.GetExportType() || !this._swClientId || !t) return t;\n      try {\n        const e = new URL(t, location.href);\n        return e.searchParams.set(\"__c3_client_id\", this._swClientId), e.toString();\n      } catch (e) {\n        return console.warn(\"Invalid iframe URL: \" + t), t;\n      }\n    }\n    LoadProjectFileUrl(e) {\n      return this.GetProjectFileUrl(e);\n    }\n    LoadImage(e) {\n      if (e.loadPolicy && !VALID_LOAD_POLICIES.has(e.loadPolicy)) throw new Error(\"invalid load policy\");\n      let t = this._assetsByUrl.get(e.url);\n      return t || (t = C32.New(C32.ImageAsset, this, { url: e.url, size: e.size || 0, loadPolicy: e.loadPolicy || this._defaultLoadPolicy }), this._assetsByUrl.set(t.GetURL(), t), this._hasFinishedInitialLoad) || (this._totalAssetSizeToLoad += t.GetSize(), this._loadPromises.push(t.Load().then(() => this._AddLoadedSize(t.GetSize())))), t;\n    }\n    _ReleaseAsset(e) {\n      this._assetsByUrl.delete(e.GetURL());\n    }\n    async WaitForAllToLoad() {\n      try {\n        await Promise.all(this._loadPromises), this._lastLoadProgress = 1;\n      } catch (e) {\n        console.error(\"Error loading: \", e), this._hasHadErrorLoading = true, this._FireLoadingProgressEvent();\n      }\n    }\n    SetInitialLoadFinished() {\n      this._hasFinishedInitialLoad = true;\n    }\n    HasHadErrorLoading() {\n      return this._hasHadErrorLoading;\n    }\n    _AddLoadedSize(e) {\n      this._assetSizeLoaded += e, this._loadingRateLimiter.Call();\n    }\n    _FireLoadingProgressEvent() {\n      const e = C32.New(C32.Event, \"loadingprogress\");\n      this._lastLoadProgress = C32.clamp(this._assetSizeLoaded / this._totalAssetSizeToLoad, 0, 1), e.progress = this._lastLoadProgress, this._runtime.Dispatcher().dispatchEvent(e);\n    }\n    GetLoadProgress() {\n      return this._lastLoadProgress;\n    }\n    GetImageLoadProgress() {\n      return this._runtime.GetSystemPlugin().GetImageLoadingProgress();\n    }\n    _SetWebFonts(e) {\n      C32.shallowAssignArray(this._webFonts, e), this._webFonts.length && this._loadPromises.push(this._LoadWebFonts());\n    }\n    async _LoadWebFonts() {\n      const e = [], t = [];\n      for (const [i, o, s] of this._webFonts) this._totalAssetSizeToLoad += s, e.push(this._LoadWebFont(i, o, t).then(() => this._AddLoadedSize(s)));\n      await Promise.all(e), this._runtime.IsInWorker() && 0 < t.length && await this._runtime.PostComponentMessageToDOMAsync(\"runtime\", \"load-webfonts\", { \"webfonts\": t });\n    }\n    async _LoadWebFont(t, i, o) {\n      try {\n        let e = await this.GetProjectFileUrl(i);\n        \"Gecko\" === C32.Platform.BrowserEngine && (t = `'${t}'`), (\"Gecko\" === C32.Platform.BrowserEngine && \"preview\" === this._runtime.GetExportType() || \"playable-ad-single-file\" === this._runtime.GetExportType()) && (e = this._GetLocalBlobURLFromFileMap(e));\n        const s = new FontFace(t, `url('${e}')`);\n        (this._runtime.IsInWorker() ? self : document).fonts.add(s), await s.load(), this._runtime.IsInWorker() && o.push({ name: t, url: e });\n      } catch (e) {\n        console.warn(`[C3 runtime] Failed to load web font '${t}': `, e);\n      }\n    }\n    IsAudioFormatSupported(e) {\n      return !!this._supportedAudioFormats[e];\n    }\n    _SetAudioFiles(e, t) {\n      this._preloadSounds = !!t;\n      for (const [i, o, s] of e) this._audioFiles.set(i, { fileName: i, formats: o.map((e2) => ({ type: e2[0], fileExtension: e2[1], fullName: i + e2[1], fileSize: e2[2] })), isMusic: s });\n    }\n    GetPreferredAudioFile(e) {\n      \"flat\" === this._fileStructure && (e = e.toLowerCase());\n      const t = this._audioFiles.get(e);\n      if (!t) return null;\n      let i = null;\n      for (const o of t.formats) if (i || \"audio/webm; codecs=opus\" !== o.type || (i = o), this.IsAudioFormatSupported(o.type)) return o;\n      return i;\n    }\n    GetProjectAudioFileUrl(e) {\n      const t = this.GetPreferredAudioFile(e);\n      return t ? { url: this.GetMediaFileUrl(t.fullName), type: t.type } : null;\n    }\n    GetAudioToPreload() {\n      if (this._preloadSounds) {\n        const e = [];\n        for (const t of this._audioFiles.values()) if (!t.isMusic) {\n          const i = this.GetPreferredAudioFile(t.fileName);\n          i && e.push({ originalUrl: t.fileName, url: this.GetMediaFileUrl(i.fullName), type: i.type, fileSize: i.fileSize });\n        }\n        return e;\n      }\n      return [];\n    }\n    _GetLocalBlobFromFileMap(e) {\n      return \"preview\" === this._runtime.GetExportType() && (e = new URL(e, location.href).toString()), this._fileMap.get(e) || null;\n    }\n    _GetLocalBlobURLFromFileMap(e) {\n      let t = this._fileMapBlobUrls.get(e);\n      if (!t) {\n        const i = this._GetLocalBlobFromFileMap(e);\n        if (!i) return e;\n        t = URL.createObjectURL(i), this._fileMapBlobUrls.set(e, t);\n      }\n      return t;\n    }\n    GetIAssetManager() {\n      return this._iAssetManager;\n    }\n    async LoadScripts(...e) {\n      const t = await Promise.all(e.map((e2) => this.GetProjectFileUrl(e2)));\n      if (this._runtime.IsInWorker()) if (1 === e.length) {\n        const i = e[0];\n        await import((C32.IsRelativeURL(i) ? \"./\" : \"\") + i);\n      } else {\n        const o = e.map((e2) => `import \"${C32.IsRelativeURL(e2) ? \"./\" : \"\"}${e2}\";`).join(\"\\n\"), s = URL.createObjectURL(new Blob([o], { type: \"application/javascript\" }));\n        await import(s);\n      }\n      else await Promise.all(t.map((e2) => AddScript(e2)));\n    }\n    async CompileWebAssembly(e) {\n      if (WebAssembly.compileStreaming) {\n        const t = await this.GetProjectFileUrl(e);\n        return WebAssembly.compileStreaming(fetch(t));\n      }\n      {\n        const i = await C32.FetchArrayBuffer(e);\n        return WebAssembly.compile(i);\n      }\n    }\n    async LoadStyleSheet(e) {\n      const t = await this.GetProjectFileUrl(e);\n      return this._runtime.PostComponentMessageToDOMAsync(\"runtime\", \"add-stylesheet\", { \"url\": t });\n    }\n  };\n}\nvar GetTypeFromFileExtension2;\nvar AddScript2;\n{\n  const C32 = self.C3;\n  C32.Asset = class extends C32.DefendedBase {\n    constructor(s, e) {\n      super(), this._assetManager = s, this._runtime = s.GetRuntime(), this._url = e.url || \"\", this._size = e.size, this._loadPolicy = e.loadPolicy, this._blob = e.blob || null, this._isLoaded = !!this._blob, this._loadPromise = null;\n    }\n    Release() {\n      this._loadPromise = null, this._assetManager = null, this._runtime = null, this._blob = null;\n    }\n    GetURL() {\n      return this._url;\n    }\n    GetSize() {\n      return this._size;\n    }\n    Load() {\n      return \"local\" === this._loadPolicy || this._blob ? (this._isLoaded = true, Promise.resolve()) : (this._loadPromise || (this._loadPromise = this._assetManager.FetchBlob(this._url, this._loadPolicy).then((s) => (this._isLoaded = true, this._loadPromise = null, this._blob = s)).catch((s) => {\n        console.error(\"Error loading resource: \", s), this._loadPromise = null;\n      })), this._loadPromise);\n    }\n    IsLoaded() {\n      return this._isLoaded;\n    }\n    GetBlob() {\n      return this._blob ? Promise.resolve(this._blob) : this._loadPromise || this._assetManager.FetchBlob(this._url, this._loadPolicy);\n    }\n  };\n}\n{\n  const C32 = self.C3, promiseThrottle = new C32.PromiseThrottle(), allImageAssets = /* @__PURE__ */ new Set();\n  C32.ImageAsset = class extends C32.Asset {\n    constructor(e, t) {\n      super(e, t), this._texturePromise = null, this._webglTexture = null, this._refCount = 0, this._imageWidth = -1, this._imageHeight = -1, allImageAssets.add(this);\n    }\n    Release() {\n      if (0 !== this._refCount) throw new Error(\"released image asset which still has texture references\");\n      this._assetManager._ReleaseAsset(this), this._texturePromise = null, allImageAssets.delete(this), super.Release();\n    }\n    static OnRendererContextLost() {\n      for (const e of allImageAssets) e._texturePromise = null, e._webglTexture = null, e._refCount = 0;\n    }\n    LoadStaticTexture(e, t) {\n      return t = t || {}, this._refCount++, this._webglTexture ? Promise.resolve(this._webglTexture) : (this._texturePromise || (t.anisotropy = this._runtime.GetCanvasManager().GetTextureAnisotropy(), this._texturePromise = this._DoLoadStaticTexture(e, t)), this._texturePromise);\n    }\n    async _DoLoadStaticTexture(t, s) {\n      try {\n        const r = await this.GetBlob();\n        return 0 === this._refCount ? this._texturePromise = null : await promiseThrottle.Add(async () => {\n          const e = await t.CreateStaticTextureAsync(r, s);\n          return this._texturePromise = null, 0 === this._refCount ? (t.DeleteTexture(e), null) : (this._webglTexture = e, this._imageWidth = e.GetWidth(), this._imageHeight = e.GetHeight(), this._webglTexture);\n        });\n      } catch (e) {\n        throw console.error(\"Failed to load texture: \", e), e;\n      }\n    }\n    ReleaseTexture() {\n      if (this._refCount <= 0) throw new Error(\"texture released too many times\");\n      if (this._refCount--, 0 === this._refCount && this._webglTexture) {\n        const e = this._webglTexture.GetRenderer();\n        e.DeleteTexture(this._webglTexture), this._webglTexture = null;\n      }\n    }\n    GetRefCount() {\n      return this._refCount;\n    }\n    GetTexture() {\n      return this._webglTexture;\n    }\n    GetWidth() {\n      return this._imageWidth;\n    }\n    GetHeight() {\n      return this._imageHeight;\n    }\n    async LoadToDrawable() {\n      const e = await this.GetBlob();\n      return C32.Supports.ImageBitmap ? createImageBitmap(e) : C32.BlobToImage(e);\n    }\n  };\n}\n{\n  let SortByInstLastCachedZIndex = function(e, s) {\n    return e.GetWorldInfo()._GetLastCachedZIndex() - s.GetWorldInfo()._GetLastCachedZIndex();\n  };\n  SortByInstLastCachedZIndex2 = SortByInstLastCachedZIndex;\n  const C32 = self.C3, assert = self.assert;\n  C32.RenderCell = class extends C32.DefendedBase {\n    constructor(e, s, n) {\n      super(), this._grid = e, this._x = s, this._y = n, this._instances = [], this._isSorted = true, this._pendingRemoval = /* @__PURE__ */ new Set(), this._isAnyPendingRemoval = false;\n    }\n    Release() {\n      C32.clearArray(this._instances), this._pendingRemoval.clear(), this._grid = null;\n    }\n    Reset() {\n      C32.clearArray(this._instances), this._isSorted = true, this._pendingRemoval.clear(), this._isAnyPendingRemoval = false;\n    }\n    SetChanged() {\n      this._isSorted = false;\n    }\n    IsEmpty() {\n      if (this._instances.length) {\n        if (this._instances.length > this._pendingRemoval.size) return false;\n        this._FlushPending();\n      }\n      return true;\n    }\n    Insert(e) {\n      this._pendingRemoval.has(e) ? (this._pendingRemoval.delete(e), 0 === this._pendingRemoval.size && (this._isAnyPendingRemoval = false)) : (this._instances.push(e), this._isSorted = 1 === this._instances.length);\n    }\n    Remove(e) {\n      this._pendingRemoval.add(e), this._isAnyPendingRemoval = true, 50 <= this._pendingRemoval.size && this._FlushPending();\n    }\n    _FlushPending() {\n      this._isAnyPendingRemoval && (this._instances.length === this._pendingRemoval.size ? this.Reset() : (C32.arrayRemoveAllInSet(this._instances, this._pendingRemoval), this._pendingRemoval.clear(), this._isAnyPendingRemoval = false));\n    }\n    _EnsureSorted() {\n      this._isSorted || (this._instances.sort(SortByInstLastCachedZIndex), this._isSorted = true);\n    }\n    Dump(e) {\n      this._FlushPending(), this._EnsureSorted(), this._instances.length && e.push(this._instances);\n    }\n  };\n}\nvar SortByInstLastCachedZIndex2;\n{\n  const C32 = self.C3;\n  C32.RenderGrid = class extends C32.DefendedBase {\n    constructor(e, t) {\n      super(), this._cellWidth = e, this._cellHeight = t, this._cells = C32.New(C32.PairMap);\n    }\n    Release() {\n      this._cells.Release(), this._cells = null;\n    }\n    GetCell(e, t, l) {\n      let s = this._cells.Get(e, t);\n      return s || (l ? (s = C32.New(C32.RenderCell, this, e, t), this._cells.Set(e, t, s), s) : null);\n    }\n    XToCell(e) {\n      return Math.floor(e / this._cellWidth);\n    }\n    YToCell(e) {\n      return Math.floor(e / this._cellHeight);\n    }\n    Update(s, o, i) {\n      if (o) {\n        for (let l = o.getLeft(), e = o.getRight(); l <= e; ++l) for (let e2 = o.getTop(), t = o.getBottom(); e2 <= t; ++e2) if (!i || !i.containsPoint(l, e2)) {\n          const h = this.GetCell(l, e2, false);\n          h && (h.Remove(s), h.IsEmpty()) && this._cells.Delete(l, e2);\n        }\n      }\n      if (i) for (let l = i.getLeft(), e = i.getRight(); l <= e; ++l) for (let e2 = i.getTop(), t = i.getBottom(); e2 <= t; ++e2) o && o.containsPoint(l, e2) || this.GetCell(l, e2, true).Insert(s);\n    }\n    QueryRange(e, t) {\n      let l = this.XToCell(e.getLeft());\n      const s = this.YToCell(e.getTop()), o = this.XToCell(e.getRight()), i = this.YToCell(e.getBottom());\n      for (; l <= o; ++l) for (let e2 = s; e2 <= i; ++e2) {\n        const h = this.GetCell(l, e2, false);\n        h && h.Dump(t);\n      }\n    }\n    MarkRangeChanged(e) {\n      let t = e.getLeft();\n      const l = e.getTop(), s = e.getRight(), o = e.getBottom();\n      for (; t <= s; ++t) for (let e2 = l; e2 <= o; ++e2) {\n        const i = this.GetCell(t, e2, false);\n        i && i.SetChanged();\n      }\n    }\n  };\n}\n{\n  let SortByInstLastCachedZIndex = function(e, t) {\n    return e.GetWorldInfo()._GetLastCachedZIndex() - t.GetWorldInfo()._GetLastCachedZIndex();\n  }, SortByInstZElevation = function(e, t) {\n    return e.GetWorldInfo().GetZElevation() - t.GetWorldInfo().GetZElevation();\n  };\n  SortByInstLastCachedZIndex2 = SortByInstLastCachedZIndex, SortByInstZElevation2 = SortByInstZElevation;\n  const C32 = self.C3, assert = self.assert, tmpRect = new C32.Rect(), tmpQuad = new C32.Quad(), renderCellArr = [], tmpDestRect = new C32.Rect(), tmpSrcRect = new C32.Rect(), glMatrix = self.glMatrix, vec3 = glMatrix.vec3, vec4 = glMatrix.vec4, mat4 = glMatrix.mat4, tempMat4 = mat4.create(), tempVec3 = vec3.create(), tempVec4 = vec4.create(), camVector = vec3.create(), lookVector = vec3.create(), upVector = vec3.create(), tempVec2 = C32.New(C32.Vector2), tempRect = C32.New(C32.Rect);\n  const tempInstanceList1 = [], tempInstanceList2 = [], tempInstancesByCameraDist = [], DEFAULT_LAYER_OPTIONS = { name: \"\", sid: -1, isDynamic: false, isVisible: true, isInteractive: true, isHTMLElementsLayer: false, backgroundColor: [1, 1, 1, 1], isTransparent: true, parallax: [1, 1], opacity: 1, isForceOwnTexture: false, renderAs3d: false, useCameraDistanceDrawOrder: false, useRenderCells: false, scaleRate: 1, blendMode: 0, zElevation: 0, initialInstancesData: [], effectListData: [], subLayersData: [] };\n  C32.Layer = class extends C32.DefendedBase {\n    constructor(e, t, s) {\n      super(), s = Object.assign({}, DEFAULT_LAYER_OPTIONS, s), this._layout = e, this._runtime = e.GetRuntime(), this._parentLayer = t, this._name = s.name, this._index = -1, this._isHTMLElementsLayer = !!s.isHTMLElementsLayer, this._htmlIndex = -1, this._sid = s.sid, this._isDynamic = !!s.isDynamic, this._isVisible = !!s.isVisible, this._isInteractive = !!s.isInteractive, this._backgroundColor = C32.New(C32.Color), this._backgroundColor.setFromJSON(s.backgroundColor), this._isTransparent = !!s.isTransparent, this._parallaxX = s.parallax[0], this._parallaxY = s.parallax[1], this._color = C32.New(C32.Color, 1, 1, 1, s.opacity), this._premultipliedColor = C32.New(C32.Color), this._isForceOwnTexture = !!s.isForceOwnTexture, this._renderAs3d = !!s.renderAs3d, this._useCameraDistanceDrawOrder = !!s.useCameraDistanceDrawOrder, this._useRenderCells = !!s.useRenderCells, this._scaleRate = s.scaleRate, this._blendMode = s.blendMode, this._curRenderTarget = null, this._scale = 1, this._zElevation = s.zElevation, this._angle = 0, this._scrollX = 0, this._scrollY = 0, this._hasOwnScrollPosition = false, this._viewport = C32.New(C32.Rect), this._viewportZ0 = C32.New(C32.Rect), this._viewport3D = C32.New(C32.Rect), this._isViewportChanged = true, this._projectionMatrix = mat4.create(), this._isProjectionMatrixChanged = true, this._modelViewMatrix = mat4.create(), this._isMVMatrixChanged = true, this._viewFrustum = C32.New(C32.Gfx.ViewFrustum), this._isViewFrustumChanged = true, this._startupInitialInstances = [], this._initialInstancesData = s.initialInstancesData, this._initialInstances = [], this._createdGlobalUids = [], this._initialUIDsToInstanceData = /* @__PURE__ */ new Map(), this._instances = [], this._zIndicesUpToDate = false, this._htmlZIndicesUpToDate = false, this._anyInstanceZElevated = false;\n      const i = this._runtime.GetCanvasManager();\n      this._effectList = C32.New(C32.EffectList, this, s.effectListData), this._effectChain = C32.New(C32.Gfx.EffectChain, i.GetEffectChainManager(), { drawContent: (e2, t2) => {\n        const s2 = t2.GetContentObject(), a = s2.GetRenderTarget();\n        e2.SetColor(s2.GetPremultipliedColor()), e2.DrawRenderTarget(a), e2.InvalidateRenderTarget(a), i.ReleaseAdditionalRenderTarget(a);\n      }, getShaderParameters: (e2) => this.GetEffectList()._GetEffectChainShaderParametersForIndex(e2) }), this._needsRebuildEffectChainSteps = true, this._wasDefaultColor = true, this._renderGrid = null, this._lastRenderList = [], this._isRenderListUpToDate = false, this._lastRenderCells = C32.New(C32.Rect, 0, 0, -1, -1), this._curRenderCells = C32.New(C32.Rect, 0, 0, -1, -1), this._iLayer = new self.ILayer(this), this._UpdatePremultipliedColor(), this.UsesRenderCells() && (this._renderGrid = C32.New(C32.RenderGrid, this._runtime.GetOriginalViewportWidth(), this._runtime.GetOriginalViewportHeight())), this._subLayers = s.subLayersData.map((e2) => C32.Layer.CreateFromExportData(this._layout, this, e2));\n    }\n    _InitInitialInstances() {\n      for (const e of this._initialInstancesData) {\n        const t = this._runtime.GetObjectClassByIndex(e[1]);\n        this._layout._AddInitialObjectClass(t), t.GetDefaultInstanceData() || (t.SetDefaultInstanceData(e), t._SetDefaultLayerIndex(this._index)), this._initialInstances.push(e), this._initialUIDsToInstanceData.set(e[2], e);\n      }\n      C32.shallowAssignArray(this._startupInitialInstances, this._initialInstances), this._initialInstancesData = null;\n    }\n    static CreateFromExportData(e, t, s) {\n      return C32.New(C32.Layer, e, t, { name: s[0], sid: s[2], isVisible: s[3], isInteractive: s[13], isHTMLElementsLayer: s[19], backgroundColor: s[4].map((e2) => e2 / 255), isTransparent: s[5], parallax: [s[6], s[7]], opacity: s[8], isForceOwnTexture: s[9], renderAs3d: s[17], useCameraDistanceDrawOrder: s[18], useRenderCells: s[10], scaleRate: s[11], blendMode: s[12], zElevation: s[16], initialInstancesData: s[14], effectListData: s[15], subLayersData: s[20] });\n    }\n    Release() {\n      for (const e of this._subLayers) e.Release();\n      C32.clearArray(this._subLayers);\n      for (const t of this._instances) this._runtime.DestroyInstance(t);\n      C32.clearArray(this._instances), this._effectList.Release(), this._effectList = null, this._effectChain.Release(), this._effectChain = null, this._iLayer = null, this._parentLayer = null, this._layout = null, this._runtime = null;\n    }\n    GetInitialInstanceData(e) {\n      return this._initialUIDsToInstanceData.get(e);\n    }\n    CreateInitialInstances(s) {\n      const a = this._layout.IsFirstVisit();\n      let i = 0;\n      const r = this._initialInstances;\n      for (let t = 0, e = r.length; t < e; ++t) {\n        const n = r[t], l = this._runtime.GetObjectClassByIndex(n[1]);\n        let e2 = true;\n        if (!l.HasPersistBehavior() || a) {\n          const o = this._runtime.CreateInstanceFromData(n, this, true);\n          s.push(o), l.IsGlobal() && (e2 = false, this._createdGlobalUids.push(o.GetUID()));\n        }\n        e2 && (r[i] = r[t], ++i);\n      }\n      C32.truncateArray(r, i), this._runtime.FlushPendingInstances(), this.SetZIndicesChanged();\n    }\n    _AddInstance(e, t) {\n      if (!e.GetPlugin().IsWorldType()) throw new Error(\"instance is not of world type\");\n      const s = e.GetWorldInfo();\n      if (s.GetLayer() !== this) throw new Error(\"instance added to wrong layer\");\n      this._instances.push(e), 0 !== s.GetZElevation() && (this._anyInstanceZElevated = true), t && this.UsesRenderCells() && e.GetWorldInfo().SetBboxChanged(), this.SetZIndicesChanged(e);\n    }\n    _MaybeAddInstance(e) {\n      this._instances.includes(e) || (this._instances.push(e), 0 !== e.GetWorldInfo().GetZElevation() && (this._anyInstanceZElevated = true), this.SetZIndicesChanged(e));\n    }\n    _PrependInstance(e, t) {\n      const s = e.GetWorldInfo();\n      if (s.GetLayer() !== this) throw new Error(\"instance added to wrong layer\");\n      this._instances.unshift(e), 0 !== s.GetZElevation() && (this._anyInstanceZElevated = true), this.SetZIndicesChanged(e), t && this.UsesRenderCells() && e.GetWorldInfo().SetBboxChanged();\n    }\n    _RemoveInstance(e, t) {\n      const s = this._instances.indexOf(e);\n      s < 0 || (t && this.UsesRenderCells() && e.GetWorldInfo()._RemoveFromRenderCells(), this._instances.splice(s, 1), this.SetZIndicesChanged(e), this._MaybeResetAnyInstanceZElevatedFlag());\n    }\n    _SetAnyInstanceZElevated() {\n      this._anyInstanceZElevated = true;\n    }\n    _MaybeResetAnyInstanceZElevatedFlag() {\n      0 === this._instances.length && (this._anyInstanceZElevated = false);\n    }\n    _SortInstancesByLastCachedZIndex(e) {\n      if (e) {\n        const t = /* @__PURE__ */ new Set();\n        for (const s of this._instances) {\n          const a = s.GetWorldInfo()._GetLastCachedZIndex();\n          0 <= a && t.add(a);\n        }\n        let e2 = -1;\n        for (const i of this._instances) {\n          const r = i.GetWorldInfo();\n          if (!(0 <= r._GetLastCachedZIndex())) {\n            for (++e2; t.has(e2); ) ++e2;\n            r._SetZIndex(e2);\n          }\n        }\n      }\n      this._instances.sort(SortByInstLastCachedZIndex);\n    }\n    _Start() {\n    }\n    _End() {\n      for (const e of this._instances) e.GetObjectClass().IsGlobal() || this._runtime.DestroyInstance(e);\n      this._runtime.FlushPendingInstances(), C32.clearArray(this._instances), this._anyInstanceZElevated = false, this.SetZIndicesChanged();\n    }\n    RecreateInitialObjects(t, e, s, a, i, r) {\n      const n = this._runtime.GetEventSheetManager(), l = this._runtime.GetAllObjectClasses(), o = t.IsFamily(), h = [];\n      for (const c of this._initialInstances) {\n        const d = c[0], _ = d[0], u = d[1];\n        if (e.containsPoint(_, u)) {\n          const G = l[c[1]];\n          if (G !== t) {\n            if (!o) continue;\n            if (!t.FamilyHasMember(G)) continue;\n          }\n          let e2 = i;\n          if (!e2) {\n            const I = this._runtime.GetCurrentLayout();\n            e2 = this.GetLayout() === I ? this : (e2 = I.GetLayerByName(this.GetName())) || I.GetLayerByIndex(this.GetIndex());\n          }\n          const f = this._runtime.CreateInstanceFromData(c, e2, false, void 0, void 0, false, r), p = (e2.SortAndAddInstancesByZIndex(f), f.GetWorldInfo());\n          p.OffsetXY(s, a), p.SetBboxChanged(), n.BlockFlushingInstances(true), f._TriggerOnCreatedOnSelfAndRelated(), n.BlockFlushingInstances(false), h.push(f);\n        }\n      }\n      return h;\n    }\n    GetInstanceCount() {\n      return this._instances.length;\n    }\n    GetLayout() {\n      return this._layout;\n    }\n    GetName() {\n      return this._name;\n    }\n    _SetIndex(e) {\n      this._index = e;\n    }\n    GetIndex() {\n      return this._index;\n    }\n    _SetHTMLIndex(e) {\n      this._htmlIndex = e;\n    }\n    GetHTMLIndex() {\n      return this._htmlIndex;\n    }\n    IsHTMLElementsLayer() {\n      return this._isHTMLElementsLayer;\n    }\n    SetIsHTMLElementsLayer(e) {\n      this._isHTMLElementsLayer !== (e = !!e) && (this._isHTMLElementsLayer = e, this._layout._ReindexAndUpdateAllLayers(), this._runtime.UpdateRender());\n    }\n    _GetSiblingIndex() {\n      let e = -1;\n      const t = this.GetParentLayer();\n      return e = (t ? t.GetSubLayers() : this.GetLayout()._GetRootLayers()).indexOf(this);\n    }\n    GetSID() {\n      return this._sid;\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    IsDynamic() {\n      return this._isDynamic;\n    }\n    HasAnyDynamicParentLayer() {\n      for (const e of this.parentLayers()) if (e.IsDynamic()) return true;\n      return false;\n    }\n    GetDevicePixelRatio() {\n      return this._runtime.GetDevicePixelRatio();\n    }\n    GetEffectList() {\n      return this._effectList;\n    }\n    GetEffectChain() {\n      return this._MaybeRebuildEffectChainSteps(), this._effectChain;\n    }\n    _MaybeRebuildEffectChainSteps() {\n      const e = this.HasDefaultColor();\n      if (this._needsRebuildEffectChainSteps || e !== this._wasDefaultColor || this._effectChain.NeedsRebuild()) {\n        const t = this.GetEffectList().GetActiveEffectTypes();\n        this._effectChain.BuildSteps(t.map((e2) => e2.GetShaderProgram()), { indexMap: t.map((e2) => e2.GetIndex()), forcePreDraw: !e, useFullSurface: true }), this._needsRebuildEffectChainSteps = false, this._wasDefaultColor = e;\n      }\n    }\n    UpdateActiveEffects() {\n      this.GetEffectList().UpdateActiveEffects(), this._needsRebuildEffectChainSteps = true;\n    }\n    UsesRenderCells() {\n      return this._useRenderCells && !this._useCameraDistanceDrawOrder;\n    }\n    GetRenderGrid() {\n      return this._renderGrid;\n    }\n    SetRenderListStale() {\n      this._isRenderListUpToDate = false;\n    }\n    IsVisible() {\n      for (const e of this.selfAndParentLayers()) if (!e._IsVisibleFlagSet()) return false;\n      return true;\n    }\n    _IsVisibleFlagSet() {\n      return this._isVisible;\n    }\n    SetVisible(e) {\n      this._isVisible !== (e = !!e) && (this._isVisible = e, this._runtime.UpdateRender());\n    }\n    SetInteractive(e) {\n      this._isInteractive = !!e;\n    }\n    IsInteractive() {\n      return this._isInteractive;\n    }\n    IsSelfAndParentsInteractive() {\n      for (const e of this.selfAndParentLayers()) if (!e.IsInteractive()) return false;\n      return true;\n    }\n    SetOwnScrollPositionEnabled(e) {\n      if (this._hasOwnScrollPosition !== (e = !!e)) {\n        if (this._hasOwnScrollPosition = e) {\n          const t = this.GetLayout();\n          this._scrollX = t.GetScrollX(), this._scrollY = t.GetScrollY();\n        }\n        this._SetMVMatrixChanged(), this._runtime.UpdateRender();\n      }\n    }\n    IsOwnScrollPositionEnabled() {\n      return this._hasOwnScrollPosition;\n    }\n    SetScrollX(e) {\n      const t = this.GetLayout(), s = t.GetScrollLeftBound(), a = t.GetScrollRightBound();\n      this._scrollX !== (e = (e = a < e ? a : e) < s ? s : e) && (this._scrollX = e, this.IsOwnScrollPositionEnabled()) && (this._SetMVMatrixChanged(), this._runtime.UpdateRender());\n    }\n    SetScrollY(e) {\n      const t = this.GetLayout(), s = t.GetScrollTopBound(), a = t.GetScrollBottomBound();\n      this._scrollY !== (e = (e = a < e ? a : e) < s ? s : e) && (this._scrollY = e, this.IsOwnScrollPositionEnabled()) && (this._SetMVMatrixChanged(), this._runtime.UpdateRender());\n    }\n    GetScrollX() {\n      return this.IsOwnScrollPositionEnabled() ? this._scrollX : this.GetLayout().GetScrollX();\n    }\n    GetScrollY() {\n      return this.IsOwnScrollPositionEnabled() ? this._scrollY : this.GetLayout().GetScrollY();\n    }\n    GetViewport() {\n      return this._MaybeUpdateViewport(), this._viewport;\n    }\n    _GetViewportZ0() {\n      return this._MaybeUpdateViewport(), this._viewportZ0;\n    }\n    GetViewport3D() {\n      return this._MaybeUpdateViewport(), this._viewport3D;\n    }\n    _GetVanishingPoint() {\n      const e = this.GetLayout();\n      return [e.GetVanishingPointX(), e.GetVanishingPointY()];\n    }\n    GetDefaultCameraZ(e) {\n      return this._runtime.GetDefaultCameraZ(e);\n    }\n    GetViewportForZ(l, o) {\n      const h = this._GetViewportZ0();\n      if (0 === l) o.copy(h);\n      else {\n        let s = h.midX(), a = h.midY(), e = this.Get2DScaleFactorToZ(l), t = h.width() / e, i = h.height() / e, [r, n] = this._GetVanishingPoint();\n        if (0.5 !== r || 0.5 !== n) {\n          const c = this.Get2DCameraZ(), d = this._runtime, _ = this.GetDefaultCameraZ() / c;\n          let e2 = (r - 0.5) * d.GetViewportWidth() / _, t2 = (n - 0.5) * d.GetViewportHeight() / _;\n          const u = this.GetAngle(), G = (0 !== u && (tempVec2.set(e2, t2), tempVec2.rotate(u), e2 = tempVec2.getX(), t2 = tempVec2.getY()), C32.unlerp(c, 0, l));\n          s += C32.lerp(e2, 0, G), a += C32.lerp(t2, 0, G);\n        }\n        o.set(s - t / 2, a - i / 2, s + t / 2, a + i / 2);\n      }\n    }\n    GetOpacity() {\n      return this._color.getA();\n    }\n    SetOpacity(e) {\n      e = C32.clamp(e, 0, 1), this._color.getA() !== e && (this._color.setA(e), this._UpdatePremultipliedColor(), this._runtime.UpdateRender());\n    }\n    _UpdatePremultipliedColor() {\n      this._premultipliedColor.copy(this._color), this._premultipliedColor.premultiply();\n    }\n    GetPremultipliedColor() {\n      return this._premultipliedColor;\n    }\n    HasDefaultColor() {\n      return this._color.equalsRgba(1, 1, 1, 1);\n    }\n    GetScaleRate() {\n      return this._scaleRate;\n    }\n    SetScaleRate(e) {\n      this._scaleRate !== e && (this._scaleRate = e, this._SetMVMatrixChanged(), this._runtime.UpdateRender());\n    }\n    GetParallaxX() {\n      return this._parallaxX;\n    }\n    GetParallaxY() {\n      return this._parallaxY;\n    }\n    SetParallax(e, t) {\n      this._parallaxX === e && this._parallaxY === t || (this._parallaxX = e, this._parallaxY = t, this._SetMVMatrixChanged(), this._runtime.UpdateRender());\n    }\n    SetParallaxX(e) {\n      this.SetParallax(e, this.GetParallaxY());\n    }\n    SetParallaxY(e) {\n      this.SetParallax(this.GetParallaxX(), e);\n    }\n    SetZElevation(e) {\n      this._zElevation !== e && (this._zElevation = e, this._runtime.UpdateRender());\n    }\n    GetZElevation() {\n      return this._zElevation;\n    }\n    SetAngle(e) {\n      e = C32.clampAngle(e), this._angle !== e && (this._angle = e, this._SetMVMatrixChanged(), this._runtime.UpdateRender());\n    }\n    GetAngle() {\n      return C32.clampAngle(this._layout.GetAngle() + this._angle);\n    }\n    GetOwnAngle() {\n      return this._angle;\n    }\n    HasInstances() {\n      return 0 < this._instances.length;\n    }\n    _GetInstances() {\n      return this._instances;\n    }\n    _GetInstancesInDrawOrder() {\n      return this.RendersIn3DMode() && this._useCameraDistanceDrawOrder ? (C32.shallowAssignArray(tempInstancesByCameraDist, this._GetInstances()), tempInstancesByCameraDist.sort((e, t) => this._SortInstancesByCameraDistance(e, t)), tempInstancesByCameraDist) : this._GetInstances();\n    }\n    _AppendAllInstancesIncludingSubLayersInDrawOrder(e) {\n      C32.appendArray(e, this._GetInstancesInDrawOrder());\n      for (const t of this._subLayers) t.IsVisible() && 0 < t.GetOpacity() && t._AppendAllInstancesIncludingSubLayersInDrawOrder(e);\n    }\n    _SortInstancesByCameraDistance(e, t) {\n      const s = this.GetLayout().Get3DCameraPosition(), a = s[0], i = s[1], r = s[2], n = e.GetWorldInfo(), l = t.GetWorldInfo(), o = n.GetX() - a, h = n.GetY() - i, c = n.GetZElevation() - r, d = l.GetX() - a, _ = l.GetY() - i, u = l.GetZElevation() - r;\n      return d * d + _ * _ + u * u - (o * o + h * h + c * c);\n    }\n    GetBackgroundColor() {\n      return this._backgroundColor;\n    }\n    IsTransparent() {\n      return this._isTransparent;\n    }\n    SetTransparent(e) {\n      this._isTransparent !== (e = !!e) && (this._isTransparent = e, this._runtime.UpdateRender());\n    }\n    IsForceOwnTexture() {\n      return this._isForceOwnTexture;\n    }\n    SetForceOwnTexture(e) {\n      this._isForceOwnTexture !== (e = !!e) && (this._isForceOwnTexture = e, this._runtime.UpdateRender());\n    }\n    RendersIn2DMode() {\n      return !this.GetRuntime().Uses3DFeatures() || !this._renderAs3d;\n    }\n    RendersIn3DMode() {\n      return !this.RendersIn2DMode();\n    }\n    Has3DCamera() {\n      return this.RendersIn3DMode() && this.GetLayout().Is3DCameraEnabled();\n    }\n    SelfAndAllSubLayersHave3DCamera() {\n      if (!this.Has3DCamera()) return false;\n      for (const e of this._subLayers) if (!e.SelfAndAllSubLayersHave3DCamera()) return false;\n      return true;\n    }\n    SetBlendMode(e) {\n      this._blendMode !== e && (this._blendMode = e, this._runtime.UpdateRender());\n    }\n    GetBlendMode() {\n      return this._blendMode;\n    }\n    IsRootLayer() {\n      return !this._parentLayer;\n    }\n    GetParentLayer() {\n      return this._parentLayer;\n    }\n    _SetParentLayer(e) {\n      this._parentLayer = e;\n    }\n    GetSubLayers() {\n      return this._subLayers;\n    }\n    HasAnySubLayers() {\n      return 0 < this._subLayers.length;\n    }\n    _AddSubLayer(e, t = true) {\n      t ? this._subLayers.push(e) : this._subLayers.unshift(e);\n    }\n    _InsertSubLayer(e, t, s) {\n      let a = this._subLayers.indexOf(t);\n      if (-1 === a) throw new Error(\"cannot find layer to insert by\");\n      s && ++a, this._subLayers.splice(a, 0, e);\n    }\n    _RemoveSubLayer(e) {\n      const t = this._subLayers.indexOf(e);\n      if (-1 === t) throw new Error(\"cannot find layer to remove\");\n      this._subLayers.splice(t, 1);\n    }\n    HasAnyVisibleSubLayer() {\n      for (const e of this._subLayers) if (e.ShouldDraw()) return true;\n      return false;\n    }\n    *selfAndAllSubLayers() {\n      for (const e of this._subLayers) yield* e.selfAndAllSubLayers();\n      yield this;\n    }\n    *parentLayers() {\n      let e = this.GetParentLayer();\n      for (; e; ) yield e, e = e.GetParentLayer();\n    }\n    *selfAndParentLayers() {\n      yield this, yield* this.parentLayers();\n    }\n    HasParentLayer(e) {\n      for (const t of this.parentLayers()) if (t === e) return true;\n      return false;\n    }\n    IsTransformCompatibleWith(e) {\n      return this === e || this._parallaxX === e._parallaxX && this._parallaxY === e._parallaxY && this._scale === e._scale && this._scaleRate === e._scaleRate && this._angle === e._angle && this.GetScrollX() === e.GetScrollX() && this.GetScrollY() === e.GetScrollY();\n    }\n    SaveTransform() {\n      return { \"parallaxX\": this.GetParallaxX(), \"parallaxY\": this.GetParallaxY(), \"scale\": this.GetOwnScale(), \"scaleRate\": this.GetScaleRate(), \"angle\": this.GetOwnAngle(), \"hasOwnScroll\": this.IsOwnScrollPositionEnabled(), \"scrollX\": this.GetScrollX(), \"scrollY\": this.GetScrollY() };\n    }\n    RestoreTransform(e) {\n      this.SetParallax(e[\"parallaxX\"], e[\"parallaxY\"]), this.SetOwnScale(e[\"scale\"]), this.SetScaleRate(e[\"scaleRate\"]), this.SetAngle(e[\"angle\"]), this.SetOwnScrollPositionEnabled(e[\"hasOwnScroll\"]), this.SetScrollX(e[\"scrollX\"]), this.SetScrollY(e[\"scrollY\"]), this._MaybeUpdateViewport();\n    }\n    _RemoveAllInstancesInSet(e) {\n      if (0 !== e.size) {\n        const t = C32.arrayRemoveAllInSet(this._instances, e);\n        0 < t && (this._MaybeResetAnyInstanceZElevatedFlag(), this.SetZIndicesChanged());\n      }\n    }\n    SetZIndicesChanged(e) {\n      this._zIndicesUpToDate = false, this._isRenderListUpToDate = false, e && !e.GetObjectClass().GetPlugin().IsHTMLElementType() || (this._htmlZIndicesUpToDate = false);\n    }\n    _UpdateZIndices() {\n      if (!this._zIndicesUpToDate) {\n        if (this._instances.sort(SortByInstZElevation), this.UsesRenderCells()) for (let e = 0, t = this._instances.length; e < t; ++e) {\n          const s = this._instances[e].GetWorldInfo();\n          s._SetZIndex(e), this._renderGrid.MarkRangeChanged(s.GetRenderCellRange());\n        }\n        else for (let e = 0, t = this._instances.length; e < t; ++e) this._instances[e].GetWorldInfo()._SetZIndex(e);\n        this._zIndicesUpToDate = true;\n      }\n    }\n    _UpdateHTMLZIndices() {\n      if (!this._htmlZIndicesUpToDate) {\n        const t = this._layout.GetRootLayersForHTMLLayer(this.GetHTMLIndex()), s = t.map((e2) => [...e2.selfAndAllSubLayers()]).flat();\n        let e = 0;\n        for (const a of s) {\n          for (const i of a._GetInstances()) i.GetObjectClass().GetPlugin().IsHTMLElementType() && i.GetWorldInfo()._SetHTMLZIndex(e++);\n          a._SetHTMLZIndicesUpToDate();\n        }\n      }\n    }\n    _SetHTMLZIndicesUpToDate() {\n      this._htmlZIndicesUpToDate = true;\n    }\n    _GetHTMLLayerDOMState() {\n      return { \"isVisible\": this.IsVisible(), \"opacity\": this.GetOpacity(), \"isInteractive\": this.IsInteractive() };\n    }\n    MoveInstanceAdjacent(e, t, s) {\n      const a = e.GetWorldInfo(), i = t.GetWorldInfo();\n      if (a.GetLayer() !== this || i.GetLayer() !== this) throw new Error(\"can't arrange Z order unless both objects on this layer\");\n      const r = a.GetZIndex();\n      let n = i.GetZIndex();\n      return r !== n + (s ? 1 : -1) && (C32.arrayRemove(this._instances, r), r < n && n--, s && n++, n === this._instances.length ? this._instances.push(e) : this._instances.splice(n, 0, e), this.SetZIndicesChanged(e), true);\n    }\n    _MergeSortedZArrays(e, t) {\n      const s = [];\n      let a = 0, i = 0, r = e.length, n = t.length;\n      for (; a < r && i < n; ) {\n        const l = e[a], o = t[i];\n        l.GetWorldInfo()._GetLastCachedZIndex() < o.GetWorldInfo()._GetLastCachedZIndex() ? (s.push(l), ++a) : (s.push(o), ++i);\n      }\n      for (; a < r; ++a) s.push(e[a]);\n      for (; i < n; ++i) s.push(t[i]);\n      return s;\n    }\n    _MergeAllSortedZArrays_pass(t) {\n      const s = [], a = t.length;\n      for (let e = 0; e < a - 1; e += 2) {\n        const i = t[e], r = t[e + 1];\n        s.push(this._MergeSortedZArrays(i, r));\n      }\n      return a % 2 == 1 && s.push(t[a - 1]), s;\n    }\n    _MergeAllSortedZArrays(e) {\n      for (; 1 < e.length; ) e = this._MergeAllSortedZArrays_pass(e);\n      return e[0];\n    }\n    _GetRenderCellInstancesToDraw() {\n      return this._UpdateZIndices(), C32.clearArray(renderCellArr), this._renderGrid.QueryRange(this.GetViewport(), renderCellArr), renderCellArr.length ? 1 === renderCellArr.length ? renderCellArr[0] : this._MergeAllSortedZArrays(renderCellArr) : [];\n    }\n    ShouldDraw() {\n      return this.IsVisible() && 0 < this.GetOpacity() && this._DrawsAnyContentInSelfOrSubLayers();\n    }\n    _DrawsAnyContentInSelfOrSubLayers() {\n      if (this.HasInstances() || !this.IsTransparent()) return true;\n      for (const e of this._subLayers) if (e._DrawsAnyContentInSelfOrSubLayers()) return true;\n      return false;\n    }\n    UsesOwnTexture() {\n      return this.IsForceOwnTexture() || !this.HasDefaultColor() || 0 !== this.GetBlendMode() || this._effectList.HasAnyActiveEffect();\n    }\n    SelfOrAnySubLayerUsesOwnTexture() {\n      if (this.UsesOwnTexture()) return true;\n      for (const e of this._subLayers) if (e.SelfOrAnySubLayerUsesOwnTexture()) return true;\n      return false;\n    }\n    GetRenderTarget() {\n      return this._curRenderTarget;\n    }\n    Get2DScaleFactorToZ(e) {\n      if (this._layout.IsOrthographicProjection()) return 1;\n      {\n        const t = this.Get3DCameraZ();\n        return t / (t - e);\n      }\n    }\n    GetResolutionScaleFactorToZ(e) {\n      const t = this._runtime.GetRenderScale();\n      if (this._layout.IsOrthographicProjection()) return t;\n      {\n        const s = this.Get3DCameraZ(), a = this.GetDefaultCameraZ();\n        return a / Math.abs(s - e) * t;\n      }\n    }\n    _SetMVMatrixChanged() {\n      this._isMVMatrixChanged = true, this._isViewFrustumChanged = true, this._isViewportChanged = true;\n    }\n    _GetModelViewMatrix(e) {\n      return this._isMVMatrixChanged && (this._CalculateModelViewMatrix(e, this._modelViewMatrix, 0, 0, null), this._isMVMatrixChanged = false), this._modelViewMatrix;\n    }\n    Get2DCameraZ(e) {\n      return this.GetDefaultCameraZ(e) / this.GetNormalScale();\n    }\n    Get3DCameraZ() {\n      return this.Has3DCamera() ? this.GetLayout().Get3DCameraPosition()[2] : this.Get2DCameraZ();\n    }\n    GetCameraPosition() {\n      if (this.Has3DCamera()) {\n        const e = this.GetLayout().Get3DCameraPosition();\n        return [e[0], e[1], e[2]];\n      }\n      return this._Get2DCameraPosition();\n    }\n    _Get2DCameraPosition(e = 0, t = 0, s = 0) {\n      const a = this._runtime, i = this.GetLayout(), r = a.GetParallaxXOrigin(), n = a.GetParallaxYOrigin();\n      let l = (this.GetScrollX() - r) * this._parallaxX + r, o = (this.GetScrollY() - n) * this._parallaxY + n, h = (a.IsPixelRoundingEnabled() && (l = Math.round(l), o = Math.round(o)), l + e), c = o + t, d = i.IsOrthographicProjection() ? this.GetDefaultCameraZ(s) : this.Get2DCameraZ(s), [_, u] = this._GetVanishingPoint();\n      if (0.5 !== _ || 0.5 !== u) {\n        const G = this.GetDefaultCameraZ(s) / d;\n        let e2 = (_ - 0.5) * a.GetViewportWidth() / G, t2 = (u - 0.5) * a.GetViewportHeight() / G;\n        const f = this.GetAngle();\n        0 !== f && (tempVec2.set(e2, t2), tempVec2.rotate(f), e2 = tempVec2.getX(), t2 = tempVec2.getY()), h += e2, c += t2;\n      }\n      return [h, c, d];\n    }\n    _CalculateModelViewMatrix(e, t, s, a, i) {\n      const r = this._runtime, n = this.GetLayout();\n      if (this.Has3DCamera()) {\n        vec3.copy(camVector, n.Get3DCameraPosition()), vec3.copy(lookVector, n.Get3DCameraLookAt()), vec3.copy(upVector, n.Get3DCameraUpVector());\n        const l = r.GetParallaxXOrigin(), o = r.GetParallaxYOrigin(), h = lookVector[0] - camVector[0], c = lookVector[1] - camVector[1], d = lookVector[2] - camVector[2];\n        camVector[0] = (camVector[0] - l) * this._parallaxX + l, camVector[1] = (camVector[1] - o) * this._parallaxY + o, camVector[2] *= Math.max(this._parallaxX, this._parallaxY), lookVector[0] = camVector[0] + h, lookVector[1] = camVector[1] + c, lookVector[2] = camVector[2] + d;\n      } else {\n        const [_, u, G] = this._Get2DCameraPosition(s, a, i), f = (vec3.set(camVector, _, u, G), vec3.set(lookVector, _, u, G - 100), this.GetAngle());\n        0 === f ? vec3.set(upVector, 0, 1, 0) : vec3.set(upVector, Math.sin(f), Math.cos(f), 0);\n      }\n      e.CalculateLookAtModelView(t, camVector, lookVector, upVector, i || r.GetViewportHeight());\n    }\n    _SetProjectionMatrixChanged() {\n      this._isProjectionMatrixChanged = true, this._isViewFrustumChanged = true, this._isViewportChanged = true;\n    }\n    _GetProjectionMatrix(e) {\n      return this._isProjectionMatrixChanged && (this._CalculateProjectionMatrix(e), this._isProjectionMatrixChanged = false), this._projectionMatrix;\n    }\n    _CalculateProjectionMatrix(e) {\n      const t = this._runtime.GetCanvasManager(), [s, a] = this._GetVanishingPoint();\n      if (this._layout.IsOrthographicProjection()) e.CalculateOrthographicMatrix(this._projectionMatrix, t.GetDrawWidth(), t.GetDrawHeight());\n      else if (0.5 === s && 0.5 === a) mat4.copy(this._projectionMatrix, t.GetDefaultProjectionMatrix());\n      else {\n        const i = t.GetDrawWidth(), r = t.GetDrawHeight();\n        e.CalculatePerspectiveMatrix(this._projectionMatrix, i / r, s, a);\n      }\n    }\n    _SetTransform(e, t = true, s = 0, a = 0, i = 0) {\n      t && e.SetProjectionMatrix(this._GetProjectionMatrix(e));\n      let r = null;\n      r = 0 === s && 0 === a && 0 === i ? this._GetModelViewMatrix(e) : (this._CalculateModelViewMatrix(e, tempMat4, s, a, i), tempMat4), e.SetModelViewMatrix(r);\n    }\n    PrepareForDraw(e) {\n      this._SetTransform(e), e.SetBaseZ(this.GetZElevation());\n    }\n    _MaybeStartWebGLProfiling(e) {\n      let t = null;\n      if (e.IsWebGL() && this._runtime.IsGPUProfiling()) {\n        const s = this._runtime.GetCanvasManager().GetLayerTimingsBuffer(this);\n        s && (t = s.AddTimeElapsedQuery(), e.StartQuery(t));\n      }\n      return t;\n    }\n    _MaybeStartWebGPUProfiling(e) {\n      if (e.IsWebGPU() && this._runtime.IsGPUProfiling()) {\n        const t = 2 * (this.GetIndex() + 1);\n        e.StartMeasuringRenderPassTime(t, 1 + t);\n      }\n    }\n    Draw(e, t, s) {\n      const a = this._runtime.GetCanvasManager(), i = this.UsesOwnTexture();\n      let r = null;\n      const n = this._MaybeStartWebGLProfiling(e);\n      if (this._MaybeStartWebGPUProfiling(e), i) {\n        const l = { sampling: this._runtime.GetSampling(), isSampled: true, canReadPixels: !!e.IsWebGPU() && this._runtime.UsesAnyBackgroundBlending() };\n        \"low\" === a.GetCurrentFullscreenScalingQuality() && (l.width = a.GetDrawWidth(), l.height = a.GetDrawHeight()), r = this._runtime.GetAdditionalRenderTarget(l), this._curRenderTarget = r, e.SetRenderTarget(r), this.IsTransparent() && e.ClearRgba(0, 0, 0, 0);\n      } else this._curRenderTarget = t, e.SetRenderTarget(t);\n      if (this.IsTransparent() || e.Clear(this._backgroundColor), this._layout._DrawLayerList(e, this._curRenderTarget, this._subLayers, i && this.IsTransparent()), this._MaybeStartWebGPUProfiling(e), this._SetTransform(e), e.SetBaseZ(this.GetZElevation()), e.SetDepthEnabled(this.RendersIn3DMode()), this.GetNormalScale() > Number.EPSILON) {\n        this._UpdateZIndices();\n        const o = this.UsesRenderCells() && 0 === this.GetZElevation() && !this._anyInstanceZElevated;\n        this.Has3DCamera() ? this._DrawInstances_3DCamera(e) : o ? this._DrawInstances_RenderCells(e) : this._DrawInstances(e, this._GetInstancesInDrawOrder());\n      }\n      e.SetBaseZ(0), e.SetCurrentZ(0), i && (e.SetDepthEnabled(false), this._DrawLayerOwnTextureToRenderTarget(e, r, t, s)), n && e.EndQuery(n), this._curRenderTarget = null;\n    }\n    _DrawInstances(s, a) {\n      const i = this.GetViewport(), r = this._curRenderTarget, n = this.GetLayout().IsOrthographicProjection(), l = this.GetLayout().HasVanishingPointOutsideViewport();\n      let o = null;\n      for (let e = 0, t = a.length; e < t; ++e) {\n        const h = a[e];\n        if (h !== o) {\n          const c = (o = h).GetWorldInfo();\n          c.IsVisible() && c.IsInViewport(i, l, n) && this._DrawInstanceMaybeWithEffects(h, c, s, r);\n        }\n      }\n    }\n    _DrawInstances_3DCamera(a) {\n      const i = this._curRenderTarget, r = this._GetViewFrustum(), n = tempInstanceList1, l = tempInstanceList2, o = this._GetInstancesInDrawOrder();\n      for (let t = 0, s = o.length; t < s; ) {\n        const h = o[t], c = h.GetWorldInfo();\n        if (c.IsVisible() && c.IsInViewport3D(r)) {\n          (!h.RendersToOwnZPlane() || 0 < c.GetDepth()) && l.push(h);\n          const d = h.GetWorldInfo().GetTotalZElevation();\n          n.push(h);\n          let e = t + 1;\n          for (; e < s; ++e) {\n            const _ = o[e], u = _.GetWorldInfo();\n            if (u.IsVisible() && u.IsInViewport3D(r)) {\n              if (u.GetTotalZElevation() !== d) break;\n              (_.RendersToOwnZPlane() ? (0 < u.GetDepth() && l.push(_), n) : l).push(_);\n            }\n          }\n          if (1 !== n.length || n[0].MustMitigateZFighting()) {\n            this._DrawCoplanarInstances_3DCamera(a, n);\n            for (let e2 = 0, t2 = l.length; e2 < t2; ++e2) {\n              const G = l[e2], f = G.GetWorldInfo();\n              f._SetDrawNonBackFacesOnly(true), this._DrawInstanceMaybeWithEffects(G, f, a, i), f._SetDrawNonBackFacesOnly(false);\n            }\n          } else {\n            this._DrawInstanceMaybeWithEffects(h, c, a, i);\n            for (let e2 = 0, t2 = l.length; e2 < t2; ++e2) {\n              const p = l[e2];\n              if (p !== h) {\n                const I = p.GetWorldInfo(), C = I.GetLayer();\n                C._DrawInstanceMaybeWithEffects(p, I, a, i);\n              }\n            }\n          }\n          t = e, C32.clearArray(n), C32.clearArray(l);\n        } else ++t;\n      }\n    }\n    _DrawCoplanarInstances_3DCamera(s, a) {\n      const i = this._curRenderTarget;\n      s.CoplanarStartStencilPass();\n      for (let e = 0, t = a.length; e < t; ++e) {\n        const r = a[e], n = r.GetWorldInfo();\n        n._SetDrawBackFaceOnly(true), this._DrawInstance(r, n, s);\n      }\n      s.CoplanarStartColorPass();\n      for (let e = 0, t = a.length; e < t; ++e) {\n        const l = a[e], o = l.GetWorldInfo();\n        this._DrawInstanceMaybeWithEffects(l, o, s, i), o._SetDrawBackFaceOnly(false);\n      }\n      s.CoplanarRestoreStandardRendering();\n    }\n    _DrawInstances_RenderCells(e) {\n      const t = this._renderGrid, s = this._curRenderCells, a = this._lastRenderCells, i = this.GetViewport();\n      let r;\n      s.set(t.XToCell(i.getLeft()), t.YToCell(i.getTop()), t.XToCell(i.getRight()), t.YToCell(i.getBottom())), this._isRenderListUpToDate && s.equals(a) ? r = this._lastRenderList : (r = this._GetRenderCellInstancesToDraw(), this._isRenderListUpToDate = true, a.copy(s)), this._DrawInstances(e, r), r !== this._lastRenderList && C32.shallowAssignArray(this._lastRenderList, r);\n    }\n    _DrawInstanceMaybeWithEffects(e, t, s, a) {\n      t.HasAnyActiveEffect() ? this._DrawInstanceWithEffectsAndRestore(e, t, s, a) : this._DrawInstance(e, t, s);\n    }\n    _DrawInstance(e, t, s) {\n      const a = t.GetRendererStateGroup();\n      s.GetCurrentStateGroup() !== a && a.Apply(), e.Draw(s);\n    }\n    _DrawInstanceWithEffectsAndRestore(e, t, s, a) {\n      this._DrawInstanceWithEffects(e, t, s, a, null) && this._SetTransform(s);\n    }\n    _DrawInstanceWithEffects(e, t, s, a, i) {\n      const r = t.GetInstanceEffectList().GetEffectChain();\n      return r.Render(s, a, { contentObject: e, blendMode: t.GetBlendMode(), devicePixelRatio: this._runtime.GetEffectDevicePixelRatioParam(), time: e.GetInstanceGameTime(), layerScale: this._runtime.GetEffectLayerScaleParam() * this.GetNormalScale(), layerAngle: this.GetAngle(), layoutRect: t.GetBoundingBox(), drawSurfaceRect: r.CanSkipCalculatingDrawSurfaceRect() ? null : this._InstanceBoxToDrawSurface(t), drawContentHook: i && i.drawContentHook, compositOffX: i && i.compositOffX, compositOffY: i && i.compositOffY, updateOwnProjection: i && i.updateOwnProjection }), s.SetBaseZ(this.GetZElevation()), r.DidChangeTransform();\n    }\n    _DrawLayerOwnTextureToRenderTarget(e, t, s, a) {\n      const i = this._effectList.GetActiveEffectTypes(), r = this._runtime;\n      0 === i.length ? (e.SetRenderTarget(s), e.SetTextureFillMode(), a && 0 === this._blendMode && this.HasDefaultColor() ? e.CopyRenderTarget(t) : (e.SetBlendMode(this._blendMode), e.SetColor(this._premultipliedColor), e.DrawRenderTarget(t)), e.InvalidateRenderTarget(t), r.ReleaseAdditionalRenderTarget(t)) : this.GetEffectChain().Render(e, s, { contentObject: this, blendMode: this.GetBlendMode(), devicePixelRatio: r.GetEffectDevicePixelRatioParam(), layerScale: r.GetEffectLayerScaleParam() * this.GetNormalScale(), layerAngle: this.GetAngle(), layoutRect: this.GetViewport(), drawSurfaceRect: null, invalidateRenderTargets: true });\n    }\n    GetOwnScale() {\n      return this._scale;\n    }\n    SetOwnScale(e) {\n      this._scale !== e && (this._scale = e, this._layout.BoundScrolling(), this._SetMVMatrixChanged(), this._runtime.UpdateRender());\n    }\n    GetRenderScale() {\n      return this.GetNormalScale() * this._runtime.GetRenderScale();\n    }\n    GetDisplayScale() {\n      return this.GetNormalScale() * this._runtime.GetDisplayScale();\n    }\n    GetNormalScale() {\n      return (this._scale * this._layout.GetScale() - 1) * this._scaleRate + 1;\n    }\n    _MaybeUpdateViewport() {\n      if (this._isViewportChanged) {\n        this._isViewportChanged = false;\n        const s = this._runtime.GetParallaxXOrigin(), a = this._runtime.GetParallaxYOrigin(), i = (this.GetScrollX() - s) * this._parallaxX + s, r = (this.GetScrollY() - a) * this._parallaxY + a, n = this.GetNormalScale(), l = this._runtime.GetViewportWidth() / n, o = this._runtime.GetViewportHeight() / n;\n        let e = i - l / 2, t = r - o / 2;\n        this._runtime.IsPixelRoundingEnabled() && (e = Math.round(e), t = Math.round(t));\n        const h = this._viewportZ0, c = (h.set(e, t, e + l, t + o), this.GetAngle()), d = (0 !== c && (tmpRect.copy(h), tmpRect.offset(-h.midX(), -h.midY()), tmpQuad.setFromRotatedRect(tmpRect, c), tmpQuad.getBoundingBox(tmpRect), tmpRect.offset(h.midX(), h.midY()), h.copy(tmpRect)), this._zElevation);\n        this.GetViewportForZ(d, this._viewport), this.Has3DCamera() ? this.CalculateViewport3D(d, this._viewport3D) : this._viewport3D.copy(this._viewport);\n      }\n    }\n    CalculateViewport3D(e, t) {\n      let s = this._runtime.GetCanvasManager(), a = s.GetCssWidth(), i = s.GetCssHeight(), [r, n] = this.CanvasCssToLayer(0, 0, e), [l, o] = this.CanvasCssToLayer(a, 0, e), [h, c] = this.CanvasCssToLayer(a, i, e), [d, _] = this.CanvasCssToLayer(0, i, e), u = Math.min(r, l, h, d), G = Math.min(n, o, c, _), f = Math.max(r, l, h, d), p = Math.max(n, o, c, _);\n      isFinite(u) || (u = -1 / 0), isFinite(G) || (G = -1 / 0), isFinite(f) || (f = 1 / 0), isFinite(p) || (p = 1 / 0), t.set(u, G, f, p);\n    }\n    CanvasCssToLayer(e, t, s = 0) {\n      return this._CanvasToLayer(e, t, s, this.GetDisplayScale());\n    }\n    DrawSurfaceToLayer(e, t, s = 0) {\n      return this._CanvasToLayer(e, t, s, this.GetRenderScale() * this.GetDevicePixelRatio());\n    }\n    _CanvasToLayer(e, t, s, a) {\n      const i = this._runtime, r = i.GetRenderer(), n = this.GetNormalScale(), l = i.GetViewportWidth() / n, o = i.GetViewportHeight() / n, h = tempVec4, c = (vec4.set(h, 0, 0, l, o), e /= a, t = h[3] - t / a, this._GetProjectionMatrix(r)), d = this._GetModelViewMatrix(r), _ = tempVec3, u = C32.Gfx.UnprojectScreenToWorldZ(e, t, s, d, c, h, _);\n      return u ? [_[0], _[1]] : [NaN, NaN];\n    }\n    CanvasCssToLayer_DefaultTransform(e, t) {\n      const s = this._scale, a = this._scaleRate, i = this._parallaxX, r = this._parallaxY, n = this._angle, l = (this._scale = 1, this._scaleRate = 1, this._parallaxX = 1, this._parallaxY = 1, this._angle = 0, this._SetMVMatrixChanged(), this.CanvasCssToLayer(e, t));\n      return this._scale = s, this._scaleRate = a, this._parallaxX = i, this._parallaxY = r, this._angle = n, this._SetMVMatrixChanged(), l;\n    }\n    LayerToCanvasCss(e, t, s = 0) {\n      return this._LayerToCanvas(e, t, s, this.GetDisplayScale());\n    }\n    LayerToDrawSurface(e, t, s = 0) {\n      return this._LayerToCanvas(e, t, s, this.GetRenderScale() * this.GetDevicePixelRatio());\n    }\n    _LayerToCanvas(e, t, s, a) {\n      const i = this._runtime, r = i.GetRenderer(), n = this.GetNormalScale(), l = i.GetViewportWidth() / n, o = i.GetViewportHeight() / n, h = tempVec4, c = (vec4.set(h, 0, 0, l, o), this._GetProjectionMatrix(r)), d = this._GetModelViewMatrix(r), _ = tempVec3, u = C32.Gfx.Project(e, t, s, d, c, h, _);\n      return u ? [_[0] * a, (h[3] - _[1]) * a] : [NaN, NaN];\n    }\n    _GetLayerToDrawSurfaceScale(e, t) {\n      return e *= this.GetRenderScale() * this.GetDevicePixelRatio(), 0 !== t && (e *= this.Get2DScaleFactorToZ(t)), e;\n    }\n    _InstanceBoxToDrawSurface(e) {\n      const t = e.GetBoundingBox(), s = e.GetTotalZElevation(), a = e.GetDepth(), h = s + a, c = t.getLeft(), d = t.getTop(), _ = t.getRight(), u = t.getBottom();\n      if (this.Has3DCamera()) {\n        if (this._IsPointBehindNearPlane(c, d, s) || this._IsPointBehindNearPlane(_, d, s) || this._IsPointBehindNearPlane(_, u, s) || this._IsPointBehindNearPlane(c, u, s)) return null;\n        if (0 < a && (this._IsPointBehindNearPlane(c, d, h) || this._IsPointBehindNearPlane(_, d, h) || this._IsPointBehindNearPlane(_, u, h) || this._IsPointBehindNearPlane(c, u, h))) return null;\n      } else if (h >= this.Get2DCameraZ()) return null;\n      let [G, f] = this.LayerToDrawSurface(c, d, s), [p, I] = this.LayerToDrawSurface(_, u, s);\n      if (0 !== this.GetAngle() || 0 < a || this.Has3DCamera()) {\n        const [C, m] = this.LayerToDrawSurface(_, d, s), [y, S] = this.LayerToDrawSurface(c, u, s);\n        if (0 < a) {\n          let [e2, t2] = this.LayerToDrawSurface(c, d, h), [s2, a2] = this.LayerToDrawSurface(_, d, h), [i, r] = this.LayerToDrawSurface(_, u, h), [n, l] = this.LayerToDrawSurface(c, u, h), o = Math.min(G, p, C, y, e2, s2, i, n);\n          p = Math.max(G, p, C, y, e2, s2, i, n), G = o, o = Math.min(f, I, m, S, t2, a2, r, l), I = Math.max(f, I, m, S, t2, a2, r, l), f = o;\n        } else {\n          let e2 = Math.min(G, p, C, y);\n          p = Math.max(G, p, C, y), G = e2, e2 = Math.min(f, I, m, S), I = Math.max(f, I, m, S), f = e2;\n        }\n      }\n      return tmpRect.set(G, f, p, I), tmpRect;\n    }\n    _GetViewFrustum() {\n      return this._isViewFrustumChanged && (this._UpdateViewFrustum(), this._isViewFrustumChanged = false), this._viewFrustum;\n    }\n    _UpdateViewFrustum() {\n      const e = this._runtime.GetRenderer(), t = this._GetProjectionMatrix(e), s = this._GetModelViewMatrix(e);\n      this._viewFrustum.CalculatePlanes(s, t);\n    }\n    _IsPointBehindNearPlane(e, t, s) {\n      return this._GetViewFrustum().IsBehindNearPlane(e, t, s);\n    }\n    _SaveToJson() {\n      const e = { \"d\": this.IsDynamic(), \"s\": this.GetOwnScale(), \"a\": this.GetOwnAngle(), \"v\": this._IsVisibleFlagSet(), \"i\": this.IsInteractive(), \"html\": this.IsHTMLElementsLayer(), \"bc\": this._backgroundColor.toJSON(), \"t\": this.IsTransparent(), \"sx\": this._scrollX, \"sy\": this._scrollY, \"hosp\": this._hasOwnScrollPosition, \"px\": this.GetParallaxX(), \"py\": this.GetParallaxY(), \"c\": this._color.toJSON(), \"sr\": this.GetScaleRate(), \"fx\": this._effectList.SaveToJson(), \"cg\": this._createdGlobalUids };\n      return e;\n    }\n    _LoadFromJson(e) {\n      this._isDynamic = !!e[\"d\"], this._scale = e[\"s\"], this._angle = e[\"a\"], this._isVisible = !!e[\"v\"], this._isInteractive = !e.hasOwnProperty(\"i\") || e[\"i\"], this._isHTMLElementsLayer = !!e[\"html\"], this._backgroundColor.setFromJSON(e[\"bc\"]), this._isTransparent = !!e[\"t\"], e.hasOwnProperty(\"sx\") && (this._scrollX = e[\"sx\"]), e.hasOwnProperty(\"sy\") && (this._scrollY = e[\"sy\"]), e.hasOwnProperty(\"hosp\") && (this._hasOwnScrollPosition = !!e[\"hosp\"]), this._parallaxX = e[\"px\"], this._parallaxY = e[\"py\"], this._color.setFromJSON(e[\"c\"]), this._UpdatePremultipliedColor(), this._scaleRate = e[\"sr\"], C32.shallowAssignArray(this._createdGlobalUids, e[\"cg\"]), C32.shallowAssignArray(this._initialInstances, this._startupInitialInstances);\n      const s = new Set(this._createdGlobalUids);\n      let a = 0;\n      for (let e2 = 0, t = this._initialInstances.length; e2 < t; ++e2) s.has(this._initialInstances[e2][2]) || (this._initialInstances[a] = this._initialInstances[e2], ++a);\n      C32.truncateArray(this._initialInstances, a), this._effectList.LoadFromJson(e[\"fx\"]), this._needsRebuildEffectChainSteps = true;\n    }\n    _LoadFromJsonAfterInstances() {\n      this._SortInstancesByLastCachedZIndex(false), this.SetZIndicesChanged(), this._SetMVMatrixChanged(), this._SetProjectionMatrixChanged();\n    }\n    GetILayer() {\n      return this._iLayer;\n    }\n    SortAndAddInstancesByZIndex(e, t = false) {\n      if (this._instances.includes(e)) t && this._instances.sort((e2, t2) => {\n        const s = e2.GetWorldInfo().GetSceneGraphZIndex(), a = t2.GetWorldInfo().GetSceneGraphZIndex();\n        return s - a;\n      });\n      else if (e.HasChildren()) {\n        const s = [...e.allChildren()];\n        s.push(e), s.sort((e2, t2) => {\n          const s2 = e2.GetWorldInfo().GetSceneGraphZIndex(), a = t2.GetWorldInfo().GetSceneGraphZIndex();\n          return s2 - a;\n        });\n        for (const a of s) if (a.IsInContainer()) {\n          for (const i of a.siblings()) if (!s.includes(i)) {\n            const r = [...i.allChildren()];\n            r.push(i), r.sort((e2, t2) => {\n              const s2 = e2.GetWorldInfo().GetSceneGraphZIndex(), a2 = t2.GetWorldInfo().GetSceneGraphZIndex();\n              return s2 - a2;\n            }), r && r.length && s.splice(s.length, 0, ...r);\n          }\n        }\n        for (const n of s) n.GetPlugin().IsWorldType() && this._AddInstance(n, true);\n      } else if (e.GetPlugin().IsWorldType() && this._AddInstance(e, true), e.IsInContainer()) for (const l of e.siblings()) {\n        const o = [...l.allChildren()];\n        if (o.push(l), o.sort((e2, t2) => {\n          const s = e2.GetWorldInfo().GetSceneGraphZIndex(), a = t2.GetWorldInfo().GetSceneGraphZIndex();\n          return s - a;\n        }), o && o.length) for (const h of o) h.GetPlugin().IsWorldType() && this._AddInstance(h, true);\n      }\n    }\n  };\n}\nvar SortByInstLastCachedZIndex2;\nvar SortByInstZElevation2;\n{\n  let vec3EqualsXYZ = function(e, t, s, a) {\n    return e[0] === Math.fround(t) && e[1] === Math.fround(s) && e[2] === Math.fround(a);\n  }, MaybePrepareLayerDraw = function(e, t) {\n    lastLayerPreparedForDrawing !== e && (e.PrepareForDraw(t), lastLayerPreparedForDrawing = e);\n  };\n  vec3EqualsXYZ2 = vec3EqualsXYZ, MaybePrepareLayerDraw2 = MaybePrepareLayerDraw;\n  const C32 = self.C3, C3Debugger = self.C3Debugger, assert = self.assert, tempDestRect = C32.New(C32.Rect), tempSrcRect = C32.New(C32.Rect), tempLayoutRect = C32.New(C32.Rect), tempColor = C32.New(C32.Color), glMatrix = self.glMatrix, vec3 = glMatrix.vec3, tempRender3dList = [], tempInstanceList1 = [], tempInstanceList2 = [], tempInstanceList3 = [];\n  let lastLayerPreparedForDrawing = null;\n  C32.Layout = class extends C32.DefendedBase {\n    constructor(e, t, s) {\n      super(), this._layoutManager = e, this._runtime = e.GetRuntime(), this._name = s[0], this._originalWidth = s[1], this._originalHeight = s[2], this._width = s[1], this._height = s[2], this._isUnboundedScrolling = !!s[3], this._isOrthographicProjection = !!s[4], this._vanishingPointX = s[5], this._vanishingPointY = s[6], this._eventSheetName = s[7], this._eventSheet = null, this._sid = s[8], this._index = t, this._scrollX = 0, this._scrollY = 0, this._scale = 1, this._angle = 0, this._initialObjectClasses = /* @__PURE__ */ new Set(), this._textureLoadedTypes = /* @__PURE__ */ new Set(), this._textureLoadPendingPromises = /* @__PURE__ */ new Set(), this._createdInstances = [], this._createdPersistedInstances = [], this._createdPersistedInstancesToDataMap = /* @__PURE__ */ new Map(), this._createdPersistedIndexToInstanceMap = /* @__PURE__ */ new Map(), this._initialNonWorld = [], this._is3dCameraEnabled = false, this._cam3dposition = vec3.create(), this._cam3dlook = vec3.create(), this._cam3dup = vec3.create(), this._rootLayers = [], this._allLayersFlat = [], this._layersByName = /* @__PURE__ */ new Map(), this._layersBySid = /* @__PURE__ */ new Map(), this._pendingSetHTMLLayerCount = -1;\n      const r = this._runtime.GetCanvasManager();\n      this._effectList = C32.New(C32.EffectList, this, s[11]), this._effectChain = C32.New(C32.Gfx.EffectChain, r.GetEffectChainManager(), { drawContent: (e2, t2) => {\n        const s2 = t2.GetContentObject(), a = s2.GetRenderTarget();\n        e2.ResetColor(), e2.DrawRenderTarget(a), e2.InvalidateRenderTarget(a), r.ReleaseAdditionalRenderTarget(a);\n      }, getShaderParameters: (e2) => this.GetEffectList()._GetEffectChainShaderParametersForIndex(e2) }), this._needsRebuildEffectChainSteps = true, this._wasFullScreenQualityLow = false, this._curRenderTarget = null, this._persistData = {}, this._persistedIntances = /* @__PURE__ */ new Map(), this._isFirstVisit = true, this._iLayout = new self.ILayout(this), this._userScriptDispatcher = C32.New(C32.Event.Dispatcher);\n      for (const a of s[9]) this._rootLayers.push(C32.Layer.CreateFromExportData(this, null, a));\n      this._ReindexLayers();\n      for (const n of this.allLayers()) n._InitInitialInstances();\n      for (const i of s[10]) {\n        const o = this._runtime.GetObjectClassByIndex(i[1]);\n        if (!o) throw new Error(\"missing nonworld object class\");\n        o.GetDefaultInstanceData() || o.SetDefaultInstanceData(i), this._initialNonWorld.push(i), this._AddInitialObjectClass(o);\n      }\n    }\n    Release() {\n      for (const e of this._allLayersFlat) e.Release();\n      C32.clearArray(this._allLayersFlat), this._textureLoadPendingPromises.clear(), this._eventSheet = null, this._layoutManager = null, this._runtime = null;\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetName() {\n      return this._name;\n    }\n    GetSID() {\n      return this._sid;\n    }\n    GetIndex() {\n      return this._index;\n    }\n    GetEffectList() {\n      return this._effectList;\n    }\n    GetEffectChain() {\n      return this._MaybeRebuildEffectChainSteps(), this._effectChain;\n    }\n    _MaybeRebuildEffectChainSteps() {\n      const e = \"low\" === this._runtime.GetCanvasManager().GetCurrentFullscreenScalingQuality();\n      if (this._needsRebuildEffectChainSteps || this._wasFullScreenQualityLow !== e || this._effectChain.NeedsRebuild()) {\n        const t = this.GetEffectList().GetActiveEffectTypes();\n        this._effectChain.BuildSteps(t.map((e2) => e2.GetShaderProgram()), { indexMap: t.map((e2) => e2.GetIndex()), forcePostDraw: e, useFullSurface: true }), this._needsRebuildEffectChainSteps = false, this._wasFullScreenQualityLow = e;\n      }\n    }\n    UpdateActiveEffects() {\n      this.GetEffectList().UpdateActiveEffects(), this._needsRebuildEffectChainSteps = true;\n    }\n    GetMinLayerScale() {\n      let s = this._allLayersFlat[0].GetNormalScale();\n      for (let e = 1, t = this._allLayersFlat.length; e < t; ++e) {\n        const a = this._allLayersFlat[e];\n        0 === a.GetParallaxX() && 0 === a.GetParallaxY() || (s = Math.min(s, a.GetNormalScale()));\n      }\n      return s;\n    }\n    _GetScrollBoundMarginHorizontal() {\n      return 0.5 * this._runtime.GetViewportWidth() / this.GetMinLayerScale();\n    }\n    _GetScrollBoundMarginVertical() {\n      return 0.5 * this._runtime.GetViewportHeight() / this.GetMinLayerScale();\n    }\n    GetScrollLeftBound() {\n      return this.IsUnboundedScrolling() ? -1 / 0 : this._GetScrollBoundMarginHorizontal();\n    }\n    GetScrollRightBound() {\n      return this.IsUnboundedScrolling() ? 1 / 0 : this.GetWidth() - this._GetScrollBoundMarginHorizontal();\n    }\n    GetScrollTopBound() {\n      return this.IsUnboundedScrolling() ? -1 / 0 : this._GetScrollBoundMarginVertical();\n    }\n    GetScrollBottomBound() {\n      return this.IsUnboundedScrolling() ? 1 / 0 : this.GetHeight() - this._GetScrollBoundMarginVertical();\n    }\n    SetScrollX(e) {\n      const t = this.GetScrollLeftBound(), s = this.GetScrollRightBound();\n      this._scrollX !== (e = (e = s < e ? s : e) < t ? t : e) && (this._scrollX = e, this._SetAllLayersMVChanged(), this._runtime.UpdateRender());\n    }\n    GetScrollX() {\n      return this._scrollX;\n    }\n    SetScrollY(e) {\n      const t = this.GetScrollTopBound(), s = this.GetScrollBottomBound();\n      this._scrollY !== (e = (e = s < e ? s : e) < t ? t : e) && (this._scrollY = e, this._SetAllLayersMVChanged(), this._runtime.UpdateRender());\n    }\n    GetScrollY() {\n      return this._scrollY;\n    }\n    IsUnboundedScrolling() {\n      return this._isUnboundedScrolling;\n    }\n    BoundScrolling() {\n      this.SetScrollX(this.GetScrollX()), this.SetScrollY(this.GetScrollY());\n      for (const e of this._allLayersFlat) e.IsOwnScrollPositionEnabled() && (e.SetScrollX(e.GetScrollX()), e.SetScrollY(e.GetScrollY()));\n    }\n    SetVanishingPointXY(e, t) {\n      this._vanishingPointX === e && this._vanishingPointY === t || (this._vanishingPointX = e, this._vanishingPointY = t, this.IsPerspectiveProjection() && (this._SetAllLayersProjectionChanged(), this._SetAllLayersMVChanged(), this._runtime.UpdateRender()));\n    }\n    GetVanishingPointX() {\n      return this.IsOrthographicProjection() ? 0.5 : this._vanishingPointX;\n    }\n    GetVanishingPointY() {\n      return this.IsOrthographicProjection() ? 0.5 : this._vanishingPointY;\n    }\n    HasVanishingPointOutsideViewport() {\n      const e = this.GetVanishingPointX(), t = this.GetVanishingPointY();\n      return e < 0 || 1 < e || t < 0 || 1 < t;\n    }\n    SetPerspectiveProjection() {\n      this._isOrthographicProjection && (this._isOrthographicProjection = false, this._SetAllLayersProjectionChanged(), this._SetAllLayersMVChanged(), this._runtime.UpdateRender());\n    }\n    SetOrthographicProjection() {\n      this._isOrthographicProjection || (this._isOrthographicProjection = true, this._SetAllLayersProjectionChanged(), this._SetAllLayersMVChanged(), this._runtime.UpdateRender());\n    }\n    IsOrthographicProjection() {\n      return this._isOrthographicProjection;\n    }\n    IsPerspectiveProjection() {\n      return !this.IsOrthographicProjection();\n    }\n    Set3DCameraEnabled(e) {\n      this._is3dCameraEnabled !== (e = !!e) && (this._is3dCameraEnabled = e, this._SetAllLayersMVChanged(), this._runtime.UpdateRender());\n    }\n    Is3DCameraEnabled() {\n      return this._is3dCameraEnabled;\n    }\n    Set3DCameraOrientation(e, t, s, a, r, n, i, o, l) {\n      vec3EqualsXYZ(this._cam3dposition, e, t, s) && vec3EqualsXYZ(this._cam3dlook, a, r, n) && vec3EqualsXYZ(this._cam3dup, i, o, l) || (vec3.set(this._cam3dposition, e, t, s), vec3.set(this._cam3dlook, a, r, n), vec3.set(this._cam3dup, i, o, l), this.Set3DCameraChanged());\n    }\n    Set3DCameraChanged() {\n      this._SetAllLayersMVChanged(), this._runtime.UpdateRender();\n    }\n    Get3DCameraPosition() {\n      return this._cam3dposition;\n    }\n    Get3DCameraLookAt() {\n      return this._cam3dlook;\n    }\n    Get3DCameraUpVector() {\n      return this._cam3dup;\n    }\n    GetScale() {\n      return this._scale;\n    }\n    SetScale(e) {\n      this._scale !== e && (this._scale = e, this._SetAllLayersMVChanged(), this.BoundScrolling(), this._runtime.UpdateRender());\n    }\n    SetAngle(e) {\n      e = C32.clampAngle(e), this._angle !== e && (this._angle = e, this._SetAllLayersMVChanged(), this._runtime.UpdateRender());\n    }\n    GetAngle() {\n      return this._angle;\n    }\n    GetWidth() {\n      return this._width;\n    }\n    SetWidth(e) {\n      !isFinite(e) || e < 1 || (this._width = e);\n    }\n    GetHeight() {\n      return this._height;\n    }\n    SetHeight(e) {\n      !isFinite(e) || e < 1 || (this._height = e);\n    }\n    GetEventSheet() {\n      return this._eventSheet;\n    }\n    _GetRootLayers() {\n      return this._rootLayers;\n    }\n    *allLayers() {\n      for (const e of this._rootLayers) yield* e.selfAndAllSubLayers();\n    }\n    GetLayers() {\n      return this._allLayersFlat;\n    }\n    GetLayerCount() {\n      return this._allLayersFlat.length;\n    }\n    GetLayer(e) {\n      return \"number\" == typeof e ? this.GetLayerByIndex(e) : this.GetLayerByName(e.toString());\n    }\n    GetLayerByIndex(e) {\n      return e = C32.clamp(Math.floor(e), 0, this._allLayersFlat.length - 1), this._allLayersFlat[e];\n    }\n    GetLayerByName(e) {\n      return this._layersByName.get(e.toLowerCase()) || null;\n    }\n    HasLayerByName(e) {\n      return !!this.GetLayerByName(e);\n    }\n    GetLayerBySID(e) {\n      return this._layersBySid.get(e) || null;\n    }\n    _SetAllLayersProjectionChanged() {\n      for (const e of this._allLayersFlat) e._SetProjectionMatrixChanged();\n    }\n    _SetAllLayersMVChanged() {\n      for (const e of this._allLayersFlat) e._SetMVMatrixChanged();\n    }\n    AddLayer(e, t, s) {\n      if (this.HasLayerByName(e)) throw new Error(`layer name '${e}' already in use`);\n      if (!t && s < 2) throw new Error(\"invalid insert position\");\n      const a = 2 <= s ? t : t.GetParentLayer(), r = C32.New(C32.Layer, this, a, { name: e, sid: Math.floor(1e15 * Math.random()), isDynamic: true });\n      this._InsertLayer(r, t, s), this.GetRuntime().UpdateRender(), this._ReindexAndUpdateAllLayers();\n    }\n    MoveLayer(e, t, s) {\n      if (!t && s < 2) throw new Error(\"invalid insert position\");\n      e === t && s < 2 || (this._RemoveLayer(e), this._InsertLayer(e, t, s), this.GetRuntime().UpdateRender(), this._ReindexAndUpdateAllLayers());\n    }\n    RemoveLayer(e) {\n      if (this._RemoveLayer(e)) {\n        const t = this._runtime.GetEventSheetManager();\n        t.BlockFlushingInstances(true), e.Release(), t.BlockFlushingInstances(false), this.GetRuntime().UpdateRender(), this._ReindexAndUpdateAllLayers();\n      }\n    }\n    RemoveAllDynamicLayers() {\n      const e = /* @__PURE__ */ new Set();\n      for (const t of this.allLayers()) t.IsDynamic() && !t.HasAnyDynamicParentLayer() && e.add(t);\n      if (0 !== e.size) {\n        const s = this._runtime.GetEventSheetManager();\n        s.BlockFlushingInstances(true);\n        for (const a of e) this._RemoveLayer(a), a.Release();\n        s.BlockFlushingInstances(false), this.GetRuntime().UpdateRender(), this._ReindexAndUpdateAllLayers();\n      }\n    }\n    _InsertLayer(t, s, a) {\n      if (2 <= a) if (s) {\n        if (s === t || s.HasParentLayer(t)) throw new Error(`cannot move layer '${t.GetName()}' to sub-layer of itself`);\n        s._AddSubLayer(t, 2 === a), t._SetParentLayer(s);\n      } else 2 === a ? this._rootLayers.push(t) : this._rootLayers.unshift(t), t._SetParentLayer(null);\n      else {\n        const e = s.GetParentLayer();\n        if (e) {\n          if (s.HasParentLayer(t)) throw new Error(`cannot move layer '${t.GetName()}' to sub-layer of itself`);\n          e._InsertSubLayer(t, s, 0 === a), t._SetParentLayer(e);\n        } else {\n          let e2 = this._rootLayers.indexOf(s);\n          if (-1 === e2) throw new Error(\"cannot find layer to insert by\");\n          0 === a && ++e2, this._rootLayers.splice(e2, 0, t), t._SetParentLayer(null);\n        }\n      }\n    }\n    _RemoveLayer(e) {\n      const t = e.GetParentLayer();\n      if (t) return t._RemoveSubLayer(e), true;\n      if (1 < this._rootLayers.length) {\n        const s = this._rootLayers.indexOf(e);\n        if (-1 === s) throw new Error(\"cannot find layer to remove\");\n        return this._rootLayers.splice(s, 1), true;\n      }\n      return false;\n    }\n    _ReindexLayers() {\n      this._allLayersFlat = [...this.allLayers()], this._layersByName.clear(), this._layersBySid.clear();\n      for (let e = 0, t = this._allLayersFlat.length; e < t; ++e) {\n        const s = this._allLayersFlat[e];\n        s._SetIndex(e), this._layersByName.set(s.GetName().toLowerCase(), s), this._layersBySid.set(s.GetSID(), s);\n      }\n    }\n    _ReindexHTMLLayers() {\n      let e = 0;\n      for (const t of this._rootLayers) {\n        for (const s of t.selfAndAllSubLayers()) s._SetHTMLIndex(e);\n        t.IsHTMLElementsLayer() && e++;\n      }\n    }\n    GetHTMLLayerCount() {\n      return this._rootLayers.at(-1).GetHTMLIndex() + 1;\n    }\n    async _ReindexAndUpdateAllLayers() {\n      this._ReindexLayers(), this._ReindexHTMLLayers(), this._pendingSetHTMLLayerCount = this.GetHTMLLayerCount();\n    }\n    _GetPendingSetHTMLLayerCount() {\n      return this._pendingSetHTMLLayerCount;\n    }\n    _ResetPendingHTMLLayerCount() {\n      this._pendingSetHTMLLayerCount = -1;\n    }\n    GetRootLayersForHTMLLayer(e) {\n      const t = [];\n      for (const s of this._rootLayers) {\n        const a = s.GetHTMLIndex();\n        if (a === e) t.push(s);\n        else if (e < a) break;\n      }\n      return t;\n    }\n    SaveTransform() {\n      return { \"scrollX\": this.GetScrollX(), \"scrollY\": this.GetScrollY(), \"scale\": this.GetScale(), \"angle\": this.GetAngle(), \"vpX\": this.GetVanishingPointX(), \"vpY\": this.GetVanishingPointY() };\n    }\n    RestoreTransform(e) {\n      this.SetScrollX(e[\"scrollX\"]), this.SetScrollY(e[\"scrollY\"]), this.SetScale(e[\"scale\"]), this.SetAngle(e[\"angle\"]), this.SetVanishingPointXY(e[\"vpX\"], e[\"vpY\"]);\n    }\n    GetLayoutBackgroundColor() {\n      let e = this._rootLayers.filter((e2) => e2.ShouldDraw())[0];\n      for (; e; ) {\n        if (!e.IsTransparent()) return tempColor.copyRgb(e.GetBackgroundColor()), tempColor.setA(1), tempColor;\n        if (e.UsesOwnTexture()) return tempColor.setRgba(0, 0, 0, 0), tempColor;\n        e = e.GetSubLayers().filter((e2) => e2.ShouldDraw())[0];\n      }\n      return tempColor.setRgba(0, 0, 0, 0), tempColor;\n    }\n    IsFirstVisit() {\n      return this._isFirstVisit;\n    }\n    _GetInitialObjectClasses() {\n      return [...this._initialObjectClasses];\n    }\n    _AddInitialObjectClass(e) {\n      if (e.IsInContainer()) for (const t of e.GetContainer().GetObjectTypes()) this._initialObjectClasses.add(t);\n      else this._initialObjectClasses.add(e);\n    }\n    _GetTextureLoadedObjectTypes() {\n      return [...this._textureLoadedTypes];\n    }\n    _Load(e, t) {\n      if (e === this || !t) return Promise.resolve();\n      e && (C32.CopySet(this._textureLoadedTypes, e._textureLoadedTypes), e._textureLoadedTypes.clear());\n      const s = [];\n      for (const a of this._initialObjectClasses) this._textureLoadedTypes.has(a) || (s.push(a.LoadTextures(t)), this._textureLoadedTypes.add(a));\n      return Promise.all(s);\n    }\n    async MaybeLoadTexturesFor(e) {\n      if (e.IsFamily()) throw new Error(\"cannot load textures for family\");\n      const t = this._runtime.GetRenderer();\n      if (t && !t.IsContextLost() && !this._textureLoadedTypes.has(e)) {\n        this._textureLoadedTypes.add(e);\n        const s = e.LoadTextures(t);\n        this._AddPendingTextureLoadPromise(s), await s, e.OnDynamicTextureLoadComplete(), this._runtime.UpdateRender();\n      }\n    }\n    _AddPendingTextureLoadPromise(e) {\n      this._textureLoadPendingPromises.add(e), e.then(() => this._textureLoadPendingPromises.delete(e)).catch(() => this._textureLoadPendingPromises.delete(e));\n    }\n    WaitForPendingTextureLoadsToComplete() {\n      return Promise.all([...this._textureLoadPendingPromises]);\n    }\n    MaybeUnloadTexturesFor(e) {\n      if (e.IsFamily() || 0 < e.GetInstanceCount()) throw new Error(\"cannot unload textures\");\n      const t = this._runtime.GetRenderer();\n      t && this._textureLoadedTypes.has(e) && (this._textureLoadedTypes.delete(e), e.ReleaseTextures(t));\n    }\n    _Unload(e, t) {\n      if (e !== this && t) for (const s of this._textureLoadedTypes) s.IsGlobal() || e._initialObjectClasses.has(s) || (s.ReleaseTextures(), this._textureLoadedTypes.delete(s));\n    }\n    _OnRendererContextLost() {\n      this._textureLoadedTypes.clear();\n    }\n    async _StartRunning(e) {\n      const t = this._runtime, s = this._layoutManager, a = t.GetEventSheetManager(), r = (this._eventSheetName && (this._eventSheet = a.GetEventSheetByName(this._eventSheetName), this._eventSheet._UpdateDeepIncludes()), s._SetMainRunningLayout(this), this._width = this._originalWidth, this._height = this._originalHeight, this._scrollX = t.GetOriginalViewportWidth() / 2, this._scrollY = t.GetOriginalViewportHeight() / 2, this.BoundScrolling(), this._SetAllLayersProjectionChanged(), this._SetAllLayersMVChanged(), this._ReindexHTMLLayers(), await this._runtime.GetCanvasManager().SetHTMLLayerCount(this.GetHTMLLayerCount(), true), this._MoveGlobalObjectsToThisLayout(e), this._runtime.SetUsingCreatePromises(true), this._CreateInitialInstances(), this._isFirstVisit || this._CreatePersistedInstances(), this._CreateAndLinkContainerInstances(this._createdInstances), this._CreateAndLinkContainerInstances(this._createdPersistedInstances), this._CreateInitialNonWorldInstances(), s.ClearPendingChangeLayout(), t.FlushPendingInstances(), this._runtime.SetUsingCreatePromises(false), this._runtime.GetCreatePromises());\n      if (await Promise.all(r), C32.clearArray(r), !t.IsLoadingState()) {\n        for (const n of this._createdInstances) n.SetupInitialSceneGraphConnections();\n        for (const i of this._createdPersistedInstances) i.SetupPersistedSceneGraphConnections(this._createdPersistedInstancesToDataMap, this._createdPersistedIndexToInstanceMap);\n        for (const [o, l] of Object.entries(this._persistData)) {\n          const h = this._runtime.GetObjectClassBySID(parseInt(o, 10));\n          h && !h.IsFamily() && h.HasPersistBehavior() && C32.clearArray(l);\n        }\n        for (const c of this._createdInstances) c._TriggerOnCreated();\n        for (const d of this._createdPersistedInstances) d._TriggerOnCreated();\n        for (const _ of this._createdInstances) _.HasParent() || _._OnHierarchyReady();\n        for (const u of this._createdPersistedInstances) u.HasParent() || u._OnHierarchyReady();\n      }\n      C32.clearArray(this._createdInstances), C32.clearArray(this._createdPersistedInstances), this._createdPersistedInstancesToDataMap.clear(), this._createdPersistedIndexToInstanceMap.clear(), await Promise.all([...this._initialObjectClasses].map((e2) => e2.PreloadTexturesWithInstances(this._runtime.GetRenderer()))), e && (t.Dispatcher().dispatchEvent(new C32.Event(\"beforefirstlayoutstart\")), await t.DispatchUserScriptEventAsyncWait(new C32.Event(\"beforeprojectstart\"))), await this.DispatchRuntimeUserScriptEventAsyncWait(new C32.Event(\"beforeanylayoutstart\")), t.Dispatcher().dispatchEvent(new C32.Event(\"beforelayoutstart\")), await this.DispatchUserScriptEventAsyncWait(new C32.Event(\"beforelayoutstart\")), t.IsLoadingState() || await t.TriggerAsync(C32.Plugins.System.Cnds.OnLayoutStart, null, null), t.Dispatcher().dispatchEvent(new C32.Event(\"afterlayoutstart\")), await this.DispatchUserScriptEventAsyncWait(new C32.Event(\"afterlayoutstart\")), await this.DispatchRuntimeUserScriptEventAsyncWait(new C32.Event(\"afteranylayoutstart\")), e && (t.Dispatcher().dispatchEvent(new C32.Event(\"afterfirstlayoutstart\")), await t.DispatchUserScriptEventAsyncWait(new C32.Event(\"afterprojectstart\"))), a._RunQueuedTriggers(s), await this.WaitForPendingTextureLoadsToComplete(), this._isFirstVisit = false;\n    }\n    _MoveGlobalObjectsToThisLayout(e) {\n      for (const t of this._runtime.GetAllObjectClasses()) if (!t.IsFamily() && t.IsWorldType()) for (const s of t.GetInstances()) {\n        const a = s.GetWorldInfo(), r = a.GetLayer(), n = C32.clamp(r.GetIndex(), 0, this._allLayersFlat.length - 1), i = this._allLayersFlat[n];\n        a._SetLayer(i, true), i._MaybeAddInstance(s);\n      }\n      if (!e) for (const o of this._allLayersFlat) o._SortInstancesByLastCachedZIndex(false);\n    }\n    _CreateInitialInstances() {\n      for (const e of this._allLayersFlat) e.CreateInitialInstances(this._createdInstances), e._Start();\n    }\n    _CreatePersistedInstances() {\n      let t = false;\n      for (const [e, s] of Object.entries(this._persistData)) {\n        const a = this._runtime.GetObjectClassBySID(parseInt(e, 10));\n        if (a && !a.IsFamily() && a.HasPersistBehavior()) for (const r of s) {\n          let e2 = null;\n          if (!a.IsWorldType() || (e2 = r.hasOwnProperty(\"instJson\") ? this.GetLayerBySID(r[\"instJson\"][\"w\"][\"l\"]) : this.GetLayerBySID(r[\"w\"][\"l\"]))) {\n            const n = this._runtime.CreateInstanceFromData(a, e2, false, 0, 0, true);\n            r.hasOwnProperty(\"instJson\") ? n.LoadFromJson(r[\"instJson\"]) : n.LoadFromJson(r), t = true, this._createdPersistedInstances.push(n), r.hasOwnProperty(\"instJson\") && (this._createdPersistedInstancesToDataMap.set(n, r), this._createdPersistedIndexToInstanceMap.set(r[\"index\"], n));\n          }\n        }\n      }\n      for (const i of this._allLayersFlat) i._SortInstancesByLastCachedZIndex(true), i.SetZIndicesChanged();\n      t && (this._runtime.FlushPendingInstances(), this._runtime._RefreshUidMap());\n    }\n    _CreateAndLinkContainerInstances(t) {\n      for (const s of t) if (s.IsInContainer()) {\n        const a = s.GetWorldInfo(), e = s.GetIID();\n        for (const r of s.GetObjectClass().GetContainer().objectTypes()) if (r !== s.GetObjectClass()) {\n          const n = r.GetInstances();\n          if (n.length > e) s._AddSibling(n[e]);\n          else {\n            let e2;\n            e2 = a ? this._runtime.CreateInstanceFromData(r, a.GetLayer(), true, a.GetX(), a.GetY(), true) : this._runtime.CreateInstanceFromData(r, null, true, 0, 0, true), this._runtime.FlushPendingInstances(), r._UpdateIIDs(), s._AddSibling(e2), t.push(e2);\n          }\n        }\n      }\n    }\n    _CreateInitialNonWorldInstances() {\n      for (const e of this._initialNonWorld) {\n        const t = this._runtime.GetObjectClassByIndex(e[1]);\n        t.IsInContainer() || this._runtime.CreateInstanceFromData(e, null, true);\n      }\n    }\n    _CreateGlobalNonWorlds() {\n      const s = [], a = this._initialNonWorld;\n      let r = 0;\n      for (let e = 0, t = a.length; e < t; ++e) {\n        const n = a[e], i = this._runtime.GetObjectClassByIndex(n[1]);\n        i.IsGlobal() ? i.IsInContainer() && i.GetContainer().HasAnyWorldType() || s.push(this._runtime.CreateInstanceFromData(n, null, true)) : (a[r] = n, ++r);\n      }\n      C32.truncateArray(a, r), this._runtime.FlushPendingInstances(), this._CreateAndLinkContainerInstances(s);\n    }\n    RecreateInitialObjects(e, t, s, a, r, n, i) {\n      if (s) return s.RecreateInitialObjects(e, t, r, n, a, i);\n      {\n        const o = [];\n        for (const l of this._allLayersFlat) o.push(l.RecreateInitialObjects(e, t, r, n, a, i));\n        return o.flat();\n      }\n    }\n    async _StopRunning() {\n      const e = this._layoutManager;\n      this._runtime.IsLoadingState() || (await this.DispatchRuntimeUserScriptEventAsyncWait(new C32.Event(\"beforeanylayoutend\")), await this.DispatchUserScriptEventAsyncWait(new C32.Event(\"beforelayoutend\")), await this._runtime.TriggerAsync(C32.Plugins.System.Cnds.OnLayoutEnd, null, null), await this.DispatchUserScriptEventAsyncWait(new C32.Event(\"afterlayoutend\")), await this.DispatchRuntimeUserScriptEventAsyncWait(new C32.Event(\"afteranylayoutend\"))), e.SetIsEndingLayout(true), this._runtime.GetEventSheetManager().ClearAllScheduledWaits(), this._isFirstVisit || this._SavePersistData();\n      for (const t of this._allLayersFlat) t._End();\n      for (const s of this._runtime.GetAllObjectClasses()) if (!(s.IsGlobal() || s.IsWorldType() || s.GetPlugin().IsSingleGlobal() || s.IsFamily())) {\n        for (const a of s.GetInstances()) this._runtime.DestroyInstance(a);\n        this._runtime.FlushPendingInstances();\n      }\n      e.SetIsEndingLayout(false), e.GetMainRunningLayout() === this && e._SetMainRunningLayout(null);\n    }\n    _SaveInstanceToPersist(e, t) {\n      const s = e.GetObjectClass().GetSID().toString(), a = (this._persistData.hasOwnProperty(s) || (this._persistData[s] = []), this._persistData[s]), r = { \"index\": t, \"instJson\": e.SaveToJson(), \"sceneGraphJson\": { \"children\": [] } };\n      a.push(r), this._persistedIntances.set(e, r);\n    }\n    _SaveSceneGraphInfoToPersist(e) {\n      const t = this._persistedIntances.get(e);\n      for (const s of e.GetChildren()) {\n        const a = this._persistedIntances.get(s);\n        a && t[\"sceneGraphJson\"][\"children\"].push({ \"index\": a[\"index\"], \"flags\": C32.SceneGraphInfo._GetFlagsNumber(s.GetWorldInfo()) });\n      }\n    }\n    _SavePersistData() {\n      this._persistedIntances.clear();\n      let e = 0;\n      for (const t of this._allLayersFlat) {\n        t._UpdateZIndices();\n        for (const s of t._GetInstances()) {\n          const a = s.GetObjectClass();\n          !a.IsGlobal() && a.HasPersistBehavior() && (this._SaveInstanceToPersist(s, e), e++);\n        }\n      }\n      for (const r of this._allLayersFlat) for (const n of r._GetInstances()) {\n        const i = n.GetObjectClass();\n        !i.IsGlobal() && i.HasPersistBehavior() && this._SaveSceneGraphInfoToPersist(n);\n      }\n      this._persistedIntances.clear();\n    }\n    ResetPersistData() {\n      this._persistData = {}, this._isFirstVisit = true;\n    }\n    GetRenderTarget() {\n      return this._curRenderTarget;\n    }\n    UsesOwnTexture() {\n      const e = this._runtime, t = e.GetRenderer().IsWebGL();\n      return \"low\" === e.GetCanvasManager().GetCurrentFullscreenScalingQuality() || t && e.UsesAnyBackgroundBlending() || this._effectList.HasAnyActiveEffect() || t && e.Uses3DFeatures();\n    }\n    _MaybeStartDrawToOwnTexture(e) {\n      const t = this._runtime.GetCanvasManager();\n      if (this.UsesOwnTexture()) {\n        e.SetRenderTarget(null), e.ClearRgba(0, 0, 0, 0);\n        const s = { sampling: this._runtime.GetSampling(), isSampled: e.IsWebGPU() || this._runtime.UsesAnyBackgroundBlending() || this._effectList.HasAnyActiveEffect(), canReadPixels: !!e.IsWebGPU() && this._runtime.UsesAnyBackgroundBlending() };\n        \"low\" === t.GetCurrentFullscreenScalingQuality() && (s.width = t.GetDrawWidth(), s.height = t.GetDrawHeight()), this._curRenderTarget = this._runtime.GetAdditionalRenderTarget(s);\n      } else this._curRenderTarget = null;\n    }\n    _MaybeCopyOwnTextureToBackbuffer(e) {\n      this._runtime._NeedsHTMLLayerCompositing(e) && (e.SetDepthEnabled(false), e.SetRenderTarget(null), e.SetTextureFillMode(), e.CopyRenderTarget(this._curRenderTarget));\n    }\n    _MaybeEndDrawToOwnTexture(e) {\n      this.UsesOwnTexture() && (e.SetDepthEnabled(false), this._DrawLayoutOwnTextureToRenderTarget(e, this._curRenderTarget));\n    }\n    DrawMain(e) {\n      e.SetRenderTarget(this._curRenderTarget), e.Clear(this.GetLayoutBackgroundColor()), this._runtime.Uses3DFeatures() && e.ClearDepth();\n      const t = this.GetRootLayersForHTMLLayer(0);\n      this._DrawLayerList(e, this._curRenderTarget, t, true), e.IsWebGPU() && e.StartMeasuringRenderPassTime(0, 1), this._MaybeEndDrawToOwnTexture(e), this._curRenderTarget = null;\n    }\n    DrawForHTMLLayerIndex(e, t) {\n      let s = null;\n      this._runtime._NeedsHTMLLayerCompositing(e) && (s = this._curRenderTarget), e.SetRenderTarget(s), e.ClearRgba(0, 0, 0, 0), this._runtime.Uses3DFeatures() && e.ClearDepth();\n      const a = this.GetRootLayersForHTMLLayer(t);\n      this._DrawLayerList(e, s, a, true), this._MaybeCopyOwnTextureToBackbuffer(e), e.EndBatch(), this._runtime.GetCanvasManager().BlitMainCanvasToHTMLLayerCanvas(t);\n    }\n    _DrawLayerList(e, a, t, r) {\n      const n = t.filter((e2) => e2.ShouldDraw());\n      for (let t2 = 0, s = n.length; t2 < s; ) {\n        const i = n[t2];\n        if (i.SelfAndAllSubLayersHave3DCamera() && !i.SelfOrAnySubLayerUsesOwnTexture()) {\n          tempRender3dList.push(i);\n          for (let e2 = t2 + 1; e2 < s; ++e2) {\n            const o = n[e2];\n            if (!o.SelfAndAllSubLayersHave3DCamera() || o.SelfOrAnySubLayerUsesOwnTexture()) break;\n            tempRender3dList.push(n[e2]);\n          }\n          if (2 <= tempRender3dList.length || 1 === tempRender3dList.length && tempRender3dList[0].HasAnyVisibleSubLayer()) {\n            this._Draw3DLayers(e, a, tempRender3dList), t2 += tempRender3dList.length, C32.clearArray(tempRender3dList);\n            continue;\n          }\n          C32.clearArray(tempRender3dList);\n        }\n        i.Draw(e, a, r && 0 === t2), ++t2;\n      }\n    }\n    _DrawLayoutOwnTextureToRenderTarget(e, t) {\n      const s = this._effectList.GetActiveEffectTypes(), a = this._runtime;\n      0 === s.length ? (e.SetRenderTarget(null), e.SetTextureFillMode(), e.CopyRenderTarget(t), e.InvalidateRenderTarget(t), a.ReleaseAdditionalRenderTarget(t)) : (tempLayoutRect.set(0, 0, a.GetViewportWidth(), a.GetViewportHeight()), this.GetEffectChain().Render(e, null, { contentObject: this, blendMode: 3, devicePixelRatio: this._runtime.GetEffectDevicePixelRatioParam(), layerScale: this._runtime.GetEffectLayerScaleParam() * this.GetScale(), layerAngle: this.GetAngle(), layoutRect: tempLayoutRect, drawSurfaceRect: null, invalidateRenderTargets: true }));\n    }\n    _Draw3DLayers(a, r, e) {\n      e[0].IsTransparent() || (tempColor.copyRgb(e[0].GetBackgroundColor()), tempColor.setA(1), a.Clear(tempColor));\n      this._runtime.GetCanvasManager();\n      a.SetDepthEnabled(true);\n      const n = tempInstanceList1, i = tempInstanceList2, o = tempInstanceList3;\n      for (const l of e) l._UpdateZIndices(), l._AppendAllInstancesIncludingSubLayersInDrawOrder(n);\n      const t = e[0], s = t._MaybeStartWebGLProfiling(a);\n      t._MaybeStartWebGPUProfiling(a);\n      for (let t2 = 0, s2 = n.length; t2 < s2; ) {\n        const h = n[t2], c = h.GetWorldInfo(), d = c.GetLayer();\n        if (c.IsVisible() && c.IsInViewport3D(d._GetViewFrustum())) {\n          (!h.RendersToOwnZPlane() || 0 < c.GetDepth()) && o.push(h);\n          const _ = h.GetWorldInfo().GetTotalZElevation();\n          i.push(h);\n          let e2 = t2 + 1;\n          for (; e2 < s2; ++e2) {\n            const u = n[e2], y = u.GetWorldInfo();\n            if (y.IsVisible() && y.IsInViewport3D(y.GetLayer()._GetViewFrustum())) {\n              if (y.GetTotalZElevation() !== _) break;\n              (u.RendersToOwnZPlane() ? (0 < y.GetDepth() && o.push(u), i) : o).push(u);\n            }\n          }\n          if (1 !== i.length || i[0].MustMitigateZFighting()) {\n            this._Draw3DLayersCoplanarInstances(a, r, i);\n            for (let e3 = 0, t3 = o.length; e3 < t3; ++e3) {\n              const L = o[e3], f = L.GetWorldInfo(), p = f.GetLayer();\n              f._SetDrawNonBackFacesOnly(true), MaybePrepareLayerDraw(p, a), p._DrawInstanceMaybeWithEffects(L, f, a, r), f._SetDrawNonBackFacesOnly(false);\n            }\n          } else {\n            MaybePrepareLayerDraw(d, a), d._DrawInstanceMaybeWithEffects(h, c, a, r);\n            for (let e3 = 0, t3 = o.length; e3 < t3; ++e3) {\n              const g = o[e3];\n              if (g !== h) {\n                const S = g.GetWorldInfo(), m = S.GetLayer();\n                MaybePrepareLayerDraw(m, a), m._DrawInstanceMaybeWithEffects(g, S, a, r);\n              }\n            }\n          }\n          t2 = e2, C32.clearArray(i), C32.clearArray(o);\n        } else ++t2;\n      }\n      s && a.EndQuery(s), C32.clearArray(n), lastLayerPreparedForDrawing = null;\n    }\n    _Draw3DLayersCoplanarInstances(s, a, r) {\n      s.CoplanarStartStencilPass();\n      for (let e = 0, t = r.length; e < t; ++e) {\n        const n = r[e], i = n.GetWorldInfo(), o = i.GetLayer();\n        i._SetDrawBackFaceOnly(true), MaybePrepareLayerDraw(o, s), o._DrawInstance(n, i, s);\n      }\n      s.CoplanarStartColorPass();\n      for (let e = 0, t = r.length; e < t; ++e) {\n        const l = r[e], h = l.GetWorldInfo(), c = h.GetLayer();\n        MaybePrepareLayerDraw(c, s), c._DrawInstanceMaybeWithEffects(l, h, s, a), h._SetDrawBackFaceOnly(false);\n      }\n      s.CoplanarRestoreStandardRendering();\n    }\n    _SaveToJson() {\n      const e = { \"sx\": this.GetScrollX(), \"sy\": this.GetScrollY(), \"s\": this.GetScale(), \"a\": this.GetAngle(), \"w\": this.GetWidth(), \"h\": this.GetHeight(), \"ortho\": this.IsOrthographicProjection(), \"vpX\": this.GetVanishingPointX(), \"vpY\": this.GetVanishingPointY(), \"fv\": this._isFirstVisit, \"persist\": this._persistData, \"fx\": this._effectList.SaveToJson(), \"layers\": {}, \"dynamicLayers\": [] };\n      for (const t of this._allLayersFlat) if (t.IsDynamic()) {\n        const s = t.GetParentLayer();\n        e[\"dynamicLayers\"].push({ \"sid\": t.GetSID(), \"name\": t.GetName(), \"parentSid\": s ? s.GetSID() : null, \"siblingIndex\": t._GetSiblingIndex(), \"data\": t._SaveToJson() });\n      } else e[\"layers\"][t.GetSID().toString()] = t._SaveToJson();\n      return e;\n    }\n    _LoadFromJson(e) {\n      this._scrollX = e[\"sx\"], this._scrollY = e[\"sy\"], this._scale = e[\"s\"], this._angle = e[\"a\"], this._width = e[\"w\"], this._height = e[\"h\"], this._isOrthographicProjection = !!e[\"ortho\"], e.hasOwnProperty(\"vpX\") && (this._vanishingPointX = e[\"vpX\"]), e.hasOwnProperty(\"vpY\") && (this._vanishingPointY = e[\"vpY\"]), this._isFirstVisit = !!e[\"fv\"], this._persistData = e[\"persist\"], this._effectList.LoadFromJson(e[\"fx\"]), this._needsRebuildEffectChainSteps = true;\n      for (const [t, s] of Object.entries(e[\"layers\"])) {\n        const a = parseInt(t, 10), r = this.GetLayerBySID(a);\n        r && r._LoadFromJson(s);\n      }\n      if (e.hasOwnProperty(\"dynamicLayers\")) {\n        this.RemoveAllDynamicLayers(), this._runtime.FlushPendingInstances();\n        const n = /* @__PURE__ */ new Map(), i = e[\"dynamicLayers\"];\n        for (let e2 = i.length - 1; 0 <= e2; --e2) {\n          const o = i[e2], l = o[\"sid\"], h = o[\"name\"], c = o[\"parentSid\"], d = o[\"siblingIndex\"], _ = o[\"data\"];\n          if (this._ReindexLayers(), !this.HasLayerByName(h) && !this.GetLayerBySID(l)) {\n            let e3, t;\n            if (null === c) e3 = null, t = this._rootLayers;\n            else {\n              if (!(e3 = this.GetLayerBySID(c))) continue;\n              t = e3.GetSubLayers();\n            }\n            const u = C32.New(C32.Layer, this, e3, { name: h, sid: l, isDynamic: true });\n            t.push(u);\n            let s = n.get(t);\n            s || (s = [], n.set(t, s)), s.push({ layer: u, siblingIndex: d }), u._LoadFromJson(_);\n          }\n        }\n        for (const [y, L] of n) {\n          L.sort((e2, t) => e2.siblingIndex - t.siblingIndex);\n          for (const f of L) {\n            const p = f.layer, g = f.siblingIndex;\n            let e2 = y.indexOf(p);\n            y.splice(e2, 1), y.splice(g, 0, p);\n          }\n        }\n      }\n      this._ReindexAndUpdateAllLayers(), this._SetAllLayersProjectionChanged(), this._SetAllLayersMVChanged();\n    }\n    GetILayout() {\n      return this._iLayout;\n    }\n    UserScriptDispatcher() {\n      return this._userScriptDispatcher;\n    }\n    DispatchUserScriptEvent(e) {\n      e.layout = this.GetILayout();\n      const t = this._runtime, s = t.IsDebug() && !t.GetEventSheetManager().IsInEventEngine();\n      s && C3Debugger.StartMeasuringScriptTime(), this._userScriptDispatcher.dispatchEvent(e), s && C3Debugger.AddScriptTime();\n    }\n    DispatchUserScriptEventAsyncWait(e) {\n      return e.layout = this.GetILayout(), this._userScriptDispatcher.dispatchEventAndWaitAsync(e);\n    }\n    DispatchRuntimeUserScriptEventAsyncWait(e) {\n      return e.layout = this.GetILayout(), this._runtime.DispatchUserScriptEventAsyncWait(e);\n    }\n    _LogLayerTree() {\n      this._LogLayerList(this._rootLayers);\n    }\n    _LogLayerList(e, t = 0) {\n      const s = e.slice(0);\n      s.reverse();\n      for (const a of s) console.log(\"\t\".repeat(t) + \"- \" + a.GetName()), this._LogLayerList(a.GetSubLayers(), t + 1);\n    }\n  };\n}\nvar vec3EqualsXYZ2;\nvar MaybePrepareLayerDraw2;\n{\n  const C32 = self.C3;\n  C32.LayoutManager = class extends C32.DefendedBase {\n    #runtime;\n    #allLayouts = [];\n    #layoutsByName = /* @__PURE__ */ new Map();\n    #layoutsBySid = /* @__PURE__ */ new Map();\n    #mainRunningLayout = null;\n    #runningSubLayouts = [];\n    #firstLayout = null;\n    #isEndingLayout = 0;\n    #pendingChangeLayout = null;\n    constructor(t) {\n      super(), this.#runtime = t;\n    }\n    Release() {\n      this.#runtime = null, this.#mainRunningLayout = null, this.#firstLayout = null, this.#pendingChangeLayout = null, C32.clearArray(this.#allLayouts), this.#layoutsByName.clear(), this.#layoutsBySid.clear(), C32.clearArray(this.#runningSubLayouts);\n    }\n    Create(t) {\n      const n = C32.New(C32.Layout, this, this.#allLayouts.length, t);\n      this.#allLayouts.push(n), this.#layoutsByName.set(n.GetName().toLowerCase(), n), this.#layoutsBySid.set(n.GetSID(), n);\n    }\n    GetRuntime() {\n      return this.#runtime;\n    }\n    SetFirstLayout(t) {\n      this.#firstLayout = t;\n    }\n    GetFirstLayout() {\n      if (this.#firstLayout) return this.#firstLayout;\n      if (this.#allLayouts.length) return this.#allLayouts[0];\n      throw new Error(\"no first layout\");\n    }\n    GetLayoutByName(t) {\n      return this.#layoutsByName.get(t.toLowerCase()) || null;\n    }\n    GetLayoutBySID(t) {\n      return this.#layoutsBySid.get(t) || null;\n    }\n    GetLayoutByIndex(t) {\n      return t = C32.clamp(Math.floor(t), 0, this.#allLayouts.length - 1), this.#allLayouts[t];\n    }\n    GetLayout(t) {\n      return \"number\" == typeof t ? this.GetLayoutByIndex(t) : this.GetLayoutByName(t.toString());\n    }\n    GetAllLayouts() {\n      return this.#allLayouts;\n    }\n    _SetMainRunningLayout(t) {\n      this.#mainRunningLayout = t;\n    }\n    GetMainRunningLayout() {\n      return this.#mainRunningLayout;\n    }\n    _AddRunningSubLayout(t) {\n      if (this.#runningSubLayouts.includes(t)) throw new Error(\"layout already running\");\n      this.#runningSubLayouts.push(t);\n    }\n    _RemoveRunningSubLayout(t) {\n      const n = this.#runningSubLayouts.indexOf(t);\n      if (-1 === n) throw new Error(\"layout not running\");\n      this.#runningSubLayouts.splice(n, 1);\n    }\n    *runningLayouts() {\n      this.#mainRunningLayout && (yield this.#mainRunningLayout), this.#runningSubLayouts.length && (yield* this.#runningSubLayouts);\n    }\n    IsLayoutRunning(t) {\n      return this.#mainRunningLayout === t || this.#runningSubLayouts.includes(t);\n    }\n    SetIsEndingLayout(t) {\n      if (t) this.#isEndingLayout++;\n      else {\n        if (this.#isEndingLayout <= 0) throw new Error(\"already unset\");\n        this.#isEndingLayout--;\n      }\n    }\n    IsEndingLayout() {\n      return 0 < this.#isEndingLayout;\n    }\n    ChangeMainLayout(t) {\n      this.#pendingChangeLayout = t;\n    }\n    ClearPendingChangeLayout() {\n      this.#pendingChangeLayout = null;\n    }\n    IsPendingChangeMainLayout() {\n      return !!this.#pendingChangeLayout;\n    }\n    GetPendingChangeMainLayout() {\n      return this.#pendingChangeLayout;\n    }\n    SetAllLayerProjectionChanged() {\n      const t = this.GetMainRunningLayout();\n      t && t._SetAllLayersProjectionChanged();\n    }\n    SetAllLayerMVChanged() {\n      const t = this.GetMainRunningLayout();\n      t && t._SetAllLayersMVChanged();\n    }\n  };\n}\n{\n  const C32 = self.C3, NAMES_REGEXP = new RegExp(\"<(.+?)>\", \"g\");\n  C32.TimelineManager = class extends C32.DefendedBase {\n    constructor(e) {\n      super(), this._runtime = e, this._timelineDataManager = C32.New(C32.TimelineDataManager), this._pluginInstance = null, this._timelines = [], this._timelinesByName = /* @__PURE__ */ new Map(), this._objectClassToTimelineMap = /* @__PURE__ */ new Map(), this._timelinesCreatedByTemplate = /* @__PURE__ */ new Map(), this._scheduledTimelines = [], this._playingTimelines = [], this._markedForRemovalTimelines = [], this._hasRuntimeListeners = false, this._changingLayout = false, this._isTickingTimelines = false, this._tickFunc = () => this._OnTick(), this._tick2Func = () => this._OnTick2(), this._beforeLayoutChange = () => this._OnBeforeChangeLayout(), this._layoutChange = () => this._OnAfterChangeLayout(), this._instanceDestroy = (e2) => this._OnInstanceDestroy(e2.instance), this._beforeLoad = (e2) => this._OnBeforeLoad(), this._afterLoad = (e2) => this._OnAfterLoad(), this._afterLayoutStart = (e2) => this._OnAfterLayoutStart(), this._destroyedWhileLoadingState = [], this._renderChange = 0;\n    }\n    Release() {\n      this.RemoveRuntimeListeners(), this._tickFunc = null, this._tick2Func = null, this._beforeLayoutChange = null, this._layoutChange = null, this._instanceDestroy = null, this._afterLoad = null;\n      for (const e of this._timelines) e.Stop(), e.Release();\n      C32.clearArray(this._timelines), this._timelines = null, this._timelineDataManager.Release(), this._timelineDataManager = null, C32.clearArray(this._scheduledTimelines), this._scheduledTimelines = null, C32.clearArray(this._playingTimelines), this._playingTimelines = null, C32.clearArray(this._markedForRemovalTimelines), this._markedForRemovalTimelines = null, this._timelinesByName.clear(), this._timelinesByName = null, this._objectClassToTimelineMap.clear(), this._objectClassToTimelineMap = null, this._timelinesCreatedByTemplate.clear(), this._timelinesCreatedByTemplate = null, C32.clearArray(this._destroyedWhileLoadingState), this._destroyedWhileLoadingState = null, this._runtime = null;\n    }\n    AddRuntimeListeners() {\n      const e = this._runtime.Dispatcher();\n      e.addEventListener(\"pretick\", this._tickFunc), e.addEventListener(\"tick2\", this._tick2Func), e.addEventListener(\"beforelayoutchange\", this._beforeLayoutChange), e.addEventListener(\"layoutchange\", this._layoutChange), e.addEventListener(\"instancedestroy\", this._instanceDestroy), e.addEventListener(\"beforeload\", this._beforeLoad), e.addEventListener(\"afterload\", this._afterLoad), e.addEventListener(\"afterlayoutstart\", this._afterLayoutStart);\n    }\n    RemoveRuntimeListeners() {\n      const e = this._runtime.Dispatcher();\n      e.removeEventListener(\"pretick\", this._tickFunc), e.removeEventListener(\"tick2\", this._tick2Func), e.removeEventListener(\"beforelayoutchange\", this._beforeLayoutChange), e.removeEventListener(\"layoutchange\", this._layoutChange), e.removeEventListener(\"instancedestroy\", this._instanceDestroy), e.removeEventListener(\"beforeload\", this._beforeLoad), e.removeEventListener(\"afterload\", this._afterLoad), e.removeEventListener(\"afterlayoutstart\", this._afterLayoutStart);\n    }\n    Create(e) {\n      this._timelineDataManager.Add(e);\n      const i = C32.TimelineState.CreateInitial(e, this);\n      this.Add(i), this.SetTimelineObjectClassesToMap(i), this._timelinesCreatedByTemplate.set(i.GetName(), 0);\n    }\n    CreateFromTemplate(e) {\n      const i = this.GetTimelineDataManager(), t = e.GetTemplateName(), s = i.Get(t), n = C32.TimelineState.CreateFromTemplate(t + \":\" + this._timelinesCreatedByTemplate.get(t), s, this);\n      return this._IncreaseTemplateTimelinesCount(t), this.Add(n), n;\n    }\n    _IncreaseTemplateTimelinesCount(e) {\n      this._timelinesCreatedByTemplate.set(e, this._timelinesCreatedByTemplate.get(e) + 1);\n    }\n    _SetCreatedTemplateTimelinesCount() {\n      for (const e of this._timelines) if (!e.IsTemplate()) {\n        const i = e.GetTemplateName();\n        this._IncreaseTemplateTimelinesCount(i);\n      }\n    }\n    _ClearCreatedTemplateTimelinesCount() {\n      for (const e of this._timelinesCreatedByTemplate.keys()) this._timelinesCreatedByTemplate.set(e, 0);\n    }\n    Add(e) {\n      this._timelines.push(e), this._timelinesByName.set(e.GetName().toLowerCase(), e);\n    }\n    Remove(e) {\n      e.Removed(), e.IsTemplate() || (C32.arrayFindRemove(this._timelines, e), C32.arrayFindRemove(this._scheduledTimelines, e), C32.arrayFindRemove(this._playingTimelines, e), C32.arrayFindRemove(this._markedForRemovalTimelines, e), this._timelinesByName.delete(e.GetName().toLowerCase()), this.RemoveTimelineFromObjectClassMap(e), e.IsReleased()) || e.Release();\n    }\n    Trigger(e) {\n      this._runtime.Trigger(e, this._pluginInstance, null);\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetTimelineDataManager() {\n      return this._timelineDataManager;\n    }\n    SetPluginInstance(e) {\n      this._pluginInstance = e;\n    }\n    GetPluginInstance() {\n      return this._pluginInstance;\n    }\n    *GetTimelines() {\n      for (const e of this._timelines) yield e;\n    }\n    *GetPlayingTimelines() {\n      for (const e of this._playingTimelines) yield e;\n    }\n    SetTimelineObjectClassToMap(e, i) {\n      this._objectClassToTimelineMap.has(e) || this._objectClassToTimelineMap.set(e, /* @__PURE__ */ new Set()), this._objectClassToTimelineMap.get(e).add(i);\n    }\n    SetTimelineObjectClassesToMap(e) {\n      for (const i of e.GetObjectClasses()) this.SetTimelineObjectClassToMap(i, e);\n    }\n    RemoveTimelineFromObjectClassMap(e) {\n      for (const [i, t] of this._objectClassToTimelineMap.entries()) t.has(e) && (t.delete(e), 0 === t.size) && this._objectClassToTimelineMap.delete(i);\n    }\n    GetTimelinesForObjectClass(e) {\n      if (this._objectClassToTimelineMap.has(e)) return this._objectClassToTimelineMap.get(e);\n    }\n    GetTimelineOfTemplateForInstances(e, i) {\n      if (i) for (const t of this._timelines) {\n        const s = i.every((e2) => t.HasTrackInstance(e2.instance, e2.trackId));\n        if (s && t.GetName().includes(e.GetName())) return t;\n      }\n    }\n    GetTimelineByName(e) {\n      return this._timelinesByName.get(e.toLowerCase()) || null;\n    }\n    GetScheduledOrPlayingTimelineByName(e) {\n      for (const i of this._scheduledTimelines) if (i.GetName() === e) return i;\n      for (const t of this._playingTimelines) if (t.GetName() === e) return t;\n      return null;\n    }\n    *GetTimelinesByName(i) {\n      if (NAMES_REGEXP.test(i)) {\n        NAMES_REGEXP.lastIndex = 0;\n        let e;\n        const t = /* @__PURE__ */ new Set();\n        do {\n          if (e = NAMES_REGEXP.exec(i)) {\n            const s = e[1].split(\",\");\n            for (const i2 of s) t.add(i2);\n          }\n        } while (e);\n        for (const i2 of t.values()) {\n          const n = this.GetTimelineByName(i2);\n          n && (yield n);\n        }\n        t.clear();\n      } else {\n        const e = this.GetTimelineByName(i);\n        e && (yield e);\n      }\n    }\n    *GetTimelinesByTags(e) {\n      for (const i of this._timelines) i.HasTags(e) && (yield i);\n    }\n    AddScheduledTimeline(e) {\n      this._scheduledTimelines.includes(e) || this._scheduledTimelines.push(e), this._MaybeEnableRuntimeListeners();\n    }\n    RemovePlayingTimeline(e) {\n      C32.arrayFindRemove(this._playingTimelines, e), this._MaybeDisableRuntimeListeners();\n    }\n    ScheduleTimeline(e) {\n      this._playingTimelines.includes(e) ? (e.SetPlaying(true), e.SetScheduled(false), e.SetMarkedForRemoval(false)) : (e.SetPlaying(false), e.SetScheduled(true), e.SetMarkedForRemoval(false), this._scheduledTimelines.includes(e) || this._scheduledTimelines.push(e)), this._MaybeEnableRuntimeListeners();\n    }\n    DeScheduleTimeline(e) {\n      e.SetPlaying(false), e.SetScheduled(false), e.ResolvePlayPromise(), C32.arrayFindRemove(this._scheduledTimelines, e), this._MaybeDisableRuntimeListeners();\n    }\n    CompleteTimeline(e) {\n      e.SetPlaying(false), e.SetScheduled(false), this._playingTimelines.includes(e) && (e.SetMarkedForRemoval(true), this._markedForRemovalTimelines.push(e), C32.arrayFindRemove(this._playingTimelines, e)), this._scheduledTimelines.includes(e) && e.SetMarkedForRemoval(true);\n    }\n    CompleteTimelineBeforeChangeOfLayout(e) {\n      e.SetPlaying(false), e.SetScheduled(false), e.SetMarkedForRemoval(false), e.SetPlaybackRate(1), C32.arrayFindRemove(this._playingTimelines, e);\n    }\n    CompleteTimelineAndResolve(e) {\n      this.CompleteTimeline(e), e.ResolvePlayPromise();\n    }\n    _OnTick() {\n      if (!this.GetRuntime().IsLoadingState() && this._hasRuntimeListeners && !this._changingLayout) {\n        for (this._isTickingTimelines = true; this._scheduledTimelines.length; ) {\n          const e = this._scheduledTimelines.pop();\n          (e.IsMarkedForRemoval() ? (e.SetInitialStateForce(), this._markedForRemovalTimelines) : (e.SetInitialState(), this._playingTimelines)).push(e), 0 !== e.GetRenderChange() && (this._renderChange = 1);\n        }\n        const i = this._runtime._GetDtFast(), t = this._runtime.GetDt1(), s = this._runtime.GetTimeScale();\n        for (let e = this._playingTimelines.length - 1; 0 <= e; e--) {\n          const n = this._playingTimelines[e];\n          n && n.Tick(i, s, t);\n        }\n        this._isTickingTimelines = false, 0 !== this._renderChange && this.GetRuntime().UpdateRender();\n      }\n    }\n    _OnTick2() {\n      if (!this.GetRuntime().IsLoadingState() && this._hasRuntimeListeners && !this._changingLayout) {\n        let t;\n        for (let e = 0, i = this._markedForRemovalTimelines.length; e < i; e++) {\n          const s = this._markedForRemovalTimelines[e];\n          t = t || /* @__PURE__ */ new Set(), s.Removed(), this._MaybeExecuteTimelineFinishTriggers(s), t.add(s);\n        }\n        if (t) {\n          C32.arrayRemoveAllInSet(this._markedForRemovalTimelines, t);\n          for (let e = this._renderChange = 0, i = this._playingTimelines.length; e < i; e++) if (0 !== this._playingTimelines[e].GetRenderChange()) {\n            this._renderChange = 1;\n            break;\n          }\n        }\n        this._MaybeDisableRuntimeListeners();\n      }\n    }\n    _MaybeExecuteTimelineFinishTriggers(e) {\n      e.IsReleased() || e.HasValidTracks() && e.IsComplete() && e.InitialStateSet() && e.FinishTriggers();\n    }\n    _MaybeEnableRuntimeListeners() {\n      this._hasRuntimeListeners || (this._hasRuntimeListeners = true);\n    }\n    _MaybeDisableRuntimeListeners() {\n      this._markedForRemovalTimelines.length || this._playingTimelines.length || this._scheduledTimelines.length || this._isTickingTimelines || (this._hasRuntimeListeners = false);\n    }\n    _OnBeforeChangeLayout() {\n      for (this._changingLayout = true; this._scheduledTimelines.length; ) this.DeScheduleTimeline(this._scheduledTimelines.pop());\n      const e = /* @__PURE__ */ new Set();\n      for (const i of this._playingTimelines) {\n        const t = i._OnBeforeChangeLayout();\n        t && (i.Removed(), e.add(i));\n      }\n      C32.arrayRemoveAllInSet(this._playingTimelines, e), e.clear();\n      for (const s of this._markedForRemovalTimelines) {\n        const n = s._OnBeforeChangeLayout();\n        n && (s.Removed(), e.add(s));\n      }\n      C32.arrayRemoveAllInSet(this._markedForRemovalTimelines, e), this._MaybeDisableRuntimeListeners();\n      for (const a of this._timelines) a.CleanCaches();\n    }\n    _OnAfterChangeLayout() {\n      this._changingLayout = false;\n    }\n    _OnInstanceDestroy(e) {\n      const i = e.GetObjectClass(), t = this.GetTimelinesForObjectClass(i);\n      if (t) if (this._runtime.IsLoadingState()) this._destroyedWhileLoadingState.push(e);\n      else for (const s of t) s.IsTemplate() || (s.IsReleased() ? this.Remove(s) : s.HasValidTracks() || (this._MaybeExecuteTimelineFinishTriggers(s), this.Remove(s)));\n    }\n    _OnBeforeLoad() {\n      for (const e of this._scheduledTimelines.map((e2) => e2)) this._MaybeExecuteTimelineFinishTriggers(e), this.Remove(e);\n      for (const i of this._playingTimelines.map((e) => e)) this._MaybeExecuteTimelineFinishTriggers(i), this.Remove(i);\n    }\n    _OnAfterLoad() {\n      for (const e of this._destroyedWhileLoadingState) this._OnInstanceDestroy(e);\n      C32.clearArray(this._destroyedWhileLoadingState);\n      for (const i of this._timelines) i._OnAfterLoad();\n    }\n    _OnAfterLayoutStart() {\n      const e = this._runtime.GetLayoutManager(), i = e.GetMainRunningLayout();\n      if (i) for (const t of this._timelines) {\n        const s = t.GetStartOnLayout();\n        s && i.GetName() === s && this.ScheduleTimeline(t);\n      }\n    }\n    _SaveToJson() {\n      return { \"timelinesJson\": this._SaveTimelinesToJson(), \"scheduledTimelinesJson\": this._SaveScheduledTimelinesToJson(), \"playingTimelinesJson\": this._SavePlayingTimelinesToJson(), \"markedForRemovalTimelinesJson\": this._SaveMarkedForRemovalTimelinesToJson(), \"hasRuntimeListeners\": this._hasRuntimeListeners, \"changingLayout\": this._changingLayout, \"isTickingTimelines\": this._isTickingTimelines };\n    }\n    _LoadFromJson(e) {\n      e && (this._ClearCreatedTemplateTimelinesCount(), this._LoadTimelinesFromJson(e[\"timelinesJson\"]), this._LoadScheduledTimelinesFromJson(e[\"scheduledTimelinesJson\"]), this._LoadPlayingTimelinesFromJson(e[\"playingTimelinesJson\"]), this._LoadMarkedForRemovalTimelinesFromJson(e[\"markedForRemovalTimelinesJson\"]), this._hasRuntimeListeners = !e[\"hasRuntimeListeners\"], this._changingLayout = !!e[\"changingLayout\"], this._isTickingTimelines = !!e[\"isTickingTimelines\"], this._SetCreatedTemplateTimelinesCount(), this._MaybeEnableRuntimeListeners(), this._MaybeDisableRuntimeListeners());\n    }\n    _SaveTimelinesToJson() {\n      return this._timelines.map((e) => e._SaveToJson());\n    }\n    _LoadTimelinesFromJson(e) {\n      for (const i of e) {\n        let e2 = this.GetTimelineByName(i[\"name\"]);\n        if (e2) e2._LoadFromJson(i);\n        else {\n          const t = this._GetTemplateNameFromJson(i);\n          if (!t) continue;\n          const s = this.GetTimelineByName(t);\n          (e2 = this.CreateFromTemplate(s))._LoadFromJson(i);\n        }\n        e2.HasTracks() || this.Remove(e2);\n      }\n    }\n    _GetTemplateNameFromJson(e) {\n      const i = e[\"name\"], t = i.split(\":\");\n      return t && 2 === t.length ? t[0] : null;\n    }\n    _SaveScheduledTimelinesToJson() {\n      return this._SaveTimelines(this._scheduledTimelines);\n    }\n    _LoadScheduledTimelinesFromJson(e) {\n      this._LoadTimelines(e, this._scheduledTimelines);\n    }\n    _SavePlayingTimelinesToJson() {\n      return this._SaveTimelines(this._playingTimelines);\n    }\n    _LoadPlayingTimelinesFromJson(e) {\n      this._LoadTimelines(e, this._playingTimelines);\n    }\n    _SaveMarkedForRemovalTimelinesToJson() {\n      return this._SaveTimelines(this._markedForRemovalTimelines);\n    }\n    _LoadMarkedForRemovalTimelinesFromJson(e) {\n      this._LoadTimelines(e, this._markedForRemovalTimelines);\n    }\n    _IsTimelineInJson(e, i) {\n      if (i) {\n        for (const t of i) if (t === e.GetName()) return true;\n      }\n      return false;\n    }\n    _SaveTimelines(e) {\n      return e.map((e2) => e2.GetName());\n    }\n    _LoadTimelines(e, i) {\n      const t = /* @__PURE__ */ new Set();\n      for (const s of i) this._IsTimelineInJson(s, e) || t.add(s);\n      if (C32.arrayRemoveAllInSet(i, t), e) for (const n of e) {\n        const a = this.GetTimelineByName(n);\n        if (a) {\n          const l = i.find(/* @__PURE__ */ ((i2) => (e2) => e2.GetName() === i2)(n));\n          l || i.push(a);\n        }\n      }\n    }\n  };\n}\n{\n  const C32 = self.C3, STEPS = 100, LENGTH_STEP_SIZE = 0.01, BEZIER_STEP_SIZE = 25, REFINE_ITERATIONS = 20, LOOKUP_STEPS_FROM_LAST = 5, TANGENT_RESULT = [0, 0], MAP_RESULT = [0, 0], SHORT_PROJECTION_RESULT = [0, 0], PROJECTION_RESULT = [0, 0, 0, 0, 0], REFINE_LUT = new Array(4), REFINE_LUT_OBJECTS = [{ x: 0, y: 0, t: 0, distance: 0 }, { x: 0, y: 0, t: 0, distance: 0 }, { x: 0, y: 0, t: 0, distance: 0 }], REFINE_RESULT = { x: 0, y: 0, t: 0, distance: 0 };\n  C32.TimelineInfo = class {\n    constructor(t, i) {\n      this._initialized = false, this._timeline = t, this._segments = [];\n      let e = null;\n      if (e = i ? this._timeline.GetTrackById(i) : C32.first(this._timeline.GetTracks())) {\n        const s = e.GetPropertyTrack(\"offsetX\"), _ = e.GetPropertyTrack(\"offsetY\");\n        if (s && _) {\n          this._xTrack = s, this._yTrack = _;\n          const h = s.GetPropertyKeyframeDataItemArrayIncludingDisabled(), n = _.GetPropertyKeyframeDataItemArrayIncludingDisabled();\n          for (let t2 = 1, i2 = Math.min(h.length, n.length); t2 < i2; ++t2) {\n            const r = h[t2], a = (r.GetNext(), r.GetPrevious()), c = n[t2], l = (c.GetNext(), c.GetPrevious());\n            a && \"cubic-bezier\" === a.GetPathMode() && l && \"cubic-bezier\" === l.GetPathMode() ? this._segments.push(C32.New(C32.TimelineCubicBezierSegmentInfo, a, l, r, c, this._segments.length)) : (a && \"line\" === a.GetPathMode() && l && l.GetPathMode(), this._segments.push(C32.New(C32.TimelineLineSegmentInfo, r, c, this._segments.length)));\n          }\n          this._initialized = true;\n        }\n      }\n    }\n    Release() {\n      for (const t of this._segments) t.Release();\n      C32.clearArray(this._segments), this._segments = null, this._timeline = null, this._xTrack = null, this._yTrack = null;\n    }\n    WasInitialized() {\n      return this._initialized;\n    }\n    segments() {\n      return this._segments;\n    }\n    SetOrigin(t) {\n      const i = \"relative\" === this._xTrack.GetResultMode() ? t.GetX() : 0, e = \"relative\" === this._yTrack.GetResultMode() ? t.GetY() : 0;\n      for (const s of this._segments) s.SetOrigin(i, e);\n    }\n    Project(i, e, t) {\n      let s = NaN, _ = this._segments.length;\n      for (let t2 = 0; t2 < _; t2++) {\n        const h = this._segments[t2];\n        if (\"cubic-bezier\" === h.GetType()) {\n          const n = h.Project(i, e);\n          (isNaN(s) || n[3] < s) && (s = n[3], SHORT_PROJECTION_RESULT[0] = n[2], SHORT_PROJECTION_RESULT[1] = h.GetIndex());\n        }\n      }\n      return SHORT_PROJECTION_RESULT;\n    }\n    ProjectWithOptions(i, e, t) {\n      const s = t.tRange;\n      C32.IsFiniteNumber(s[0]) || (s[0] = 0), C32.IsFiniteNumber(s[1]) || (s[1] = 1);\n      let _ = NaN, h = this._segments.length;\n      for (let t2 = 0; t2 < h; t2++) {\n        const n = this._segments[t2];\n        if (\"cubic-bezier\" === n.GetType()) {\n          const r = n.ProjectWithRange(i, e, s);\n          (isNaN(_) || r[3] < _) && (_ = r[3], SHORT_PROJECTION_RESULT[0] = r[2], SHORT_PROJECTION_RESULT[1] = n.GetIndex());\n        }\n      }\n      return SHORT_PROJECTION_RESULT;\n    }\n    Tangent(t, i) {\n      return this._segments[i].Tangent(t);\n    }\n    TangentAngle(t, i) {\n      return this._segments[i].TangentAngle(t);\n    }\n  }, C32.TimelineCubicBezierSegmentInfo = class {\n    constructor(t, i, e, s, _) {\n      this._index = _;\n      const h = t.GetAddOn(\"cubic-bezier\"), n = e.GetAddOn(\"cubic-bezier\"), r = i.GetAddOn(\"cubic-bezier\"), a = s.GetAddOn(\"cubic-bezier\");\n      this._aX = t.GetValueWithResultMode(), this._aY = i.GetValueWithResultMode(), this._bX = t.GetValueWithResultMode() + h.GetStartAnchor(), this._bY = i.GetValueWithResultMode() + r.GetStartAnchor(), this._cX = e.GetValueWithResultMode() + n.GetEndAnchor(), this._cY = s.GetValueWithResultMode() + a.GetEndAnchor(), this._dX = e.GetValueWithResultMode(), this._dY = s.GetValueWithResultMode(), this._aXO = 0, this._aYO = 0, this._bXO = 0, this._bYO = 0, this._cXO = 0, this._cYO = 0, this._dXO = 0, this._dYO = 0, this._d0x = 0, this._d0y = 0, this._d1x = 0, this._d1y = 0, this._d2x = 0, this._d2y = 0, this._x1Factor = 0, this._x2Factor = 0, this._x3Factor = 0, this._y1Factor = 0, this._y2Factor = 0, this._y3Factor = 0, this._lutIndex = NaN, this._initialized = false, this._len = STEPS, this._arcLengths = new Array(this._len + 1), this._arcLengths[0] = 0, this._length = 0, this._lut = [], this._lutObjects = [];\n      for (let t2 = 0; t2 < STEPS; t2++) this._lutObjects.push({ x: 0, y: 0, t: 0, distance: 0 });\n      this._CalculateLength();\n    }\n    Release() {\n      C32.clearArray(this._arcLengths), this._arcLengths = null, C32.clearArray(this._lut), this._lut = null, C32.clearArray(this._lutObjects), this._lutObjects = null;\n    }\n    GetType() {\n      return \"cubic-bezier\";\n    }\n    GetIndex() {\n      return this._index;\n    }\n    GetStepCount() {\n      return Math.floor(this._length / BEZIER_STEP_SIZE);\n    }\n    GetStepIncrement() {\n      return 1 / this.GetStepCount();\n    }\n    SetOrigin(t, i) {\n      this._originX = t, this._originY = i, this._arcLengths = new Array(this._len + 1), this._arcLengths[0] = 0, this._CalculateLength(), this._aXO = this._aX + this._originX, this._aYO = this._aY + this._originY, this._bXO = this._bX + this._originX, this._bYO = this._bY + this._originY, this._cXO = this._cX + this._originX, this._cYO = this._cY + this._originY, this._dXO = this._dX + this._originX, this._dYO = this._dY + this._originY, this._d0x = 3 * (this._bXO - this._aXO), this._d0y = 3 * (this._bYO - this._aYO), this._d1x = 3 * (this._cXO - this._bXO), this._d1y = 3 * (this._cYO - this._bYO), this._d2x = 3 * (this._dXO - this._cXO), this._d2y = 3 * (this._dYO - this._cYO), this._x1Factor = 3 * (this._bXO - this._aXO), this._x2Factor = 3 * (this._aXO + this._cXO - 2 * this._bXO), this._x3Factor = this._dXO - this._aXO + 3 * (this._bXO - this._cXO), this._y1Factor = 3 * (this._bYO - this._aYO), this._y2Factor = 3 * (this._aYO + this._cYO - 2 * this._bYO), this._y3Factor = this._dYO - this._aYO + 3 * (this._bYO - this._cYO);\n    }\n    Map(t) {\n      if (!this._initialized) return NaN;\n      const i = this._Map(t);\n      return MAP_RESULT[0] = this._X(i), MAP_RESULT[1] = this._Y(i), MAP_RESULT;\n    }\n    Project(t, i) {\n      const e = this._GenerateLUT(STEPS), s = this._FindClosestFromLUT(t, i, e), _ = this._RefineProjection(t, i, e, s);\n      return PROJECTION_RESULT[0] = _.x, PROJECTION_RESULT[1] = _.y, PROJECTION_RESULT[2] = _.t, PROJECTION_RESULT[3] = _.distance, PROJECTION_RESULT;\n    }\n    ProjectWithRange(t, i, e) {\n      const s = this._GenerateLUT(STEPS), _ = this._FindClosestFromLUTWithRange(t, i, s, e), h = this._RefineProjection(t, i, s, _);\n      return PROJECTION_RESULT[0] = h.x, PROJECTION_RESULT[1] = h.y, PROJECTION_RESULT[2] = h.t, PROJECTION_RESULT[3] = h.distance, PROJECTION_RESULT;\n    }\n    Tangent(t) {\n      const i = 1 - t, e = i * i, s = 2 * i * t, _ = t * t, h = e * this._d0x + s * this._d1x + _ * this._d2x, n = e * this._d0y + s * this._d1y + _ * this._d2y, r = C32.hypot2DFast(h, n);\n      return TANGENT_RESULT[0] = h / r, TANGENT_RESULT[1] = n / r, TANGENT_RESULT;\n    }\n    TangentAngle(t) {\n      const i = 1 - t, e = i * i, s = 2 * i * t, _ = t * t, h = e * this._d0x + s * this._d1x + _ * this._d2x, n = e * this._d0y + s * this._d1y + _ * this._d2y;\n      return Math.atan2(n, h);\n    }\n    _Map(_) {\n      if (this._initialized) {\n        let t = _ * this._arcLengths[this._len], i = 0, e = this._len, s = 0;\n        for (; i < e; ) s = i + ((e - i) / 2 | 0), this._arcLengths[s] < t ? i = s + 1 : e = s;\n        this._arcLengths[s] > t && s--;\n        const h = this._arcLengths[s];\n        return h === t ? s / this._len : (s + (t - h) / (this._arcLengths[s + 1] - h)) / this._len;\n      }\n    }\n    _X(t) {\n      return this._initialized ? self.Ease.GetRuntimeEase(\"cubicbezier\")(t, this._aX + this._originX, this._bX + this._originX, this._cX + this._originX, this._dX + this._originX) : NaN;\n    }\n    _Y(t) {\n      return this._initialized ? self.Ease.GetRuntimeEase(\"cubicbezier\")(t, this._aY + this._originY, this._bY + this._originY, this._cY + this._originY, this._dY + this._originY) : NaN;\n    }\n    _GenerateLUT(i) {\n      if (i = i || STEPS, !(this._lut.length >= i)) {\n        this._lut = new Array(i), i++;\n        for (let t = 0; t < i - 1; t++) {\n          const e = t / (i - 1), s = e ** 2, _ = e ** 3, h = this._x1Factor * e, n = this._x2Factor * s, r = this._x3Factor * _, a = this._y1Factor * e, c = this._y2Factor * s, l = this._y3Factor * _, o = this._aXO + h + n + r, T = this._aYO + a + c + l;\n          this._lutObjects[t].x = o, this._lutObjects[t].y = T, this._lutObjects[t].t = e, this._lutObjects[t].distance = 0, this._lut[t] = this._lutObjects[t];\n        }\n      }\n      return this._lut;\n    }\n    _FindClosestFromLUT(i, e, s, t = 0, _ = Number.MAX_SAFE_INTEGER) {\n      let h = 0;\n      if (isNaN(this._lutIndex)) for (let t2 = 0; t2 < STEPS; t2++) {\n        const n = s[t2], r = n.x - i, a = n.y - e;\n        n.distance = r * r + a * a, n.distance < _ && (_ = n.distance, h = t2);\n      }\n      else {\n        for (let t2 = this._lutIndex; t2 < this._lutIndex + LOOKUP_STEPS_FROM_LAST && !(t2 >= s.length); t2++) {\n          const c = s[t2], l = c.x - i, o = c.y - e;\n          c.distance = l * l + o * o, c.distance < _ && (_ = c.distance, h = t2);\n        }\n        for (let t2 = this._lutIndex; t2 > this._lutIndex - LOOKUP_STEPS_FROM_LAST && !(t2 < 0); t2--) {\n          const T = s[t2], d = T.x - i, E = T.y - e;\n          T.distance = d * d + E * E, T.distance < _ && (_ = T.distance, h = t2);\n        }\n      }\n      return this._lutIndex = h;\n    }\n    _FindClosestFromLUTWithRange(i, e, s, _, h = Number.MAX_SAFE_INTEGER) {\n      let n = 0;\n      if (isNaN(this._lutIndex)) for (let t = 0; t < STEPS; t++) {\n        const r = s[t], a = r.x - i, c = r.y - e;\n        r.distance = a * a + c * c, r.t >= _[0] && r.t <= _[1] && r.distance < h && (h = r.distance, n = t);\n      }\n      else {\n        for (let t = this._lutIndex; t < this._lutIndex + LOOKUP_STEPS_FROM_LAST && !(t >= s.length); t++) {\n          const l = s[t], o = l.x - i, T = l.y - e;\n          l.distance = o * o + T * T, l.t >= _[0] && l.t <= _[1] && l.distance < h && (h = l.distance, n = t);\n        }\n        for (let t = this._lutIndex; t > this._lutIndex - LOOKUP_STEPS_FROM_LAST && !(t < 0); t--) {\n          const d = s[t], E = d.x - i, O = d.y - e;\n          d.distance = E * E + O * O, d.t >= _[0] && d.t <= _[1] && d.distance < h && (h = d.distance, n = t);\n        }\n      }\n      return this._lutIndex = n;\n    }\n    _RefineProjection(h, n, r, a) {\n      let c = r[a], t = 1, l = Number.MAX_SAFE_INTEGER;\n      t: do {\n        const o = r.length;\n        let t2 = 0 === a ? 0 : a - 1, i = a === o - 1 ? o - 1 : a + 1, e = r[t2].t, s = r[i].t, _ = (s - e) / 4;\n        if (_ < 1e-3) break;\n        REFINE_LUT[0] = r[t2];\n        for (let t3 = 1; t3 <= 2; t3++) {\n          const T = e + t3 * _, d = T ** 2, E = T ** 3, O = this._x1Factor * T, u = this._x2Factor * d, R = this._x3Factor * E, S = this._y1Factor * T, g = this._y2Factor * d, I = this._y3Factor * E, N = this._aXO + O + u + R, L = this._aYO + S + g + I, x = N - h, y = L - n, G = x * x + y * y;\n          if (G < l) {\n            l = G, a = t3, REFINE_RESULT.x = N, REFINE_RESULT.y = L, REFINE_RESULT.t = T, REFINE_RESULT.distance = G, c = REFINE_RESULT;\n            break t;\n          }\n          const P = REFINE_LUT_OBJECTS[t3 - 1];\n          P.x = N, P.y = L, P.t = T, P.distance = G, REFINE_LUT[t3] = P;\n        }\n        REFINE_LUT[3] = r[i], r = REFINE_LUT;\n      } while (t++ < REFINE_ITERATIONS);\n      return c;\n    }\n    _CalculateLength() {\n      this._initialized = true;\n      let i = this._X(0), e = this._Y(0), s = 0;\n      for (let t = 1; t <= this._len; t++) {\n        const _ = this._X(t * LENGTH_STEP_SIZE), h = this._Y(t * LENGTH_STEP_SIZE), n = i - _, r = e - h;\n        s += C32.hypot2DFast(n, r), this._arcLengths[t] = s, i = _, e = h;\n      }\n      this._length = s;\n    }\n  }, C32.TimelineLineSegmentInfo = class {\n    constructor(t, i, e) {\n      this._index = e, this._targetX = t.GetValueWithResultMode(), this._targetY = i.GetValueWithResultMode(), this._originX = 0, this._originY = 0;\n    }\n    Release() {\n    }\n    GetType() {\n      return \"line\";\n    }\n    GetIndex() {\n      return this._index;\n    }\n    SetOrigin(t, i) {\n      this._originX = t, this._originY = i;\n    }\n    GetX() {\n      return this._targetX + this._originX;\n    }\n    GetY() {\n      return this._targetY + this._originY;\n    }\n  };\n}\n{\n  const C32 = self.C3, PING_PONG_BEGIN = 0, PING_PONG_END = 1;\n  C32.TimelineState = class extends C32.DefendedBase {\n    constructor(e, t, i) {\n      super(), this._runtime = i.GetRuntime(), this._timelineManager = i, this._timelineDataItem = t, this._name = e, this._tracks = [], this._tracksLength = 0, this._beforeAndAfterTracks = null, this._beforeAndAfterTracksLength = 0, this.CreateTrackStates(), this._playPromise = null, this._playResolve = null, this._playheadTime = 0, this._overshoot = 0, this._playbackRate = 1, this._pingPongState = PING_PONG_BEGIN, this._currentRepeatCount = 1, this._isPlaying = false, this._isScheduled = false, this._initialStateSet = false, this._complete = true, this._released = false, this._markedForRemoval = false, this._completedTick = -1, this._implicitPause = false, this._isTemplate = false, this._finishedTriggers = false, this._firstTick = false, this._lastDelta = NaN, this._tags = [\"\"], this._stringTags = \"\", this._tagsChanged = false, this._renderChange = 0, this._hasNestedContent = 0, this._iTimelineState = null;\n    }\n    static CreateInitial(e, t) {\n      const i = t.GetTimelineDataManager(), s = i.GetNameId(), a = i.Get(e[s]), n = C32.New(C32.TimelineState, e[s], a, t);\n      return n.SetIsTemplate(true), n;\n    }\n    static CreateFromTemplate(e, t, i) {\n      return C32.New(C32.TimelineState, e, t, i);\n    }\n    Release() {\n      if (!this.IsReleased()) {\n        const e = this._runtime.Dispatcher();\n        this._timelineManager.DeScheduleTimeline(this), this._timelineManager.CompleteTimelineAndResolve(this);\n        for (const t of this._tracks) t.Release();\n        C32.clearArray(this._tracks), this._tracks = null, this._runtime = null, this._timelineManager = null, this._timelineDataItem = null, this._released = true, this._playPromise = null, this._playResolve = null, this.FireReleaseEvent(e);\n      }\n    }\n    FireReleaseEvent(e) {\n      const t = C32.New(C32.Event, \"timelinestatereleased\");\n      t.timelineState = this, e.dispatchEvent(t);\n    }\n    GetType() {\n      return 0;\n    }\n    CreateTrackStates() {\n      for (const e of this._timelineDataItem.GetTrackData().trackDataItems()) this._tracksLength = this._tracks.push(C32.TrackState.Create(this, e));\n    }\n    GetTimelineManager() {\n      return this._timelineManager;\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetTracks() {\n      return this._tracks;\n    }\n    GetSimilarPropertyTracks(s, a, n, r) {\n      if (this._hasNestedContent) {\n        let i;\n        for (let t = 0; t < this._tracks.length; t++) {\n          let e = this._tracks[t];\n          if (s === e.GetInstance()) {\n            const h = e.GetPropertyTrack(n);\n            h && a.constructor === h.GetSourceAdapter().constructor && h.GetResultMode() === r.GetResultMode() && (i = i || []).push(h);\n          }\n        }\n        return i;\n      }\n    }\n    HasTracks() {\n      return !!this._tracks.length;\n    }\n    GetTrackById(e) {\n      for (const t of this._tracks) if (C32.equalsNoCase(t.GetId(), e)) return t;\n      return null;\n    }\n    GetTrackByName(e) {\n      for (const t of this._tracks) if (!t.IsInstanceTrack() && C32.equalsNoCase(t.GetName(), e)) return t;\n      return null;\n    }\n    SetName(e) {\n      this._name = e;\n    }\n    GetName() {\n      return this._name;\n    }\n    GetTimelineDataItem() {\n      return this._timelineDataItem;\n    }\n    GetTemplateName() {\n      return this._timelineDataItem.GetName();\n    }\n    GetTotalTime() {\n      return this._timelineDataItem.GetTotalTime();\n    }\n    SetTotalTime(e) {\n      this._timelineDataItem.SetTotalTime(e);\n    }\n    GetStep() {\n      return this._timelineDataItem.GetStep();\n    }\n    SetStep(e) {\n      this._timelineDataItem.SetStep(e);\n    }\n    GetInterpolationMode() {\n      return this._timelineDataItem.GetInterpolationMode();\n    }\n    SetInterpolationMode(e) {\n      this._timelineDataItem.SetInterpolationMode(e);\n    }\n    GetResultMode() {\n      return this._timelineDataItem.GetResultMode();\n    }\n    SetResultMode(e) {\n      this._timelineDataItem.GetResultMode(e);\n    }\n    SetEase(e) {\n      for (const t of this.GetTracks()) t.SetEase(e);\n    }\n    GetLoop() {\n      return this._timelineDataItem.GetLoop();\n    }\n    SetLoop(e) {\n      return this._timelineDataItem.SetLoop(e);\n    }\n    GetPingPong() {\n      return this._timelineDataItem.GetPingPong();\n    }\n    SetPingPong(e) {\n      return this._timelineDataItem.SetPingPong(e);\n    }\n    GetRepeatCount() {\n      return this._timelineDataItem.GetRepeatCount();\n    }\n    SetRepeatCount(e) {\n      return this._timelineDataItem.SetRepeatCount(e);\n    }\n    SetPlaybackRate(e) {\n      return this._playbackRate = e;\n    }\n    GetPlaybackRate() {\n      return this._playbackRate;\n    }\n    GetStartOnLayout() {\n      return this._timelineDataItem.GetStartOnLayout();\n    }\n    GetTransformWithSceneGraph() {\n      return this._timelineDataItem.GetTransformWithSceneGraph();\n    }\n    GetUseSystemTimescale() {\n      return this._timelineDataItem.GetUseSystemTimescale();\n    }\n    GetPingPongState() {\n      return this._pingPongState;\n    }\n    IsForwardPlayBack() {\n      return !this.IsPlaying() || 0 < this._playbackRate;\n    }\n    GetPlayPromise() {\n      return this._playPromise || (this._playPromise = new Promise((e) => {\n        this._playResolve = e;\n      })), this._playPromise;\n    }\n    ResolvePlayPromise() {\n      this._playPromise && (this._playResolve(), this._playPromise = null, this._playResolve = null);\n    }\n    SetTags(e) {\n      this._tags = C32.TimelineState._GetTagArray(e), this._tagsChanged = true;\n    }\n    GetTags() {\n      return this._tags;\n    }\n    GetStringTags() {\n      return this._tagsChanged && (this._stringTags = this._tags.join(\" \")), this._tagsChanged = false, this._stringTags;\n    }\n    HasTags(e) {\n      if (!this._tags) return false;\n      if (!this._tags.length) return false;\n      const t = C32.TimelineState._GetTagArray(e);\n      return !!t && !!t.length && t.every(C32.TimelineState._HasTag, this);\n    }\n    OnStarted() {\n      C32.Plugins.Timeline && this.constructor === C32.TimelineState && (C32.Plugins.Timeline.Cnds.PushTriggerTimeline(this), this._timelineManager.Trigger(C32.Plugins.Timeline.Cnds.OnTimelineStarted), this._timelineManager.Trigger(C32.Plugins.Timeline.Cnds.OnTimelineStartedByName), this._timelineManager.Trigger(C32.Plugins.Timeline.Cnds.OnTimelineStartedByTags), this._timelineManager.Trigger(C32.Plugins.Timeline.Cnds.OnAnyTimelineStarted), C32.Plugins.Timeline.Cnds.PopTriggerTimeline());\n    }\n    OnCompleted() {\n      this._completedTick = this._runtime.GetTickCount();\n    }\n    FinishTriggers() {\n      this._finishedTriggers || (this._finishedTriggers = true, C32.Plugins.Timeline && this.constructor === C32.TimelineState && (C32.Plugins.Timeline.Cnds.PushTriggerTimeline(this), this._timelineManager.Trigger(C32.Plugins.Timeline.Cnds.OnTimelineFinished), this._timelineManager.Trigger(C32.Plugins.Timeline.Cnds.OnTimelineFinishedByName), this._timelineManager.Trigger(C32.Plugins.Timeline.Cnds.OnTimelineFinishedByTags), this._timelineManager.Trigger(C32.Plugins.Timeline.Cnds.OnAnyTimelineFinished), C32.Plugins.Timeline.Cnds.PopTriggerTimeline()));\n    }\n    SetPlaying(e) {\n      this._isPlaying = e;\n    }\n    IsCompletedTick() {\n      return this._completedTick === this._runtime.GetTickCount();\n    }\n    IsPlaying(e = false) {\n      return !!this.IsCompletedTick() || !(!this.IsScheduled() || e) || this._isPlaying;\n    }\n    _IsPlaying() {\n      return this.IsPlaying(true);\n    }\n    IsPaused() {\n      return this._IsPaused();\n    }\n    _IsPaused() {\n      return !(this.IsReleased() || this.IsScheduled() || this._IsPlaying() || this.IsComplete());\n    }\n    SetScheduled(e) {\n      this._isScheduled = e;\n    }\n    IsScheduled() {\n      return this._isScheduled;\n    }\n    SetComplete(e) {\n      this._complete = e;\n      const t = this.GetTime();\n      (t <= 0 || t >= this.GetTotalTime()) && (this._complete = true);\n    }\n    IsComplete() {\n      return this._complete;\n    }\n    IsReleased() {\n      return this._released;\n    }\n    SetMarkedForRemoval(e) {\n      this._markedForRemoval = e;\n    }\n    IsMarkedForRemoval() {\n      return this._markedForRemoval;\n    }\n    SetImplicitPause(e) {\n      this._implicitPause = e;\n    }\n    IsImplicitPause() {\n      return this._implicitPause;\n    }\n    SetIsTemplate(e) {\n      this._isTemplate = !!e;\n    }\n    IsTemplate() {\n      return this._isTemplate;\n    }\n    InitialStateSet() {\n      return this._initialStateSet;\n    }\n    GetTime() {\n      return this._playheadTime;\n    }\n    SetTime(e) {\n      const t = this.GetTime();\n      this._SetTime(e), this.SetComplete(false), this.IsComplete() || this.SetImplicitPause(true), !this._IsPlaying() && !this.IsScheduled() && this._initialStateSet || (this._IsPlaying() || this.IsScheduled() || this._initialStateSet ? this._IsPlaying() ? this.Stop() : this.IsScheduled() && (this._timelineManager.DeScheduleTimeline(this), this.SetInitialStateFromSetTime()) : this.SetInitialStateFromSetTime()), this._SetUpdateStateBefore(), this._Interpolate(this.GetTime(), false, true, true, t), this._SetUpdateStateAfter(), this._renderChange && this.GetRuntime().UpdateRender(), this._OnSetTime();\n    }\n    _SetTime(e) {\n      (e = C32.IsFiniteNumber(e) ? e : this.GetTotalTime()) < 0 ? this._playheadTime = 0 : e >= this.GetTotalTime() ? this._playheadTime = this.GetTotalTime() : this._playheadTime = e;\n    }\n    _SetTimeAndReset(e) {\n      (e = C32.IsFiniteNumber(e) ? e : this.GetTotalTime()) < 0 ? this._playheadTime = 0 : e >= this.GetTotalTime() ? this._playheadTime = this.GetTotalTime() : this._playheadTime = e;\n      for (const t of this._tracks) t.SetResetState();\n    }\n    _OnSetTime() {\n      C32.Plugins.Timeline && this.constructor === C32.TimelineState && (C32.Plugins.Timeline.Cnds.PushTriggerTimeline(this), this._timelineManager.Trigger(C32.Plugins.Timeline.Cnds.OnTimeSet), this._timelineManager.Trigger(C32.Plugins.Timeline.Cnds.OnTimeSetByName), this._timelineManager.Trigger(C32.Plugins.Timeline.Cnds.OnTimeSetByTags), C32.Plugins.Timeline.Cnds.PopTriggerTimeline());\n    }\n    _CanResume() {\n      if (!this.GetLoop()) {\n        if (this.GetPingPong() && this._pingPongState === PING_PONG_END) {\n          if (this.IsForwardPlayBack()) {\n            if (this.GetTime() >= this.GetTotalTime()) return false;\n          } else if (this.GetTime() <= 0) return false;\n        } else if (!this.GetLoop() && !this.GetPingPong()) {\n          if (this.IsForwardPlayBack()) {\n            if (this.GetTime() >= this.GetTotalTime()) return false;\n          } else if (this.GetTime() <= 0) return false;\n        }\n      }\n      return true;\n    }\n    Resume() {\n      this.IsReleased() || this._CanResume() && this.Play(true);\n    }\n    Play(e = false) {\n      return !this.IsReleased() && !this.IsScheduled() && (this._IsPlaying() && this.IsCompletedTick() ? this._SchedulePlayingTimeline() : !this._IsPlaying() && !!(this.IsComplete() || e || this.IsImplicitPause()) && this._ScheduleStoppedTimeline());\n    }\n    _SchedulePlayingTimeline() {\n      return this.SetImplicitPause(false), this._timelineManager.RemovePlayingTimeline(this), this._timelineManager.ScheduleTimeline(this), this.GetPlayPromise(), true;\n    }\n    _ScheduleStoppedTimeline() {\n      return this.SetImplicitPause(false), this._timelineManager.ScheduleTimeline(this), this.GetPlayPromise(), true;\n    }\n    Stop(e = false) {\n      this.IsReleased() || (this.SetComplete(e), this._timelineManager.CompleteTimeline(this), this.IsComplete() && this.ResolvePlayPromise());\n    }\n    Reset(e = true, t = false) {\n      if (!this.IsReleased()) {\n        if (!this._IsPlaying() && this.IsScheduled()) return this._timelineManager.DeScheduleTimeline(this);\n        if (!this.IsComplete()) {\n          this.Stop(true), this.IsForwardPlayBack() ? this._SetTime(0) : this._SetTime(this.GetTotalTime());\n          const i = this.GetTime();\n          this._SetUpdateStateBefore(), t ? this._InterpolateBeforeChangeLayout(i) : this._Interpolate(i, false, false, true), e && this._OnSetTime(), this._SetUpdateStateAfter(), this._renderChange && e && this.GetRuntime().UpdateRender();\n        }\n      }\n    }\n    ResetBeforeChangeLayout() {\n      this.Reset(false, true);\n    }\n    _InterpolateBeforeChangeLayout(e) {\n      this._Interpolate(e, false, false, true, NaN, false, true);\n    }\n    _OnBeforeChangeLayout() {\n      if (!this.IsReleased()) {\n        if (!this.GetRuntime().IsLoadingState() && this.HasValidGlobalTracks()) return false;\n        this._timelineManager.CompleteTimelineBeforeChangeOfLayout(this), this.GetRuntime().IsLoadingState() || this.ResetBeforeChangeLayout();\n      }\n      return true;\n    }\n    SetInitialStateFromSetTime() {\n      this.SetInitialState(true);\n    }\n    SetInitialStateForce() {\n      this.SetInitialState(false, true), this.SetPlaying(false), this.SetScheduled(false);\n    }\n    SetInitialState(e = false, t = false) {\n      if (!this.IsMarkedForRemoval() || t) {\n        if (e) {\n          this._finishedTriggers = false, this._initialStateSet = true, this._firstTick = true, this._SetUpdateStateBefore();\n          for (const i of this._tracks) i.SetInitialState();\n        } else if (this.SetPlaying(true), this.SetScheduled(false), this.OnStarted(), this.IsComplete()) {\n          this._completedTick = -1, this._pingPongState !== PING_PONG_BEGIN && (this._playbackRate = Math.abs(this._playbackRate)), this._pingPongState = PING_PONG_BEGIN, this._currentRepeatCount = 1, this._complete = false, this._finishedTriggers = false, this._initialStateSet = true, this._firstTick = true, this.IsForwardPlayBack() ? this._SetTime(0) : this._SetTime(this.GetTotalTime()), this._SetUpdateStateBefore();\n          for (const s of this._tracks) s.SetInitialState();\n        } else {\n          this._firstTick = true, this._finishedTriggers = false, this._SetUpdateStateBefore();\n          for (const a of this._tracks) a.SetResumeState();\n        }\n        this._SetUpdateStateAfter();\n      }\n    }\n    GetRenderChange() {\n      return this._renderChange;\n    }\n    _SetUpdateStateBefore() {\n      this._hasNestedContent = 0;\n      for (const e of this._tracks) e.IsNested() && (this._hasNestedContent = 1);\n    }\n    _SetUpdateStateAfter() {\n      this._renderChange = 0;\n      for (const e of this._tracks) e._SetUpdateState(), 0 === this._renderChange && 1 === e.GetRenderChange() && (this._renderChange = 1), this._beforeAndAfterTracks || 1 !== e.GetNeedsBeforeAndAfter() || (this._beforeAndAfterTracks || (this._beforeAndAfterTracks = []), this._beforeAndAfterTracksLength = this._beforeAndAfterTracks.push(e));\n    }\n    Tick(e, t, i) {\n      if (this.GetUseSystemTimescale()) {\n        if (0 === e && 0 === this._lastDelta) return;\n        this._lastDelta = e, e = i;\n      } else {\n        if (0 === i && 0 === this._lastDelta) return;\n        e = this._lastDelta = i, t = 1;\n      }\n      const s = this._playheadTime + this._overshoot, a = e * t * this._playbackRate, n = s + a, r = this._timelineDataItem._totalTime;\n      n < 0 ? (this._playheadTime = 0, this._overshoot = -n) : r <= n ? (this._playheadTime = r, this._overshoot = this._playheadTime - n) : (this._playheadTime = n, this._overshoot = 0);\n      let h = false, l = false;\n      const o = this.GetLoop(), _ = this.GetPingPong();\n      o || _ ? o && !_ ? 0 < this._playbackRate ? this._playheadTime >= r && (this._SetTimeAndReset(0), l = true) : this._playheadTime <= 0 && (this._SetTimeAndReset(r), l = true) : !o && _ ? 0 < this._playbackRate ? this._playheadTime >= r && (this._SetTime(r), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), l = true, this._pingPongState === PING_PONG_END ? this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._pingPongState = PING_PONG_BEGIN) : h = true : this._pingPongState === PING_PONG_BEGIN && (this._pingPongState = PING_PONG_END)) : this._playheadTime <= 0 && (this._SetTime(0), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), l = true, this._pingPongState === PING_PONG_END ? this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._pingPongState = PING_PONG_BEGIN) : h = true : this._pingPongState === PING_PONG_BEGIN && (this._pingPongState = PING_PONG_END)) : o && _ && (0 < this._playbackRate ? this._playheadTime >= r && (this._SetTime(r), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), l = true, this._pingPongState++, C32.wrap(this._pingPongState, 0, 2)) : this._playheadTime <= 0 && (this._SetTime(0), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), l = true, this._pingPongState++, C32.wrap(this._pingPongState, 0, 2))) : 0 < this._playbackRate ? this._playheadTime >= r && (this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._SetTimeAndReset(0), l = true) : (this._SetTime(r), h = true)) : this._playheadTime <= 0 && (this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._SetTimeAndReset(r), l = true) : (this._SetTime(0), h = true));\n      let m;\n      const c = this._tracksLength;\n      if (h) {\n        for (m = 0; m < c; m++) this._tracks[m].SetEndState();\n        this.Stop(true), this.OnCompleted();\n      } else {\n        const T = this._beforeAndAfterTracksLength;\n        for (m = 0; m < T; m++) this._beforeAndAfterTracks[m].BeforeInterpolate();\n        if (1 === this._hasNestedContent) for (m = 0; m < c; m++) {\n          const g = this._tracks[m], d = g.GetStartOffset(), u = this._playheadTime - d, S = s - d;\n          u < 0 && 0 < S ? (this._playheadTime = d < 0 ? 0 : r <= d ? r : d, g.Interpolate(d, true, false, l, this._firstTick, false)) : g.Interpolate(this._playheadTime, true, false, l, this._firstTick, false);\n        }\n        else for (m = 0; m < c; m++) this._tracks[m].Interpolate(this._playheadTime, true, false, l, this._firstTick, false);\n        for (m = 0; m < T; m++) this._beforeAndAfterTracks[m].AfterInterpolate();\n        this._firstTick && (this._firstTick = false);\n      }\n    }\n    _Interpolate(t, i = false, s = false, a = false, n = NaN, e = false, r = false) {\n      for (const h of this._tracks) h.BeforeInterpolate();\n      for (const l of this._tracks) {\n        let e2 = t;\n        if (\"number\" == typeof n && !isNaN(n)) {\n          const o = this.GetTime(), _ = o - l.GetStartOffset(), m = n - l.GetStartOffset();\n          _ < 0 && 0 < m && (e2 = l.GetStartOffset(), this._SetTime(e2));\n        }\n        l.Interpolate(e2, i, s, a, this._firstTick, r);\n      }\n      for (const c of this._tracks) c.AfterInterpolate();\n      this._firstTick && e && (this._firstTick = false);\n    }\n    AddTrack() {\n      const e = this._timelineDataItem.GetTrackData().AddEmptyTrackDataItem(), t = C32.TrackState.Create(this, e);\n      return this._tracksLength = this._tracks.push(t), t;\n    }\n    Removed() {\n      if (!this.IsReleased()) for (const e of this._tracks) e.TimelineRemoved();\n    }\n    CleanCaches() {\n      for (const e of this._tracks) e.CleanCaches();\n    }\n    ClearTrackInstances() {\n      for (const e of this._tracks) e.ClearInstance();\n    }\n    SetTrackInstance(e, t, i) {\n      if (t) {\n        if (\"number\" == typeof i && 0 <= i) {\n          const s = this._tracks[i];\n          return s ? (s.SetInstance(t), void this._timelineManager.SetTimelineObjectClassToMap(t.GetObjectClass(), this)) : void 0;\n        }\n        for (const a of this._tracks) if (a.IsInstanceTrack()) {\n          if (e) {\n            if (a.GetId() === e) {\n              a.SetInstance(t), this._timelineManager.SetTimelineObjectClassToMap(t.GetObjectClass(), this);\n              break;\n            }\n          } else if (!a.HasInstance()) {\n            a.SetInstance(t), this._timelineManager.SetTimelineObjectClassToMap(t.GetObjectClass(), this);\n            break;\n          }\n        }\n      }\n    }\n    HasTrackInstance(e, t) {\n      for (const i of this._tracks) if (i.IsInstanceTrack()) {\n        if (t) {\n          if (t === i.GetId() && e === i.GetInstance()) return true;\n        } else if (e === i.GetInstance()) return true;\n      }\n      return false;\n    }\n    HasValidTracks() {\n      return this._tracks.some((e) => !e.IsInstanceTrack() || e.CanInstanceBeValid());\n    }\n    HasValidGlobalTracks() {\n      return this._tracks.some((e) => {\n        if (e.IsInstanceTrack()) {\n          if (!e.CanInstanceBeValid()) return false;\n          const t = e.GetObjectClass();\n          return t ? t.IsGlobal() : false;\n        }\n        return false;\n      });\n    }\n    GetPropertyTrack(e) {\n      for (const t of this.GetTracks()) for (const i of t.GetPropertyTracks()) if (i.GetPropertyName() === e) return i;\n    }\n    GetTrackFromInstance(e) {\n      for (const t of this._tracks) if (e === t.GetInstance()) return t;\n      return null;\n    }\n    GetKeyframeWithTags(e) {\n      let t = e ? e.split(\" \") : [];\n      const i = new Set(t.map((e2) => e2.toLowerCase().trim()));\n      t = [...i.values()];\n      for (const s of this.GetTracks()) for (const a of s.GetKeyframeDataItems()) {\n        const n = t.every((e2) => a.HasTag(e2));\n        if (n) return a;\n      }\n    }\n    GetObjectClasses() {\n      const e = [];\n      for (const t of this.GetTracks()) e.push(t.GetObjectClass());\n      return e.filter((e2) => e2);\n    }\n    _OnAfterLoad() {\n      for (const e of this.GetTracks()) e._OnAfterLoad();\n    }\n    _SaveToJson() {\n      return { \"tracksJson\": this._SaveTracksToJson(), \"name\": this._name, \"playheadTime\": this.GetTime(), \"playbackRate\": this._playbackRate, \"pingPongState\": this._pingPongState, \"currentRepeatCount\": this._currentRepeatCount, \"isPlaying\": this._isPlaying, \"isScheduled\": this._isScheduled, \"initialStateSet\": this._initialStateSet, \"finishedTriggers\": this._finishedTriggers, \"complete\": this._complete, \"released\": this._released, \"markedForRemoval\": this._markedForRemoval, \"completedTick\": this._completedTick, \"implicitPause\": this._implicitPause, \"isTemplate\": this._isTemplate, \"tags\": this._tags.join(\" \"), \"stringTags\": this._stringTags, \"tagsChanged\": this._tagsChanged, \"firstTick\": this._firstTick };\n    }\n    _LoadFromJson(e) {\n      e && (this._LoadTracksFromJson(e[\"tracksJson\"]), this._name = e[\"name\"], this._playheadTime = e[\"playheadTime\"], this._playbackRate = e[\"playbackRate\"], this._pingPongState = e[\"pingPongState\"], this._currentRepeatCount = e[\"currentRepeatCount\"], this._isPlaying = !!e[\"isPlaying\"], this._isScheduled = !!e[\"isScheduled\"], this._initialStateSet = !!e[\"initialStateSet\"], this._finishedTriggers = !!e.hasOwnProperty(\"finishedTriggers\") && !!e[\"finishedTriggers\"], this._complete = !!e[\"complete\"], this._released = !!e[\"released\"], this._markedForRemoval = !!e[\"markedForRemoval\"], this._completedTick = e[\"completedTick\"], this._implicitPause = !!e[\"implicitPause\"], this._isTemplate = !!e[\"isTemplate\"], this._tags = e[\"tags\"].split(\" \"), this._stringTags = e[\"stringTags\"], this._tagsChanged = !!e[\"tagsChanged\"], this._firstTick = !!e[\"firstTick\"]);\n    }\n    _SaveTracksToJson() {\n      return this._tracks.map((e) => e._SaveToJson());\n    }\n    _LoadTracksFromJson(e) {\n      this.ClearTrackInstances(), e.forEach((e2, t) => {\n        const i = this._tracks[t];\n        i._LoadFromJson(e2);\n      }), this._tracks.filter((e2) => e2.CanInstanceBeValid());\n    }\n    static _HasTag(e) {\n      const t = this.GetTags();\n      return \"\" === e ? 1 === t.length && \"\" === t[0] : t.map((e2) => e2.toLowerCase()).includes(e.toLowerCase());\n    }\n    static _GetTagArray(e) {\n      if (C32.IsArray(e)) return e.slice(0);\n      if (C32.IsString(e)) return e.split(\" \");\n      throw new Error(\"invalid tags\");\n    }\n    GetITimelineState() {\n      return this._iTimelineState || (this._iTimelineState = C32.New(self.ITimelineState, this)), this._iTimelineState;\n    }\n  };\n}\n{\n  const C32 = self.C3, INSTANCE_TRACK = 0, VALUE_TRACK = 1, AUDIO_TRACK = 2;\n  C32.TrackState = class extends C32.DefendedBase {\n    constructor(t, e) {\n      super(), this._timeline = t, this._trackDataItem = e, this._trackData = e.GetTrackData(), this._instanceUid = NaN, this._objectClassIndex = NaN, this._instance = null, this._worldInfo = null, this._cleared = false, this._isNested = 0 < e.GetStartOffset(), this._initialStateOfNestedSet = false, this._endStateOfNestedSet = false, this._instanceUidToLoad = NaN, this._lastKeyframeDataItem = null, this._keyframeDataItems = this._trackDataItem.GetKeyframeData().GetKeyframeDataItemArray(), this._propertyTracks = [], this.CreatePropertyTrackStates(), this._worldInfoChange = 0, this._renderChange = 0, this._needsBeforeAndAfter = 0;\n    }\n    static Create(t, e) {\n      return C32.New(C32.TrackState, t, e);\n    }\n    Release() {\n      this._keyframeDataItems = null;\n      for (const t of this._propertyTracks) t.Release();\n      C32.clearArray(this._propertyTracks), this._propertyTracks = null, this._timeline = null, this._instance = null, this._worldInfo = null, this._trackDataItem = null, this._lastKeyframeDataItem = null;\n    }\n    CreatePropertyTrackStates() {\n      for (const t of this._trackDataItem.GetPropertyTrackData().propertyTrackDataItems()) this._propertyTracks.push(C32.PropertyTrackState.Create(this, t));\n    }\n    TimelineRemoved() {\n      for (const t of this._propertyTracks) t.TimelineRemoved();\n    }\n    CleanCaches() {\n      for (const t of this._propertyTracks) t.CleanCaches();\n      this._instance = null, this._worldInfo = null;\n    }\n    GetTimeline() {\n      return this._timeline;\n    }\n    GetRuntime() {\n      return this._timeline.GetRuntime();\n    }\n    GetKeyframeDataItems() {\n      return this._keyframeDataItems || (this._keyframeDataItems = this._trackDataItem.GetKeyframeData().GetKeyframeDataItemArray()), this._keyframeDataItems;\n    }\n    GetPropertyTracks() {\n      return this._propertyTracks;\n    }\n    GetPropertyTrack(e) {\n      for (let t = 0; t < this._propertyTracks.length; t++) {\n        const a = this._propertyTracks[t];\n        if (a.GetPropertyName() === e) return a;\n      }\n    }\n    MaybeGetInstance() {\n      this._instance || this.GetInstance();\n    }\n    IsInstanceValid() {\n      return !!this._instance && !this._instance.IsDestroyed();\n    }\n    CanInstanceBeValid() {\n      if (!this.IsInstanceTrack()) return false;\n      const t = this.GetInstanceUID(), e = this.GetRuntime().GetInstanceByUID(t);\n      return !!e && !e.IsDestroyed();\n    }\n    GetObjectClass() {\n      if (this.IsInstanceTrack()) {\n        const t = this.GetObjectClassIndex();\n        if (-1 !== t) return this.GetRuntime().GetObjectClassByIndex(t);\n      }\n    }\n    GetTrackIndexInTimeline() {\n      return this._timeline.GetTracks().indexOf(this);\n    }\n    ClearInstance() {\n      this._instance = null, this._instanceUid = NaN, this._worldInfo = null, this._objectClassIndex = NaN, this._cleared = true;\n    }\n    HasInstance() {\n      return !!this._instance;\n    }\n    GetInstance() {\n      if (!this._cleared) {\n        if (!this._instance || !this.IsInstanceValid()) {\n          const t = this.GetInstanceUID();\n          this._instance = this.GetRuntime().GetInstanceByUID(t);\n        }\n        return this._instance;\n      }\n    }\n    SetInstance(t) {\n      if (this._cleared = false, this._instance !== t) {\n        this.CleanCaches(), this._instance = t, this._objectClassIndex = t.GetObjectClass().GetIndex(), this._instanceUid = t.GetUID(), this._worldInfo = t.GetWorldInfo();\n        for (const e of this.propertyTrackItems()) {\n          const a = e.propertyTrack, s = e.sourceAdapter, r = a.GetSourceAdapterId();\n          switch (r) {\n            case \"instance-variable\": {\n              s.GetEditorIndex();\n              const i = t.GetObjectClass(), n = i.GetInstanceVariableIndexByName(e.name), o = i.GetInstanceVariableName(n), h = i.GetInstanceVariableType(n);\n              o === e.name && h === e.type && s.UpdateInstanceVariableIndex(n);\n              break;\n            }\n            case \"behavior\": {\n              const c = e.behaviorType, l = this.GetObjectClass(), I = t.GetObjectClass(), d = s.GetBehaviorType(I);\n              if (c && d) {\n                const f = c.GetName();\n                l.GetBehaviorIndexByName(f), I.GetBehaviorIndexByName(f), s.GetEditorIndex();\n                s.UpdateBehaviorTypeSid(d.GetSID());\n              }\n              break;\n            }\n          }\n        }\n      }\n    }\n    *propertyTrackItems() {\n      for (const t of this._propertyTracks) {\n        const e = t.GetSourceAdapter(), a = this.GetObjectClass(), s = { propertyTrack: t, sourceAdapter: e };\n        switch (t.GetSourceAdapterId()) {\n          case \"world-instance\":\n            s.property = t.GetPropertyName();\n            break;\n          case \"instance-variable\": {\n            const r = e.GetEditorIndex();\n            s.name = a.GetInstanceVariableName(r), s.type = a.GetInstanceVariableType(r);\n            break;\n          }\n          case \"effect\": {\n            const i = a.GetEffectList(), n = e.GetEffectType(i);\n            s.effectType = n;\n            break;\n          }\n          case \"behavior\": {\n            const o = e.GetBehaviorType(a);\n            s.behaviorType = o;\n            break;\n          }\n          case \"plugin\":\n            s.plugin = a.GetPlugin();\n        }\n        yield s;\n      }\n    }\n    GetWorldInfo() {\n      if (!this._worldInfo || !this.IsInstanceValid()) {\n        const t = this.GetInstance();\n        t && (this._worldInfo = t.GetWorldInfo());\n      }\n      return this._worldInfo;\n    }\n    GetTrackDataItem() {\n      return this._trackDataItem;\n    }\n    GetInstanceUID() {\n      return isNaN(this._instanceUid) ? this._trackDataItem.GetInstanceUID() : this._instanceUid;\n    }\n    SetInstanceUID(t) {\n      this._trackDataItem.SetInstanceUID(t);\n    }\n    GetInterpolationMode() {\n      return this._trackDataItem.GetInterpolationMode();\n    }\n    SetInterpolationMode(t) {\n      this._trackDataItem.SetInterpolationMode(t);\n    }\n    GetResultMode() {\n      return this._trackDataItem.GetResultMode();\n    }\n    GetId() {\n      return this._trackDataItem.GetId();\n    }\n    GetStartOffset() {\n      return this._trackDataItem.GetStartOffset();\n    }\n    GetLocalTotalTime() {\n      return this._trackDataItem.GetLocalTotalTime();\n    }\n    SetLocalTotalTime(t) {\n      this._trackDataItem.SetLocalTotalTime(t);\n    }\n    SetResultMode(t) {\n      this._trackDataItem.SetResultMode(t);\n    }\n    SetEase(t) {\n      for (const e of this.GetKeyframeDataItems()) e.SetEase(t);\n      for (const a of this.GetPropertyTracks()) a.SetEase(t);\n    }\n    GetEnable() {\n      return this._trackDataItem.GetEnable();\n    }\n    SetEnable(t) {\n      this._trackDataItem.SetEnable(t);\n    }\n    GetObjectClassIndex() {\n      return isNaN(this._objectClassIndex) ? this._trackDataItem.GetObjectClassIndex() : this._objectClassIndex;\n    }\n    SetObjectClassIndex(t) {\n      this._trackDataItem.SetObjectClassIndex(t);\n    }\n    SetOriginalWidth(t) {\n      this._trackDataItem.SetOriginalWidth(t);\n    }\n    GetOriginalWidth() {\n      const t = this.GetInstance();\n      if (t) {\n        const e = t.GetSdkInstance();\n        if (e.IsOriginalSizeKnown()) return t.GetSdkInstance().GetOriginalWidth();\n      }\n      return this._trackDataItem.GetOriginalWidth();\n    }\n    SetOriginalHeight(t) {\n      this._trackDataItem.SetOriginalHeight(t);\n    }\n    GetOriginalHeight() {\n      const t = this.GetInstance();\n      if (t) {\n        const e = t.GetSdkInstance();\n        if (e.IsOriginalSizeKnown()) return t.GetSdkInstance().GetOriginalHeight();\n      }\n      return this._trackDataItem.GetOriginalHeight();\n    }\n    GetType() {\n      return this._trackDataItem.GetType();\n    }\n    GetName() {\n      return this._trackDataItem.GetName();\n    }\n    IsInstanceTrack() {\n      return this.GetType() === INSTANCE_TRACK;\n    }\n    IsValueTrack() {\n      return this.GetType() === VALUE_TRACK;\n    }\n    IsAudioTrack() {\n      return this.GetType() === AUDIO_TRACK;\n    }\n    GetWorldInfoChange() {\n      return this._worldInfoChange;\n    }\n    GetRenderChange() {\n      return this._renderChange;\n    }\n    GetNeedsBeforeAndAfter() {\n      return this._needsBeforeAndAfter;\n    }\n    IsNested() {\n      return this._isNested;\n    }\n    SetResetState() {\n      for (const t of this._propertyTracks) t.SetResetState();\n    }\n    SetInitialState() {\n      if (this.MaybeGetInstance(), this.IsInstanceValid() || !this.IsInstanceTrack()) {\n        const t = this.GetTimeline(), e = t.IsForwardPlayBack(), a = e ? 0 : this.GetLocalTotalTime();\n        for (const r of this._propertyTracks) r.SetInitialState(a), 0 === this._worldInfoChange && 1 === r.GetWorldInfoChange() && (this._worldInfoChange = 1), 0 === this._renderChange && 1 === r.GetRenderChange() && (this._renderChange = 1);\n        this._needsBeforeAndAfter = 0;\n        const s = this._propertyTracks.some((t2) => t2.GetNeedsBeforeAndAfter());\n        s && (this._needsBeforeAndAfter = 1), this._lastKeyframeDataItem = this._GetLastKeyFrameBeforeTime(a), this._initialStateOfNestedSet = false, this._endStateOfNestedSet = false, this.Interpolate(a), this.OnKeyframeReached(this._GetLastKeyFrameBeforeTime(a));\n      }\n    }\n    SetResumeState() {\n      if (this.MaybeGetInstance(), this.IsInstanceValid() || !this.IsInstanceTrack()) {\n        this._timeline.IsForwardPlayBack();\n        const t = this._timeline.GetTime() - this.GetStartOffset();\n        this._lastKeyframeDataItem = this._GetLastKeyFrameBeforeTime(t);\n        for (const e of this._propertyTracks) e.SetResumeState(t);\n      }\n    }\n    SetEndState() {\n      if (!this.GetTimeline().IsComplete() && (this.MaybeGetInstance(), this.IsInstanceValid() || !this.IsInstanceTrack()) && !this._isNested) {\n        const t = this._timeline.GetTime(), e = this.GetStartOffset() + this.GetLocalTotalTime();\n        e <= t ? this.Interpolate(this.GetLocalTotalTime(), true, false, true, false, false, true) : t <= 0 && this.Interpolate(0, true, false, true, false, false, true);\n      }\n    }\n    _SetUpdateState() {\n      for (let t = 0, e = this._propertyTracks.length; t < e; t++) {\n        const a = this._propertyTracks[t];\n        a._SetUpdateState(), 0 === this._worldInfoChange && 1 === a.GetWorldInfoChange() && (this._worldInfoChange = 1), 0 === this._renderChange && 1 === a.GetRenderChange() && (this._renderChange = 1);\n      }\n    }\n    BeforeInterpolate() {\n      const e = this._propertyTracks.length;\n      for (let t = 0; t < e; t++) this._propertyTracks[t].BeforeInterpolate();\n    }\n    Interpolate(a, t = false, s = false, r = false, e = false, i = false, n = false) {\n      this._instance || this.GetInstance();\n      const o = this._instance && !this._instance.IsDestroyed(), h = this._trackDataItem._type === INSTANCE_TRACK;\n      if ((o || !h) && !(i && h && this.GetObjectClass().IsGlobal() || (a -= this.GetStartOffset()) < 0)) {\n        this.MaybeSetInitialStateOfNestedTrack(a, t), this.MaybeTriggerKeyframeReachedConditions(a, t, e);\n        for (let t2 = 0, e2 = this._propertyTracks.length; t2 < e2; t2++) this._propertyTracks[t2].Interpolate(a, s, r, n);\n        this.MaybeSetEndStateOfNestedTrack(a, t), 0 !== this._worldInfoChange && (this._worldInfo || (this._worldInfo = this._instance.GetWorldInfo()), this._worldInfo) && this._worldInfo.SetBboxChanged();\n      }\n    }\n    AfterInterpolate() {\n      const e = this._propertyTracks.length;\n      for (let t = 0; t < e; t++) this._propertyTracks[t].AfterInterpolate();\n    }\n    MaybeSetInitialStateOfNestedTrack(t, e) {\n      if (e && this._isNested && !this._initialStateOfNestedSet) {\n        const a = this.GetTimeline();\n        if (a.IsForwardPlayBack()) {\n          if (t < 0) return;\n        } else if (t > this.GetLocalTotalTime()) return;\n        for (const s of this._propertyTracks) s.SetInitialState();\n        this._initialStateOfNestedSet = true;\n      }\n    }\n    MaybeSetEndStateOfNestedTrack(t, e) {\n      if (e && this._isNested && !this._endStateOfNestedSet) {\n        const a = this.GetTimeline();\n        if (a.IsForwardPlayBack()) {\n          if (t >= this.GetLocalTotalTime()) {\n            for (const s of this._propertyTracks) s.Interpolate(this.GetLocalTotalTime(), false, true);\n            this._endStateOfNestedSet = true;\n          }\n        } else if (t <= 0) {\n          for (const r of this._propertyTracks) r.Interpolate(0, false, true);\n          this._endStateOfNestedSet = true;\n        }\n      }\n    }\n    MaybeTriggerKeyframeReachedConditions(t, e, a) {\n      if (!a && e && C32.Plugins.Timeline) {\n        const s = this.GetTimeline(), r = this._lastKeyframeDataItem.GetNext(), i = this._lastKeyframeDataItem.GetTime(), n = r ? r.GetTime() : s.GetTotalTime();\n        if (t <= i || n <= t) if (this._lastKeyframeDataItem = this._trackData.GetFirstKeyFrameDataItemLowerOrEqualThan(t, this._trackDataItem), s.IsForwardPlayBack()) r && this.OnKeyframeReached(this._lastKeyframeDataItem);\n        else {\n          const r2 = this._lastKeyframeDataItem.GetNext();\n          r2 && this.OnKeyframeReached(r2);\n        }\n      }\n    }\n    _GetLastKeyFrameBeforeTime(t) {\n      const e = this._trackData.GetKeyFrameDataItemAtTime(t, this._trackDataItem);\n      return e || this._trackData.GetFirstKeyFrameDataItemLowerOrEqualThan(t, this._trackDataItem);\n    }\n    OnKeyframeReached(t) {\n      if (C32.Plugins.Timeline) {\n        const e = this.GetTimeline(), a = e.GetTimelineManager();\n        C32.Plugins.Timeline.Cnds.PushTriggerTimeline(e), C32.Plugins.Timeline.Cnds.PushTriggerKeyframe(t), a.Trigger(C32.Plugins.Timeline.Cnds.OnAnyKeyframeReached), a.Trigger(C32.Plugins.Timeline.Cnds.OnKeyframeReached), C32.Plugins.Timeline.Cnds.PopTriggerTimeline(e), C32.Plugins.Timeline.Cnds.PopTriggerKeyframe(t);\n      }\n    }\n    AddKeyframe() {\n      const t = this._trackDataItem.GetKeyframeData(), e = t.AddEmptyKeyframeDataItem();\n      return e;\n    }\n    AddPropertyTrack() {\n      const t = this._trackDataItem.GetPropertyTrackData(), e = t.AddEmptyPropertyTrackDataItem(), a = C32.PropertyTrackState.Create(this, e);\n      return this._propertyTracks.push(a), a;\n    }\n    DeleteKeyframes(t) {\n      const e = this._trackDataItem.GetKeyframeData();\n      e.DeleteKeyframeDataItems(t);\n    }\n    DeletePropertyKeyframes(t) {\n      for (const e of this._propertyTracks) e.DeletePropertyKeyframes(t);\n    }\n    SaveState() {\n      for (const t of this._propertyTracks) t.SaveState();\n    }\n    CompareInitialStateWithCurrent() {\n      if (this.MaybeGetInstance(), this.IsInstanceValid() || !this.IsInstanceTrack()) for (const t of this._propertyTracks) t.CompareInitialStateWithCurrent();\n    }\n    CompareSaveStateWithCurrent() {\n      if (this.MaybeGetInstance(), this.IsInstanceValid() || !this.IsInstanceTrack()) {\n        let t = false;\n        for (const e of this._propertyTracks) {\n          const a = e.CompareSaveStateWithCurrent();\n          !t && a && (t = true);\n        }\n        if (t) {\n          const s = this.AddKeyframe();\n          s.SetTime(this.GetTimeline().GetTime()), s.SetEase(\"noease\"), s.SetEnable(true), s.SetTags(\"\");\n        }\n      }\n    }\n    _OnAfterLoad() {\n      isNaN(this._instanceUidToLoad) || this._LoadInstanceFromJson(this._instanceUidToLoad), this._instanceUidToLoad = NaN;\n    }\n    _SaveToJson() {\n      const t = this.GetInstance(), e = t ? t.GetUID() : this.GetInstanceUID();\n      return { \"propertyTracksJson\": this._SavePropertyTracksToJson(), \"lastKeyframeDataItemJson\": this._SaveLastKeyframeDataItemToJson(), \"initialStateOfNestedSet\": this._initialStateOfNestedSet, \"endStateOfNestedSet\": this._endStateOfNestedSet, \"instanceUid\": e, \"cleared\": this._cleared };\n    }\n    _LoadFromJson(t) {\n      if (t) {\n        this._LoadPropertyTracksFromJson(t[\"propertyTracksJson\"]), this._LoadLastKeyframeDataItemFromJson(t[\"lastKeyframeDataItemJson\"]), this._instanceUidToLoad = t[\"instanceUid\"], this._initialStateOfNestedSet = false, t.hasOwnProperty[\"initialStateOfNestedSet\"] && (this._initialStateOfNestedSet = t[\"initialStateOfNestedSet\"]), this._endStateOfNestedSet = false, t.hasOwnProperty[\"endStateOfNestedSet\"] && (this._endStateOfNestedSet = t[\"endStateOfNestedSet\"]), this._cleared = !!t.hasOwnProperty(\"cleared\") && t[\"cleared\"];\n        for (const e of this._propertyTracks) 0 === this._worldInfoChange && 1 === e.GetWorldInfoChange() && (this._worldInfoChange = 1), 0 === this._renderChange && 1 === e.GetRenderChange() && (this._renderChange = 1);\n        this._needsBeforeAndAfter = 0, this._propertyTracks.some((t2) => t2.GetNeedsBeforeAndAfter()) && (this._needsBeforeAndAfter = 1);\n      }\n    }\n    _SaveLastKeyframeDataItemToJson() {\n      const t = this._trackDataItem.GetKeyframeData();\n      return t.GetKeyframeDataItemIndex(this._lastKeyframeDataItem);\n    }\n    _SavePropertyTracksToJson() {\n      return this._propertyTracks.map((t) => t._SaveToJson());\n    }\n    _LoadPropertyTracksFromJson(t) {\n      t.forEach((t2, e) => {\n        const a = this._propertyTracks[e];\n        a._LoadFromJson(t2);\n      });\n    }\n    _LoadInstanceFromJson(t) {\n      if (C32.IsFiniteNumber(t)) {\n        const e = this.GetRuntime().GetInstanceByUID(t);\n        if (e) {\n          const a = this.GetTimeline();\n          a.SetTrackInstance(this._trackDataItem.GetId(), e, this.GetTrackIndexInTimeline());\n        }\n      }\n    }\n    _LoadLastKeyframeDataItemFromJson(t) {\n      const e = this._trackDataItem.GetKeyframeData();\n      this._lastKeyframeDataItem = e.GetKeyframeDataItemFromIndex(t);\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.PropertyTrackState = class extends C32.DefendedBase {\n    constructor(e, t) {\n      super(), this._track = e, this._propertyTrackDataItem = t, this._propertyTrackData = t.GetPropertyTrackData(), this._worldInfoChange = 0, this._renderChange = 0, this._needsBeforeAndAfter = 0, this._sourceAdapter = this.GetSourceAdapter(), this._propertyKeyframeDataItems = this._propertyTrackDataItem.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray(), this._lastPropertyKeyframeDataItem = null, this._absoluteValueObject = null;\n    }\n    static Create(e, t) {\n      return C32.New(C32.PropertyTrackState, e, t);\n    }\n    Release() {\n      this._track = null, this._sourceAdapter && (this._sourceAdapter.Release(), this._sourceAdapter = null), this._propertyKeyframeDataItems = null, this._propertyTrackDataItem = null, this._propertyTrackData = null;\n    }\n    GetWorldInfoChange() {\n      return this._worldInfoChange;\n    }\n    GetRenderChange() {\n      return this._renderChange;\n    }\n    GetNeedsBeforeAndAfter() {\n      return this._needsBeforeAndAfter;\n    }\n    HasAbsoluteValueObject() {\n      return !!this._absoluteValueObject;\n    }\n    SetAbsoluteValueObject(e) {\n      this._absoluteValueObject = e;\n    }\n    GetAbsoluteValueObject() {\n      return this._absoluteValueObject;\n    }\n    GetTrack() {\n      return this._track;\n    }\n    GetPropertyTrackDataItem() {\n      return this._propertyTrackDataItem;\n    }\n    GetPropertyTrackData() {\n      return this._propertyTrackData;\n    }\n    GetTimeline() {\n      return this._track.GetTimeline();\n    }\n    GetRuntime() {\n      return this._track.GetRuntime();\n    }\n    GetInstance() {\n      return this._track.GetInstance();\n    }\n    GetSourceAdapter() {\n      if (!this._sourceAdapter) {\n        const t = this._propertyTrackDataItem.GetSourceAdapterId();\n        let e;\n        switch (t) {\n          case \"behavior\":\n            e = new C32.PropertyTrackState.BehaviorSourceAdapter(this);\n            break;\n          case \"effect\":\n            e = new C32.PropertyTrackState.EffectSourceAdapter(this), this._renderChange = 1;\n            break;\n          case \"instance-variable\":\n            e = new C32.PropertyTrackState.InstanceVariableSourceAdapter(this);\n            break;\n          case \"plugin\":\n            e = new C32.PropertyTrackState.PluginSourceAdapter(this), this._renderChange = 1;\n            break;\n          case \"world-instance\":\n            e = new C32.PropertyTrackState.PropertySourceAdapter(this), this._renderChange = 1, this._worldInfoChange = 1;\n            break;\n          case \"value\":\n            e = new C32.PropertyTrackState.ValueSourceAdapter(this);\n            break;\n          case \"audio\":\n            e = new C32.PropertyTrackState.AudioSourceAdapter(this);\n        }\n        this._sourceAdapter = e;\n      }\n      return this._sourceAdapter;\n    }\n    GetSourceAdapterId() {\n      return this._propertyTrackDataItem.GetSourceAdapterId();\n    }\n    SetSourceAdapterId(e) {\n      this._propertyTrackDataItem.SetSourceAdapterId(e);\n    }\n    GetSourceAdapterArgs() {\n      return this._propertyTrackDataItem.GetSourceAdapterArguments();\n    }\n    SetSourceAdapterArgs(e) {\n      this._propertyTrackDataItem.SetSourceAdapterArguments(e);\n    }\n    GetSourceAdapterValue() {\n      return this.GetSourceAdapter().GetValue();\n    }\n    GetPropertyName() {\n      return this._propertyTrackDataItem.GetProperty();\n    }\n    SetPropertyName(e) {\n      this._propertyTrackDataItem.SetProperty(e);\n    }\n    GetPropertyType() {\n      return this._propertyTrackDataItem.GetType();\n    }\n    SetPropertyType(e) {\n      this._propertyTrackDataItem.SetType(e);\n    }\n    GetPropertyKeyframeType() {\n      return this.GetPropertyTrackData().GetFirstPropertyKeyframeDataItem(this._propertyTrackDataItem).GetType();\n    }\n    GetMin() {\n      return this._propertyTrackDataItem.GetMin();\n    }\n    SetMin(e) {\n      this._propertyTrackDataItem.SetMin(e);\n    }\n    GetMax() {\n      return this._propertyTrackDataItem.GetMax();\n    }\n    SetMax(e) {\n      this._propertyTrackDataItem.SetMax(e);\n    }\n    GetEnable() {\n      return this._propertyTrackDataItem.GetEnable();\n    }\n    SetEnable(e) {\n      this._propertyTrackDataItem.SetEnable(e);\n    }\n    GetInterpolationMode() {\n      return this._propertyTrackDataItem.GetInterpolationMode();\n    }\n    SetInterpolationMode(e) {\n      this._propertyTrackDataItem.SetInterpolationMode(e);\n    }\n    GetResultMode() {\n      return this._propertyTrackDataItem.GetResultMode();\n    }\n    SetResultMode(e) {\n      this._propertyTrackDataItem.SetResultMode(e);\n    }\n    SetEase(e) {\n      for (const t of this.GetPropertyKeyframeDataItems()) t.SetEase(e);\n    }\n    CanHavePropertyKeyframes() {\n      return this._propertyTrackDataItem.CanHavePropertyKeyframes();\n    }\n    GetPropertyKeyframeDataItems() {\n      return this._propertyKeyframeDataItems || (this._propertyKeyframeDataItems = this._propertyTrackDataItem.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray()), this._propertyKeyframeDataItems;\n    }\n    GetPropertyKeyframeDataItemArrayIncludingDisabled() {\n      return this._propertyTrackDataItem.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArrayIncludingDisabled();\n    }\n    GetPropertyKeyFrameDataItemAtTime(e) {\n      return this._propertyTrackData.GetPropertyKeyFrameDataItemAtTime(e, this._propertyTrackDataItem);\n    }\n    GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e) {\n      return this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem);\n    }\n    GetPropertyKeyframeDataItemPairForTime(e) {\n      let t = this._propertyTrackData.GetPropertyKeyFrameDataItemAtTime(e, this._propertyTrackDataItem), r;\n      return r = t ? this._propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherThan(e, this._propertyTrackDataItem) : (t = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem), this._propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(e, this._propertyTrackDataItem)), { start: t, end: r };\n    }\n    *GetPropertyKeyframeValues() {\n      for (const e of this.GetPropertyKeyframeDataItems()) yield e.GetValueWithResultMode();\n    }\n    *GetPropertyKeyframeTimes() {\n      for (const e of this.GetPropertyKeyframeDataItems()) yield e.GetTime();\n    }\n    TimelineRemoved() {\n      this.GetSourceAdapter().TimelineRemoved();\n    }\n    CleanCaches() {\n      this.GetSourceAdapter().CleanCaches();\n    }\n    GetCurrentState() {\n      return this.GetSourceAdapter().GetCurrentState();\n    }\n    SetResetState() {\n      this.GetSourceAdapter().SetResetState();\n    }\n    SetInitialState(e) {\n      this.GetSourceAdapter().SetInitialState(), this._lastPropertyKeyframeDataItem = this._GetLastPropertyKeyFrameBeforeTime(e), this._SetUpdateState();\n    }\n    SetResumeState(e) {\n      this.GetSourceAdapter().SetResumeState(), this._lastPropertyKeyframeDataItem = this._GetLastPropertyKeyFrameBeforeTime(e);\n    }\n    _SetUpdateState() {\n      const e = this.GetTrack();\n      if (this._needsBeforeAndAfter = 0, e.IsInstanceTrack()) {\n        const t = this.GetTimeline(), r = e.GetInstance(), a = this.GetSourceAdapter(), o = this.GetPropertyName(), s = a.MayNeedBeforeAndAfterInterpolate();\n        if (s) {\n          const p = t.GetSimilarPropertyTracks(r, a, o, this);\n          p && p.length && (this._needsBeforeAndAfter = 1);\n        } else this._needsBeforeAndAfter = 0;\n      }\n    }\n    _GetLastPropertyKeyFrameBeforeTime(e) {\n      const t = this.GetTimeline(), r = this._propertyTrackData.GetPropertyKeyFrameDataItemAtTime(e, this._propertyTrackDataItem);\n      return r || (t.IsForwardPlayBack() ? this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem) : this._propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(e, this._propertyTrackDataItem));\n    }\n    BeforeInterpolate() {\n      this._sourceAdapter.BeforeInterpolate();\n    }\n    Interpolate(e, t = false, r = false, a = false) {\n      let o, s, p = false;\n      if (t) o = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem);\n      else {\n        if (this._lastPropertyKeyframeDataItem) {\n          const i = this.GetTimeline(), y = this._lastPropertyKeyframeDataItem.GetNext(), m = this._lastPropertyKeyframeDataItem.GetTime(), n = y ? y.GetTime() : i.GetTotalTime();\n          (e <= m || n <= e) && (this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem), p = true);\n        } else this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem), p = true;\n        o = this._lastPropertyKeyframeDataItem;\n      }\n      o && (s = o.GetNext()), this._sourceAdapter.Interpolate(e, o, s, t, r, a, p);\n    }\n    GetInterpolatedValue(e) {\n      if (this._lastPropertyKeyframeDataItem) {\n        const a = this.GetTimeline(), o = this._lastPropertyKeyframeDataItem.GetNext(), s = this._lastPropertyKeyframeDataItem.GetTime(), p = o ? o.GetTime() : a.GetTotalTime();\n        (e <= s || p <= e) && (this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem));\n      } else this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem);\n      const t = this._lastPropertyKeyframeDataItem, r = t.GetNext();\n      return this._sourceAdapter.GetInterpolatedValue(e, t, r);\n    }\n    GetInterpolatedValueFast(e, t, r) {\n      return this._sourceAdapter.GetInterpolatedValue(e, t, r);\n    }\n    AfterInterpolate() {\n      this._sourceAdapter.AfterInterpolate();\n    }\n    static GetStartPropertyKeyframeForTime(e, t) {\n      const r = t.GetPropertyTrackDataItem(), a = t._propertyTrackData;\n      return a.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, r);\n    }\n    static GetEndPropertyKeyframeForTime(e, t) {\n      const r = t.GetPropertyTrackDataItem(), a = t._propertyTrackData;\n      return a.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(e, r);\n    }\n    AddPropertyKeyframe() {\n      const e = this._propertyTrackDataItem.GetPropertyKeyframeData(), t = e.AddEmptyPropertyKeyframeDataItem();\n      return this._lastPropertyKeyframeDataItem = null, t;\n    }\n    DeletePropertyKeyframes(e) {\n      this._lastPropertyKeyframeDataItem = null;\n      const t = this._propertyTrackDataItem.GetPropertyKeyframeData();\n      t.DeletePropertyKeyframeDataItems(e);\n    }\n    SaveState() {\n      this.GetSourceAdapter().SaveState();\n    }\n    CompareInitialStateWithCurrent() {\n      const e = this.GetSourceAdapter().CompareInitialStateWithCurrent();\n      if (e) {\n        const t = this._propertyTrackData.GetFirstPropertyKeyframeDataItem(this._propertyTrackDataItem), r = this.GetSourceAdapter().GetCurrentState();\n        t.SetAbsoluteValue(r);\n      }\n    }\n    CompareSaveStateWithCurrent() {\n      const e = this.GetSourceAdapter().CompareSaveStateWithCurrent();\n      return e && this.AddPropertyKeyframeAtCurrentTime(), this.GetSourceAdapter().ClearSaveState(), e;\n    }\n    AddPropertyKeyframeAtCurrentTime() {\n      const e = this.GetTimeline().GetTime(), t = this.GetSourceAdapter(), r = C32.PropertyTrackState.GetStartPropertyKeyframeForTime(e, this), a = this.AddPropertyKeyframe();\n      a.SetType(r.GetType()), a.SetTime(e), a.SetEase(r.GetEase()), a.SetEnable(true), a.SetValue(t.GetValueAtTime()), a.SetAbsoluteValue(t.GetCurrentState());\n    }\n    _SaveToJson() {\n      return { \"sourceAdapterJson\": this.GetSourceAdapter()._SaveToJson() };\n    }\n    _LoadFromJson(e) {\n      e && this.GetSourceAdapter()._LoadFromJson(e[\"sourceAdapterJson\"]);\n    }\n  };\n}\n{\n  const C32 = self.C3, NS = C32.PropertyTrackState;\n  NS.PropertySourceAdapter = class {\n    constructor(e) {\n      this._propertyTrack = e, this._propertyAdapter = null, this.GetPropertyAdapter();\n    }\n    Release() {\n      this._propertyAdapter && (this._propertyAdapter.Release(), this._propertyAdapter = null), this._propertyTrack = null;\n    }\n    MayNeedBeforeAndAfterInterpolate() {\n      return this._propertyAdapter.MayNeedBeforeAndAfterInterpolate();\n    }\n    GetPropertyTrack() {\n      return this._propertyTrack;\n    }\n    TimelineRemoved() {\n      this._propertyAdapter && this._propertyAdapter.TimelineRemoved();\n    }\n    CleanCaches() {\n      this._propertyAdapter && this._propertyAdapter.CleanCaches();\n    }\n    GetPropertyAdapter() {\n      return this._propertyAdapter || (this._propertyAdapter = this._CreatePropertyAdapter()), this._propertyAdapter;\n    }\n    GetEditorIndex() {\n    }\n    GetIndex() {\n      return this.GetEditorIndex();\n    }\n    GetTarget() {\n    }\n    SetResetState() {\n      this.GetPropertyAdapter().SetResetState();\n    }\n    SetInitialState() {\n      this.GetPropertyAdapter().SetInitialState();\n    }\n    SetResumeState() {\n      this.GetPropertyAdapter().SetResumeState();\n    }\n    BeforeInterpolate() {\n      this._propertyAdapter.BeforeChangeProperty();\n    }\n    Interpolate(e, t, r, p, a, o, n) {\n      const s = this._propertyTrack.GetPropertyKeyframeType();\n      let i;\n      switch (s) {\n        case \"numeric\":\n          i = NS.NumericTypeAdapter.Interpolate(e, t, r, this._propertyTrack);\n          break;\n        case \"angle\":\n          i = NS.AngleTypeAdapter.Interpolate(e, t, r, this._propertyTrack);\n          break;\n        case \"boolean\":\n          i = NS.BooleanTypeAdapter.Interpolate(e, t, r, this._propertyTrack);\n          break;\n        case \"color\":\n          i = NS.ColorTypeAdapter.Interpolate(e, t, r, this._propertyTrack);\n          break;\n        case \"text\":\n          i = NS.TextTypeAdapter.Interpolate(e, t, r, this._propertyTrack);\n      }\n      this._propertyAdapter.ChangeProperty(e, i, t, r, p, a, o, n);\n    }\n    GetInterpolatedValue(e, t, r) {\n      switch (this._propertyTrack.GetPropertyKeyframeType()) {\n        case \"numeric\":\n          return NS.NumericTypeAdapter.Interpolate(e, t, r, this._propertyTrack);\n        case \"angle\":\n          return NS.AngleTypeAdapter.Interpolate(e, t, r, this._propertyTrack);\n        case \"boolean\":\n          return NS.BooleanTypeAdapter.Interpolate(e, t, r, this._propertyTrack);\n        case \"color\":\n          return NS.ColorTypeAdapter.Interpolate(e, t, r, this._propertyTrack);\n        case \"text\":\n          return NS.TextTypeAdapter.Interpolate(e, t, r, this._propertyTrack);\n      }\n    }\n    AfterInterpolate() {\n      this._propertyAdapter.AfterChangeProperty();\n    }\n    SaveState() {\n      this.GetPropertyAdapter().SetSaveState();\n    }\n    ClearSaveState() {\n      this.GetPropertyAdapter().ClearSaveState();\n    }\n    GetCurrentState() {\n      return this.GetPropertyAdapter().GetCurrentState();\n    }\n    CompareInitialStateWithCurrent() {\n      return this.GetPropertyAdapter().CompareInitialStateWithCurrent();\n    }\n    CompareSaveStateWithCurrent() {\n      return this.GetPropertyAdapter().CompareSaveStateWithCurrent();\n    }\n    GetValueAtTime() {\n      const e = this._propertyTrack, t = e.GetTrack(), r = t.GetTimeline().GetTime(), p = NS.GetStartPropertyKeyframeForTime(r, e), a = p.GetNext(), o = e.GetPropertyKeyframeType();\n      switch (o) {\n        case \"numeric\":\n          return NS.NumericTypeAdapter.Interpolate(r, p, a, e);\n        case \"angle\":\n          return NS.AngleTypeAdapter.Interpolate(r, p, a, e);\n        case \"boolean\":\n          return NS.BooleanTypeAdapter.Interpolate(r, p, a, e);\n        case \"color\":\n          return NS.ColorTypeAdapter.Interpolate(r, p, a, e);\n        case \"text\":\n          return NS.TextTypeAdapter.Interpolate(r, p, a, e);\n      }\n    }\n    _CreatePropertyAdapter() {\n      const e = this._propertyTrack, t = e.CanHavePropertyKeyframes() ? e.GetPropertyKeyframeType() : \"\";\n      switch (t) {\n        case \"combo\":\n        case \"boolean\":\n        case \"text\":\n        case \"string\":\n          return new NS.PropertyInterpolationAdapter.NoInterpolationAdapter(this);\n        case \"numeric\":\n        case \"number\":\n        case \"angle\":\n          return new (\"combo\" === this._propertyTrack.GetPropertyType() ? NS.PropertyInterpolationAdapter.NoInterpolationAdapter : NS.PropertyInterpolationAdapter.NumericInterpolationAdapter)(this);\n        case \"color\":\n        case \"offsetColor\":\n          return new NS.PropertyInterpolationAdapter.ColorInterpolationAdapter(this);\n        default:\n          return new NS.PropertyInterpolationAdapter.NumericInterpolationAdapter(this);\n      }\n    }\n    _SaveToJson() {\n      return { \"propertyAdapterJson\": this.GetPropertyAdapter()._SaveToJson() };\n    }\n    _LoadFromJson(e) {\n      e && this.GetPropertyAdapter()._LoadFromJson(e[\"propertyAdapterJson\"]);\n    }\n  };\n}\n{\n  const C32 = self.C3, INDEX = 0;\n  class InstanceVariableSourceAdapter extends C32.PropertyTrackState.PropertySourceAdapter {\n    constructor(e) {\n      super(e), this._updatedIndex = NaN;\n    }\n    GetEditorIndex() {\n      return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[INDEX];\n    }\n    GetIndex() {\n      return this._updatedIndex || super.GetIndex();\n    }\n    GetTarget() {\n      return this._propertyTrack.GetTrack().GetInstance();\n    }\n    UpdateInstanceVariableIndex(e) {\n      const t = this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[INDEX];\n      t !== e && (this._updatedIndex = e);\n    }\n    Interpolate(e, t, r, a, n, p, d) {\n      this.GetPropertyAdapter().CanChange(t.GetValue()) && super.Interpolate(e, t, r, a, n, p, d);\n    }\n    GetInterpolatedValue(e, t, r) {\n      if (this.GetPropertyAdapter().CanChange(t.GetValue())) return super.GetInterpolatedValue(e, t, r);\n    }\n    _SaveToJson() {\n      return Object.assign(super._SaveToJson(), { \"index\": this._updatedIndex });\n    }\n    _LoadFromJson(e) {\n      e && (super._LoadFromJson(e), this._updatedIndex = e[\"index\"]);\n    }\n  }\n  C32.PropertyTrackState.InstanceVariableSourceAdapter = InstanceVariableSourceAdapter;\n}\n{\n  const C32 = self.C3, SID = 0, INDEX = 1, NAME = 2;\n  class BehaviorSourceAdapter extends C32.PropertyTrackState.PropertySourceAdapter {\n    constructor(e) {\n      super(e), this._sid = NaN;\n    }\n    GetEditorIndex() {\n      const e = this._propertyTrack.GetPropertyTrackDataItem();\n      return e.GetSourceAdapterArguments()[INDEX];\n    }\n    GetTarget() {\n      const e = this._propertyTrack.GetPropertyTrackDataItem(), t = this._propertyTrack.GetTrack(), r = this._sid || e.GetSourceAdapterArguments()[SID], a = t.GetInstance(), s = a.GetBehaviorIndexBySID(r), o = a.GetBehaviorInstances()[s];\n      return o.GetSdkInstance();\n    }\n    GetBehaviorType(e) {\n      const t = this._propertyTrack.GetPropertyTrackDataItem(), r = t.GetSourceAdapterArguments()[NAME];\n      return e.GetBehaviorTypeByName(r);\n    }\n    UpdateBehaviorTypeSid(e) {\n      const t = this._propertyTrack.GetPropertyTrackDataItem();\n      t.GetSourceAdapterArguments()[SID] !== e && (this._sid = e);\n    }\n    Interpolate(e, t, r, a, s, o, p) {\n      const c = this._propertyTrack.GetTrack(), n = c.GetInstance();\n      this.GetBehaviorType(n.GetObjectClass()) && super.Interpolate(e, t, r, a, s, o, p);\n    }\n    GetInterpolatedValue(e, t, r) {\n      const a = this._propertyTrack.GetTrack(), s = a.GetInstance();\n      if (this.GetBehaviorType(s.GetObjectClass())) return super.GetInterpolatedValue(e, t, r);\n    }\n    _SaveToJson() {\n      return Object.assign(super._SaveToJson(), { \"sid\": this._sid });\n    }\n    _LoadFromJson(e) {\n      e && (super._LoadFromJson(e), this._sid = e[\"sid\"]);\n    }\n  }\n  C32.PropertyTrackState.BehaviorSourceAdapter = BehaviorSourceAdapter;\n}\n{\n  const C32 = self.C3, NAME = 0, INDEX = 1;\n  class EffectSourceAdapter extends C32.PropertyTrackState.PropertySourceAdapter {\n    constructor(e) {\n      super(e);\n    }\n    GetEditorIndex() {\n      return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[INDEX];\n    }\n    GetTarget() {\n      const e = this._propertyTrack, t = e.GetTrack(), r = t.GetWorldInfo(), c = r.GetInstanceEffectList(), f = c.GetEffectList(), a = this.GetEffectType(f), s = a.GetIndex();\n      return c.IsEffectIndexActive(s) ? c.GetEffectParametersForIndex(s) : null;\n    }\n    GetEffectType(e) {\n      const t = this._propertyTrack, r = t.GetPropertyTrackDataItem().GetSourceAdapterArguments()[NAME];\n      return e.GetEffectTypeByName(r);\n    }\n    Interpolate(e, t, r, c, f, a, s) {\n      this._IsEffectActive() && super.Interpolate(e, t, r, c, f, a, s);\n    }\n    GetInterpolatedValue(e, t, r) {\n      if (this._IsEffectActive()) return super.GetInterpolatedValue(e, t, r);\n    }\n    _IsEffectActive() {\n      const e = this._propertyTrack, t = e.GetTrack(), r = t.GetWorldInfo(), c = r.GetInstanceEffectList(), f = c.GetEffectList(), a = this.GetEffectType(f);\n      if (a) {\n        const s = a.GetIndex();\n        return c.IsEffectIndexActive(s);\n      }\n    }\n  }\n  C32.PropertyTrackState.EffectSourceAdapter = EffectSourceAdapter;\n}\n{\n  const C32 = self.C3, INDEX = 0;\n  class PluginSourceAdapter extends C32.PropertyTrackState.PropertySourceAdapter {\n    constructor(t) {\n      super(t);\n    }\n    GetEditorIndex() {\n      return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[INDEX];\n    }\n    GetTarget() {\n      return this._propertyTrack.GetTrack().GetInstance().GetSdkInstance();\n    }\n    Interpolate(t, e, r, a, s, n, c) {\n      const p = this._propertyTrack.GetTrack(), i = p.GetObjectClass().GetPlugin(), o = p.GetInstance().GetObjectClass().GetPlugin();\n      i === o && super.Interpolate(t, e, r, a, s, n, c);\n    }\n    GetInterpolatedValue(t, e, r) {\n      const a = this._propertyTrack.GetTrack(), s = a.GetObjectClass().GetPlugin(), n = a.GetInstance().GetObjectClass().GetPlugin();\n      if (s === n) return super.GetInterpolatedValue(t, e, r);\n    }\n    GetOptionalCallbacks() {\n      const t = this._propertyTrack.GetTrack(), e = t.GetObjectClass().GetPlugin();\n      if (C32.Plugins.Sprite && e instanceof C32.Plugins.Sprite && (\"initial-frame\" === this._propertyTrack.GetPropertyName() || \"initial-animation\" === this._propertyTrack.GetPropertyName())) switch (this._propertyTrack.GetResultMode()) {\n        case \"relative\":\n        case \"absolute\":\n          return null;\n      }\n    }\n  }\n  C32.PropertyTrackState.PluginSourceAdapter = PluginSourceAdapter;\n}\n{\n  const C32 = self.C3;\n  class ValueSourceAdapter extends C32.PropertyTrackState.PropertySourceAdapter {\n    constructor(t) {\n      super(t), this._value = 0, this._init = false;\n    }\n    MayNeedBeforeAndAfterInterpolate() {\n      return false;\n    }\n    SetInitialState() {\n      const t = this._propertyTrack.GetPropertyTrackData();\n      let e = this._propertyTrack.GetPropertyTrackDataItem();\n      e = t.GetFirstPropertyKeyframeDataItem(e), this._value = e.GetValueWithResultMode();\n    }\n    SetResumeState() {\n    }\n    GetValue() {\n      return this._init || this._propertyTrack.Interpolate(0), this._value;\n    }\n    Interpolate(t, e, r, a, i, o, u) {\n      this._value = C32.PropertyTrackState.NumericTypeAdapter.Interpolate(t, e, r, this._propertyTrack), this._init = true;\n    }\n    SaveState() {\n    }\n    ClearSaveState() {\n    }\n    GetCurrentState() {\n      return this._value;\n    }\n    CompareInitialStateWithCurrent() {\n      return false;\n    }\n    CompareSaveStateWithCurrent() {\n      return false;\n    }\n    _SaveToJson() {\n      return { \"value\": this._value, \"init\": this._init };\n    }\n    _LoadFromJson(t) {\n      t && (this._value = t[\"value\"], this._init = !t.hasOwnProperty(\"init\") || t[\"init\"]);\n    }\n  }\n  C32.PropertyTrackState.ValueSourceAdapter = ValueSourceAdapter;\n}\n{\n  const C32 = self.C3, PROJECT_FILE = 0, PROJECT_FILE_NAME = 0, PROJECT_FILE_TYPE = 1, START_OFFSET = 1, AUDIO_DURATION = 2, AUDIO_TAG = 3;\n  class AudioSourceAdapter extends C32.PropertyTrackState.PropertySourceAdapter {\n    constructor(t) {\n      super(t), this._audioPlaybackStarted = false, this._sdkInstance = null, this._actions = null, this._expressions = null, this._timeline = this._propertyTrack.GetTimeline(), this._track = this._propertyTrack.GetTrack(), this._sourceAdapterArgs = this._propertyTrack.GetSourceAdapterArgs(), this._fileArgs = this._sourceAdapterArgs[PROJECT_FILE], this._startOffsetTime = this._sourceAdapterArgs[START_OFFSET], this._sourceAdapterArgs[AUDIO_TAG] ? this._audioTag = this._sourceAdapterArgs[AUDIO_TAG] : this._audioTag = Math.random().toString(36).slice(2), this._pauseTime = NaN, this._pauseVolume = NaN, this._volume = NaN, this._audioSource = null, this._Initialize();\n    }\n    Release() {\n      super.Release(), this._sdkInstance = null, this._actions = null, this._expressions = null, this._timeline = null, this._track = null, this._sourceAdapterArgs = null, this._fileArgs = null, this._audioSource = null;\n    }\n    _Initialize() {\n      if (self.C3.Plugins.Audio) {\n        const t = this._propertyTrack.GetRuntime(), e = t.GetSingleGlobalObjectClassByCtor(self.C3.Plugins.Audio);\n        e && (this._sdkInstance = e.GetSingleGlobalInstance().GetSdkInstance()), this._actions = self.C3.Plugins.Audio.Acts, this._expressions = self.C3.Plugins.Audio.Exps;\n      }\n    }\n    _MaybeSetAudioSource() {\n      if (!this._audioSource) {\n        const t = this._propertyTrack.GetTrack(), e = t.GetPropertyTrack(\"audioSource\");\n        e && (this._audioSource = e.GetSourceAdapter());\n      }\n    }\n    _GetPauseVolume() {\n      const t = this._propertyTrack.GetTrack(), e = t.GetPropertyTrack(\"volume\");\n      return (e ? e.GetSourceAdapter() : this)._pauseVolume;\n    }\n    TimelineRemoved() {\n      super.TimelineRemoved(), this._audioPlaybackStarted = false, this._sdkInstance && (this._expressions && (this._pauseTime = this._expressions.PlaybackTime.call(this._sdkInstance, this._audioTag), this._pauseVolume = this._expressions.Volume.call(this._sdkInstance, this._audioTag)), this._actions) && this._actions.Stop.call(this._sdkInstance, this._audioTag);\n    }\n    GetAudioTag() {\n      return this._audioTag;\n    }\n    GetVolume() {\n      return this._volume;\n    }\n    SetVolume(t) {\n      this._volume = t;\n    }\n    SetInitialState() {\n      super.SetInitialState(), this._pauseTime = NaN, this._audioPlaybackStarted = false;\n    }\n    SetResumeState() {\n      super.SetResumeState();\n      const t = this._propertyTrack.GetTimeline(), e = t.GetTime();\n      switch (this._pauseTime = e - this._startOffsetTime, this._propertyTrack.GetPropertyName()) {\n        case \"audioSource\":\n          break;\n        case \"volume\":\n          this._pauseVolume = this._propertyTrack.GetInterpolatedValue(e);\n      }\n      this._audioPlaybackStarted = false;\n    }\n    Interpolate(t, e, s, i, a, o, r) {\n      if (this._sdkInstance) switch (this._propertyTrack.GetPropertyName()) {\n        case \"audioSource\": {\n          if (!this._timeline.IsForwardPlayBack()) return;\n          if (i) return void (this._actions && this._actions.Stop.call(this._sdkInstance, this._audioTag));\n          if (t < this._startOffsetTime) return void (this._audioPlaybackStarted = false);\n          const u = this._expressions.PlaybackRate.call(this._sdkInstance, this._audioTag), _ = this._timeline.GetPlaybackRate();\n          if (_ !== u && this._actions.SetPlaybackRate.call(this._sdkInstance, this._audioTag, _), this._audioPlaybackStarted) return;\n          if (!this._propertyTrack.GetTimeline().IsPlaying()) return;\n          if (this._audioPlaybackStarted = true, isNaN(this._pauseTime)) {\n            const l = self[\"performance\"].now(), h = t - this._startOffsetTime, c = this._sdkInstance.GetAudioContextState();\n            if (\"suspended\" === c) return void (this._audioPlaybackStarted = false);\n            const n = self[\"performance\"].now(), d = (n - l) / 1e3, p = h + d;\n            if (this._actions) {\n              let t2 = this.GetVolume();\n              isNaN(t2) ? (this.SetVolume(0), t2 = 0) : this.SetVolume(t2), this._actions.PlayFromTimeline.call(this._sdkInstance, this._fileArgs, t2, this._audioTag, p);\n            }\n          } else {\n            const S = this._pauseTime, m = (this._pauseTime = NaN, this._GetPauseVolume()), T = (this._pauseVolume = NaN, this._sdkInstance.GetAudioContextState());\n            if (\"suspended\" === T) return void (this._audioPlaybackStarted = false);\n            this._actions && (this.SetVolume(m), this._actions.PlayFromTimeline.call(this._sdkInstance, this._fileArgs, m, this._audioTag, S));\n          }\n          break;\n        }\n        case \"volume\":\n          this._MaybeSetAudioSource(), super.Interpolate(t, e, s, i, a, o, r);\n      }\n    }\n    GetInterpolatedValue(t, e, s) {\n      if (this._sdkInstance) switch (this._propertyTrack.GetPropertyName()) {\n        case \"audioSource\":\n          return;\n        case \"volume\":\n          return this._MaybeSetAudioSource(), super.GetInterpolatedValue(t, e, s);\n      }\n    }\n    Getter(t, e) {\n      return this._audioSource ? this._audioSource.GetVolume() : 0;\n    }\n    Setter(t, e, s, i) {\n      this._audioSource && this._audioSource.SetVolume(this.Getter() + e), this._actions && this._audioSource && this._actions.SetVolume.call(this._sdkInstance, this._audioSource.GetAudioTag(), this._audioSource.GetVolume());\n    }\n    AbsoluteSetter(t, e, s) {\n      this._audioSource && this._audioSource.SetVolume(e), this._actions && this._audioSource && this._actions.SetVolume.call(this._sdkInstance, this._audioSource.GetAudioTag(), this._audioSource.GetVolume());\n    }\n    DoesRounding() {\n      return true;\n    }\n    _SaveToJson() {\n      return { \"audioPlaybackStarted\": this._audioPlaybackStarted, \"audioTag\": this._audioTag, \"pauseTime\": this._pauseTime, \"pauseVolume\": this._pauseVolume, \"volume\": this._volume };\n    }\n    _LoadFromJson(t) {\n      t && (this._audioPlaybackStarted = t[\"audioPlaybackStarted\"], this._audioTag = t[\"audioTag\"], this._pauseTime = t[\"pauseTime\"], this._pauseVolume = t[\"pauseVolume\"], this._volume = t[\"volume\"], this._Initialize());\n    }\n  }\n  C32.PropertyTrackState.AudioSourceAdapter = AudioSourceAdapter;\n}\n{\n  const C32 = self.C3;\n  C32.PropertyTrackState.PropertyInterpolationAdapter = class {\n    constructor(t) {\n      this._sourceAdapter = t, this._propertyTrack = t.GetPropertyTrack(), this._worldInfo = this._propertyTrack.GetTrack().GetWorldInfo(), this._property = this._propertyTrack.GetPropertyName(), this._firstAbsoluteUpdate = false, this._saveState = null, this._target = null;\n    }\n    Release() {\n      this._sourceAdapter = null, this._propertyTrack = null, this._worldInfo = null, this._saveState = null, this._target = null;\n    }\n    MayNeedBeforeAndAfterInterpolate() {\n      return false;\n    }\n    TimelineRemoved() {\n    }\n    CleanCaches() {\n      this._worldInfo = null, this._saveState = null, this._target = null;\n    }\n    GetSourceAdapter() {\n      return this._sourceAdapter;\n    }\n    GetPropertyTrack() {\n      return this._propertyTrack;\n    }\n    GetWorldInfo() {\n      return this._worldInfo || (this._worldInfo = this._propertyTrack.GetTrack().GetWorldInfo()), this._worldInfo;\n    }\n    SetFirstAbsoluteUpdate(t) {\n      this._firstAbsoluteUpdate = !!t;\n    }\n    GetFirstAbsoluteUpdate() {\n      return this._firstAbsoluteUpdate;\n    }\n    SetResetState() {\n    }\n    SetInitialState() {\n    }\n    SetResumeState() {\n    }\n    SetSaveState() {\n      this._saveState = this.GetCurrentState();\n    }\n    ClearSaveState() {\n      this._saveState = null;\n    }\n    GetCurrentState() {\n    }\n    CompareInitialStateWithCurrent() {\n    }\n    CompareSaveStateWithCurrent() {\n    }\n    CanChange(t) {\n      const e = typeof this._Getter(), r = typeof t;\n      return e == r;\n    }\n    BeforeChangeProperty() {\n    }\n    ChangeProperty(t, e, r, a, s, o, i, n) {\n    }\n    AfterChangeProperty() {\n    }\n    _FirstKeyframeGetter() {\n      const t = this._PickTimelinePlaybackMode(() => {\n        const t2 = this._propertyTrack.GetPropertyTrackDataItem(), e = this._propertyTrack.GetPropertyTrackData();\n        return e.GetFirstPropertyKeyframeDataItem(t2);\n      }, () => {\n        const t2 = this._propertyTrack.GetPropertyTrackDataItem(), e = this._propertyTrack.GetPropertyTrackData();\n        return e.GetLastPropertyKeyframeDataItem(t2);\n      });\n      return t.GetAbsoluteValue();\n    }\n    _CurrentKeyframeGetter() {\n      const t = this._propertyTrack.GetTimeline(), a = t.GetTime() - this._propertyTrack.GetTrack().GetStartOffset(), e = this._PickTimelinePlaybackMode(() => {\n        const t2 = this._propertyTrack.GetPropertyTrackDataItem(), e2 = this._propertyTrack.GetPropertyTrackData();\n        return e2.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, t2);\n      }, () => {\n        const t2 = this._propertyTrack.GetPropertyTrackDataItem(), e2 = this._propertyTrack.GetPropertyTrackData(), r = e2.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(a, t2);\n        return r || e2.GetLastPropertyKeyframeDataItem(t2);\n      });\n      return e.GetAbsoluteValue();\n    }\n    _PickTimelinePlaybackMode(t, e) {\n      const r = this._propertyTrack.GetTimeline();\n      return (r.IsForwardPlayBack() ? t : e)();\n    }\n    _PickResultMode(t, e) {\n      const r = this._propertyTrack.GetResultMode();\n      return (\"relative\" === r ? t : e)();\n    }\n    _PickFirstAbsoluteUpdate(t, e) {\n      return (this.GetFirstAbsoluteUpdate() ? (this.SetFirstAbsoluteUpdate(false), t) : e)();\n    }\n    _GetAbsoluteInitialValue(t) {\n    }\n    _GetIndex() {\n      return this._sourceAdapter.GetIndex();\n    }\n    _GetTarget() {\n      return this._target || (this._target = this._sourceAdapter.GetTarget()), this._target;\n    }\n    _PickSource(t, e, r, a, s, o) {\n      const i = this._propertyTrack.GetSourceAdapterId();\n      switch (i) {\n        case \"behavior\":\n          return t();\n        case \"effect\":\n          return e();\n        case \"instance-variable\":\n          return r();\n        case \"plugin\":\n          return a();\n        case \"world-instance\":\n          return s();\n        case \"audio\":\n          return o();\n      }\n    }\n    _SaveToJson() {\n      return { \"firstAbsoluteUpdate\": this._firstAbsoluteUpdate, \"saveState\": this._saveState };\n    }\n    _LoadFromJson(t) {\n      t && (this._firstAbsoluteUpdate = t[\"firstAbsoluteUpdate\"], this._saveState = t[\"saveState\"]);\n    }\n    _GetPropertyKeyframeStubs(t, e = false) {\n      const r = [];\n      for (const a of t) {\n        const s = a.GetTrack().GetStartOffset();\n        for (const o of a.GetPropertyKeyframeDataItems()) (!e || 0 !== o.GetTime()) && e || r.push({ time: s + o.GetTime(), value: o.GetAbsoluteValue() });\n      }\n      return r.sort((t2, e2) => t2.time - e2.time);\n    }\n    _GetLastPropertyKeyframeStub(t, e, r) {\n      return this._GetPropertyKeyframeStubLowerThanPlayhead(e, r);\n    }\n    _GetPropertyKeyframeStubLowerThanPlayhead(e, r) {\n      for (let t = r.length - 1; 0 <= t; t--) {\n        const a = r[t].time;\n        if (a <= e) return r[t];\n      }\n      return null;\n    }\n  };\n}\n{\n  const C32 = self.C3, TMP_COLORS_MAP = /* @__PURE__ */ new Map(), TMP_COLOR = [0, 0, 0];\n  class ColorInterpolationAdapter extends C32.PropertyTrackState.PropertyInterpolationAdapter {\n    constructor(e) {\n      super(e);\n    }\n    SetResetState() {\n    }\n    SetInitialState() {\n    }\n    SetResumeState() {\n    }\n    GetCurrentState() {\n      const e = this._propertyTrack.GetSourceAdapterId(), t = this._GetTarget(), r = this._GetIndex();\n      switch (e) {\n        case \"behavior\":\n          return this._ToColorArray(t.GetPropertyValueByIndex(r));\n        case \"effect\":\n          return this._ToColorArray(t[r]);\n        case \"plugin\":\n          return this._ToColorArray(t.GetPropertyValueByIndex(r));\n        case \"world-instance\":\n          return this._ToColorArray(this._Getter());\n      }\n    }\n    CompareInitialStateWithCurrent() {\n      const e = this._FirstKeyframeGetter();\n      return !this._CompareColors(e, this._Getter());\n    }\n    CompareSaveStateWithCurrent() {\n      return !C32.IsNullOrUndefined(this._saveState) && !this._CompareColors(this._saveState, this._Getter());\n    }\n    _CompareColors(e, t) {\n      return e = this._GetColorFromArray(e), t = this._GetColorFromArray(t), e.equalsIgnoringAlpha(t);\n    }\n    _FirstKeyframeGetter() {\n      const e = super._FirstKeyframeGetter();\n      return this._GetColorFromArray(e);\n    }\n    _CurrentKeyframeGetter() {\n      const e = super._CurrentKeyframeGetter();\n      return this._GetColorFromArray(e);\n    }\n    _GetAbsoluteInitialValue(e) {\n    }\n    _ToColorArray(e) {\n      return (C32.IsInstanceOf(e, C32.Color) ? e.toArray() : e).slice(0, 3);\n    }\n    _GetColorFromArray(e) {\n      return C32.IsInstanceOf(e, C32.Color) ? e : new C32.Color(e[0], e[1], e[2], 1);\n    }\n    CanChange(e) {\n      return true;\n    }\n    MayNeedBeforeAndAfterInterpolate() {\n      return true;\n    }\n    BeforeChangeProperty() {\n      const e = this._propertyTrack.GetTimeline(), t = this._propertyTrack.GetInstance(), r = this._propertyTrack.GetSourceAdapter(), o = e.GetSimilarPropertyTracks(t, r, this._property, this._propertyTrack);\n      if (o && 1 < o.length) {\n        TMP_COLORS_MAP.has(t) || TMP_COLORS_MAP.set(t, /* @__PURE__ */ new Map());\n        const a = TMP_COLORS_MAP.get(t), s = this._propertyTrack.GetSourceAdapterId(), n = (a.has(s) || a.set(s, /* @__PURE__ */ new Map()), a.get(s));\n        n.has(this._property) || n.set(this._property, { used: false, color: new C32.Color(0, 0, 0, 1) });\n      }\n    }\n    _GetTmpColor(e, t, r) {\n      const o = TMP_COLORS_MAP.get(e).get(t).get(r);\n      return o.used = true, o.color;\n    }\n    ChangeProperty(e, t, r, o, a, s, n, i) {\n      const p = this._propertyTrack.GetTimeline(), _ = this._propertyTrack.GetTrack(), l = this._propertyTrack.GetInstance(), c = this._propertyTrack.GetSourceAdapter(), h = this._propertyTrack.GetSourceAdapterId(), C = this._property, y = p.GetSimilarPropertyTracks(l, c, C, this._propertyTrack);\n      if (y && 1 < y.length) {\n        const u = this._GetPropertyKeyframeStubs(y, true), G = this._GetLastPropertyKeyframeStub(p, p.GetTime(), u);\n        if (G) {\n          const T = _.GetStartOffset(), d = G.time - T;\n          if (0 == d) this._GetTmpColor(l, h, this._property).addRgb(t[0], t[1], t[2]);\n          else if (!(d < 0)) {\n            const P = t[0], S = t[1], f = t[2], A = this._propertyTrack.Interpolate(d, false, true), O = C32.Color.DiffChannel(P, A[0]), I = C32.Color.DiffChannel(S, A[1]), m = C32.Color.DiffChannel(f, A[2]);\n            this._GetTmpColor(l, h, this._property).addRgb(O, I, m);\n          }\n        }\n      } else this._Setter(t[0], t[1], t[2]);\n    }\n    AfterChangeProperty() {\n      const e = this._propertyTrack.GetInstance();\n      if (TMP_COLORS_MAP.has(e)) {\n        const t = TMP_COLORS_MAP.get(e), r = this._propertyTrack.GetSourceAdapterId();\n        if (t.has(r)) {\n          const o = t.get(r);\n          if (o.has(this._property)) {\n            const a = o.get(this._property), s = a.used, n = a.color;\n            s && this._Setter(n.getR(), n.getG(), n.getB()), 0 === o.size && t.delete(r), 0 === t.size && TMP_COLORS_MAP.delete(e);\n          }\n        }\n      }\n    }\n    _Getter() {\n      const e = this._propertyTrack.GetSourceAdapterId(), t = this._GetTarget(), r = this._GetIndex();\n      switch (e) {\n        case \"behavior\":\n          return this._GetColorFromArray(t.GetPropertyValueByIndex(r));\n        case \"effect\":\n          return t[r].clone();\n        case \"plugin\":\n          return this._GetColorFromArray(t.GetPropertyValueByIndex(r));\n        case \"world-instance\":\n          return this.GetWorldInfo().GetUnpremultipliedColor().clone();\n      }\n    }\n    _Setter(e, t, r) {\n      const o = this._propertyTrack.GetSourceAdapterId(), a = this._GetTarget(), s = this._GetIndex();\n      switch (o) {\n        case \"behavior\":\n          TMP_COLOR[0] = e, TMP_COLOR[1] = t, TMP_COLOR[2] = r, a.SetPropertyValueByIndex(s, TMP_COLOR);\n          break;\n        case \"effect\":\n          a[s].setRgb(e, t, r);\n          break;\n        case \"plugin\":\n          TMP_COLOR[0] = e, TMP_COLOR[1] = t, TMP_COLOR[2] = r, a.SetPropertyValueByIndex(s, TMP_COLOR);\n          break;\n        case \"world-instance\":\n          this.GetWorldInfo().SetUnpremultipliedColorRGB(e, t, r);\n      }\n    }\n    _SaveToJson() {\n    }\n    _LoadFromJson(e) {\n    }\n  }\n  C32.PropertyTrackState.PropertyInterpolationAdapter.ColorInterpolationAdapter = ColorInterpolationAdapter;\n}\n{\n  const C32 = self.C3, NS = C32.PropertyTrackState;\n  class NoInterpolationAdapter extends C32.PropertyTrackState.PropertyInterpolationAdapter {\n    constructor(e) {\n      super(e);\n    }\n    SetResetState() {\n    }\n    SetInitialState() {\n    }\n    SetResumeState() {\n    }\n    GetCurrentState() {\n      return this._Getter();\n    }\n    CompareInitialStateWithCurrent() {\n      const e = this._FirstKeyframeGetter();\n      return e !== this.GetCurrentState();\n    }\n    CompareSaveStateWithCurrent() {\n      return !C32.IsNullOrUndefined(this._saveState) && this._saveState !== this.GetCurrentState();\n    }\n    MayNeedBeforeAndAfterInterpolate() {\n      return false;\n    }\n    ChangeProperty(e, t, r, a, n, s, i, o) {\n      const p = this._propertyTrack, c = p.GetTrack(), l = p.GetSourceAdapterId(), h = p.GetTimeline(), u = c.GetInstance(), S = p.GetSourceAdapter(), G = this._property, d = h.GetSimilarPropertyTracks(u, S, G, p);\n      if (d && 1 < d.length) {\n        const _ = this._GetPropertyKeyframeStubs(d), I = e + c.GetStartOffset(), T = this._GetLastPropertyKeyframeStub(h, I, _);\n        T && (t = T.value);\n      }\n      const y = p.GetPropertyKeyframeType();\n      switch (y) {\n        case \"numeric\":\n          if (NS.NumericTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), t, l)) break;\n          return;\n        case \"angle\":\n          if (NS.AngleTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), t, l)) break;\n          return;\n        case \"boolean\":\n          if (NS.BooleanTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), t, l)) break;\n          return;\n        case \"color\":\n          if (NS.ColorTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), t, l)) break;\n          return;\n        case \"text\":\n          if (!NS.TextTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), t, l)) return;\n      }\n      this._Setter(t);\n    }\n    _Getter() {\n      const e = this._propertyTrack.GetSourceAdapterId(), t = this._GetTarget(), r = this._GetIndex();\n      switch (e) {\n        case \"behavior\":\n          return t.GetPropertyValueByIndex(r);\n        case \"effect\":\n          return t[r];\n        case \"instance-variable\":\n          return t.GetInstanceVariableValue(r);\n        case \"plugin\":\n          return t.GetPropertyValueByIndex(r);\n      }\n    }\n    _Setter(e) {\n      const t = this._propertyTrack.GetSourceAdapterId(), r = this._GetTarget(), a = this._GetIndex();\n      switch (t) {\n        case \"behavior\":\n          r.SetPropertyValueByIndex(a, e);\n          break;\n        case \"effect\":\n          r[a] = e;\n          break;\n        case \"instance-variable\":\n          r.SetInstanceVariableValue(a, e);\n          break;\n        case \"plugin\":\n          r.SetPropertyValueByIndex(a, e);\n      }\n    }\n  }\n  C32.PropertyTrackState.PropertyInterpolationAdapter.NoInterpolationAdapter = NoInterpolationAdapter;\n}\n{\n  const C32 = self.C3, NS = C32.PropertyTrackState.PropertyInterpolationAdapter, INSTANCE_FUNC_MAP = /* @__PURE__ */ new Map(), add = (t, e, r, a, i, s = false, o = null, n = null) => {\n    INSTANCE_FUNC_MAP.set(t, { setter: e, absolute_setter: r, getter: a, round: i, fRound: s, init: o, reset: n });\n  };\n  add(\"offsetX\", (t, e, r, a) => {\n    \"relative\" === a._propertyTrack.GetResultMode() ? t.OffsetX(e, r.GetTimeline().GetTransformWithSceneGraph()) : t.OffsetX(e);\n  }, (t, e) => t.SetX(e), (t) => t.GetX(), true), add(\"offsetY\", (t, e, r, a) => {\n    \"relative\" === a._propertyTrack.GetResultMode() ? t.OffsetY(e, r.GetTimeline().GetTransformWithSceneGraph()) : t.OffsetY(e);\n  }, (t, e) => t.SetY(e), (t) => t.GetY(), true), add(\"offsetWidth\", (e, t, a, i, r) => {\n    if (0 !== t) {\n      const s = \"relative\" === i._propertyTrack.GetResultMode(), o = 1 === i._typeAdapter.GetType();\n      if ((s || o) && e.HasParent() && e.GetTransformWithParentWidth()) {\n        if (isNaN(i._absoluteToFactor)) {\n          const n = [];\n          let t2 = e.GetParent();\n          for (; t2; ) n.push(t2), t2 = t2.GetParent();\n          n.reverse();\n          const c = (t3, e2) => e2.GetTimeline().GetTrackFromInstance(t3.GetInstance()), l = (t3, e2) => {\n            const r3 = c(t3, e2);\n            if (r3) return r3.GetOriginalWidth();\n            const a2 = t3.GetInstance().GetSdkInstance();\n            return a2.IsOriginalSizeKnown() ? a2.GetOriginalWidth() : t3._GetSceneGraphInfo()._GetStartWidth();\n          }, p = (t3, e2, r3, a2 = 0) => {\n            const i2 = c(t3, e2);\n            if (!i2) return a2;\n            const s2 = i2.GetPropertyTrack(r3);\n            if (!s2) return a2;\n            const o2 = s2.GetPropertyTrackDataItem().GetPropertyKeyframeData();\n            if (!o2) return a2;\n            const n2 = o2.GetLastPropertyKeyframeDataItem();\n            return n2 ? n2.GetValue() : a2;\n          };\n          let r2;\n          if (o) {\n            let t3 = n[n.length - 1];\n            r2 = t3.GetWidth();\n          } else {\n            let e2 = n[0];\n            const _ = e2._GetSceneGraphInfo()._GetStartWidth(), h = e2._GetSceneGraphInfo().GetStartScaleX();\n            r2 = _ * h, r2 = (r2 += p(e2, a, \"offsetWidth\")) + l(e2, a) * p(e2, a, \"offsetScaleX\");\n            for (let t3 = 1; t3 < n.length; t3++) {\n              const u = (e2 = n[t3])._GetSceneGraphInfo().GetStartScaleX();\n              r2 = (r2 = (r2 *= u) + p(e2, a, \"offsetWidth\")) + l(e2, a) * p(e2, a, \"offsetScaleX\");\n            }\n          }\n          i._absoluteToFactor = 0 === r2 ? Number.EPSILON : r2;\n        }\n        r || e.OffsetWidth(t / i._absoluteToFactor, true);\n      } else e.OffsetWidth(t);\n    }\n  }, (t, e) => t.SetWidth(e), (t) => t.GetWidth(), true), add(\"offsetHeight\", (e, t, a, i, r) => {\n    if (0 !== t) {\n      const s = \"relative\" === i._propertyTrack.GetResultMode(), o = 1 === i._typeAdapter.GetType();\n      if ((s || o) && e.HasParent() && e.GetTransformWithParentHeight()) {\n        if (isNaN(i._absoluteToFactor)) {\n          const n = [];\n          let t2 = e.GetParent();\n          for (; t2; ) n.push(t2), t2 = t2.GetParent();\n          n.reverse();\n          const c = (t3, e2) => {\n            a2 = t3;\n            const r3 = e2.GetTimeline().GetTrackFromInstance(a2.GetInstance());\n            var a2;\n            if (r3) return r3.GetOriginalHeight();\n            const i2 = t3.GetInstance().GetSdkInstance();\n            return i2.IsOriginalSizeKnown() ? i2.GetOriginalHeight() : t3._GetSceneGraphInfo()._GetStartHeight();\n          }, l = (t3, e2, r3, a2 = 0) => {\n            const i2 = e2.GetTimeline().GetTrackFromInstance(t3.GetInstance());\n            if (!i2) return a2;\n            const s2 = i2.GetPropertyTrack(r3);\n            if (!s2) return a2;\n            const o2 = s2.GetPropertyTrackDataItem().GetPropertyKeyframeData();\n            if (!o2) return a2;\n            const n2 = o2.GetLastPropertyKeyframeDataItem();\n            return n2 ? n2.GetValue() : a2;\n          };\n          let r2;\n          if (o) {\n            let t3 = n[n.length - 1];\n            r2 = t3.GetHeight();\n          } else {\n            let e2 = n[0];\n            const p = e2._GetSceneGraphInfo()._GetStartHeight(), _ = e2._GetSceneGraphInfo().GetStartScaleY();\n            r2 = p * _, r2 = (r2 += l(e2, a, \"offsetHeight\")) + c(e2, a) * l(e2, a, \"offsetScaleY\");\n            for (let t3 = 1; t3 < n.length; t3++) {\n              const h = (e2 = n[t3])._GetSceneGraphInfo().GetStartScaleY();\n              r2 = (r2 = (r2 *= h) + l(e2, a)) + c(e2, a) * l(e2, a, \"offsetScaleY\");\n            }\n          }\n          i._absoluteToFactor = 0 === r2 ? Number.EPSILON : r2;\n        }\n        r || e.OffsetHeight(t / i._absoluteToFactor, true);\n      } else e.OffsetHeight(t);\n    }\n  }, (t, e) => t.SetHeight(e), (t) => t.GetHeight(), true), add(\"offsetAngle\", (t, e, r, a, i) => {\n    t.OffsetAngle(e);\n  }, (t, e) => t.SetAngle(e), (t) => t.GetAngle(), false, true), add(\"offsetOpacity\", (t, e, r, a, i) => {\n    const s = a._opacityFactor || 1, o = (e /= s, t.GetOpacity()), n = o + e;\n    if (0 === a._clampAccumulator) 1 < n ? a._clampAccumulator += n - 1 : n < 0 && (a._clampAccumulator += n), t.OffsetOpacity(e);\n    else {\n      const n2 = t.GetOpacity() + e;\n      0 < e && 0 < a._clampAccumulator ? 1 < n2 && (a._clampAccumulator += n2 - 1) : 0 < e && a._clampAccumulator < 0 ? (a._clampAccumulator += e, 0 < a._clampAccumulator && (t.OffsetOpacity(a._clampAccumulator), a._clampAccumulator = 0)) : e < 0 && 0 < a._clampAccumulator ? (a._clampAccumulator += e, a._clampAccumulator < 0 && (t.OffsetOpacity(a._clampAccumulator), a._clampAccumulator = 0)) : e < 0 && a._clampAccumulator < 0 && n2 < 0 && (a._clampAccumulator += n2);\n    }\n  }, (t, e) => {\n    t.SetOpacity(e);\n  }, (t) => t.GetOpacity(), false, true, (r, a, i) => {\n    switch (r._clampAccumulator = 0, r._propertyTrack.GetResultMode()) {\n      case \"relative\": {\n        r._propertyTrack.GetPropertyTrackData();\n        const s = r._propertyTrack.GetPropertyTrackDataItem(), o = s.GetPropertyKeyframeData(), n = o.GetPropertyKeyframeDataItemArray();\n        let t2 = r.GetWorldInfo().GetOpacity(), e2 = t2;\n        for (const c of n) {\n          const l = c.GetTime(), p = r._propertyTrack.GetInterpolatedValue(l);\n          e2 = t2 + p, e2 = C32.clamp(e2, 0, 1);\n        }\n        r._totalForewardOpacityDelta = t2 - e2, r._totalForewardOpacityDelta = Math.round(100 * (r._totalForewardOpacityDelta + Number.EPSILON)) / 100, e2 = t2;\n        for (let t3 = n.length - 1; 0 <= t3; t3--) {\n          const _ = n[t3].GetTime(), h = r._propertyTrack.GetInterpolatedValue(_);\n          e2 -= h, e2 = C32.clamp(e2, 0, 1);\n        }\n        r._totalBackwardOpacityDelta = e2, r._totalBackwardOpacityDelta = Math.round(100 * (r._totalBackwardOpacityDelta + Number.EPSILON)) / 100;\n        break;\n      }\n    }\n    const t = \"relative\" === r._propertyTrack.GetResultMode(), e = 1 === r._typeAdapter.GetType();\n    if ((t || e) && a.HasParent() && a.GetTransformWithParentOpacity()) {\n      const u = [];\n      let t2 = a.GetParent();\n      for (; t2; ) u.push(t2), t2 = t2.GetParent();\n      u.reverse();\n      const f = (t3, e3, r2) => {\n        const a2 = e3.GetTimeline().GetTrackFromInstance(t3.GetInstance());\n        if (!a2) return 0;\n        const i2 = a2.GetPropertyTrack(r2);\n        if (!i2) return 0;\n        const s = i2.GetPropertyTrackDataItem().GetPropertyKeyframeData();\n        if (!s) return 0;\n        const o = s.GetLastPropertyKeyframeDataItem();\n        return o ? o.GetValue() : 0;\n      };\n      let e2 = u[0]._GetSceneGraphInfo().GetStartOpacity();\n      e2 += f(u[0], i, \"offsetOpacity\");\n      for (let t3 = 1; t3 < u.length; t3++) e2 += f(u[t3], i, \"offsetOpacity\");\n      r._opacityFactor = 0 === e2 ? 1 : e2;\n    }\n  }, (e) => {\n    switch (e._propertyTrack.GetResultMode()) {\n      case \"relative\": {\n        e._clampAccumulator = 0;\n        const r = e.GetWorldInfo();\n        let t = r.GetOpacity();\n        t = Math.round(100 * (t + Number.EPSILON)) / 100, e._propertyTrack.GetTimeline().IsForwardPlayBack() ? (r.SetOpacity(t + e._totalForewardOpacityDelta), e._lastValue = 0) : (r.SetOpacity(t - e._totalBackwardOpacityDelta), e._lastValue = e.GetSourceAdapter().GetValueAtTime());\n        break;\n      }\n    }\n  }), add(\"offsetOriginX\", (t, e) => t.OffsetOriginX(e), (t, e) => t.SetOriginX(e), (t) => t.GetOriginX(), false), add(\"offsetOriginY\", (t, e) => t.OffsetOriginY(e), (t, e) => t.SetOriginY(e), (t) => t.GetOriginY(), false), add(\"offsetZElevation\", (t, e) => t.OffsetZElevation(e), (t, e) => t.SetZElevation(e), (t) => t.GetZElevation(), true), add(\"offsetScaleX\", (t, e, r, a) => {\n    if (0 !== e) {\n      const i = t.GetWidth() < 0 ? -1 : 1;\n      if (\"relative\" === a._propertyTrack.GetResultMode() && t.HasParent() && t.GetTransformWithParentWidth()) {\n        const s = r.GetOriginalWidth() * i * e;\n        isNaN(a._absoluteToFactor) && INSTANCE_FUNC_MAP.get(\"offsetWidth\").setter(t, 1, r, a, true), t.OffsetWidth(s / a._absoluteToFactor, true);\n      } else t.OffsetWidth(r.GetOriginalWidth() * i * e);\n    }\n  }, (t, e, r) => {\n    t.SetWidth(r.GetOriginalWidth() * e);\n  }, (e, r) => {\n    const a = e.GetWidth() < 0 ? -1 : 1;\n    if (e.GetTransformWithParentWidth()) {\n      const i = e.GetParent(), s = r.GetTimeline().GetTrackFromInstance(i.GetInstance());\n      let t = NaN;\n      if (s) t = i.GetWidth() / s.GetOriginalWidth();\n      else {\n        const o = i.GetInstance().GetSdkInstance();\n        t = o.IsOriginalSizeKnown() ? i.GetWidth() / o.GetOriginalWidth() : 1;\n      }\n      return e.GetWidth() * a / (r.GetOriginalWidth() * t);\n    }\n    return e.GetWidth() * a / r.GetOriginalWidth();\n  }, false), add(\"offsetScaleY\", (t, e, r, a) => {\n    if (0 !== e) {\n      const i = t.GetHeight() < 0 ? -1 : 1;\n      if (\"relative\" === a._propertyTrack.GetResultMode() && t.HasParent() && t.GetTransformWithParentHeight()) {\n        const s = r.GetOriginalHeight() * i * e;\n        isNaN(a._absoluteToFactor) && INSTANCE_FUNC_MAP.get(\"offsetHeight\").setter(t, 1, r, a, true), t.OffsetHeight(s / a._absoluteToFactor, true);\n      } else t.OffsetHeight(r.GetOriginalHeight() * i * e);\n    }\n  }, (t, e, r) => {\n    t.SetHeight(r.GetOriginalHeight() * e);\n  }, (e, r) => {\n    const a = e.GetHeight() < 0 ? -1 : 1;\n    if (e.GetTransformWithParentHeight()) {\n      const i = e.GetParent(), s = r.GetTimeline().GetTrackFromInstance(i.GetInstance());\n      let t = NaN;\n      if (s) t = i.GetHeight() / s.GetOriginalHeight();\n      else {\n        const o = i.GetInstance().GetSdkInstance();\n        t = o.IsOriginalSizeKnown() ? i.GetHeight() / o.GetOriginalHeight() : 1;\n      }\n      return e.GetHeight() * a / (r.GetOriginalHeight() * t);\n    }\n    return e.GetHeight() * a / r.GetOriginalHeight();\n  }, false);\n  class NumericInterpolationAdapter extends C32.PropertyTrackState.PropertyInterpolationAdapter {\n    constructor(t) {\n      super(t), this._lastValue = 0, this._clampAccumulator = 0, this._totalForewardOpacityDelta = 0, this._totalBackwardOpacityDelta = 0, this._opacityFactor = NaN, this._absoluteToFactor = NaN, this._angleReflectMirrorOrFlip = void 0, this._angleReflectMirrorAndFlip = void 0, this._instance_getter = null, this._instance_setter = null, this._instance_absolute_setter = null, this._reset_action = null, this._init_action = null, this._source_adapter_getter = null, this._source_adapter_setter = null, this._source_adapter_absolute_setter = null, this._round = false, this._fRound = false, C32.IsInstanceOf(this._propertyTrack.GetTimeline(), C32.TweenState) ? this._typeAdapter = new C32.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTween(this) : this._typeAdapter = new C32.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTimeline(this);\n      const e = this._propertyTrack.GetPropertyName();\n      switch (this._propertyTrack.GetSourceAdapterId()) {\n        case \"world-instance\": {\n          const r = INSTANCE_FUNC_MAP.get(e);\n          this._instance_getter = r.getter, this._instance_setter = r.setter, this._instance_absolute_setter = r.absolute_setter, this._round = r.round, this._fRound = r.fRound, this._init_action = r.init, this._reset_action = r.reset;\n          break;\n        }\n        case \"audio\":\n          this._source_adapter_getter = t.Getter, this._source_adapter_setter = t.Setter, this._source_adapter_absolute_setter = t.AbsoluteSetter, this._round = !!t.DoesRounding(), this._fRound = false;\n      }\n    }\n    Release() {\n      this._typeAdapter = null, this._instance_getter = null, this._instance_setter = null, this._instance_absolute_setter = null, this._reset_action = null, this._init_action = null, this._source_adapter_getter = null, this._source_adapter_setter = null, this._source_adapter_absolute_setter = null, super.Release();\n    }\n    MayNeedBeforeAndAfterInterpolate() {\n      return this._typeAdapter.MayNeedBeforeAndAfterInterpolate();\n    }\n    GetLastValue() {\n      return this._lastValue;\n    }\n    SetLastValue(t) {\n      this._lastValue = t;\n    }\n    SetResetState() {\n      this._reset_action && this._reset_action(this);\n    }\n    SetInitialState() {\n      const t = this._typeAdapter.SetInitialState();\n      if (\"number\" == typeof t && (this._lastValue = t), this._init_action) {\n        const e = this.GetWorldInfo(), r = this._propertyTrack.GetTrack();\n        this._init_action(this, e, r);\n      }\n    }\n    SetResumeState() {\n      const t = this._typeAdapter.SetResumeState();\n      \"number\" == typeof t && (this._lastValue = t);\n    }\n    GetCurrentState() {\n      return this._Getter();\n    }\n    CompareInitialStateWithCurrent() {\n      const t = this._FirstKeyframeGetter();\n      return t !== this.GetCurrentState();\n    }\n    CompareSaveStateWithCurrent() {\n      return !C32.IsNullOrUndefined(this._saveState) && this._saveState !== this.GetCurrentState();\n    }\n    BeforeChangeProperty() {\n      this._typeAdapter.BeforeChangeProperty();\n    }\n    ChangeProperty(t, e, r, a, i, s, o, n) {\n      return this._typeAdapter.ChangeProperty(t, e, r, a, i, s, o, n);\n    }\n    AfterChangeProperty() {\n      this._typeAdapter.AfterChangeProperty();\n    }\n    _Getter() {\n      const t = this._GetTarget(), e = this._GetIndex(), r = this.GetWorldInfo(), a = this._propertyTrack.GetTrack(), i = this._propertyTrack.GetSourceAdapterId();\n      switch (i) {\n        case \"behavior\":\n          return t.GetPropertyValueByIndex(e);\n        case \"effect\":\n          return t[e];\n        case \"instance-variable\":\n          return t.GetInstanceVariableValue(e);\n        case \"plugin\":\n          return t.GetPropertyValueByIndex(e);\n        case \"world-instance\":\n          return this._instance_getter(r, a);\n        case \"audio\":\n          return this._source_adapter_getter.call(this.GetSourceAdapter(), r, a);\n      }\n    }\n    _Setter(t, e, r) {\n      const a = this._GetTarget(), i = this._GetIndex(), s = this.GetWorldInfo(), o = this._propertyTrack.GetTrack(), n = this._propertyTrack.GetSourceAdapterId();\n      switch (n) {\n        case \"behavior\":\n          a.OffsetPropertyValueByIndex(i, t);\n          break;\n        case \"effect\":\n          a[i] += t;\n          break;\n        case \"instance-variable\":\n          a.SetInstanceVariableOffset(i, t);\n          break;\n        case \"plugin\":\n          a.OffsetPropertyValueByIndex(i, t, this.GetSourceAdapter().GetOptionalCallbacks());\n          break;\n        case \"world-instance\":\n          this._instance_setter(s, t, o, this);\n          break;\n        case \"audio\":\n          this._source_adapter_setter.call(this.GetSourceAdapter(), s, t, o, this);\n      }\n    }\n    _SetterAbsolute(t, e, r) {\n      let a = this._propertyTrack.GetInterpolationMode();\n      if (\"discrete\" !== (a = \"default\" === a ? \"continuous\" : a) || e) {\n        if (\"discrete\" === a && r) {\n          const l = this._propertyTrack.GetTimeline(), p = l.GetTime(), _ = this._propertyTrack.GetPropertyKeyFrameDataItemAtTime(p);\n          if (!_) return;\n        }\n        const i = this._GetTarget(), s = this._GetIndex(), o = this.GetWorldInfo(), n = this._propertyTrack.GetTrack(), c = this._propertyTrack.GetSourceAdapterId();\n        switch (c) {\n          case \"behavior\":\n            i.SetPropertyValueByIndex(s, t);\n            break;\n          case \"effect\":\n            i[s] = t;\n            break;\n          case \"instance-variable\":\n            i.SetInstanceVariableValue(s, t);\n            break;\n          case \"plugin\":\n            i.SetPropertyValueByIndex(s, t, this.GetSourceAdapter().GetOptionalCallbacks());\n            break;\n          case \"world-instance\":\n            this._instance_absolute_setter(o, t, n);\n            break;\n          case \"audio\":\n            this._source_adapter_absolute_setter.call(this.GetSourceAdapter(), o, t, n);\n        }\n      }\n    }\n    _MaybeEnsureValue(t, e, r, a, i, s, o, n) {\n      this._typeAdapter._MaybeEnsureValue(t, e, r, a, i, s, o, n);\n    }\n    _AddDelta(t, e, r, a, i) {\n      const s = (t = \"angle\" === this._propertyTrack.GetPropertyType() ? C32.toDegrees(t) : t).toString(), o = s.split(\".\")[1] || \"\", n = o.length, c = this._Getter();\n      let l;\n      switch (l = 0 === n ? this._round ? Math.round(c) : this._fRound ? \"angle\" === this._propertyTrack.GetPropertyType() ? C32.toRadians(Math.round(C32.toDegrees(c))) : Number(C32.toFixed(c, 2)) : c : this._round ? Number(C32.toFixed(c, n)) : (this._fRound, c), this._Setter(l - c, e, r), this._propertyTrack.GetPropertyName()) {\n        case \"offsetWidth\":\n        case \"offsetScaleX\": {\n          const p = this.GetWorldInfo(), _ = p.GetWidth(), h = Number(C32.toFixed(_, 2));\n          p.OffsetWidth(h - _);\n          break;\n        }\n        case \"offsetHeight\":\n        case \"offsetScaleY\": {\n          const u = this.GetWorldInfo(), f = u.GetHeight(), d = Number(C32.toFixed(f, 2));\n          u.OffsetHeight(d - f);\n          break;\n        }\n      }\n    }\n    _SaveToJson() {\n      return Object.assign(super._SaveToJson(), { \"v\": this._lastValue, \"a\": this._clampAccumulator, \"fod\": this._totalForewardOpacityDelta, \"bod\": this._totalBackwardOpacityDelta, \"of\": this._opacityFactor, \"sf\": this._absoluteToFactor, \"armorf\": this._angleReflectMirrorOrFlip, \"armandf\": this._angleReflectMirrorAndFlip });\n    }\n    _LoadFromJson(t) {\n      t && (super._LoadFromJson(t), this._lastValue = t[\"v\"], this._clampAccumulator = t[\"a\"], this._totalForewardOpacityDelta = C32.IsFiniteNumber(t[\"fod\"]) ? t[\"fod\"] : 0, this._totalBackwardOpacityDelta = C32.IsFiniteNumber(t[\"bod\"]) ? t[\"bod\"] : 0, this._opacityFactor = C32.IsFiniteNumber(t[\"of\"]) ? t[\"of\"] : NaN, this._absoluteToFactor = C32.IsFiniteNumber(t[\"sf\"]) ? t[\"sf\"] : NaN, this._angleReflectMirrorOrFlip = C32.IsFiniteNumber(t[\"armorf\"]) ? t[\"armorf\"] : void 0, this._angleReflectMirrorAndFlip = C32.IsFiniteNumber(t[\"armandf\"]) ? t[\"armandf\"] : void 0);\n    }\n  }\n  C32.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapter = NumericInterpolationAdapter;\n}\n{\n  const C32 = self.C3;\n  class AbsoluteValueObject {\n    constructor(e) {\n      this._used = false, this._value = 0, this._propertyKeyframeReached = false, this._endState = false, this._propertyTracks = e;\n      for (let e2 = 0, t = this._propertyTracks.length; e2 < t; e2++) this._propertyTracks[e2].SetAbsoluteValueObject(this);\n    }\n    GetPropertyTracks() {\n      return this._propertyTracks;\n    }\n    SetUsed() {\n      this._used = true;\n    }\n    GetUsed() {\n      return this._used;\n    }\n    SetValue(e) {\n      this._value = e;\n    }\n    GetValue() {\n      return this._value;\n    }\n    SetPropertyKeyframeReached(e) {\n      this._propertyKeyframeReached = e;\n    }\n    GetPropertyKeyframeReached() {\n      return this._propertyKeyframeReached;\n    }\n    SetEndState(e) {\n      this._endState = e;\n    }\n    GetEndState() {\n      return this._endState;\n    }\n    Reset() {\n      this._used = false, this._value = 0, this._propertyKeyframeReached = false, this._endState = false;\n    }\n  }\n  class NumericInterpolationAdapterForTimeline {\n    constructor(e) {\n      this._numericInterpolationAdapter = e;\n    }\n    Release() {\n      this._numericInterpolationAdapter = null;\n    }\n    GetType() {\n      return 0;\n    }\n    SetInitialState() {\n      const e = this._numericInterpolationAdapter;\n      this._numericInterpolationAdapter.GetPropertyTrack();\n      return e._PickResultMode(() => e._PickTimelinePlaybackMode(() => 0, () => e.GetSourceAdapter().GetValueAtTime()), () => {\n      });\n    }\n    SetResumeState() {\n    }\n    MayNeedBeforeAndAfterInterpolate() {\n      this._numericInterpolationAdapter;\n      const e = this._numericInterpolationAdapter.GetPropertyTrack();\n      switch (e.GetResultMode()) {\n        case \"relative\":\n          return false;\n        case \"absolute\":\n          return true;\n      }\n    }\n    BeforeChangeProperty() {\n      this._numericInterpolationAdapter;\n      const e = this._numericInterpolationAdapter.GetPropertyTrack(), t = e.GetPropertyName();\n      switch (e.GetResultMode()) {\n        case \"relative\":\n          break;\n        case \"absolute\":\n          if (e.HasAbsoluteValueObject()) {\n            const r = e.GetAbsoluteValueObject();\n            r.Reset();\n          } else {\n            const a = e.GetTimeline(), s = e.GetInstance(), o = e.GetSourceAdapter(), i = a.GetSimilarPropertyTracks(s, o, t, e);\n            i && 1 < i.length && new AbsoluteValueObject(i);\n          }\n      }\n    }\n    ChangeProperty(e, t, r, a, s, o, i, n) {\n      const l = this._numericInterpolationAdapter, u = this._numericInterpolationAdapter.GetPropertyTrack();\n      switch (u.GetResultMode()) {\n        case \"relative\": {\n          const c = l.GetLastValue();\n          l._Setter(t - c, r, a), o && this._MaybeEnsureValue(e, r, a, s, c, t), l.SetLastValue(t);\n          break;\n        }\n        case \"absolute\": {\n          const p = u.GetTimeline(), d = u.GetTrack();\n          u.GetInstance(), u.GetSourceAdapter();\n          if (u.HasAbsoluteValueObject()) {\n            const h = u.GetAbsoluteValueObject(), G = h.GetPropertyTracks(), y = l._GetPropertyKeyframeStubs(G, true), _ = l._GetLastPropertyKeyframeStub(p, p.GetTime(), y);\n            if (_) {\n              const m = d.GetStartOffset(), A = _.time - m;\n              if (0 == A) h.SetEndState(i), h.SetPropertyKeyframeReached(n), h.SetUsed(), h.SetValue(h.GetValue() + t);\n              else {\n                if (A < 0) return;\n                const S = u.GetInterpolatedValue(A);\n                h.SetEndState(i), h.SetPropertyKeyframeReached(n), h.SetUsed(), h.SetValue(h.GetValue() + (t - S));\n              }\n            }\n          } else l._SetterAbsolute(t, n, i);\n          break;\n        }\n      }\n    }\n    AfterChangeProperty() {\n      const e = this._numericInterpolationAdapter, t = this._numericInterpolationAdapter.GetPropertyTrack();\n      switch (t.GetResultMode()) {\n        case \"relative\":\n          break;\n        case \"absolute\":\n          if (t.HasAbsoluteValueObject()) {\n            const r = t.GetAbsoluteValueObject();\n            r.GetUsed() && e._SetterAbsolute(r.GetValue(), r.GetPropertyKeyframeReached(), r.GetEndState());\n          }\n      }\n    }\n    _MaybeEnsureValue(e, t, r, a, s, o) {\n      const i = this._numericInterpolationAdapter;\n      a || (t && e === t.GetTime() ? i._AddDelta(t.GetValueWithResultMode(), t, r) : r && e === r.GetTime() ? i._AddDelta(r.GetValueWithResultMode(), t, r) : o - s == 0 && i._AddDelta(t.GetValueWithResultMode(), t, r));\n    }\n  }\n  C32.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTimeline = NumericInterpolationAdapterForTimeline;\n}\n{\n  const C32 = self.C3;\n  class NumericInterpolationAdapterForTween {\n    constructor(e) {\n      this._numericInterpolationAdapter = e;\n    }\n    Release() {\n      this._numericInterpolationAdapter = null;\n    }\n    GetType() {\n      return 1;\n    }\n    SetInitialState() {\n      const e = this._numericInterpolationAdapter;\n      return e.SetFirstAbsoluteUpdate(true), this._GetAbsoluteInitialValue(e._FirstKeyframeGetter());\n    }\n    SetResumeState() {\n      const e = this._numericInterpolationAdapter;\n      if (e._FirstKeyframeGetter() !== e._CurrentKeyframeGetter()) return e.SetFirstAbsoluteUpdate(true), this._GetAbsoluteInitialValue(e._CurrentKeyframeGetter());\n    }\n    MayNeedBeforeAndAfterInterpolate() {\n      return false;\n    }\n    BeforeChangeProperty() {\n    }\n    ChangeProperty(e, t, r, a, n, i, o, l) {\n      const s = this._numericInterpolationAdapter, u = s.GetLastValue();\n      switch (s.GetPropertyTrack().GetResultMode()) {\n        case \"relative\":\n          s._Setter(t - u, r, a), i && this._MaybeEnsureValue(e, r, a, n, u, t, false, o);\n          break;\n        case \"absolute\":\n          s.GetFirstAbsoluteUpdate() ? (s.SetFirstAbsoluteUpdate(false), s._Setter(u, r, a)) : 0 === e && 0 === s.GetPropertyTrack().GetTimeline().GetTotalTime() ? s._SetterAbsolute(t, true, false) : (s._Setter(t - u, r, a), i && this._MaybeEnsureValue(e, r, a, n, u, t, this._ForceEndValue(), o));\n      }\n      s.SetLastValue(t);\n    }\n    AfterChangeProperty() {\n    }\n    _GetAbsoluteInitialValue(e) {\n      const t = this._numericInterpolationAdapter;\n      return e - t.GetCurrentState();\n    }\n    _ForceEndValue() {\n      const e = this._numericInterpolationAdapter, t = e.GetWorldInfo().GetInstance(), r = e.GetPropertyTrack().GetRuntime(), a = r.GetTimelineManager();\n      let n = 0;\n      for (const i of a.GetPlayingTimelines()) 0 === i.GetType() ? i.HasTrackInstance(t) && n++ : 1 === i.GetType() && i.GetInstance() === t && n++;\n      return n <= 1;\n    }\n    _MaybeEnsureValue(e, t, r, a, n, i, o, l) {\n      const s = this._numericInterpolationAdapter;\n      a ? t && e === t.GetTime() ? s._AddDelta(t.GetValueWithResultMode(), t, r, o, l) : r && e === r.GetTime() ? s._AddDelta(r.GetValueWithResultMode(), t, r, o, l) : r || s._AddDelta(t.GetValueWithResultMode(), t, r, o, l) : t && e === t.GetTime() ? s._AddDelta(t.GetValueWithResultMode(), t, r, o, l) : r && e === r.GetTime() ? s._AddDelta(r.GetValueWithResultMode(), t, r, o, l) : i - n == 0 && s._AddDelta(t.GetValueWithResultMode(), t, r, o, l);\n    }\n  }\n  C32.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTween = NumericInterpolationAdapterForTween;\n}\n{\n  const C32 = self.C3, Ease = self.Ease;\n  C32.PropertyTrackState.NumericTypeAdapter = class {\n    constructor() {\n    }\n    static WillChange(e, t, a, r) {\n      let s;\n      switch (r) {\n        case \"behavior\":\n          s = t.GetPropertyValueByIndex(e);\n          break;\n        case \"effect\":\n          s = t[e];\n          break;\n        case \"instance-variable\":\n          s = t.GetInstanceVariableValue(e);\n          break;\n        case \"plugin\":\n          s = t.GetPropertyValueByIndex(e);\n      }\n      return s !== a;\n    }\n    static Interpolate(t, a, r, s) {\n      if (!r) {\n        let e = s.GetPropertyTrackDataItem();\n        const i = s.GetPropertyTrackData();\n        return (e = i.GetLastPropertyKeyframeDataItem(e)).GetValueWithResultMode();\n      }\n      let n = s.GetInterpolationMode();\n      if (\"default\" === n && (n = \"continuous\"), \"discrete\" === (n = \"combo\" === s.GetPropertyType() ? \"discrete\" : n)) return a.GetValueWithResultMode();\n      if (\"continuous\" === n || \"step\" === n) {\n        const o = s.GetTimeline().GetStep();\n        if (\"step\" === n && 0 !== o) {\n          const m = 1 / o;\n          t = Math.floor(t * m) / m;\n        }\n        const c = a.GetValueWithResultMode(), l = r.GetValueWithResultMode(), u = a.GetAddOn(\"cubic-bezier\"), G = r.GetAddOn(\"cubic-bezier\"), p = u && u.GetStartEnable() && G && G.GetEndEnable();\n        if (!p && c === l) return c;\n        const d = a.GetTime(), b = r.GetTime(), f = (\"step\" === n && 0 !== o && (t = C32.clamp(t, d, b)), C32.normalize(t, d, b)), y = a.GetEase();\n        let e;\n        if (p) {\n          const E = b - d;\n          e = Ease.GetRuntimeEase(y)(E * f, 0, 1, E), e = Ease.GetRuntimeEase(\"cubicbezier\")(e, c, c + u.GetStartAnchor(), l + G.GetEndAnchor(), l);\n        } else e = Ease.GetRuntimeEase(y)((b - d) * f, c, l - c, b - d);\n        return \"integer\" === s.GetPropertyType() ? Math.floor(e) : e;\n      }\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.PropertyTrackState.AngleTypeAdapter = class {\n    constructor() {\n    }\n    static WillChange(e, t, a, r) {\n      let s;\n      switch (r) {\n        case \"behavior\":\n          s = t.GetPropertyValueByIndex(e);\n          break;\n        case \"effect\":\n          s = t[e];\n          break;\n        case \"instance-variable\":\n          s = t.GetInstanceVariableValue(e);\n          break;\n        case \"plugin\":\n          s = t.GetPropertyValueByIndex(e);\n      }\n      return s !== a;\n    }\n    static Interpolate(e, t, a, r) {\n      if (!a) {\n        let e2 = r.GetPropertyTrackDataItem();\n        const n = r.GetPropertyTrackData();\n        return (e2 = n.GetLastPropertyKeyframeDataItem(e2)).GetValueWithResultMode();\n      }\n      let s = r.GetInterpolationMode();\n      if (\"default\" === s && (s = \"continuous\"), \"discrete\" === (s = \"combo\" === r.GetPropertyType() ? \"discrete\" : s)) return t.GetValueWithResultMode();\n      if (\"continuous\" === s || \"step\" === s) {\n        const o = r.GetTimeline().GetStep();\n        if (\"step\" === s && 0 !== o) {\n          const p = 1 / o;\n          e = Math.floor(e * p) / p;\n        }\n        const i = t.GetTime(), l = a.GetTime(), c = t.GetValueWithResultMode(), u = a.GetValueWithResultMode(), G = (\"step\" === s && 0 !== o && (e = C32.clamp(e, i, l)), t.GetAddOn(\"angle\"));\n        if (!G) {\n          if (c === u) return c;\n          const f = C32.normalize(e, i, l), d = self.Ease.GetRuntimeEase(t.GetEase());\n          return C32.angleLerp(c, u, d(f, 0, 1, 1));\n        }\n        {\n          const C = G.GetRevolutions();\n          if (c === u && 0 === C) return c;\n          const m = C32.normalize(e, i, l), y = self.Ease.GetRuntimeEase(t.GetEase()), k = y(m, 0, 1, 1);\n          switch (G.GetDirection()) {\n            case \"closest\":\n              return C32.angleLerp(c, u, k, C);\n            case \"clockwise\":\n              return C32.angleLerpClockwise(c, u, k, C);\n            case \"anti-clockwise\":\n              return C32.angleLerpAntiClockwise(c, u, k, C);\n          }\n        }\n      }\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.PropertyTrackState.BooleanTypeAdapter = class {\n    constructor() {\n    }\n    static WillChange(e, t, a, r) {\n      let c;\n      switch (r) {\n        case \"behavior\":\n          c = t.GetPropertyValueByIndex(e);\n          break;\n        case \"effect\":\n          c = t[e];\n          break;\n        case \"instance-variable\":\n          c = t.GetInstanceVariableValue(e);\n          break;\n        case \"plugin\":\n          c = t.GetPropertyValueByIndex(e);\n      }\n      return !!c != !!a;\n    }\n    static Interpolate(e, t, a, r) {\n      if (a) return t.GetValueWithResultMode() ? 1 : 0;\n      {\n        let e2 = r.GetPropertyTrackDataItem();\n        const c = r.GetPropertyTrackData();\n        return (e2 = c.GetLastPropertyKeyframeDataItem(e2)).GetValueWithResultMode() ? 1 : 0;\n      }\n    }\n  };\n}\n{\n  const C32 = self.C3, TEMP_COLOR_ARRAY = [0, 0, 0], TEMP_COLOR_ARRAY_2 = [0, 0, 0], TEMP_COLOR_ARRAY_3 = [0, 0, 0];\n  C32.PropertyTrackState.ColorTypeAdapter = class {\n    constructor() {\n    }\n    static WillChange(R, e, _, t) {\n      let A;\n      switch (t) {\n        case \"behavior\":\n          A = e.GetPropertyValueByIndex(R);\n          break;\n        case \"effect\":\n          A = e[R];\n          break;\n        case \"instance-variable\":\n          A = e.GetInstanceVariableValue(R);\n          break;\n        case \"plugin\":\n          A = e.GetPropertyValueByIndex(R);\n      }\n      return Array.isArray(_) ? (TEMP_COLOR_ARRAY[0] = _[0], TEMP_COLOR_ARRAY[1] = _[1], TEMP_COLOR_ARRAY[2] = _[2]) : (TEMP_COLOR_ARRAY_3.parseCommaSeparatedRgb(_), TEMP_COLOR_ARRAY[0] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getR()), TEMP_COLOR_ARRAY[1] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getG()), TEMP_COLOR_ARRAY[2] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getB())), Array.isArray(A) ? (TEMP_COLOR_ARRAY_2[0] = A[0], TEMP_COLOR_ARRAY_2[1] = A[1], TEMP_COLOR_ARRAY_2[2] = A[2]) : (TEMP_COLOR_ARRAY_3.parseCommaSeparatedRgb(A), TEMP_COLOR_ARRAY_2[0] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getR()), TEMP_COLOR_ARRAY_2[1] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getG()), TEMP_COLOR_ARRAY_2[2] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getB())), TEMP_COLOR_ARRAY[0] !== TEMP_COLOR_ARRAY_2[0] || TEMP_COLOR_ARRAY[1] !== TEMP_COLOR_ARRAY_2[1] || TEMP_COLOR_ARRAY[2] !== TEMP_COLOR_ARRAY_2[2];\n    }\n    static Interpolate(R, e, _, t) {\n      if (!_) {\n        let R2 = t.GetPropertyTrackDataItem();\n        const O = t.GetPropertyTrackData(), a = (R2 = O.GetLastPropertyKeyframeDataItem(R2)).GetValueWithResultMode();\n        return TEMP_COLOR_ARRAY[0] = a[0], TEMP_COLOR_ARRAY[1] = a[1], TEMP_COLOR_ARRAY[2] = a[2], TEMP_COLOR_ARRAY;\n      }\n      let A = t.GetInterpolationMode();\n      if (\"discrete\" === (A = \"default\" === A ? \"continuous\" : A)) {\n        const r = e.GetValueWithResultMode();\n        return TEMP_COLOR_ARRAY[0] = r[0], TEMP_COLOR_ARRAY[1] = r[1], TEMP_COLOR_ARRAY[2] = r[2], TEMP_COLOR_ARRAY;\n      }\n      if (\"continuous\" === A || \"step\" === A) {\n        const M = t.GetTimeline().GetStep();\n        if (\"step\" === A && 0 !== M) {\n          const f = 1 / M;\n          R = Math.floor(R * f) / f;\n        }\n        const C = e.GetTime(), T = _.GetTime(), P = e.GetValueWithResultMode(), o = _.GetValueWithResultMode(), E = (\"step\" === A && 0 !== M && (R = C32.clamp(R, C, T)), C32.normalize(R, C, T)), L = e.GetEase(), Y = P[0], s = P[1], l = P[2], i = o[0], n = o[1], c = o[2], u = self.Ease.GetRuntimeEase(L), p = T - C, G = p * E;\n        return TEMP_COLOR_ARRAY[0] = Y === i ? Y : u(G, Y, i - Y, p), TEMP_COLOR_ARRAY[1] = s === n ? s : u(G, s, n - s, p), TEMP_COLOR_ARRAY[2] = l === c ? l : u(G, l, c - l, p), TEMP_COLOR_ARRAY;\n      }\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.PropertyTrackState.TextTypeAdapter = class {\n    constructor() {\n    }\n    static WillChange(e, t, a, r) {\n      let c;\n      switch (r) {\n        case \"behavior\":\n          c = t.GetPropertyValueByIndex(e);\n          break;\n        case \"effect\":\n          c = t[e];\n          break;\n        case \"instance-variable\":\n          c = t.GetInstanceVariableValue(e);\n          break;\n        case \"plugin\":\n          c = t.GetPropertyValueByIndex(e);\n      }\n      return c !== a;\n    }\n    static Interpolate(e, t, a, r) {\n      if (a) return t.GetValueWithResultMode();\n      {\n        let e2 = r.GetPropertyTrackDataItem();\n        const c = r.GetPropertyTrackData();\n        return (e2 = c.GetLastPropertyKeyframeDataItem(e2)).GetValueWithResultMode();\n      }\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.TimelineDataManager = class {\n    constructor() {\n      this._timelineDataItems = /* @__PURE__ */ new Map();\n    }\n    Release() {\n      for (const e of this._timelineDataItems.values()) e.Release();\n      this._timelineDataItems.clear(), this._timelineDataItems = null;\n    }\n    Add(e) {\n      const a = new C32.TimelineDataItem(e), t = a.GetName();\n      this._timelineDataItems.set(t, a);\n    }\n    Get(e) {\n      return this._timelineDataItems.get(e);\n    }\n    GetNameId() {\n      return 0;\n    }\n    static _CreateDataItems(e, a, t, s) {\n      if (a) for (const i of a) C32.TimelineDataManager._CreateDataItem(\"create\", i, e, t, s);\n    }\n    static _CreateDataItemsIncludingDisabled(e, a, t, s) {\n      if (a) for (const i of a) C32.TimelineDataManager._CreateDataItem(\"create-including-disabled\", i, e, t, s);\n    }\n    static _LoadDataItemsFromJson(t, e, a, s) {\n      t.length ? e.forEach((e2, a2) => {\n        t[a2]._LoadFromJson(e2);\n      }) : e.forEach((e2) => {\n        C32.TimelineDataManager._CreateDataItem(\"load\", e2, t, a, s);\n      });\n    }\n    static _CreateDataItem(e, a, t, s, i) {\n      let n;\n      if (\"function\" == typeof s) switch (e) {\n        case \"load\":\n          n = new s(null, i);\n          break;\n        case \"create\":\n        case \"create-including-disabled\":\n          n = new s(a, i);\n      }\n      else if (\"object\" == typeof s) {\n        const c = s.prop, l = a[c], r = s.map.get(l);\n        switch (e) {\n          case \"load\":\n            n = new r(null, i);\n            break;\n          case \"create\":\n          case \"create-including-disabled\":\n            n = new r(a, i);\n        }\n      }\n      switch (e) {\n        case \"load\":\n          n._LoadFromJson(a), t.push(n);\n          break;\n        case \"create\":\n          if (\"function\" == typeof n.GetEnable && !n.GetEnable()) return n.Release();\n          t.push(n);\n          break;\n        case \"create-including-disabled\":\n          t.push(n);\n      }\n    }\n  };\n}\n{\n  const C32 = self.C3, NAME = 0, TOTAL_TIME = 1, STEP = 2, INTERPOLATION_MODE = 3, RESULT_MODE = 4, TRACKS = 5, LOOP = 6, PING_PONG = 7, REPEAT_COUNT = 8, START_ON_LAYOUT = 9, TRANSFORM_WITH_SCENE_GRAPH = 10, USE_SYSTEM_TIMESCALE = 11;\n  C32.TimelineDataItem = class {\n    constructor(t) {\n      this._name = \"\", this._totalTime = NaN, this._step = 0, this._interpolationMode = \"default\", this._resultMode = \"default\", this._loop = false, this._pingPong = false, this._repeatCount = 1, this._trackData = null, this._startOnLayout = \"\", this._transformWithSceneGraph = false, this._useSystemTimescale = true, t && (this._name = t[NAME], this._totalTime = t[TOTAL_TIME], this._step = t[STEP], this._interpolationMode = t[INTERPOLATION_MODE], this._resultMode = t[RESULT_MODE], this._loop = !!t[LOOP], this._pingPong = !!t[PING_PONG], this._repeatCount = t[REPEAT_COUNT], this._startOnLayout = t[START_ON_LAYOUT], this._transformWithSceneGraph = !!t[TRANSFORM_WITH_SCENE_GRAPH], this._useSystemTimescale = !!t[USE_SYSTEM_TIMESCALE], this._trackData = new C32.TrackData(t[TRACKS], this));\n    }\n    Release() {\n      this._trackData.Release(), this._trackData = null;\n    }\n    GetTrackData() {\n      return this._trackData || (this._trackData = new C32.TrackData(null, this)), this._trackData;\n    }\n    GetName() {\n      return this._name;\n    }\n    SetName(t) {\n      this._name = t;\n    }\n    GetTotalTime() {\n      return this._totalTime;\n    }\n    SetTotalTime(t) {\n      this._totalTime = t;\n    }\n    GetStep() {\n      return this._step;\n    }\n    SetStep(t) {\n      this._step = t;\n    }\n    GetInterpolationMode() {\n      return this._interpolationMode;\n    }\n    SetInterpolationMode(t) {\n      this._interpolationMode = t;\n    }\n    GetResultMode() {\n      return this._resultMode;\n    }\n    SetResultMode(t) {\n      this._resultMode = t;\n    }\n    GetLoop() {\n      return this._loop;\n    }\n    SetLoop(t) {\n      this._loop = t;\n    }\n    GetPingPong() {\n      return this._pingPong;\n    }\n    SetPingPong(t) {\n      this._pingPong = t;\n    }\n    GetRepeatCount() {\n      return this._repeatCount;\n    }\n    SetRepeatCount(t) {\n      this._repeatCount = t;\n    }\n    GetStartOnLayout() {\n      return this._startOnLayout;\n    }\n    GetTransformWithSceneGraph() {\n      return this._transformWithSceneGraph;\n    }\n    GetUseSystemTimescale() {\n      return this._useSystemTimescale;\n    }\n    _SaveToJson() {\n      return { \"trackDataJson\": this._trackData._SaveToJson(), \"name\": this._name, \"totalTime\": this._totalTime, \"step\": this._step, \"interpolationMode\": this._interpolationMode, \"resultMode\": this._resultMode, \"loop\": this._loop, \"pingPong\": this._pingPong, \"repeatCount\": this._repeatCount, \"startOnLayout\": this._startOnLayout, \"transformWithSceneGraph\": !!this._transformWithSceneGraph, \"useSystemTimescale\": this._useSystemTimescale };\n    }\n    _LoadFromJson(t) {\n      t && (this.GetTrackData()._LoadFromJson(t[\"trackDataJson\"]), this._name = t[\"name\"], this._totalTime = t[\"totalTime\"], this._step = t[\"step\"], this._interpolationMode = t[\"interpolationMode\"], this._resultMode = t[\"resultMode\"], this._loop = t[\"loop\"], this._pingPong = t[\"pingPong\"], this._repeatCount = t[\"repeatCount\"], this._startOnLayout = t[\"startOnLayout\"], this._transformWithSceneGraph = !!t[\"transformWithSceneGraph\"], this._useSystemTimescale = !!t[\"useSystemTimescale\"]);\n    }\n  };\n}\n{\n  const C32 = self.C3, WI_DATA = 0, OC_INDEX = 1, WI_UID = 2, INTERPOLATION_MODE = 1, RESULT_MODE = 2, ENABLED = 3, KEYFRAMES = 4, PROPERTY_TRACKS = 5, ID = 6, NESTED_DATA = 7, START_OFFSET = 0, LOCAL_TOTAL_TIME = 1, WI_ADDITIONAL_DATA = 8, ORIGINAL_WIDTH = 0, ORIGINAL_HEIGHT = 1, TRACK_TYPE = 9, TRACK_NAME = 10;\n  class TrackDataItem {\n    constructor(t, a) {\n      this._trackData = a, this._instanceData = null, this._additionalInstanceData = null, this._instanceUid = NaN, this._objectClassIndex = NaN, this._interpolationMode = \"default\", this._resultMode = \"default\", this._enabled = false, this._keyframeData = null, this._propertyTrackData = null, this._id = \"\", this._nestedData = null, this._startOffset = 0, this._localTotalTime = this._trackData.GetTimelineDataItem().GetTotalTime(), this._type = 0, this._name = \"\", t && (t[WI_DATA] && (this._instanceData = t[WI_DATA], this._instanceUid = t[WI_DATA][WI_UID], this._objectClassIndex = t[WI_DATA][OC_INDEX]), this._interpolationMode = t[INTERPOLATION_MODE], this._resultMode = t[RESULT_MODE], this._enabled = !!t[ENABLED], t[ID] && (this._id = t[ID]), t[NESTED_DATA] && (this._nestedData = t[NESTED_DATA], this._startOffset = t[NESTED_DATA][START_OFFSET], this._localTotalTime = t[NESTED_DATA][LOCAL_TOTAL_TIME]), t[WI_ADDITIONAL_DATA] && (this._additionalInstanceData = t[WI_ADDITIONAL_DATA]), t[WI_ADDITIONAL_DATA] && (this._additionalInstanceData = t[WI_ADDITIONAL_DATA]), t[TRACK_TYPE] && (this._type = t[TRACK_TYPE]), t[TRACK_NAME] && (this._name = t[TRACK_NAME]), this._keyframeData = new C32.KeyframeData(t[KEYFRAMES], this), this._propertyTrackData = new C32.PropertyTrackData(t[PROPERTY_TRACKS], this));\n    }\n    Release() {\n      this._instanceData = null, this._trackData = null, this._keyframeData && (this._keyframeData.Release(), this._keyframeData = null), this._propertyTrackData && (this._propertyTrackData.Release(), this._propertyTrackData = null), this._nestedData = null;\n    }\n    GetTrackData() {\n      return this._trackData;\n    }\n    GetKeyframeData() {\n      return this._keyframeData || (this._keyframeData = new C32.KeyframeData(null, this)), this._keyframeData;\n    }\n    GetPropertyTrackData() {\n      return this._propertyTrackData || (this._propertyTrackData = new C32.PropertyTrackData(null, this)), this._propertyTrackData;\n    }\n    GetInstanceData() {\n      return this._instanceData;\n    }\n    GetObjectClassIndex() {\n      return this._objectClassIndex;\n    }\n    SetObjectClassIndex(t) {\n      this._objectClassIndex = t;\n    }\n    GetInstanceUID() {\n      return this._instanceUid;\n    }\n    SetInstanceUID(t) {\n      this._instanceUid = t;\n    }\n    GetInterpolationMode() {\n      return this._interpolationMode;\n    }\n    SetInterpolationMode(t) {\n      this._interpolationMode = t;\n    }\n    GetResultMode() {\n      return this._resultMode;\n    }\n    SetResultMode(t) {\n      this._resultMode = t;\n    }\n    GetEnable() {\n      return this._enabled;\n    }\n    SetEnable(t) {\n      this._enabled = !!t;\n    }\n    GetId() {\n      return this._id;\n    }\n    GetStartOffset() {\n      return this._startOffset;\n    }\n    GetLocalTotalTime() {\n      return this._localTotalTime;\n    }\n    SetLocalTotalTime(t) {\n      this._localTotalTime = t;\n    }\n    GetOriginalWidth() {\n      return this._additionalInstanceData[ORIGINAL_WIDTH];\n    }\n    SetOriginalWidth(t) {\n      this._additionalInstanceData || (this._additionalInstanceData = []), this._additionalInstanceData[ORIGINAL_WIDTH] = t;\n    }\n    GetOriginalHeight() {\n      return this._additionalInstanceData || (this._additionalInstanceData = []), this._additionalInstanceData[ORIGINAL_HEIGHT];\n    }\n    SetOriginalHeight(t) {\n      this._additionalInstanceData || (this._additionalInstanceData = []), this._additionalInstanceData[ORIGINAL_HEIGHT] = t;\n    }\n    GetType() {\n      return this._type;\n    }\n    GetName() {\n      return this._name;\n    }\n    _SaveToJson() {\n      return { \"keyframeDataJson\": this._keyframeData._SaveToJson(), \"propertyTrackDataJson\": this._propertyTrackData._SaveToJson(), \"instanceData\": this._instanceData, \"additionalInstanceData\": this._additionalInstanceData, \"instanceUid\": this._instanceUid, \"objectClassIndex\": this._objectClassIndex, \"interpolationMode\": this._interpolationMode, \"resultMode\": this._resultMode, \"enabled\": this._enabled, \"id\": this._id, \"nestedData\": this._nestedData, \"type\": this._type, \"name\": this._name };\n    }\n    _LoadFromJson(t) {\n      t && (this._instanceData = t[\"instanceData\"], this._instanceUid = t[\"instanceUid\"], this._objectClassIndex = t[\"objectClassIndex\"], this._interpolationMode = t[\"interpolationMode\"], this._resultMode = t[\"resultMode\"], this._enabled = t[\"enabled\"], this._id = t[\"id\"], this._type = t[\"type\"] || 0, this._name = t[\"name\"] || \"\", this._localTotalTime = this._trackData.GetTimelineDataItem().GetTotalTime(), t[\"nestedData\"] && (this._nestedData = t[\"nestedData\"], this._startOffset = this._nestedData[START_OFFSET], this._localTotalTime = this._nestedData[LOCAL_TOTAL_TIME]), t[\"additionalInstanceData\"] && (this._additionalInstanceData = t[\"additionalInstanceData\"]), this.GetKeyframeData()._LoadFromJson(t[\"keyframeDataJson\"]), this.GetPropertyTrackData()._LoadFromJson(t[\"propertyTrackDataJson\"]));\n    }\n  }\n  C32.TrackData = class {\n    constructor(t, a) {\n      this._timelineDataItem = a, this._trackDataItems = [], C32.TimelineDataManager._CreateDataItems(this._trackDataItems, t, TrackDataItem, this);\n    }\n    Release() {\n      this._timelineDataItem = null;\n      for (const t of this._trackDataItems) t.Release();\n      C32.clearArray(this._trackDataItems), this._trackDataItems = null;\n    }\n    GetTimelineDataItem() {\n      return this._timelineDataItem;\n    }\n    AddEmptyTrackDataItem() {\n      const t = new TrackDataItem(null, this);\n      return this._trackDataItems.push(t), t;\n    }\n    GetFirstKeyframeDataItem(t) {\n      return t.GetKeyframeData().GetKeyframeDataItemArray()[0];\n    }\n    GetLastKeyframeDataItem(t) {\n      const a = t.GetKeyframeData().GetKeyframeDataItemArray();\n      return a.at(-1);\n    }\n    GetKeyFrameDataItemAtTime(a, t) {\n      const e = t.GetKeyframeData().GetKeyframeDataItemArray(), s = e.length;\n      for (let t2 = 0; t2 < s; t2++) {\n        const i = e[t2];\n        if (i.GetTime() === a) return i;\n      }\n    }\n    GetFirstKeyFrameDataItemHigherThan(a, t) {\n      const e = t.GetKeyframeData().GetKeyframeDataItemArray(), s = e.length;\n      for (let t2 = 0; t2 < s; t2++) {\n        const i = e[t2];\n        if (i.GetTime() > a) return i;\n      }\n    }\n    GetFirstKeyFrameDataItemHigherOrEqualThan(a, t) {\n      const e = t.GetKeyframeData().GetKeyframeDataItemArray(), s = e.length;\n      for (let t2 = 0; t2 < s; t2++) {\n        const i = e[t2];\n        if (i.GetTime() >= a) return i;\n      }\n    }\n    GetFirstKeyFrameDataItemLowerOrEqualThan(a, t) {\n      const e = t.GetKeyframeData().GetKeyframeDataItemArray();\n      for (let t2 = e.length - 1; 0 <= t2; t2--) {\n        const s = e[t2];\n        if (s.GetTime() <= a) return s;\n      }\n    }\n    *trackDataItems() {\n      for (const t of this._trackDataItems) yield t;\n    }\n    _SaveToJson() {\n      return { \"trackDataItemsJson\": this._trackDataItems.map((t) => t._SaveToJson()) };\n    }\n    _LoadFromJson(t) {\n      t && C32.TimelineDataManager._LoadDataItemsFromJson(this._trackDataItems, t[\"trackDataItemsJson\"], TrackDataItem, this);\n    }\n  };\n}\n{\n  const C32 = self.C3, SOURCE_DATA = 0, SOURCE = 0, PROPERTY = 1, TYPE = 2, MIN = 3, MAX = 4, INTERPOLATION_MODE = 5, RESULT_MODE = 6, ENABLED = 7, PROPERTY_KEYFRAMES = 8, CAN_HAVE_PROPERTY_KEYFRAMES = 9;\n  class PropertyTrackDataItem {\n    constructor(t, e) {\n      this._propertyTrackData = e, this._sourceAdapterId = \"\", this._sourceAdapterArguments = null, this._property = null, this._type = null, this._min = NaN, this._max = NaN, this._interpolationMode = \"default\", this._resultMode = \"default\", this._enabled = false, this._propertyKeyframeData = null, this._canHavePropertyKeyframes = true, t && (this._sourceAdapterId = t[SOURCE_DATA][SOURCE], this._sourceAdapterArguments = t[SOURCE_DATA].slice(1), this._property = t[PROPERTY], this._type = t[TYPE], this._min = t[MIN], this._max = t[MAX], this._interpolationMode = t[INTERPOLATION_MODE], this._resultMode = t[RESULT_MODE], this._enabled = !!t[ENABLED], this._propertyKeyframeData = new C32.PropertyKeyframeData(t[PROPERTY_KEYFRAMES], this), this._canHavePropertyKeyframes = t[CAN_HAVE_PROPERTY_KEYFRAMES]);\n    }\n    Release() {\n      this._propertyKeyframeData.Release(), this._propertyKeyframeData = null, this._propertyTrackData = null, this._sourceAdapterArguments = null;\n    }\n    GetPropertyTrackData() {\n      return this._propertyTrackData;\n    }\n    GetPropertyKeyframeData() {\n      return this._propertyKeyframeData || (this._propertyKeyframeData = new C32.PropertyKeyframeData(null, this)), this._propertyKeyframeData;\n    }\n    GetSourceAdapterId() {\n      return this._sourceAdapterId;\n    }\n    SetSourceAdapterId(t) {\n      this._sourceAdapterId = t;\n    }\n    GetSourceAdapterArguments() {\n      return this._sourceAdapterArguments;\n    }\n    SetSourceAdapterArguments(t) {\n      this._sourceAdapterArguments = t;\n    }\n    GetProperty() {\n      return this._property;\n    }\n    SetProperty(t) {\n      this._property = t;\n    }\n    GetType() {\n      return this._type;\n    }\n    SetType(t) {\n      this._type = t;\n    }\n    GetMin() {\n      return this._min;\n    }\n    SetMin(t) {\n      this._min = t;\n    }\n    GetMax() {\n      return this._max;\n    }\n    SetMax(t) {\n      this._max = t;\n    }\n    GetInterpolationMode() {\n      return this._interpolationMode;\n    }\n    SetInterpolationMode(t) {\n      this._interpolationMode = t;\n    }\n    GetResultMode() {\n      return this._resultMode;\n    }\n    SetResultMode(t) {\n      this._resultMode = t;\n    }\n    GetEnable() {\n      return this._enabled;\n    }\n    SetEnable(t) {\n      this._enabled = !!t;\n    }\n    CanHavePropertyKeyframes() {\n      return !!this._canHavePropertyKeyframes;\n    }\n    _SaveToJson() {\n      return { \"propertyKeyframeDataJson\": this._propertyKeyframeData._SaveToJson(), \"sourceAdapterId\": this._sourceAdapterId, \"sourceAdapterArguments\": this._sourceAdapterArguments, \"property\": this._property, \"type\": this._type, \"min\": this._min, \"max\": this._max, \"interpolationMode\": this._interpolationMode, \"resultMode\": this._resultMode, \"enabled\": this._enabled, \"canHavePropertyKeyframes\": this._canHavePropertyKeyframes };\n    }\n    _LoadFromJson(t) {\n      t && (this._sourceAdapterId = t[\"sourceAdapterId\"], this._sourceAdapterArguments = t[\"sourceAdapterArguments\"], this._property = t[\"property\"], this._type = t[\"type\"], this._min = t[\"min\"], this._max = t[\"max\"], this._interpolationMode = t[\"interpolationMode\"], this._resultMode = t[\"resultMode\"], this._enabled = t[\"enabled\"], this._canHavePropertyKeyframes = t[\"canHavePropertyKeyframes\"], this.GetPropertyKeyframeData()._LoadFromJson(t[\"propertyKeyframeDataJson\"]));\n    }\n  }\n  C32.PropertyTrackData = class {\n    constructor(t, e) {\n      this._trackDataItem = e, this._propertyTrackDataItems = [], C32.TimelineDataManager._CreateDataItems(this._propertyTrackDataItems, t, PropertyTrackDataItem, this);\n    }\n    Release() {\n      this._trackDataItem = null;\n      for (const t of this._propertyTrackDataItems) t.Release();\n      C32.clearArray(this._propertyTrackDataItems), this._propertyTrackDataItems = null;\n    }\n    GetTrackDataItem() {\n      return this._trackDataItem;\n    }\n    AddEmptyPropertyTrackDataItem() {\n      const t = new PropertyTrackDataItem(null, this);\n      return this._propertyTrackDataItems.push(t), t;\n    }\n    GetFirstPropertyKeyframeDataItem(t) {\n      const e = t.GetPropertyKeyframeData();\n      return e.GetPropertyKeyframeDataItemArray()[0];\n    }\n    GetLastPropertyKeyframeDataItem(t) {\n      const e = t.GetPropertyKeyframeData(), r = e.GetPropertyKeyframeDataItemArray();\n      return r.at(-1);\n    }\n    GetPropertyKeyFrameDataItemAtTime(e, t) {\n      const r = t.GetPropertyKeyframeData(), a = r.GetPropertyKeyframeDataItemArray(), s = a.length;\n      for (let t2 = 0; t2 < s; t2++) {\n        const o = a[t2];\n        if (o.GetTime() === e) return o;\n      }\n    }\n    GetFirstPropertyKeyFrameDataItemHigherThan(e, t) {\n      const r = t.GetPropertyKeyframeData(), a = r.GetPropertyKeyframeDataItemArray(), s = a.length;\n      for (let t2 = 0; t2 < s; t2++) {\n        const o = a[t2];\n        if (o.GetTime() > e) return o;\n      }\n    }\n    GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(e, t) {\n      const r = t.GetPropertyKeyframeData(), a = r.GetPropertyKeyframeDataItemArray(), s = a.length;\n      for (let t2 = 0; t2 < s; t2++) {\n        const o = a[t2];\n        if (o.GetTime() >= e) return o;\n      }\n    }\n    GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, t) {\n      const r = t.GetPropertyKeyframeData(), a = r.GetPropertyKeyframeDataItemArray();\n      for (let t2 = a.length - 1; 0 <= t2; t2--) {\n        const s = a[t2];\n        if (s.GetTime() <= e) return s;\n      }\n    }\n    *propertyTrackDataItems() {\n      for (const t of this._propertyTrackDataItems) yield t;\n    }\n    _SaveToJson() {\n      return { \"propertyTrackDataItemsJson\": this._propertyTrackDataItems.map((t) => t._SaveToJson()) };\n    }\n    _LoadFromJson(t) {\n      t && C32.TimelineDataManager._LoadDataItemsFromJson(this._propertyTrackDataItems, t[\"propertyTrackDataItemsJson\"], PropertyTrackDataItem, this);\n    }\n  };\n}\n{\n  const C32 = self.C3, TIME = 0, EASE = 1, ENABLE = 2, TAGS = 3;\n  class KeyframeDataItem {\n    constructor(e, t) {\n      if (this._keyframeData = t, this._time = -1, this._ease = \"noease\", this._enable = false, this._tags = null, this._lowerTags = null, e) {\n        this._time = e[TIME], this._ease = e[EASE], this._enable = !!e[ENABLE];\n        const a = e[TAGS];\n        this._tags = a ? a.split(\" \") : [], this._lowerTags = new Set(this._tags.map((e2) => e2.toLowerCase())), this._next = null;\n      }\n    }\n    Release() {\n      this._keyframeData = null, C32.clearArray(this._tags), this._tags = null, this._lowerTags.clear(), this._lowerTags = null, this._next = null;\n    }\n    GetKeyframeData() {\n      return this._keyframeData;\n    }\n    GetNext() {\n      return this._next;\n    }\n    SetNext(e) {\n      this._next = e;\n    }\n    GetTime() {\n      return this._time;\n    }\n    SetTime(e) {\n      this._time = e, this._keyframeData._LinkKeyframeDataItems();\n    }\n    GetEase() {\n      return this._ease;\n    }\n    SetEase(e) {\n      this._ease = e;\n    }\n    GetEnable() {\n      return this._enable;\n    }\n    SetEnable(e) {\n      this._enable = !!e;\n    }\n    GetTags() {\n      return this._tags;\n    }\n    SetTags(e) {\n      this._tags = e ? e.split(\" \") : [], this._lowerTags = new Set(this._tags.map((e2) => e2.toLowerCase()));\n    }\n    GetLowerTags() {\n      return this._lowerTags;\n    }\n    HasTag(e) {\n      return this._lowerTags.has(e.toLowerCase());\n    }\n    _SaveToJson() {\n      return { \"time\": this._time, \"ease\": this._ease, \"enable\": this._enable, \"tags\": this._tags };\n    }\n    _LoadFromJson(e) {\n      e && (this._time = e[\"time\"], this._ease = e[\"ease\"], this._enable = e[\"enable\"], this._tags = e[\"tags\"], this._lowerTags = new Set(this._tags.map((e2) => e2.toLowerCase())));\n    }\n  }\n  C32.KeyframeData = class {\n    constructor(e, t) {\n      this._trackDataItem = t, this._keyframeDataItems = [], C32.TimelineDataManager._CreateDataItems(this._keyframeDataItems, e, KeyframeDataItem, this), this._LinkKeyframeDataItems();\n    }\n    Release() {\n      this._trackDataItem = null;\n      for (const e of this._keyframeDataItems) e.Release();\n      C32.clearArray(this._keyframeDataItems), this._keyframeDataItems = null;\n    }\n    _LinkKeyframeDataItems() {\n      this._keyframeDataItems.sort((e, t) => e.GetTime() - t.GetTime());\n      for (let e = 0; e < this._keyframeDataItems.length; e++) {\n        const t = this._keyframeDataItems[e];\n        t.SetNext(this._keyframeDataItems[e + 1]);\n      }\n    }\n    GetTrackDataItem() {\n      return this._trackDataItem;\n    }\n    GetKeyframeDataItemCount() {\n      return this._keyframeDataItems.length;\n    }\n    GetKeyframeDataItemArray() {\n      return this._keyframeDataItems;\n    }\n    AddEmptyKeyframeDataItem() {\n      const e = new KeyframeDataItem(null, this);\n      return this._keyframeDataItems.push(e), this._LinkKeyframeDataItems(), e;\n    }\n    DeleteKeyframeDataItems(e) {\n      for (const t of this._keyframeDataItems) if (e(t)) {\n        const a = this._keyframeDataItems.indexOf(t);\n        -1 !== a && (t.Release(), this._keyframeDataItems.splice(a, 1));\n      }\n      this.SortKeyframeDataItems(), this._LinkKeyframeDataItems();\n    }\n    SortKeyframeDataItems() {\n      this._keyframeDataItems.sort((e, t) => e.GetTime() - t.GetTime());\n    }\n    GetKeyframeDataItemIndex(e) {\n      return this._keyframeDataItems.indexOf(e);\n    }\n    GetKeyframeDataItemFromIndex(e) {\n      return this._keyframeDataItems[e];\n    }\n    *keyframeDataItems() {\n      for (const e of this._keyframeDataItems) yield e;\n    }\n    *keyframeDataItemsReverse() {\n      for (let e = this._keyframeDataItems.length - 1; 0 <= e; e--) yield this._keyframeDataItems[e];\n    }\n    _SaveToJson() {\n      return { \"keyframeDataItemsJson\": this._keyframeDataItems.map((e) => e._SaveToJson()) };\n    }\n    _LoadFromJson(e) {\n      e && (C32.TimelineDataManager._LoadDataItemsFromJson(this._keyframeDataItems, e[\"keyframeDataItemsJson\"], KeyframeDataItem, this), this._LinkKeyframeDataItems());\n    }\n  };\n}\n{\n  const C32 = self.C3, VALUE_DATA = 0, VALUE_DATA_VALUE = 0, VALUE_DATA_ABSOLUTE_VALUE = 1, VALUE_DATA_TYPE = 2, TIME = 1, EASE = 2, ENABLE = 3, ADDONS = 4, PATH_MODE = 5;\n  class PropertyKeyframeDataItem {\n    constructor(e, t) {\n      this._propertyKeyframeData = t, this._value = null, this._aValue = null, this._type = \"\", this._time = NaN, this._ease = \"noease\", this._enable = false, this._addonData = null, this._addonInstance = void 0, this._pathMode = \"line\", e && (this._value = e[VALUE_DATA][VALUE_DATA_VALUE], this._aValue = e[VALUE_DATA][VALUE_DATA_ABSOLUTE_VALUE], this._type = e[VALUE_DATA][VALUE_DATA_TYPE], this._time = e[TIME], this._ease = e[EASE], this._enable = !!e[ENABLE], this._pathMode = e[PATH_MODE], this._addonData = null, e[ADDONS] && (this._addonData = new C32.AddonData(e[ADDONS], this)), this._next = null, this._prev = null);\n    }\n    Release() {\n      this._propertyKeyframeData = null, this._addonData && (this._addonData.Release(), this._addonData = null), this._next = null, this._prev = null;\n    }\n    GetAddonData() {\n      return this._addonData;\n    }\n    SetNext(e) {\n      this._next = e;\n    }\n    GetNext() {\n      return this._next;\n    }\n    SetPrevious(e) {\n      this._prev = e;\n    }\n    GetPrevious() {\n      return this._prev;\n    }\n    GetValue() {\n      return this._value;\n    }\n    SetValue(e) {\n      \"color\" === this._type && C32.IsFiniteNumber(e) ? (this._value[0] = C32.GetRValue(e), this._value[1] = C32.GetGValue(e), this._value[2] = C32.GetBValue(e)) : this._value = e;\n    }\n    GetAbsoluteValue() {\n      return this._aValue;\n    }\n    SetAbsoluteValue(e) {\n      \"color\" === this._type && C32.IsFiniteNumber(e) ? (this._aValue[0] = C32.GetRValue(e), this._aValue[1] = C32.GetGValue(e), this._aValue[2] = C32.GetBValue(e)) : this._aValue = e;\n    }\n    GetValueWithResultMode() {\n      const e = this._propertyKeyframeData.GetPropertyTrackDataItem().GetResultMode();\n      return \"relative\" === e ? this.GetValue() : \"absolute\" === e ? this.GetAbsoluteValue() : void 0;\n    }\n    GetType() {\n      return this._type;\n    }\n    SetType(e) {\n      this._type = e;\n    }\n    GetTime() {\n      return this._time;\n    }\n    SetTime(e) {\n      this._time = e, this._propertyKeyframeData._LinkPropertyKeyframeDataItems();\n    }\n    GetEase() {\n      return this._ease;\n    }\n    SetEase(e) {\n      this._ease = e;\n    }\n    GetEnable() {\n      return this._enable;\n    }\n    SetEnable(e) {\n      this._enable = !!e;\n    }\n    GetPathMode() {\n      return this._pathMode;\n    }\n    GetAddOn(t) {\n      if (this._addonData) {\n        if (!this._addonInstance && null !== this._addonInstance) {\n          const a = this._addonData.GetAddDataItemArray();\n          if (a) {\n            const r = a.length;\n            for (let e = 0; e < r; e++) {\n              const s = a[e];\n              if (s.GetId() === t) return this._addonInstance = s, this._addonInstance;\n            }\n          }\n          this._addonInstance = null;\n        }\n        return this._addonInstance;\n      }\n    }\n    _SaveToJson() {\n      const e = this._addonData;\n      return { \"addonDataJson\": e && e._SaveToJson(), \"value\": this._value, \"aValue\": this._aValue, \"type\": this._type, \"time\": this._time, \"ease\": this._ease, \"enable\": this._enable };\n    }\n    _LoadFromJson(e) {\n      e && (e[\"addonDataJson\"] && this._addonData._SetFromJson(e[\"addonDataJson\"]), this._value = e[\"value\"], this._aValue = e[\"aValue\"], this._type = e[\"type\"], this._time = e[\"time\"], this._ease = e[\"ease\"], this._enable = e[\"enable\"]);\n    }\n  }\n  C32.PropertyKeyframeData = class {\n    constructor(e, t) {\n      this._propertyTrackDataItem = t, this._propertyKeyframeDataItems = [], this._propertyKeyframeDataItemsIncludingDisabled = [], C32.TimelineDataManager._CreateDataItems(this._propertyKeyframeDataItems, e, PropertyKeyframeDataItem, this), C32.TimelineDataManager._CreateDataItemsIncludingDisabled(this._propertyKeyframeDataItemsIncludingDisabled, e, PropertyKeyframeDataItem, this), this._LinkPropertyKeyframeDataItems();\n    }\n    Release() {\n      this._propertyTrackDataItem = null;\n      for (const e of this._propertyKeyframeDataItems) e.Release();\n      C32.clearArray(this._propertyKeyframeDataItems), this._propertyKeyframeDataItems = null;\n      for (const t of this._propertyKeyframeDataItemsIncludingDisabled) t.Release();\n      C32.clearArray(this._propertyKeyframeDataItemsIncludingDisabled), this._propertyKeyframeDataItemsIncludingDisabled = null;\n    }\n    _LinkPropertyKeyframeDataItems() {\n      let t = this._propertyKeyframeDataItems;\n      t.sort((e, t2) => e.GetTime() - t2.GetTime());\n      for (let e = 0; e < t.length; e++) {\n        const a = t[e];\n        e + 1 < t.length && a.SetNext(t[e + 1]), 0 <= e - 1 && a.SetPrevious(t[e - 1]);\n      }\n      (t = this._propertyKeyframeDataItemsIncludingDisabled).sort((e, t2) => e.GetTime() - t2.GetTime());\n      for (let e = 0; e < t.length; e++) {\n        const r = t[e];\n        e + 1 < t.length && r.SetNext(t[e + 1]), 0 <= e - 1 && r.SetPrevious(t[e - 1]);\n      }\n    }\n    AddEmptyPropertyKeyframeDataItem() {\n      const e = new PropertyKeyframeDataItem(null, this);\n      return this._propertyKeyframeDataItems.push(e), this._LinkPropertyKeyframeDataItems(), e;\n    }\n    DeletePropertyKeyframeDataItems(e) {\n      for (const t of this._propertyKeyframeDataItems) if (e(t)) {\n        const a = this._propertyKeyframeDataItems.indexOf(t);\n        -1 !== a && (t.Release(), this._propertyKeyframeDataItems.splice(a, 1));\n      }\n      this.SortPropertyKeyFrameDataItems(), this._LinkPropertyKeyframeDataItems();\n    }\n    SortPropertyKeyFrameDataItems() {\n      this._propertyKeyframeDataItems.sort((e, t) => e.GetTime() - t.GetTime());\n    }\n    GetPropertyTrackDataItem() {\n      return this._propertyTrackDataItem;\n    }\n    GetPropertyKeyframeDataItemCount() {\n      return this._propertyKeyframeDataItems.length;\n    }\n    GetLastPropertyKeyframeDataItem() {\n      return this._propertyKeyframeDataItems[this._propertyKeyframeDataItems.length - 1];\n    }\n    GetPropertyKeyframeDataItemArray() {\n      return this._propertyKeyframeDataItems;\n    }\n    GetPropertyKeyframeDataItemArrayIncludingDisabled() {\n      return this._propertyKeyframeDataItemsIncludingDisabled;\n    }\n    *propertyKeyframeDataItems() {\n      for (const e of this._propertyKeyframeDataItems) yield e;\n    }\n    *propertyKeyframeDataItemsReverse() {\n      for (let e = this._propertyKeyframeDataItems.length - 1; 0 <= e; e--) yield this._propertyKeyframeDataItems[e];\n    }\n    _SaveToJson() {\n      const e = this._propertyKeyframeDataItems, t = this._propertyKeyframeDataItemsIncludingDisabled;\n      return { \"propertyKeyframeDataItemsJson\": e.map((e2) => e2._SaveToJson()), \"propertyKeyframeDataItemsIncludingDisabledJson\": t.map((e2) => e2._SaveToJson()) };\n    }\n    _LoadFromJson(e) {\n      e && (C32.TimelineDataManager._LoadDataItemsFromJson(this._propertyKeyframeDataItems, e[\"propertyKeyframeDataItemsJson\"], PropertyKeyframeDataItem, this), C32.TimelineDataManager._LoadDataItemsFromJson(this._propertyKeyframeDataItemsIncludingDisabled, e[\"propertyKeyframeDataItemsIncludingDisabledJson\"], PropertyKeyframeDataItem, this), this._LinkPropertyKeyframeDataItems());\n    }\n  };\n}\n{\n  const C32 = self.C3, ADDON_ID = 0, ADDON_DATA = 1;\n  class AddonDataItem {\n    constructor(t, a) {\n      this._addonData = a, this._id = t[ADDON_ID], this._data = t[ADDON_DATA];\n    }\n    Release() {\n      this._addonData = null, this._data = null;\n    }\n    GetAddonData() {\n      return this._addonData;\n    }\n    GetId() {\n      return this._id;\n    }\n    _SaveToJson() {\n      return { \"id\": this._id, \"data\": this._data };\n    }\n    _LoadFromJson(t) {\n      t && (this._id = t[\"id\"], this._data = t[\"data\"]);\n    }\n  }\n  const START_ANCHOR = 0, START_ENABLE = 1, END_ANCHOR = 2, END_ENABLE = 3;\n  class AddonDataCubicBezierItem extends AddonDataItem {\n    constructor(t, a) {\n      super(t, a), this._startAnchor = this._data[START_ANCHOR], this._startEnable = !!this._data[START_ENABLE], this._endAnchor = this._data[END_ANCHOR], this._endEnable = !!this._data[END_ENABLE];\n    }\n    Release() {\n      super.Release();\n    }\n    GetStartAnchor() {\n      return this._startAnchor;\n    }\n    GetStartEnable() {\n      return this._startEnable;\n    }\n    GetEndAnchor() {\n      return this._endAnchor;\n    }\n    GetEndEnable() {\n      return this._endEnable;\n    }\n    _SaveToJson() {\n      return Object.assign(super._SaveToJson(), { \"startAnchor\": this._startAnchor, \"startEnable\": !!this._startEnable, \"endAnchor\": this._endAnchor, \"endEnable\": !!this._endEnable });\n    }\n    _LoadFromJson(t) {\n      t && (super._LoadFromJson(t), this._startAnchor = t[\"startAnchor\"], this._startEnable = !!t[\"startEnable\"], this._endAnchor = t[\"endAnchor\"], this._endEnable = !!t[\"endEnable\"]);\n    }\n  }\n  const DIRECTION = 0, REVOLUTIONS = 1;\n  class AddonDataAngleItem extends AddonDataItem {\n    constructor(t, a) {\n      super(t, a), this._direction = this._data[DIRECTION], this._revolutions = this._data[REVOLUTIONS];\n    }\n    Release() {\n      super.Release();\n    }\n    GetDirection() {\n      return this._direction;\n    }\n    GetRevolutions() {\n      return this._revolutions;\n    }\n    _SaveToJson() {\n      return Object.assign(super._SaveToJson(), { \"direction\": this._direction, \"revolutions\": this._revolutions });\n    }\n    _LoadFromJson(t) {\n      t && (super._LoadFromJson(t), this._direction = t[\"direction\"], this._revolutions = t[\"revolutions\"]);\n    }\n  }\n  C32.AddonData = class {\n    constructor(t, a) {\n      this._propertyKeyframeDataItem = a, this._addonDataItems = [], C32.TimelineDataManager._CreateDataItems(this._addonDataItems, t, { prop: 0, map: /* @__PURE__ */ new Map([[\"cubic-bezier\", AddonDataCubicBezierItem], [\"angle\", AddonDataAngleItem]]) }, this);\n    }\n    Release() {\n      this._propertyKeyframeDataItem = null;\n      for (const t of this._addonDataItems) t.Release();\n      C32.clearArray(this._addonDataItems), this._addonDataItems = null;\n    }\n    GetPropertyKeyframeDataItem() {\n      return this._propertyKeyframeDataItem;\n    }\n    GetAddDataItemArray() {\n      return this._addonDataItems;\n    }\n    *addonDataItems() {\n      for (const t of this._addonDataItems) yield t;\n    }\n    _SaveToJson() {\n      return { \"addonDataItemsJson\": this._addonDataItems.map((t) => t._SaveToJson()) };\n    }\n    _LoadFromJson(t) {\n      t && C32.TimelineDataManager._LoadDataItemsFromJson(this._addonDataItems, t[\"addonDataItemsJson\"], { prop: \"id\", map: /* @__PURE__ */ new Map([[\"cubic-bezier\", AddonDataCubicBezierItem], [\"angle\", AddonDataAngleItem]]) }, this);\n    }\n  };\n}\n{\n  const C32 = self.C3, INITIAL_VALUE_MODE_START_VALUE = \"start-value\", INITIAL_VALUE_MODE_CURRENT_STATE = \"current-state\", PING_PONG_BEGIN = 0, PING_PONG_END = 1;\n  let createdTweens = 0;\n  C32.TweenState = class extends C32.TimelineState {\n    constructor(e, t) {\n      super(\"tween-\" + createdTweens++, e, t), this._id = \"\", this._destroyInstanceOnComplete = false, this._initialValueMode = INITIAL_VALUE_MODE_START_VALUE, this._instance = null, this._on_completed_callbacks = null, this._on_started_callbacks = null, this._track = null, this._iTweenState = null;\n    }\n    FireReleaseEvent(e) {\n      const t = C32.New(C32.Event, \"tweenstatereleased\");\n      t.tweenState = this, e.dispatchEvent(t);\n    }\n    GetType() {\n      return 1;\n    }\n    CreateTrackStates() {\n      for (const e of this._timelineDataItem.GetTrackData().trackDataItems()) this._tracks.push(C32.TweenTrackState.Create(this, e));\n      this._track = this._tracks[0];\n    }\n    AddTrack() {\n      const e = this._timelineDataItem.GetTrackData().AddEmptyTrackDataItem(), t = C32.TweenTrackState.Create(this, e);\n      return this._tracks.push(t), this._CacheTrack(), t;\n    }\n    _CacheTrack() {\n      this._track = this._tracks[0];\n    }\n    GetPropertyTrack(e) {\n      return this._track.GetPropertyTracks()[0];\n    }\n    SetPropertyType(e) {\n      this._propertyType = e;\n    }\n    GetInstance() {\n      const e = this.GetTracks();\n      if (e && e.length) {\n        const t = e[0];\n        if (this._track = t) {\n          const n = t.GetInstance();\n          return t.IsInstanceValid() ? n : void 0;\n        }\n      }\n    }\n    AddStartedCallback(e) {\n      this._on_started_callbacks || (this._on_started_callbacks = []), this._on_started_callbacks.push(e);\n    }\n    AddCompletedCallback(e) {\n      this._on_completed_callbacks || (this._on_completed_callbacks = []), this._on_completed_callbacks.push(e);\n    }\n    RemoveStartedCallback(e) {\n      if (this._on_started_callbacks) {\n        const t = this._on_started_callbacks.indexOf(e);\n        -1 !== t && this._on_started_callbacks.splice(t, 1);\n      }\n    }\n    RemoveCompletedCallback(e) {\n      if (this._on_completed_callbacks) {\n        const t = this._on_completed_callbacks.indexOf(e);\n        -1 !== t && this._on_completed_callbacks.splice(t, 1);\n      }\n    }\n    SetStartValue(e, t) {\n      for (const n of this._tracks) for (const s of n._propertyTracks) if (s.GetPropertyName() === t) {\n        const i = s.GetPropertyTrackData(), a = s.GetPropertyTrackDataItem(), r = i.GetFirstPropertyKeyframeDataItem(a);\n        r.SetValue(e), r.SetAbsoluteValue(e);\n      }\n    }\n    _GetPropertyTrackState(e) {\n      for (const t of this._tracks) for (const n of t._propertyTracks) if (n.GetPropertyName() === e) return n;\n    }\n    BeforeSetEndValues(e) {\n      for (const t of e) {\n        const n = this._GetPropertyTrackState(t);\n        this.SetStartValue(n.GetCurrentState(), t);\n      }\n      if (this.IsForwardPlayBack()) {\n        const s = this.GetTotalTime() - this.GetTime();\n        this.SetTotalTime(s);\n        for (const i of this._tracks) i.SetLocalTotalTime(s);\n        this._SetTime(0);\n      } else {\n        const a = this.GetTime();\n        this.SetTotalTime(a);\n        for (const r of this._tracks) r.SetLocalTotalTime(a);\n        this._SetTime(a);\n      }\n      this.SetInitialStateFromSetTime();\n    }\n    SetEndValue(e, t) {\n      const n = this._GetPropertyTrackState(t), s = n.GetPropertyTrackData(), i = n.GetPropertyTrackDataItem(), a = s.GetLastPropertyKeyframeDataItem(i);\n      a.SetTime(this.GetTotalTime()), a.SetValue(e), a.SetAbsoluteValue(e);\n    }\n    SetId(e) {\n      this._id = e;\n    }\n    GetId() {\n      return this._id;\n    }\n    SetInitialValueMode(e) {\n      this._initialValueMode = e;\n    }\n    GetInitialValueMode() {\n      return this._initialValueMode;\n    }\n    SetDestroyInstanceOnComplete(e) {\n      this._destroyInstanceOnComplete = e;\n    }\n    GetDestroyInstanceOnComplete() {\n      return this._destroyInstanceOnComplete;\n    }\n    OnStarted() {\n      if (this._on_started_callbacks) for (const e of this._on_started_callbacks) e(this);\n      if (!this.IsComplete()) for (const t of this._tracks) t.CompareSaveStateWithCurrent();\n    }\n    OnCompleted() {\n      this._completedTick = this._runtime.GetTickCount();\n    }\n    FinishTriggers() {\n      if (!this._finishedTriggers && (this._finishedTriggers = true, this._on_completed_callbacks)) for (const e of this._on_completed_callbacks) e(this);\n    }\n    SetTime(e) {\n      this._DeleteIntermediateKeyframes(), super.SetTime(e);\n    }\n    _SetTimeAndReset(e) {\n      (e = C32.IsFiniteNumber(e) ? e : this.GetTotalTime()) < 0 ? this._playheadTime = 0 : e >= this.GetTotalTime() ? this._playheadTime = this.GetTotalTime() : this._playheadTime = e, this._track.SetResetState();\n    }\n    SetInitialState(e) {\n      if (!this.InitialStateSet() && this.GetInitialValueMode() === INITIAL_VALUE_MODE_CURRENT_STATE) for (const t of this._tracks) t.CompareInitialStateWithCurrent();\n      super.SetInitialState(e);\n    }\n    Stop(e = false) {\n      if (super.Stop(e), !this.IsComplete()) for (const t of this._tracks) t.SaveState();\n    }\n    Reset(e = true, t = false) {\n      this._DeleteIntermediateKeyframes(), super.Reset(e, t);\n    }\n    _DeleteIntermediateKeyframes() {\n      for (const e of this._tracks) {\n        const t = (e2) => {\n          const t2 = e2.GetTime(), n = this.GetTotalTime();\n          return 0 !== t2 && t2 !== n;\n        };\n        e.DeleteKeyframes(t), e.DeletePropertyKeyframes(t);\n      }\n    }\n    _OnBeforeChangeLayout() {\n      if (!this.IsReleased()) {\n        const e = this.GetInstance();\n        if (e && e.GetObjectClass().IsGlobal()) return false;\n        this._timelineManager.CompleteTimelineBeforeChangeOfLayout(this), this.ResetBeforeChangeLayout();\n      }\n      return true;\n    }\n    Tick(n, e, t) {\n      if (this._instance || (this._instance = this.GetInstance()), !this._instance || this._instance.IsDestroyed()) this.Stop(true), this.OnCompleted();\n      else {\n        const s = this._instance.GetTimeScale();\n        if (0 !== (n = -1 !== s ? t * s : n) || 0 !== this._lastDelta) {\n          this._lastDelta = n;\n          const i = this._playheadTime + this._overshoot, a = n * this._playbackRate, r = i + a, o = this._timelineDataItem._totalTime;\n          r < 0 ? (this._playheadTime = 0, this._overshoot = -r) : o <= r ? (this._playheadTime = o, this._overshoot = this._playheadTime - r) : (this._playheadTime = r, this._overshoot = 0);\n          let e2 = false, t2 = false;\n          const h = this.GetLoop(), T = this.GetPingPong();\n          h || T ? h && !T ? 0 < this._playbackRate ? this._playheadTime >= o && (this._SetTimeAndReset(0), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensLoop), t2 = true) : this._playheadTime <= 0 && (this._SetTimeAndReset(o), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensLoop), t2 = true) : !h && T ? 0 < this._playbackRate ? this._playheadTime >= o && (this._SetTime(o), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), t2 = true, this._pingPongState === PING_PONG_END ? this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensLoop), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensPingPong), this._pingPongState = PING_PONG_BEGIN) : (this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensPingPong), e2 = true) : this._pingPongState === PING_PONG_BEGIN && (this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensPingPong), this._pingPongState = PING_PONG_END)) : this._playheadTime <= 0 && (this._SetTime(0), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), t2 = true, this._pingPongState === PING_PONG_END ? this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensLoop), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensPingPong), this._pingPongState = PING_PONG_BEGIN) : (e2 = true, this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensPingPong)) : this._pingPongState === PING_PONG_BEGIN && (this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensPingPong), this._pingPongState = PING_PONG_END)) : h && T && (0 < this._playbackRate ? this._playheadTime >= o && (this._SetTime(o), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), t2 = true, this._pingPongState === PING_PONG_BEGIN && (this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensPingPong)), this._pingPongState === PING_PONG_END && (this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensLoop), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensPingPong)), this._pingPongState++, this._pingPongState = C32.wrap(this._pingPongState, 0, 2)) : this._playheadTime <= 0 && (this._SetTime(0), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), t2 = true, this._pingPongState === PING_PONG_BEGIN && (this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensPingPong)), this._pingPongState === PING_PONG_END && (this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensLoop), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensPingPong)), this._pingPongState++, this._pingPongState = C32.wrap(this._pingPongState, 0, 2))) : 0 < this._playbackRate ? this._playheadTime >= o && (this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._SetTimeAndReset(0), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensLoop), t2 = true) : (this._SetTime(o), e2 = true)) : this._playheadTime <= 0 && (this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._SetTimeAndReset(o), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensLoop), t2 = true) : (this._SetTime(0), e2 = true)), e2 ? (this._track.SetEndState(), this.Stop(true), this.OnCompleted()) : (this._track.Interpolate(this._playheadTime, true, false, t2, this._firstTick, false), this._firstTick && (this._firstTick = false));\n        }\n      }\n    }\n    _TweenTrigger(e) {\n      const t = this.GetInstance(), n = t.GetBehaviorSdkInstanceFromCtor(C32.Behaviors.Tween);\n      n.PushTriggerTween(this), this._runtime.Trigger(e, t, n.GetBehaviorType()), n.PopTriggerTween();\n    }\n    _SaveToJson() {\n      const e = super._SaveToJson(), t = this.GetTimelineDataItem();\n      return Object.assign(e, { \"tweenDataItemJson\": t._SaveToJson(), \"id\": this._id, \"destroyInstanceOnComplete\": this._destroyInstanceOnComplete, \"initialValueMode\": this._initialValueMode });\n    }\n    _LoadFromJson(e) {\n      if (e) {\n        const t = this.GetTimelineDataItem();\n        t._LoadFromJson(e[\"tweenDataItemJson\"]), super._LoadFromJson(e), this._id = e[\"id\"], this._destroyInstanceOnComplete = e[\"destroyInstanceOnComplete\"], this._initialValueMode = e[\"initialValueMode\"], this._CacheTrack();\n      }\n    }\n    static IsPlaying(e) {\n      return e.IsPlaying();\n    }\n    static IsPaused(e) {\n      return e.IsPaused();\n    }\n    static IsPing(e) {\n      return !!e.GetPingPong() && e.GetPingPongState() === PING_PONG_BEGIN;\n    }\n    static IsPong(e) {\n      return !!e.GetPingPong() && e.GetPingPongState() === PING_PONG_END;\n    }\n    static Build(e) {\n      const t = e.runtime.GetTimelineManager(), n = new C32.TimelineDataItem();\n      if (e.json) {\n        n._LoadFromJson(e.json[\"tweenDataItemJson\"]);\n        const s = new C32.TweenState(n, t);\n        return s._LoadFromJson(e.json), s;\n      }\n      {\n        const i = new C32.TweenState(n, t), a = (C32.IsArray(e.propertyTracksConfig) || (e.propertyTracksConfig = [e.propertyTracksConfig]), i.SetId(e.id), i.SetTags(e.tags), i.SetInitialValueMode(e.initialValueMode), i.SetDestroyInstanceOnComplete(e.releaseOnComplete), i.SetLoop(e.loop), i.SetPingPong(e.pingPong), i.SetTotalTime(e.time), i.SetStep(0), i.SetInterpolationMode(\"default\"), i.SetResultMode(e.propertyTracksConfig[0].resultMode), i.SetRepeatCount(e.repeatCount), i.AddTrack()), r = (a.SetInstanceUID(e.instance.GetUID()), a.SetInterpolationMode(\"default\"), a.SetResultMode(e.propertyTracksConfig[0].resultMode), a.SetEnable(true), a.SetObjectClassIndex(e.instance.GetObjectClass().GetIndex()), e.instance.GetSdkInstance()), o = r.IsOriginalSizeKnown() ? r.GetOriginalWidth() : e.instance.GetWorldInfo().GetWidth(), h = r.IsOriginalSizeKnown() ? r.GetOriginalHeight() : e.instance.GetWorldInfo().GetHeight(), T = (a.SetOriginalWidth(o), a.SetOriginalHeight(h), a.AddKeyframe()), _ = (T.SetTime(0), T.SetEase(\"noease\"), T.SetEnable(true), T.SetTags(\"\"), a.AddKeyframe());\n        _.SetTime(e.time), _.SetEase(\"noease\"), _.SetEnable(true), _.SetTags(\"\");\n        for (const l of e.propertyTracksConfig) {\n          const c = a.AddPropertyTrack(), g = (c.SetSourceAdapterId(l.sourceId), c.SetSourceAdapterArgs(l.sourceArgs), c.SetPropertyName(l.property), c.SetPropertyType(l.type), c.SetMin(NaN), c.SetMax(NaN), c.SetInterpolationMode(\"default\"), c.SetResultMode(l.resultMode), c.SetEnable(true), c.AddPropertyKeyframe()), d = (g.SetType(l.valueType), g.SetTime(0), g.SetEase(l.ease), g.SetEnable(true), g.SetValue(l.startValue), g.SetAbsoluteValue(l.startValue), c.AddPropertyKeyframe());\n          d.SetType(l.valueType), d.SetTime(e.time), d.SetEase(l.ease), d.SetEnable(true), d.SetValue(l.endValue), d.SetAbsoluteValue(l.endValue), c.GetSourceAdapter();\n        }\n        return i;\n      }\n    }\n    static SetInstanceUID(e, t) {\n      if (!isNaN(t)) for (const n of e.GetTracks()) n.SetInstanceUID(t);\n    }\n    GetITweenState(e, t) {\n      return this._iTweenState || (this._iTweenState = C32.New(self.ITweenState, this, e, t)), this._iTweenState;\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.TweenTrackState = class extends C32.TrackState {\n    constructor(t, e) {\n      super(t, e), this._firstPropertyTrack = null, this._secondPropertyTrack = null;\n    }\n    static Create(t, e) {\n      return C32.New(C32.TweenTrackState, t, e);\n    }\n    _CachePropertyTracks() {\n      1 === this._propertyTracks.length ? this._firstPropertyTrack = this._propertyTracks[0] : (this._firstPropertyTrack = this._propertyTracks[0], this._secondPropertyTrack = this._propertyTracks[1]);\n    }\n    CreatePropertyTrackStates() {\n      for (const t of this._trackDataItem.GetPropertyTrackData().propertyTrackDataItems()) this._propertyTracks.push(C32.TweenPropertyTrackState.Create(this, t));\n      this._CachePropertyTracks();\n    }\n    AddPropertyTrack() {\n      const t = this._trackDataItem.GetPropertyTrackData(), e = t.AddEmptyPropertyTrackDataItem(), r = C32.TweenPropertyTrackState.Create(this, e);\n      return this._propertyTracks.push(r), this._CachePropertyTracks(), r;\n    }\n    SetInitialState() {\n      if (this.MaybeGetInstance(), this.IsInstanceValid() || !this.IsInstanceTrack()) {\n        const t = this.GetTimeline(), e = t.IsForwardPlayBack(), r = e ? 0 : this.GetLocalTotalTime();\n        for (const a of this._propertyTracks) a.SetInitialState(r), 0 === this._worldInfoChange && 1 === a.GetWorldInfoChange() && (this._worldInfoChange = 1), 0 === this._renderChange && 1 === a.GetRenderChange() && (this._renderChange = 1);\n        this._needsBeforeAndAfter = 0;\n        const s = this._propertyTracks.some((t2) => t2.GetNeedsBeforeAndAfter());\n        s && (this._needsBeforeAndAfter = 1), this._lastKeyframeDataItem = this._GetLastKeyFrameBeforeTime(r), this._initialStateOfNestedSet = false, this._endStateOfNestedSet = false, this.Interpolate(r);\n      }\n    }\n    BeforeInterpolate() {\n    }\n    Interpolate(t, e = 0, r = false, s = false, a, o = false, i = false) {\n      if (this._instance || this.GetInstance(), this._instance) {\n        const n = !this._instance.IsDestroyed();\n        return n ? (!o || !this.GetObjectClass().IsGlobal()) && ((this._secondPropertyTrack ? (this._firstPropertyTrack.Interpolate(t, r, s, i), this._secondPropertyTrack) : this._firstPropertyTrack).Interpolate(t, r, s, i), void (0 !== this._firstPropertyTrack.GetWorldInfoChange() && (this._worldInfo || (this._worldInfo = this._instance.GetWorldInfo()), this._worldInfo) && this._worldInfo.SetBboxChanged())) : false;\n      }\n    }\n    AfterInterpolate() {\n    }\n    _LoadFromJson(t) {\n      super._LoadFromJson(t), this._CachePropertyTracks();\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.TweenPropertyTrackState = class extends C32.PropertyTrackState {\n    constructor(t, e) {\n      super(t, e), this._basic = false;\n    }\n    static Create(t, e) {\n      return C32.New(C32.TweenPropertyTrackState, t, e);\n    }\n    Interpolate(t, e = false, r = false, a = false) {\n      let s, o;\n      if (this._basic) s = this._propertyKeyframeDataItems[0], o = this._propertyKeyframeDataItems[1];\n      else {\n        if (e) s = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(t, this._propertyTrackDataItem);\n        else {\n          if (this._lastPropertyKeyframeDataItem) {\n            const y = this.GetTimeline(), p = this._lastPropertyKeyframeDataItem.GetNext(), i = this._lastPropertyKeyframeDataItem.GetTime(), m = p ? p.GetTime() : y.GetTotalTime();\n            (t <= i || m <= t) && (this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(t, this._propertyTrackDataItem));\n          } else this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(t, this._propertyTrackDataItem);\n          s = this._lastPropertyKeyframeDataItem;\n        }\n        o = s.GetNext();\n      }\n      this._sourceAdapter.Interpolate(t, s, o, e, r, a);\n    }\n    AddPropertyKeyframe() {\n      const t = this._propertyTrackDataItem.GetPropertyKeyframeData(), e = t.AddEmptyPropertyKeyframeDataItem();\n      return this._lastPropertyKeyframeDataItem = null, this._basic = this.GetPropertyKeyframeDataItems().length <= 2, e;\n    }\n    DeletePropertyKeyframes(t) {\n      this._lastPropertyKeyframeDataItem = null;\n      const e = this._propertyTrackDataItem.GetPropertyKeyframeData();\n      e.DeletePropertyKeyframeDataItems(t), this._basic = this.GetPropertyKeyframeDataItems().length <= 2;\n    }\n    _SaveToJson() {\n      return { \"sourceAdapterJson\": this.GetSourceAdapter()._SaveToJson(), \"basic\": this._basic };\n    }\n    _LoadFromJson(t) {\n      t && (this.GetSourceAdapter()._LoadFromJson(t[\"sourceAdapterJson\"]), this._basic = t[\"basic\"]);\n    }\n  };\n}\n{\n  const C32 = self.C3, Ease = self.Ease, NAME = 0, TRANSITION_KEYFRAMES = 1, LINEAR = 2;\n  C32.Transition = class extends C32.DefendedBase {\n    constructor(e, t = true) {\n      super(), this._name = e[NAME], this._linear = e[LINEAR], this._transitionKeyframes = [];\n      for (const a of e[TRANSITION_KEYFRAMES]) {\n        const s = C32.TransitionKeyframe.Create(this, a);\n        this._transitionKeyframes.push(s);\n      }\n      for (let e2 = 0; e2 < this._transitionKeyframes.length; e2++) {\n        const r = this._transitionKeyframes[e2], i = this._transitionKeyframes[e2 + 1], n = this._transitionKeyframes[e2 - 1];\n        r.SetNext(i), r.SetPrevious(n);\n      }\n      this._precalculatedSamples = /* @__PURE__ */ new Map(), this._transitionKeyframeCache = /* @__PURE__ */ new Map(), this._PreCalcSamples(), t && Ease.AddCustomEase(this._name, (e2, t2, a, s) => this.Interpolate(e2, t2, a, s), null, { transition: this });\n    }\n    static Create(e) {\n      return C32.New(C32.Transition, e);\n    }\n    Release() {\n      for (const e of this._transitionKeyframes) e.Release();\n      C32.clearArray(this._transitionKeyframes), this._transitionKeyframes = null, this._precalculatedSamples.clear(), this._precalculatedSamples = null, this._transitionKeyframeCache.clear(), this._transitionKeyframeCache = null;\n    }\n    MakeLinear(e) {\n      this._linear = !!e;\n    }\n    GetTransitionKeyFrameAt(e) {\n      const t = this._transitionKeyframeCache.get(e);\n      if (t) return t;\n      for (const t2 of this._transitionKeyframes) if (t2.GetValueX() === e) return this._transitionKeyframeCache.set(e, t2), t2;\n    }\n    GetFirstTransitionKeyFrameLowerOrEqualThan(t) {\n      for (let e = this._transitionKeyframes.length - 1; 0 <= e; e--) {\n        const a = this._transitionKeyframes[e], s = a.GetValueX();\n        if (s <= t) {\n          let e2 = a;\n          if (s < t) return e2;\n          if (s === t) {\n            for (; e2; ) {\n              const r = e2.GetPrevious();\n              if (!r) break;\n              if (r.GetValueX() !== e2.GetValueX()) break;\n              e2 = r;\n            }\n            return e2;\n          }\n        }\n      }\n    }\n    Interpolate(e, t, a, s) {\n      let r = e / s;\n      if (this._linear) {\n        const E = this.GetTransitionKeyFrameAt(0), n2 = this.GetTransitionKeyFrameAt(1), V = t + (t + a) * E.GetValueY(), p = (t + a) * n2.GetValueY(), S = p - V;\n        return 0 === s ? V + S : Ease.NoEase(e, V, S, s);\n      }\n      0 === s && (r = 1);\n      let i = this.GetFirstTransitionKeyFrameLowerOrEqualThan(r), n = i.GetNext();\n      if (!n) {\n        const X = i.GetPrevious(), A = i;\n        i = X, n = A;\n      }\n      const l = n.GetValueX() - i.GetValueX(), o = C32.mapToRange(r, i.GetValueX(), n.GetValueX(), 0, l);\n      if (i.IsSegmentLinear() || 0 == l) {\n        const C = t + (t + a) * i.GetValueY(), d = (t + a) * n.GetValueY(), T = d - C;\n        return 0 == l ? 1 === o ? C + T : C : Ease.NoEase(o, C, T, l);\n      }\n      const h = i.GetValueX(), u = i.GetValueY(), c = i.GetValueX() + i.GetStartAnchorX(), f = i.GetValueY() + i.GetStartAnchorY(), G = n.GetValueX() + n.GetEndAnchorX(), m = n.GetValueY() + n.GetEndAnchorY(), _ = n.GetValueX(), K = n.GetValueY();\n      let y = Ease.GetRuntimeEase(\"spline\")(o, h, u, c, f, G, m, _, K, this._precalculatedSamples.get(i));\n      return (1 - (y += i.GetValueY())) * t + y * (t + a);\n    }\n    _PreCalcSamples() {\n      this._precalculatedSamples.clear();\n      for (let e = 0; e < this._transitionKeyframes.length - 1; e++) {\n        const t = this._transitionKeyframes[e];\n        if (t.GetStartEnable()) {\n          const a = t, s = this._transitionKeyframes[e + 1];\n          if (s.GetEndEnable()) {\n            const r = a.GetValueX(), i = a.GetValueX() + a.GetStartAnchorX(), n = s.GetValueX() + s.GetEndAnchorX(), l = s.GetValueX();\n            this._precalculatedSamples.set(a, Ease.GetBezierSamples(r, i, n, l));\n          }\n        }\n      }\n    }\n  };\n}\n{\n  const C32 = self.C3, VALUE_X = 0, VALUE_Y = 1, START_ANCHOR_X = 2, START_ANCHOR_Y = 3, END_ANCHOR_X = 4, END_ANCHOR_Y = 5, START_ENABLE = 6, END_ENABLE = 7, SEGMENT_MODE = 8;\n  C32.TransitionKeyframe = class extends C32.DefendedBase {\n    constructor(t, e) {\n      super(), this._transition = t, this._valueX = e[VALUE_X], this._valueY = e[VALUE_Y], this._startAnchorX = e[START_ANCHOR_X], this._startAnchorY = e[START_ANCHOR_Y], this._endAnchorX = e[END_ANCHOR_X], this._endAnchorY = e[END_ANCHOR_Y], this._startEnable = e[START_ENABLE], this._endEnable = e[END_ENABLE], this._segmentMode = e[SEGMENT_MODE], this._next = null, this._prev = null;\n    }\n    Release() {\n      this._transition = null;\n    }\n    static Create(t, e) {\n      return C32.New(C32.TransitionKeyframe, t, e);\n    }\n    SetNext(t) {\n      this._next = t;\n    }\n    GetNext() {\n      return this._next;\n    }\n    SetPrevious(t) {\n      this._prev = t;\n    }\n    GetPrevious() {\n      return this._prev;\n    }\n    GetValueX() {\n      return this._valueX;\n    }\n    GetValueY() {\n      return this._valueY;\n    }\n    GetStartAnchorX() {\n      return this._startAnchorX;\n    }\n    GetStartAnchorY() {\n      return this._startAnchorY;\n    }\n    GetEndAnchorX() {\n      return this._endAnchorX;\n    }\n    GetEndAnchorY() {\n      return this._endAnchorY;\n    }\n    GetStartEnable() {\n      return this._startEnable;\n    }\n    GetEndEnable() {\n      return this._endEnable;\n    }\n    IsSegmentLinear() {\n      return \"linear\" === this._segmentMode;\n    }\n    IsSegmentCubic() {\n      return \"cubic\" === this._segmentMode;\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.TransitionManager = class extends C32.DefendedBase {\n    constructor(s) {\n      super(), this._runtime = s, this._transitions = [];\n    }\n    Release() {\n      for (const s of this._transitions) s.Release();\n      C32.clearArray(this._transitions), this._transitions = null;\n    }\n    Create(s) {\n      this._transitions.push(C32.Transition.Create(s));\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.TemplateManager = class extends C32.DefendedBase {\n    constructor(e) {\n      super(), this._runtime = e, this._templateDataMap = null, this._instanceToTemplateNameMap = null, this._instanceDestroy = (e2) => this._OnInstanceDestroy(e2.instance);\n    }\n    Release() {\n      if (this.RemoveRuntimeListeners(), this._templateDataMap) {\n        for (const e of this._templateDataMap.values()) e.clear();\n        this._templateDataMap.clear();\n      }\n      this._templateDataMap = null, this._runtime = null;\n    }\n    Create(e) {\n      if (this._templateDataMap || (this._templateDataMap = /* @__PURE__ */ new Map()), e) {\n        const t = e[0][16], a = t[0], s = e[1], n = (this._templateDataMap.has(s) || this._templateDataMap.set(s, /* @__PURE__ */ new Map()), this._templateDataMap.get(s));\n        n.set(a, e);\n      }\n    }\n    AddRuntimeListeners() {\n      const e = this._runtime.Dispatcher();\n      e && e.addEventListener(\"instancedestroy\", this._instanceDestroy);\n    }\n    RemoveRuntimeListeners() {\n      const e = this._runtime.Dispatcher();\n      e && e.removeEventListener(\"instancedestroy\", this._instanceDestroy);\n    }\n    HasTemplates() {\n      return !!this._templateDataMap && 0 !== this._templateDataMap.size;\n    }\n    GetTemplateData(e, t) {\n      let a = 0;\n      if (a = e instanceof C32.ObjectClass ? e.GetIndex() : e, this._templateDataMap.has(a)) {\n        const s = this._templateDataMap.get(a).get(t);\n        return s ? JSON.parse(JSON.stringify(s)) : void 0;\n      }\n    }\n    MapInstanceToTemplateName(e, t) {\n      this._instanceToTemplateNameMap || (this._instanceToTemplateNameMap = /* @__PURE__ */ new WeakMap()), this._instanceToTemplateNameMap.has(e) || this._instanceToTemplateNameMap.set(e, t);\n    }\n    GetInstanceTemplateName(e) {\n      if (!this._instanceToTemplateNameMap) return \"\";\n      const t = this._instanceToTemplateNameMap.get(e);\n      return t || \"\";\n    }\n    _OnInstanceDestroy(e) {\n      this._instanceToTemplateNameMap && this._instanceToTemplateNameMap.has(e) && this._instanceToTemplateNameMap.delete(e);\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.FlowchartManager = class {\n    constructor(a) {\n      this._runtime = a, this._flowchartDataManager = new C32.FlowchartDataManager();\n    }\n    Release() {\n      this._flowchartDataManager.Release(), this._flowchartDataManager = null, this._runtime = null;\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    Create(a) {\n      this._flowchartDataManager.Add(a);\n    }\n    GetFlowchartDataItemByName(a) {\n      return this._flowchartDataManager.Get(a);\n    }\n    HasFlowcharts() {\n      return this._flowchartDataManager.HasFlowcharts();\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.FlowchartState = class {\n    constructor(t, e, r, a, o, h, s) {\n      this._runtime = o.GetRuntime(), this._flowchartManager = o, this._flowchartName = t, this._startNodeTag = r, this._flowchartDataItem = a, this._tag = e, this._pluginInstance = h, this._pluginUID = s ?? h.GetInstance().GetUID(), this._SetStartFlowchartNode(), this._currentFlowchartNodeId = this._startFlowchartNode?.GetFlowchartId() ?? -1, this._previousFlowchartNodeIds = [], this._previousFlowchartState = null, this._previousFlowchartStateStartNodeId = NaN, this._referenceFlowchartStates = null, this._currentReferenceFlowchartState = null, this._rootFlowchartState = null, this._previousFlowchartStateTag = \"\", this._referenceFlowchartStatesJson = null, this._currentReferenceFlowchartStateTag = \"\", this._rootFlowchartStateTag = \"\", this._triggerCount = 0, this._markForRelease = false, this._released = false;\n    }\n    Release() {\n      this._released || (C32.clearArray(this._previousFlowchartNodeIds), this._previousFlowchartNodeIds = null, this._runtime = null, this._flowchartManager = null, this._flowchartDataItem = null, this._pluginInstance = null, this._previousFlowchartState = null, this._previousFlowchartStateStartNodeId = NaN, this._referenceFlowchartStates && this._referenceFlowchartStates.clear(), this._referenceFlowchartStates = null, this._currentReferenceFlowchartState = null, this._rootFlowchartState = null, this._previousFlowchartStateTag = \"\", this._referenceFlowchartStatesJson = null, this._currentReferenceFlowchartStateTag = \"\", this._rootFlowchartStateTag = \"\", this._released = true);\n    }\n    WasReleased() {\n      return this._released;\n    }\n    GetFlowchartManager() {\n      return this._flowchartManager;\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetName() {\n      return this._flowchartName;\n    }\n    GetFlowchartDataItem() {\n      return this._flowchartDataItem;\n    }\n    GetTag() {\n      return this._tag;\n    }\n    GetPluginInstance() {\n      return this._pluginInstance || (this._pluginInstance = this._runtime.GetInstanceByUID(this._pluginUID).GetSdkInstance()), this._pluginInstance;\n    }\n    GetCurrentNode() {\n      return this.GetFlowchartElementById(this._currentFlowchartNodeId);\n    }\n    GetCurrentNodeTag() {\n      const t = this.GetCurrentNode();\n      return t ? t.GetTag() : \"\";\n    }\n    GetCurrentNodeTags() {\n      const t = this.GetCurrentNode();\n      return t ? t.GetTags() : [];\n    }\n    CurrentNodeHasTags(t) {\n      const e = this.GetCurrentNodeTags();\n      if (!e) return false;\n      if (!e.length) return false;\n      const r = C32.FlowchartState._GetTagArray(t);\n      return !(!r || !r.length) && r.every(C32.FlowchartState._HasTag, e);\n    }\n    CurrentNodeCompareTags(t, e) {\n      const r = this.GetCurrentNodeTags();\n      if (!r) return false;\n      if (!r.length) return false;\n      const a = C32.FlowchartState._GetTagArray(t);\n      return !(!a || !a.length) && a.every((t2) => C32.FlowchartState._CompareTag.call(r, t2, e));\n    }\n    static _HasTag(t) {\n      const e = this;\n      return \"\" === t ? 1 === e.length && \"\" === e[0] : e.map((t2) => t2.trim().toLowerCase()).includes(t.trim().toLowerCase());\n    }\n    static _GetTagArray(t) {\n      return t.trim().split(\" \");\n    }\n    static _CompareTag(e, r) {\n      const t = this;\n      return \"\" === e ? 1 === t.length && \"\" === t[0] : t.some((t2) => C32.compare(t2.trim(), r, e.trim()));\n    }\n    GetCurrentNodeParent(t) {\n      const e = this.GetCurrentNode();\n      if (e) {\n        if (C32.IsFiniteNumber(t)) {\n          const r = e.GetParentFlowchartIds(), a = r ? r[t] : void 0;\n          if (C32.IsFiniteNumber(a)) return this.GetFlowchartElementById(a);\n        }\n        if (\"string\" == typeof t) for (const o of e.GetParentFlowchartIds()) {\n          const h = this.GetFlowchartElementById(o);\n          if (h.HasTags(t)) return this.GetFlowchartElementById(h.GetFlowchartId());\n        }\n      }\n    }\n    GetCurrentNodeParentTag(t) {\n      const e = this.GetCurrentNodeParent(t);\n      return e ? e.GetTag() : \"\";\n    }\n    GetCurrentNodeParentTags(t) {\n      const e = this.GetCurrentNodeParent(t);\n      return e ? e.GetTags() : \"\";\n    }\n    GetCurrentNodeParentIndex(t) {\n      const e = this.GetCurrentNode();\n      if (!e) return -1;\n      const r = e.GetParentFlowchartIds();\n      if (!r) return -1;\n      const a = this.GetCurrentNodeParent(t);\n      return a ? r.indexOf(a.GetFlowchartId()) : -1;\n    }\n    GetCurrentNodeParentCount() {\n      const t = this.GetCurrentNode();\n      if (!t) return 0;\n      const e = t.GetParentFlowchartIds();\n      return e ? e.length : 0;\n    }\n    GetFlowchartElementById(t) {\n      return this._flowchartDataItem.GetFlowchartElementById(t);\n    }\n    Reset() {\n      const t = this._GetRootFlowchartState();\n      t._Reset(true);\n    }\n    _Reset(t) {\n      if (this._GetReferenceFlowchartStates()) {\n        for (const [e, r] of this._GetReferenceFlowchartStates().entries()) r._Reset(false);\n        this._GetReferenceFlowchartStates().clear();\n      }\n      if (this._referenceFlowchartStates = null, this._previousFlowchartState = null, this._previousFlowchartStateStartNode = null, this._currentReferenceFlowchartState = null, this._previousFlowchartStateTag = \"\", this._referenceFlowchartStatesJson = null, this._currentReferenceFlowchartStateTag = \"\", this._rootFlowchartStateTag = \"\", this._previousFlowchartNodeIds = [], t) {\n        this._flowchartManager.SetCurrentFlowchartState(this);\n        const a = this._startFlowchartNode.GetFlowchartId();\n        a !== this._currentFlowchartNodeId && this._GotoFlowchartNode(a);\n      } else this._currentFlowchartNodeId = this._startFlowchartNode.GetFlowchartId();\n    }\n    GetCurrentNodeOutputCount() {\n      const t = this._flowchartDataItem.GetFlowchartElementById(this._currentFlowchartNodeId);\n      return t ? t.GetFlowchartNodeOutputData().GetFlowchartNodeOutputDataItemCount() : 0;\n    }\n    GetCurrentNodeOutputNameAt(t) {\n      const e = this._GetFlowchartNodeOutputAt(t);\n      return e ? e.GetName() : \"\";\n    }\n    GetCurrentNodeOutputValueAt(t) {\n      let e;\n      return C32.IsFiniteNumber(t) && (e = this._GetFlowchartNodeOutputAt(t)), \"string\" == typeof t && (e = this._GetFlowchartNodeOutputByName(t)), \"number\" != typeof t && \"string\" != typeof t && console.warn(\"[Flowcharts] unexpected argument type in GetCurrentNodeOutputValueAt expression\"), e ? e.GetValue() : \"\";\n    }\n    GotoNextFlowchartNode(t) {\n      let e;\n      if (C32.IsFiniteNumber(t) && (e = this._GetFlowchartNodeOutputAt(t)), e = \"string\" == typeof t ? this._GetFlowchartNodeOutputByName(t) : e) {\n        const r = e.GetConnectedFlowchartNodeFlowchartId();\n        C32.IsFiniteNumber(r) && (this._previousFlowchartNodeIds.push(this._currentFlowchartNodeId), this._GotoFlowchartNode(r));\n      }\n    }\n    GotoAnyFlowchartNode(t) {\n      const e = this._flowchartDataItem.GetFlowchartNodeByTags(t);\n      if (e) {\n        const r = this._flowchartDataItem.GetFlowchartElementById(e.GetFlowchartId());\n        r && (this._previousFlowchartNodeIds.push(this._currentFlowchartNodeId), this._GotoFlowchartNode(r.GetFlowchartId()));\n      }\n    }\n    GotoPreviousFlowchartNode() {\n      const t = this._previousFlowchartNodeIds.pop();\n      C32.IsFiniteNumber(t) ? this._GotoFlowchartNode(t) : this._GetPreviousFlowchartState() && (this._flowchartManager.SetCurrentFlowchartState(this._GetPreviousFlowchartState(), true, false, false), this._GetPreviousFlowchartState()._GotoFlowchartNode(this._GetPreviousFlowchartStateStartNodeId()), this._GetRootFlowchartState()._SetCurrentReferenceFlowchart(this._GetPreviousFlowchartState()));\n    }\n    GotoParentFlowchartNode(t) {\n      const e = this.GetCurrentNode();\n      if (e) {\n        e.GetFlowchartId();\n        const r = this.GetCurrentNodeParent(t);\n        r && (this._previousFlowchartNodeIds.push(this._currentFlowchartNodeId), this._GotoFlowchartNode(r.GetFlowchartId()));\n      }\n    }\n    HasOutput(e) {\n      if (C32.IsFiniteNumber(e)) {\n        const t = this._flowchartDataItem.GetFlowchartElementById(this._currentFlowchartNodeId), r = t.GetFlowchartNodeOutputData().GetFlowchartNodeOutputDataItems();\n        return !!r[e];\n      }\n      if (\"string\" == typeof e) {\n        const a = this._flowchartDataItem.GetFlowchartElementById(this._currentFlowchartNodeId), o = a.GetFlowchartNodeOutputData().GetFlowchartNodeOutputDataItems();\n        for (let t = 0; t < o.length; t++) if (o[t].GetName() === e) return true;\n      }\n      return false;\n    }\n    MarkForRelease() {\n      this._markForRelease = true;\n    }\n    IsInTriggerState() {\n      return 0 < this._triggerCount;\n    }\n    PushIsTriggerState() {\n      this._triggerCount++;\n    }\n    PopIsTriggerState() {\n      this._triggerCount--, 0 === this._triggerCount && this._markForRelease && this._flowchartManager.RemoveFlowchartState(this);\n    }\n    _GotoFlowchartNode(t) {\n      const r = this._currentFlowchartNodeId, e = this.GetPluginInstance().GetInstance();\n      if (this.PushIsTriggerState(), this._flowchartManager.PushFlowchartState(this), this._runtime.Trigger(C32.Plugins.Flowchart.Cnds.OnBeforeAnyNodeChange, e), this._runtime.Trigger(C32.Plugins.Flowchart.Cnds.OnBeforeTaggedNodeChange, e), this._runtime.Trigger(C32.Plugins.Flowchart.Cnds.OnBeforeAnyNodeChangeInFlowchart, e), this._runtime.Trigger(C32.Plugins.Flowchart.Cnds.OnBeforeTaggedNodeChangeInFlowchart, e), this._currentFlowchartNodeId = t, this._runtime.Trigger(C32.Plugins.Flowchart.Cnds.OnAnyNodeChange, e), this._runtime.Trigger(C32.Plugins.Flowchart.Cnds.OnTaggedNodeChange, e), this._runtime.Trigger(C32.Plugins.Flowchart.Cnds.OnAnyNodeChangeInFlowchart, e), this._runtime.Trigger(C32.Plugins.Flowchart.Cnds.OnTaggedNodeChangeInFlowchart, e), this._flowchartManager.PopFlowchartState(), this.PopIsTriggerState(), !this.WasReleased()) {\n        const a = this.GetFlowchartElementById(this._currentFlowchartNodeId);\n        if (\"reference\" === a.GetType()) {\n          const o = a.GetReferenceFlowchartName();\n          if (this._HasReferenceFlowchartState(a)) {\n            this._previousFlowchartNodeIds.pop();\n            const h = this._GetReferenceFlowchartState(a), s = (this._flowchartManager.SetCurrentFlowchartState(h, true, true, false), h._SetPreviousFlowchart(this, r), this._GetRootFlowchartState());\n            s._SetCurrentReferenceFlowchart(h);\n          } else {\n            const c = a.GetReferenceFlowchartStartNodeTag();\n            if (o) {\n              this._previousFlowchartNodeIds.pop();\n              let e2 = a.GetReferenceFlowchartTag();\n              if (e2) {\n                let t2 = this._flowchartManager.GetFlowchartState(e2);\n                for (; t2; ) e2 = C32.IncrementNumberAtEndOf(e2), t2 = this._flowchartManager.GetFlowchartState(e2);\n              } else {\n                e2 = o + \"-ref\";\n                let t2 = this._flowchartManager.GetFlowchartState(e2);\n                for (; t2; ) e2 = C32.IncrementNumberAtEndOf(e2), t2 = this._flowchartManager.GetFlowchartState(e2);\n              }\n              const n = this._flowchartManager.AddFlowchartState(o, c, e2, this._pluginInstance, true), l = (n._SetPreviousFlowchart(this, r), this._SetReferenceFlowchartState(a, n), this._GetRootFlowchartState());\n              n._SetRootFlowchartState(l), l._SetCurrentReferenceFlowchart(n);\n            }\n          }\n        }\n      }\n    }\n    _GetFlowchartNodeOutputAt(t) {\n      const e = this._flowchartDataItem.GetFlowchartElementById(this._currentFlowchartNodeId);\n      if (!e) return null;\n      const r = e.GetFlowchartNodeOutputData().GetFlowchartNodeOutputDataItems();\n      if (!r) return null;\n      const a = r[t];\n      return a || null;\n    }\n    _GetFlowchartNodeOutputByName(t) {\n      const e = this._flowchartDataItem.GetFlowchartElementById(this._currentFlowchartNodeId);\n      if (!e) return null;\n      const r = e.GetFlowchartNodeOutputData().GetFlowchartNodeOutputDataItemByName(t);\n      return r || null;\n    }\n    _SetStartFlowchartNode(e) {\n      if (\"number\" == typeof e) {\n        let t = this.GetFlowchartElementById(e);\n        t = t || this._flowchartDataItem.GetFlowchartStartNode(), this._startFlowchartNode = t;\n      } else {\n        let t = this._flowchartDataItem.GetFlowchartNodeByTags(this._startNodeTag);\n        t = t || this._flowchartDataItem.GetFlowchartStartNode(), this._startFlowchartNode = t;\n      }\n    }\n    _SaveToJson() {\n      return this._markForRelease ? null : { \"flowchartName\": this._flowchartName, \"flowchartTag\": this._tag, \"startNodeTag\": this._startNodeTag, \"currentNodeId\": this._currentFlowchartNodeId, \"previousNodeIds\": this._previousFlowchartNodeIds, \"pluginUID\": this._pluginInstance.GetInstance().GetUID(), \"reference\": { \"previousFlowchartTag\": this._GetPreviousFlowchartState() ? this._GetPreviousFlowchartState().GetTag() : \"\", \"previousStartNodeId\": C32.IsFiniteNumber(this._GetPreviousFlowchartStateStartNodeId()) ? this._GetPreviousFlowchartStateStartNodeId() : NaN, \"referencesJson\": this._GetFlowchartReferencesJson(), \"currentReferenceFlowchartTag\": this.GetCurrentReferenceFlowchart() ? this.GetCurrentReferenceFlowchart().GetTag() : \"\", \"rootFlowchartTag\": this._GetRootFlowchartState() ? this._GetRootFlowchartState().GetTag() : \"\" } };\n    }\n    _GetFlowchartReferencesJson() {\n      if (!this._HasReferenceFlowchartStates()) return null;\n      const t = [];\n      for (const [e, r] of this._GetReferenceFlowchartStates().entries()) t.push({ \"flowchartElementId\": e.GetFlowchartId(), \"flowchartStateTag\": r.GetTag() });\n      return t.length ? t : null;\n    }\n    _LoadFromJson(t) {\n      if (t) {\n        if (this._flowchartName = t[\"flowchartName\"], this._tag = t[\"flowchartTag\"], this._startNodeTag = t[\"startNodeTag\"], this._currentFlowchartNodeId = t[\"currentNodeId\"], this._previousFlowchartNodeIds = t[\"previousNodeIds\"], this._pluginUID = t[\"pluginUID\"], t.hasOwnProperty(\"reference\")) {\n          const e = t[\"reference\"];\n          this._previousFlowchartStateTag = e[\"previousFlowchartTag\"], this._previousFlowchartStateStartNodeId = e[\"previousStartNodeId\"], this._referenceFlowchartStatesJson = e[\"referencesJson\"], this._currentReferenceFlowchartStateTag = e[\"currentReferenceFlowchartTag\"], this._rootFlowchartStateTag = e[\"rootFlowchartTag\"];\n        }\n        this._SetStartFlowchartNode();\n      }\n    }\n    _GetPreviousFlowchartState() {\n      return \"string\" == typeof this._previousFlowchartStateTag && this._previousFlowchartStateTag && (this._previousFlowchartState = this._flowchartManager.GetFlowchartState(this._previousFlowchartStateTag), this._previousFlowchartStateTag = \"\"), this._previousFlowchartState;\n    }\n    _GetPreviousFlowchartStateStartNodeId() {\n      return this._previousFlowchartStateStartNodeId;\n    }\n    _SetPreviousFlowchart(t, e) {\n      this._previousFlowchartState = t, this._previousFlowchartStateStartNodeId = e;\n    }\n    GetCurrentReferenceFlowchart() {\n      return \"string\" == typeof this._currentReferenceFlowchartStateTag && this._currentReferenceFlowchartStateTag && (this._currentReferenceFlowchartState = this._flowchartManager.GetFlowchartState(this._currentReferenceFlowchartStateTag), this._currentReferenceFlowchartStateTag = \"\"), this._currentReferenceFlowchartState;\n    }\n    _SetCurrentReferenceFlowchart(t) {\n      this._currentReferenceFlowchartState = t, this._currentReferenceFlowchartState === this && (this._currentReferenceFlowchartState = null);\n    }\n    _GetRootFlowchartState() {\n      return \"string\" == typeof this._rootFlowchartStateTag && this._rootFlowchartStateTag && (this._rootFlowchartState = this._flowchartManager.GetFlowchartState(this._rootFlowchartStateTag), this._rootFlowchartStateTag = \"\"), this._rootFlowchartState || this;\n    }\n    _SetRootFlowchartState(t) {\n      this._rootFlowchartState = t;\n    }\n    _HasReferenceFlowchartStates() {\n      return this._RebuildReferenceFlowchartStates(), !!this._referenceFlowchartStates;\n    }\n    _HasReferenceFlowchartState(t) {\n      return this._RebuildReferenceFlowchartStates(), this._referenceFlowchartStates && this._referenceFlowchartStates.has(t);\n    }\n    _RebuildReferenceFlowchartStates() {\n      if (this._referenceFlowchartStatesJson) {\n        this._referenceFlowchartStates && this._referenceFlowchartStates.clear(), this._referenceFlowchartStates || (this._referenceFlowchartStates = /* @__PURE__ */ new Map());\n        for (const t of this._referenceFlowchartStatesJson) {\n          const e = this._flowchartManager.GetFlowchartState(t[\"flowchartStateTag\"]), r = e.GetFlowchartElementById(t[\"flowchartElementId\"]);\n          this._referenceFlowchartStates.set(r, e);\n        }\n        this._referenceFlowchartStatesJson = null;\n      }\n    }\n    _GetReferenceFlowchartStates() {\n      return this._RebuildReferenceFlowchartStates(), this._referenceFlowchartStates;\n    }\n    _GetReferenceFlowchartState(t) {\n      return this._RebuildReferenceFlowchartStates(), this._referenceFlowchartStates.get(t);\n    }\n    _SetReferenceFlowchartState(t, e) {\n      this._referenceFlowchartStates || (this._referenceFlowchartStates = /* @__PURE__ */ new Map()), this._referenceFlowchartStates.set(t, e);\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.FlowchartStateManager = class {\n    constructor(t) {\n      this._runtime = t, this._flowchartStates = /* @__PURE__ */ new Map(), this._currentFlowchartState = null, this._flowchartStateStack = [], this._on_after_load = () => this._OnAfterLoad(), this._loadJson = null;\n    }\n    Release() {\n      C32.clearArray(this._flowchartStateStack), this._flowchartStateStack = null, this._flowchartStates.clear(), this._flowchartStates = null, this._currentFlowchartState = null, this._runtime = null, this._loadJson = null;\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    AddFlowchartState(t, e, a, r, h, s) {\n      const o = this._runtime.GetFlowchartManager().GetFlowchartDataItemByName(t);\n      if (o) {\n        if (!this._flowchartStates.has(a)) {\n          const c = new C32.FlowchartState(t, a, e, o, this, r, s);\n          return this._flowchartStates.set(a, c), h && this.SetCurrentFlowchartState(c, true), c;\n        }\n        {\n          const c = this._flowchartStates.get(a);\n          void (c && this.RemoveFlowchartState(c));\n        }\n      } else console.warn(`[Flowcharts] no flowchart found with name '${t}'`);\n    }\n    RemoveFlowchartState(t) {\n      if (t.MarkForRelease(), !t.IsInTriggerState()) {\n        const e = t.GetTag();\n        this._flowchartStates.delete(e), t.Release(), this._currentFlowchartState === t && (this._currentFlowchartState = null);\n      }\n    }\n    ResetFlowchartState(t) {\n      t.Reset();\n    }\n    GetFlowchartState(t) {\n      return this._flowchartStates.get(t);\n    }\n    PushFlowchartState(t) {\n      this._flowchartStateStack.push(t);\n    }\n    PopFlowchartState() {\n      this._flowchartStateStack.pop();\n    }\n    SetCurrentFlowchartState(t, e = false, a = false, r = true) {\n      if (r) {\n        const h = t.GetCurrentReferenceFlowchart();\n        t = h || t;\n      }\n      t !== this._currentFlowchartState && (this._TriggerBeforeFlowchartChange(), this._TriggerAfterFlowchartChange(t, e, a));\n    }\n    GetCurrentFlowchartState(t) {\n      return \"string\" == typeof t ? this.GetFlowchartState(t) : this._flowchartStateStack.length ? this._flowchartStateStack[this._flowchartStateStack.length - 1] : this._currentFlowchartState;\n    }\n    _TriggerBeforeFlowchartChange() {\n      if (this._currentFlowchartState && !this._currentFlowchartState.WasReleased()) {\n        const t = this._currentFlowchartState.GetPluginInstance().GetInstance();\n        this._currentFlowchartState.PushIsTriggerState(), this.PushFlowchartState(this._currentFlowchartState), this._runtime.Trigger(C32.Plugins.Flowchart.Cnds.OnBeforeFlowchartChange, t), this.PopFlowchartState(), this._currentFlowchartState.PopIsTriggerState();\n      }\n    }\n    _TriggerAfterFlowchartChange(t, e = false, a = false) {\n      if (this._currentFlowchartState = t, this._currentFlowchartState && !this._currentFlowchartState.WasReleased()) {\n        const r = this._currentFlowchartState.GetPluginInstance().GetInstance();\n        this._currentFlowchartState.PushIsTriggerState(), this.PushFlowchartState(this._currentFlowchartState), this._runtime.Trigger(C32.Plugins.Flowchart.Cnds.OnFlowchartChange, r), true !== a && \"number\" != typeof a || this._currentFlowchartState._SetStartFlowchartNode(a), e && (this._runtime.Trigger(C32.Plugins.Flowchart.Cnds.OnAnyNodeChange, r), this._runtime.Trigger(C32.Plugins.Flowchart.Cnds.OnTaggedNodeChange, r)), this.PopFlowchartState(), this._currentFlowchartState.PopIsTriggerState();\n      }\n    }\n    _SaveToJson() {\n      return { \"flowchartJsonObjects\": [...this._flowchartStates.values()].map((t) => t._SaveToJson()), \"currentFlowchartTag\": this._currentFlowchartState ? this._currentFlowchartState.GetTag() : null };\n    }\n    _LoadFromJson(t) {\n      if (t) {\n        this._loadJson = t;\n        const e = /* @__PURE__ */ new Map();\n        for (const a of this._loadJson[\"flowchartJsonObjects\"]) {\n          const r = a[\"flowchartTag\"];\n          if (this._flowchartStates.has(r)) {\n            const h = this._flowchartStates.get(r);\n            h._LoadFromJson(a), e.set(r, h);\n          } else {\n            const s = this.AddFlowchartState(a[\"flowchartName\"], a[\"startNodeTag\"], a[\"flowchartTag\"], null, false, a[\"pluginUID\"]);\n            s._LoadFromJson(a), e.set(a[\"flowchartTag\"], s);\n          }\n        }\n        for (const [o, c] of this._flowchartStates.entries()) e.has(o) || c.Release();\n        this._flowchartStates.clear(), this._flowchartStates = e, this._runtime.IsLoadingState() ? this._runtime.Dispatcher().addEventListener(\"afterload\", this._on_after_load) : this._OnAfterLoad();\n      }\n    }\n    _OnAfterLoad() {\n      this._runtime.Dispatcher().removeEventListener(\"afterload\", this._on_after_load);\n      const t = this._flowchartStates.get(this._loadJson[\"currentFlowchartTag\"]);\n      t && this.SetCurrentFlowchartState(t, true), this._loadJson = null;\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.FlowchartDataManager = class {\n    constructor() {\n      this._flowchartDataItems = /* @__PURE__ */ new Map();\n    }\n    Release() {\n      for (const t of this._flowchartDataItems.values()) t.Release();\n      this._flowchartDataItems.clear(), this._flowchartDataItems = null;\n    }\n    Add(t) {\n      const a = new C32.FlowchartDataItem(t), s = a.GetName();\n      this._flowchartDataItems.set(s, a);\n    }\n    Get(t) {\n      return this._flowchartDataItems.get(t);\n    }\n    HasFlowcharts() {\n      return !!this._flowchartDataItems.size;\n    }\n    static CreateDataItems(t, a, s, e) {\n      if (a) for (const o of a) {\n        const r = new s(o, e);\n        t.push(r);\n      }\n    }\n  };\n}\n{\n  const C32 = self.C3, NAME = 0, NODES = 1;\n  C32.FlowchartDataItem = class {\n    constructor(t) {\n      this._name = t[NAME], this._flowchartNodeData = new C32.FlowchartNodeData(t[NODES], this);\n    }\n    Release() {\n      this._flowchartNodeData.Release(), this._flowchartNodeData = null;\n    }\n    GetFlowchartNodeData() {\n      return this._flowchartNodeData;\n    }\n    GetFlowchartElementById(t) {\n      return this._flowchartNodeData.GetFlowchartElementById(t);\n    }\n    GetFlowchartNodeByTags(t) {\n      return this._flowchartNodeData.GetFlowchartNodeByTags(t);\n    }\n    GetFlowchartStartNode() {\n      return this._flowchartNodeData.GetFlowchartStartNode();\n    }\n    GetName() {\n      return this._name;\n    }\n  };\n}\n{\n  const C32 = self.C3, FLOWCHART_ID = 0, TAG = 1, PARENT_FLOWCHART_IDS = 2, PARENT_OUTPUT_FLOWCHART_IDS = 3, CHILDREN_FLOWCHART_IDS = 4, OUTPUTS = 5, IS_START = 6, TYPE = 7, REFERENCE_FLOWCHART = 8, REFERENCE_FLOWCHART_START_NODE = 9, REFERENCE_FLOWCHART_TAG = 10;\n  class FlowchartNodeDataItem {\n    constructor(t, e) {\n      this._flowchartNodeData = e, this._type = t[TYPE], this._flowchartId = t[FLOWCHART_ID], this._tag = t[TAG], this._tag ? this._tags = this._tag.trim().split(\" \").map((t2) => t2.trim()) : this._tags = [], this._parentFlowchartIds = t[PARENT_FLOWCHART_IDS], this._parentOutputFlowchartIds = null, this._childrenFlowchartIds = null, \"dictionary\" === this._type && (this._parentOutputFlowchartIds = t[PARENT_OUTPUT_FLOWCHART_IDS], this._childrenFlowchartIds = t[CHILDREN_FLOWCHART_IDS]), this._isStart = t[IS_START], this._referenceFlowchartName = null, this._referenceFlowchartStartNodeTag = null, this._referenceFlowchartTag = null, \"reference\" === this._type && (this._referenceFlowchartName = t[REFERENCE_FLOWCHART], this._referenceFlowchartStartNodeTag = t[REFERENCE_FLOWCHART_START_NODE], this._referenceFlowchartTag = t[REFERENCE_FLOWCHART_TAG]), this._flowchartNodeOutputData = new C32.FlowchartNodeOutputData(t[OUTPUTS], this);\n    }\n    Release() {\n      this._flowchartNodeData = null;\n    }\n    GetFlowchartNodeData() {\n      return this._flowchartNodeData;\n    }\n    GetFlowchartNodeOutputData() {\n      return this._flowchartNodeOutputData;\n    }\n    GetFlowchartId() {\n      return this._flowchartId;\n    }\n    GetTag() {\n      return this._tag;\n    }\n    GetTags() {\n      return this._tags;\n    }\n    HasTags(t) {\n      if (!this._tags) return false;\n      if (!this._tags.length) return false;\n      const e = C32.FlowchartState._GetTagArray(t);\n      return !(!e || !e.length) && e.every(C32.FlowchartState._HasTag, this._tags);\n    }\n    GetIsStart() {\n      return this._isStart;\n    }\n    SetIsStart(t) {\n      this._isStart = !!t;\n    }\n    CanBeStartNode() {\n      if (\"dictionary\" === this._type) return true;\n      if (\"reference\" === this._type) return false;\n      throw new Error(\"unexpected flowchart node type: \" + this._type);\n    }\n    GetParentFlowchartIds() {\n      return this._parentFlowchartIds;\n    }\n    GetParentOutputFlowchartIds() {\n      return this._parentOutputFlowchartIds;\n    }\n    GetChildrenFlowchartIds() {\n      return this._childrenFlowchartIds;\n    }\n    GetType() {\n      return this._type;\n    }\n    GetReferenceFlowchartName() {\n      return this._referenceFlowchartName;\n    }\n    GetReferenceFlowchartStartNodeTag() {\n      return this._referenceFlowchartStartNodeTag;\n    }\n    GetReferenceFlowchartTag() {\n      return this._referenceFlowchartTag;\n    }\n  }\n  C32.FlowchartNodeData = class {\n    constructor(t, e) {\n      this._flowchartDataItem = e, this._flowchartNodeItems = [], this._flowchartNodeItemsIdMap = /* @__PURE__ */ new Map(), this._flowchartNodeItemsTagMap = /* @__PURE__ */ new Map(), this._flowchartNodeStartItem = null, C32.FlowchartDataManager.CreateDataItems(this._flowchartNodeItems, t, FlowchartNodeDataItem, this);\n      for (const a of this._flowchartNodeItems) {\n        const r = a.GetFlowchartId(), o = a.GetTag(), s = a.GetTags(), h = a.GetIsStart();\n        if (this._flowchartNodeItemsIdMap.set(r, a), o) for (const l of s) this._flowchartNodeItemsTagMap.has(l) || this._flowchartNodeItemsTagMap.set(l, /* @__PURE__ */ new Set()), this._flowchartNodeItemsTagMap.get(l).add(a);\n        h && (this._flowchartNodeStartItem = a);\n        const c = a.GetFlowchartNodeOutputData();\n        for (const i of c.flowchartNodeOutputDataItems()) {\n          const n = i.GetFlowchartId();\n          this._flowchartNodeItemsIdMap.set(n, i);\n        }\n      }\n      this._flowchartNodeStartItem || this._SetStartNodeIfMissing();\n    }\n    Release() {\n      this._flowchartDataItem = null;\n      for (const t of this._flowchartNodeItems) t.Release();\n      C32.clearArray(this._flowchartNodeItems), this._flowchartNodeItems = null;\n    }\n    GetFlowchartDataItem() {\n      return this._flowchartDataItem;\n    }\n    GetFlowchartElementById(t) {\n      return this._flowchartNodeItemsIdMap.get(t);\n    }\n    GetFlowchartNodeByTags(t) {\n      if (!t || !t.length) return null;\n      const a = [];\n      for (const r of t.trim().split(\" \")) {\n        let t2 = this._flowchartNodeItemsTagMap.get(r.trim()) ?? /* @__PURE__ */ new Set();\n        if (0 === t2.size) return null;\n        a.push(t2);\n      }\n      const e = a.reduce((t2, e2) => e2.size < t2.size ? e2 : t2);\n      return [...e].filter((e2) => a.every((t2) => t2.has(e2)))[0];\n    }\n    GetFlowchartStartNode() {\n      return this._flowchartNodeStartItem;\n    }\n    *flowchartNodeDataItems() {\n      for (const t of this._flowchartNodeItems) yield t;\n    }\n    _SetStartNodeIfMissing() {\n      let t = 0;\n      for (const e of this.flowchartNodeDataItems()) e.GetIsStart() && t++;\n      if (0 === t) {\n        for (const a of this.flowchartNodeDataItems()) if (a.CanBeStartNode() && !a.GetIsStart()) return void a.SetIsStart(true);\n      } else {\n        if (1 === t) return;\n        if (1 < t) {\n          let t2 = true;\n          for (const r of this.flowchartNodeDataItems()) r.CanBeStartNode() && (r.GetIsStart() && t2 ? t2 = false : r.GetIsStart() && !t2 && r.SetIsStart(false));\n        }\n      }\n      for (const o of this.flowchartNodeDataItems()) if (o.CanBeStartNode() && o.GetIsStart()) return void (this._flowchartNodeStartItem = o);\n    }\n  };\n}\n{\n  const C32 = self.C3, FLOWCHART_ID = 0, NAME = 1, VALUE = 2, CONNECTED_FLOWCHART_NODE_FLOWCHART_ID = 3;\n  class FlowchartNodeDataOutputItem {\n    constructor(t, e) {\n      this._flowchartNodeOutputData = e, this._flowchartId = t[FLOWCHART_ID], this._name = t[NAME], this._value = t[VALUE], this._connectedFlowchartNodeFlowchartId = t[CONNECTED_FLOWCHART_NODE_FLOWCHART_ID];\n    }\n    Release() {\n      this._flowchartNodeOutputData = null;\n    }\n    GetFlowchartNodeOutputData() {\n      return this._flowchartNodeOutputData;\n    }\n    GetFlowchartId() {\n      return this._flowchartId;\n    }\n    GetName() {\n      return this._name;\n    }\n    GetValue() {\n      return this._value;\n    }\n    GetConnectedFlowchartNodeFlowchartId() {\n      return this._connectedFlowchartNodeFlowchartId;\n    }\n  }\n  C32.FlowchartNodeOutputData = class {\n    constructor(t, e) {\n      this._flowchartDataNodeItem = e, this._flowchartNodeOutputItems = [], this._flowchartNodeOutputItemsNameMap = /* @__PURE__ */ new Map(), C32.FlowchartDataManager.CreateDataItems(this._flowchartNodeOutputItems, t, FlowchartNodeDataOutputItem, this);\n      for (const a of this._flowchartNodeOutputItems) this._flowchartNodeOutputItemsNameMap.set(a.GetName(), a);\n    }\n    Release() {\n      this._flowchartDataNodeItem = null;\n      for (const t of this._flowchartNodeOutputItems) t.Release();\n      C32.clearArray(this._flowchartNodeOutputItems), this._flowchartNodeOutputItems = null;\n    }\n    GetFlowchartNodeDataItem() {\n      return this._flowchartDataNodeItem;\n    }\n    GetFlowchartNodeOutputDataItemCount() {\n      return this._flowchartNodeOutputItems.length;\n    }\n    GetFlowchartNodeOutputDataItems() {\n      return this._flowchartNodeOutputItems;\n    }\n    GetFlowchartNodeOutputDataItemByName(t) {\n      return this._flowchartNodeOutputItemsNameMap.get(t);\n    }\n    *flowchartNodeOutputDataItems() {\n      for (const t of this._flowchartNodeOutputItems) yield t;\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.SolStack = class extends C32.DefendedBase {\n    constructor(t) {\n      super(), this._objectClass = t, this._stack = [], this._stack.push(C32.New(C32.Sol, this)), this._index = 0, this._current = this._stack[0];\n    }\n    Release() {\n      for (const t of this._stack) t.Release();\n      C32.clearArray(this._stack), this._current = null, this._objectClass = null;\n    }\n    GetObjectClass() {\n      return this._objectClass;\n    }\n    GetCurrentSol() {\n      return this._current;\n    }\n    GetOneBelowCurrentSol() {\n      return this._stack[this._index - 1];\n    }\n    Clear() {\n      this.GetCurrentSol().Clear();\n    }\n    PushClean() {\n      const t = this._stack, s = ++this._index;\n      if (s === t.length) {\n        const e = C32.New(C32.Sol, this);\n        t.push(e), this._current = e;\n      } else {\n        const n = t[s];\n        n.Reset(), this._current = n;\n      }\n    }\n    PushCopy() {\n      const t = this._stack, s = ++this._index, e = (s === t.length && t.push(C32.New(C32.Sol, this)), t[s]);\n      e.Copy(t[s - 1]), this._current = e;\n    }\n    Pop() {\n      this._current = this._stack[--this._index];\n    }\n    RemoveInstances(e) {\n      const n = this._stack;\n      for (let t = 0, s = n.length; t < s; ++t) n[t].RemoveInstances(e);\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.Sol = class extends C32.DefendedBase {\n    constructor(s) {\n      super(), this._stack = s, this._objectClass = this._stack.GetObjectClass(), this._eventStack = this._objectClass.GetRuntime().GetEventStack(), this._selectAll = true, this._instances = [], this._elseInstances = [];\n    }\n    Release() {\n      this.ClearArrays(), this._stack = null, this._objectClass = null, this._eventStack = null;\n    }\n    ClearArrays() {\n      C32.clearArray(this._instances), C32.clearArray(this._elseInstances);\n    }\n    GetObjectClass() {\n      return this._objectClass;\n    }\n    IsSelectAll() {\n      return this._selectAll;\n    }\n    HasAnyInstances() {\n      return this._selectAll ? !!this._objectClass.GetInstanceCount() : !!this._instances.length;\n    }\n    GetInstances() {\n      return this._selectAll ? this._objectClass.GetInstances() : this._instances;\n    }\n    HasAnyElseInstances() {\n      return !!this._elseInstances.length;\n    }\n    GetElseInstances() {\n      return this._elseInstances;\n    }\n    GetExpressionInstances() {\n      const s = this.GetInstances();\n      return s.length ? s : this._elseInstances;\n    }\n    Reset() {\n      this._selectAll = true, C32.clearArray(this._elseInstances);\n    }\n    Clear() {\n      this._selectAll = true;\n    }\n    Copy(s) {\n      s.IsSelectAll() ? this.Reset() : (this._selectAll = false, C32.shallowAssignArray(this._instances, s._instances), C32.clearArray(this._elseInstances));\n    }\n    _PushInstance(s) {\n      this._instances.push(s);\n    }\n    _PushElseInstance(s) {\n      this._elseInstances.push(s);\n    }\n    _SetSelectAll(s) {\n      this._selectAll = !!s;\n    }\n    _GetOwnInstances() {\n      return this._instances;\n    }\n    _GetOwnElseInstances() {\n      return this._elseInstances;\n    }\n    SetSinglePicked(s) {\n      this._selectAll = false, C32.clearArray(this._instances), this._instances.push(s);\n    }\n    SetArrayPicked(s) {\n      this._selectAll = false, C32.shallowAssignArray(this._instances, s);\n    }\n    SetSetPicked(s) {\n      this._selectAll = false, C32.clearArray(this._instances);\n      for (const e of s) this._instances.push(e);\n    }\n    AddElseInstances(s, e) {\n      for (const t of e) s.has(t) || this._elseInstances.push(t);\n    }\n    TransferElseInstancesToOwn(s) {\n      for (const e of s) this._instances.push(e);\n      C32.arrayRemoveAllInSet(this._elseInstances, s);\n    }\n    ClearElseInstances() {\n      C32.clearArray(this._elseInstances);\n    }\n    PickOne(s) {\n      if (s) if (this._eventStack.GetCurrentStackFrame().GetCurrentEvent().IsOrBlock()) {\n        this.IsSelectAll() && (C32.clearArray(this._instances), C32.shallowAssignArray(this._elseInstances, s.GetObjectClass().GetInstances()), this._selectAll = false);\n        const e = this._elseInstances.indexOf(s);\n        -1 !== e && (this._instances.push(this._elseInstances[e]), this._elseInstances.splice(e, 1));\n      } else this.SetSinglePicked(s);\n    }\n    RemoveInstances(s) {\n      C32.arrayRemoveAllInSet(this._instances, s), C32.arrayRemoveAllInSet(this._elseInstances, s);\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.EventStack = class extends C32.DefendedBase {\n    constructor(t) {\n      super(), this._eventSheetManager = t, this._runtime = this._eventSheetManager.GetRuntime(), this._stack = [], this._stack.push(C32.New(C32.EventStackFrame, this, null)), this._index = 0, this._expFuncStack = [];\n    }\n    Release() {\n      for (const t of this._stack) t.Release();\n      C32.clearArray(this._stack), C32.clearArray(this._expFuncStack), this._eventSheetManager = null, this._runtime = null;\n    }\n    GetEventSheetManager() {\n      return this._eventSheetManager;\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetCurrentStackFrame() {\n      return this._stack[this._index];\n    }\n    GetAllStackFrames() {\n      return this._stack;\n    }\n    GetCurrentStackFrameIndex() {\n      return this._index;\n    }\n    Push(t) {\n      const e = this._stack, n = ++this._index;\n      if (n === e.length) {\n        const s = C32.New(C32.EventStackFrame, this, t);\n        return e.push(s), s;\n      }\n      {\n        const r = e[n];\n        return r.Reset(t), r;\n      }\n    }\n    Pop() {\n      --this._index;\n    }\n    PushExpFunc(t) {\n      this._expFuncStack.push(t);\n    }\n    PopExpFunc() {\n      this._expFuncStack.pop();\n    }\n    GetCurrentExpFuncStackFrame() {\n      const t = this._expFuncStack;\n      return 0 === t.length ? null : t.at(-1);\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.EventStackFrame = class extends C32.DefendedBase {\n    constructor(t, e) {\n      super(), this._stack = t, this._runtime = this._stack.GetRuntime(), this._currentEvent = e, this._cndIndex = 0, this._actIndex = 0, this._lastEventTrue = false, this._elseBranchRan = false, this._expressionObjectClass = null, this._functionReturnType = 0, this._functionReturnValue = 0, this._dynamicSolModifiers = null;\n    }\n    Release() {\n      this.Reset(null), this._stack = null, this._runtime = null;\n    }\n    Reset(t) {\n      this._currentEvent = t, this._cndIndex = 0, this._actIndex = 0, this._lastEventTrue = false, this._elseBranchRan = false, this._dynamicSolModifiers = null;\n    }\n    _Restore(t, e) {\n      this._currentEvent = t, this._cndIndex = 0, this._actIndex = e;\n    }\n    ResetQuick() {\n      this._cndIndex = 0, this._actIndex = 0;\n    }\n    GetCurrentEvent() {\n      return this._currentEvent;\n    }\n    SetCurrentEvent(t) {\n      this._currentEvent = t;\n    }\n    GetConditionIndex() {\n      return this._cndIndex;\n    }\n    SetConditionIndex(t) {\n      this._cndIndex = t;\n    }\n    GetActionIndex() {\n      return this._actIndex;\n    }\n    SetActionIndex(t) {\n      this._actIndex = t;\n    }\n    SetLastEventTrue(t) {\n      this._lastEventTrue = !!t;\n    }\n    GetLastEventTrue() {\n      return this._lastEventTrue;\n    }\n    SetElseBranchRan(t) {\n      this._elseBranchRan = !!t;\n    }\n    GetElseBranchRan() {\n      return this._elseBranchRan;\n    }\n    SetExpressionObjectClass(t) {\n      this._expressionObjectClass = t;\n    }\n    GetExpressionObjectClass() {\n      return this._expressionObjectClass;\n    }\n    InitCallFunctionExpression(t, e) {\n      this._functionReturnType = t, this._functionReturnValue = e;\n    }\n    GetFunctionReturnType() {\n      return this._functionReturnType;\n    }\n    SetFunctionReturnValue(t) {\n      this._functionReturnValue = t;\n    }\n    GetFunctionReturnValue() {\n      return this._functionReturnValue;\n    }\n    IsSolModifierAfterCnds() {\n      const t = this._currentEvent;\n      return !!t.IsSolWriterAfterCnds() || this._cndIndex < t.GetConditionCount() - 1 && !!t.GetSolModifiers().length;\n    }\n    SetDynamicSolModifiers(t) {\n      this._dynamicSolModifiers = t;\n    }\n    GetDynamicSolModifiers() {\n      return this._dynamicSolModifiers;\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.LocalVarStack = class extends C32.DefendedBase {\n    constructor(t) {\n      super(), this._eventSheetManager = t, this._runtime = this._eventSheetManager.GetRuntime(), this._stack = [], this._index = -1, this._current = null, this._initialValues = [];\n    }\n    Release() {\n      C32.clearArray(this._stack), this._eventSheetManager = null, this._runtime = null;\n    }\n    _SetInitialValues(t) {\n      this._initialValues = t;\n      const e = this._initialValues.slice(0);\n      this._stack.push(e), this._index = 0, this._current = e;\n    }\n    GetEventSheetManager() {\n      return this._eventSheetManager;\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetCurrent() {\n      return this._current;\n    }\n    Push() {\n      const t = ++this._index, e = this._stack;\n      t === e.length ? e.push(this._initialValues.slice(0)) : C32.shallowAssignArray(e[t], this._initialValues), this._current = e[t];\n    }\n    Pop() {\n      this._current = this._stack[--this._index];\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.LoopStack = class extends C32.DefendedBase {\n    constructor(t) {\n      super(), this._eventSheetManager = t, this._runtime = this._eventSheetManager.GetRuntime(), this._stack = [], this._index = -1;\n    }\n    Release() {\n      C32.clearArray(this._stack), this._eventSheetManager = null, this._runtime = null;\n    }\n    GetEventSheetManager() {\n      return this._eventSheetManager;\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    IsInLoop() {\n      return 0 <= this._index;\n    }\n    GetCurrent() {\n      return this._stack[this._index];\n    }\n    Push() {\n      if (++this._index, this._index === this._stack.length) {\n        const t = C32.New(C32.Loop, this);\n        return this._stack.push(t), t;\n      }\n      {\n        const e = this._stack[this._index];\n        return e.Reset(), e;\n      }\n    }\n    Pop() {\n      --this._index;\n    }\n    FindByName(e) {\n      const s = this._stack;\n      for (let t = this._index; 0 <= t; --t) {\n        const n = s[t];\n        if (n.GetName() === e) return n;\n      }\n      return null;\n    }\n    _GetStack() {\n      return this._stack.slice(0, this._index + 1);\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.Loop = class extends C32.DefendedBase {\n    constructor(e) {\n      super(), this._loopStack = e, this._name = \"\", this._index = 0, this._isStopped = false, this._end = NaN;\n    }\n    Reset() {\n      this._name = \"\", this._index = 0, this._isStopped = false, this._end = NaN;\n    }\n    SetName(e) {\n      this._name = e;\n    }\n    GetName() {\n      return this._name;\n    }\n    SetIndex(e) {\n      this._index = e;\n    }\n    GetIndex() {\n      return this._index;\n    }\n    Stop() {\n      this._isStopped = true;\n    }\n    IsStopped() {\n      return this._isStopped;\n    }\n    SetEnd(e) {\n      this._end = e;\n    }\n    GetEnd() {\n      return this._end;\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.ArrayStack = class extends C32.DefendedBase {\n    constructor() {\n      super(), this._stack = [], this._index = -1;\n    }\n    Release() {\n      C32.clearArray(this._stack);\n    }\n    GetCurrent() {\n      return this._stack[this._index];\n    }\n    Push() {\n      if (++this._index, this._index !== this._stack.length) return this._stack[this._index];\n      {\n        const s = [];\n        return this._stack.push(s), s;\n      }\n    }\n    Pop() {\n      --this._index;\n    }\n  };\n}\n{\n  let SortSolArray = function(t, e) {\n    return t.GetIndex() - e.GetIndex();\n  }, IsSolArrayIdentical = function(s, n) {\n    for (let t = 0, e = s.length; t < e; ++t) if (s[t] !== n[t]) return false;\n    return true;\n  };\n  SortSolArray2 = SortSolArray, IsSolArrayIdentical2 = IsSolArrayIdentical;\n  const C32 = self.C3, assert = self.assert;\n  C32.EventSheetManager = class extends C32.DefendedBase {\n    constructor(t) {\n      super(), this._runtime = t, this._allSheets = [], this._sheetsByName = /* @__PURE__ */ new Map(), this._allGroups = [], this._groupsByName = /* @__PURE__ */ new Map(), this._blocksBySid = /* @__PURE__ */ new Map(), this._cndsBySid = /* @__PURE__ */ new Map(), this._actsBySid = /* @__PURE__ */ new Map(), this._allUniqueSolModifiers = /* @__PURE__ */ new Map(), this._eventVarsBySid = /* @__PURE__ */ new Map(), this._nextLocalVarIndex = 0, this._allGlobalVars = [], this._allLocalVars = [], this._localVarInitialValues = [], this._functionBlocksByName = /* @__PURE__ */ new Map(), this._customActionBlocksMap = /* @__PURE__ */ new Map(), this._eventStack = C32.New(C32.EventStack, this), this._localVarStack = C32.New(C32.LocalVarStack, this), this._loopStack = C32.New(C32.LoopStack, this), this._triggersToPostInit = [], this._queuedTriggers = [], this._queuedDebugTriggers = [], this._runningEventsDepth = 0, this._executingTriggerDepth = 0, this._blockFlushingDepth = 0, this._scheduledWaits = [], this._asyncActionPromises = [], this._signalTags = [], this._signalPromises = /* @__PURE__ */ new Map(), this._instSignals = /* @__PURE__ */ new Map(), self[\"c3_callFunction\"] = (t2, e) => this._InvokeFunctionFromJS(t2, e);\n    }\n    Release() {\n      this.ClearAllScheduledWaits(), this._eventStack.Release(), this._eventStack = null, this._localVarStack.Release(), this._localVarStack = null, C32.clearArray(this._queuedTriggers), C32.clearArray(this._queuedDebugTriggers), this._runtime = null, C32.clearArray(this._allSheets), this._sheetsByName.clear();\n    }\n    Create(t) {\n      const e = C32.New(C32.EventSheet, this, t);\n      this._allSheets.push(e), this._sheetsByName.set(e.GetName().toLowerCase(), e);\n    }\n    _AddTriggerToPostInit(t) {\n      this._triggersToPostInit.push(t);\n    }\n    _PostInit() {\n      for (const t of this._customActionBlocksMap.values()) t._CheckOverrideState();\n      for (const e of this._functionBlocksByName.values()) e._PostInit();\n      for (const s of this._customActionBlocksMap.values()) s._PostInit();\n      for (const n of this._allSheets) n._PostInit();\n      for (const i of this._allSheets) i._UpdateDeepIncludes();\n      for (const r of this._triggersToPostInit) r._PostInit(false);\n      C32.clearArray(this._triggersToPostInit), this._localVarStack._SetInitialValues(this._localVarInitialValues);\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetEventSheetByName(t) {\n      return this._sheetsByName.get(t.toLowerCase()) || null;\n    }\n    _RegisterGroup(t) {\n      this._allGroups.push(t), this._groupsByName.set(t.GetGroupName(), t);\n    }\n    _RegisterEventBlock(t) {\n      this._blocksBySid.set(t.GetSID(), t);\n    }\n    _RegisterCondition(t) {\n      this._cndsBySid.set(t.GetSID(), t);\n    }\n    _RegisterAction(t) {\n      this._actsBySid.set(t.GetSID(), t);\n    }\n    _RegisterFunctionBlock(t) {\n      switch (t.GetFunctionType()) {\n        case 0:\n          this._functionBlocksByName.set(t.GetFunctionName().toLowerCase(), t);\n          break;\n        case 1:\n          this._customActionBlocksMap.set(t.GetFunctionName().toLowerCase(), t);\n      }\n    }\n    _RegisterEventVariable(t) {\n      this._eventVarsBySid.set(t.GetSID(), t), (t.IsGlobal() ? this._allGlobalVars : this._allLocalVars).push(t);\n    }\n    _DeduplicateSolModifierList(s) {\n      2 <= s.length && s.sort(SortSolArray);\n      let n = this._allUniqueSolModifiers.get(s.length);\n      n || (n = [], this._allUniqueSolModifiers.set(s.length, n));\n      for (let t = 0, e = n.length; t < e; ++t) {\n        const i = n[t];\n        if (IsSolArrayIdentical(s, i)) return i;\n      }\n      return n.push(s), s;\n    }\n    _GetNextLocalVarIndex(t) {\n      return this._localVarInitialValues.push(t.GetInitialValue()), this._nextLocalVarIndex++;\n    }\n    GetEventStack() {\n      return this._eventStack;\n    }\n    GetCurrentEventStackFrame() {\n      return this.GetEventStack().GetCurrentStackFrame();\n    }\n    GetCurrentEvent() {\n      return this.GetCurrentEventStackFrame().GetCurrentEvent();\n    }\n    GetCurrentCondition() {\n      const t = this.GetCurrentEventStackFrame(), e = t.GetCurrentEvent();\n      return e.GetConditionAt(t.GetConditionIndex());\n    }\n    GetCurrentAction() {\n      const t = this.GetCurrentEventStackFrame(), e = t.GetCurrentEvent();\n      return e.GetActionAt(t.GetActionIndex());\n    }\n    GetLocalVarStack() {\n      return this._localVarStack;\n    }\n    GetLoopStack() {\n      return this._loopStack;\n    }\n    GetAllLocalVariablesInScope(t) {\n      const e = [];\n      for (t = t.GetScopeParent(); t; ) C32.appendArray(e, t._GetAllLocalVariablesInScope()), t = t.GetScopeParent();\n      return e;\n    }\n    _GetLocalVariablesScriptInterface(t) {\n      const e = {};\n      for (const s of this.GetAllLocalVariablesInScope(t)) e[s.GetJsPropName()] = s._GetScriptInterfaceDescriptor();\n      return Object.create(Object.prototype, e);\n    }\n    GetEventVariableBySID(t) {\n      return this._eventVarsBySid.get(t) || null;\n    }\n    GetEventBlockBySID(t) {\n      return this._blocksBySid.get(t) || null;\n    }\n    GetConditionBySID(t) {\n      return this._cndsBySid.get(t) || null;\n    }\n    GetActionBySID(t) {\n      return this._actsBySid.get(t) || null;\n    }\n    GetFunctionBlockByName(t) {\n      return this._functionBlocksByName.get(t.toLowerCase()) || null;\n    }\n    GetCustomActionBlockByName(t, e) {\n      let s = this._customActionBlocksMap.get((t.GetName() + \".\" + e).toLowerCase());\n      if (s) return s;\n      if (!t.IsFamily()) {\n        for (const n of t.GetFamilies()) if (s = this._customActionBlocksMap.get((n.GetName() + \".\" + e).toLowerCase())) return s;\n      }\n      return null;\n    }\n    GetAllGlobalVariables() {\n      return this._allGlobalVars;\n    }\n    GetAllLocalVariables() {\n      return this._allLocalVars;\n    }\n    ResetAllGlobalsToInitialValue(t) {\n      for (const e of this._allGlobalVars) e.ResetToInitialValue();\n      if (t) for (const s of this._allLocalVars) s.IsStatic() && s.ResetToInitialValue();\n    }\n    GetEventGroupByName(t) {\n      return this._groupsByName.get(t.toLowerCase()) || null;\n    }\n    GetEventGroupBySID(t) {\n      const e = this._blocksBySid.get(t);\n      return e && e.IsGroup() ? e : null;\n    }\n    GetAllGroups() {\n      return this._allGroups;\n    }\n    ResetAllGroupsInitialActivation() {\n      for (const t of this._allGroups) t.ResetInitialActivation();\n    }\n    _ResetAllHasRunFlags() {\n      for (const t of this._allSheets) t._ResetHasRunFlag();\n    }\n    RunEvents(t) {\n      this._ResetAllHasRunFlags(), this._runningEventsDepth++;\n      for (const e of t.runningLayouts()) {\n        const s = e.GetEventSheet();\n        s && (this._runtime.PushCurrentLayout(e), s.Run(), this._runtime.PopCurrentLayout());\n      }\n      this._runningEventsDepth--;\n    }\n    async DebugRunEvents(t) {\n      this._ResetAllHasRunFlags(), this._runningEventsDepth++;\n      for (const e of this._DebugRunEventsGen(t)) await this._runtime.DebugBreak(e);\n      this._runningEventsDepth--;\n    }\n    *_DebugRunEventsGen(t) {\n      for (const e of t.runningLayouts()) {\n        const s = e.GetEventSheet();\n        s && (this._runtime.PushCurrentLayout(e), yield* s.DebugRun(), this._runtime.PopCurrentLayout());\n      }\n    }\n    _Trigger(t, e, s, n) {\n      let i = false;\n      if (!t.GetMainRunningLayout()) return this.QueueTrigger(e, s, n);\n      this._executingTriggerDepth++;\n      for (const r of t.runningLayouts()) {\n        const o = r.GetEventSheet();\n        if (o) {\n          this._runtime.PushCurrentLayout(r);\n          for (const l of o.deepIncludes()) {\n            const u = l._Trigger(e, s, n);\n            i = i || u;\n          }\n          const a = o._Trigger(e, s, n);\n          i = i || a, this._runtime.PopCurrentLayout();\n        }\n      }\n      return this._executingTriggerDepth--, i;\n    }\n    *_DebugTrigger(t, e, s, n) {\n      let i = false;\n      if (!t.GetMainRunningLayout()) return this.QueueTrigger(e, s, n);\n      this._executingTriggerDepth++;\n      for (const r of t.runningLayouts()) {\n        const o = r.GetEventSheet();\n        if (o) {\n          this._runtime.PushCurrentLayout(r);\n          for (const l of o.deepIncludes()) {\n            const u = yield* l._DebugTrigger(e, s, n);\n            i = i || u;\n          }\n          const a = yield* o._DebugTrigger(e, s, n);\n          i = i || a, this._runtime.PopCurrentLayout();\n        }\n      }\n      return this._executingTriggerDepth--, i;\n    }\n    QueueTrigger(t, e, s) {\n      return this._queuedTriggers.push([t, e, s]), false;\n    }\n    QueueDebugTrigger(t, e, s) {\n      let n = null;\n      const i = new Promise((t2) => n = t2);\n      return this._queuedDebugTriggers.push([t, e, s, n]), i;\n    }\n    *_RunQueuedDebugTriggersGen() {\n      if (this._runtime.HitBreakpoint()) throw new Error(\"should not be in breakpoint\");\n      const t = this._runtime.GetLayoutManager();\n      for (; this._queuedDebugTriggers.length; ) {\n        const [e, s, n, i] = this._queuedDebugTriggers.shift(), r = yield* this._DebugTrigger(t, e, s, n);\n        i(r);\n      }\n    }\n    async RunQueuedDebugTriggersAsync() {\n      for (const t of this._RunQueuedDebugTriggersGen()) await this._runtime.DebugBreak(t);\n    }\n    _FastTrigger(t, s, n, i) {\n      let r = false;\n      const e = t.GetMainRunningLayout(), o = e.GetEventSheet();\n      if (o) {\n        this._executingTriggerDepth++, this._runtime.PushCurrentLayout(e);\n        const a = o.deepIncludes();\n        for (let t2 = 0, e2 = a.length; t2 < e2; ++t2) {\n          const u = a[t2]._FastTrigger(s, n, i);\n          r = r || u;\n        }\n        const l = o._FastTrigger(s, n, i);\n        return r = r || l, this._runtime.PopCurrentLayout(), this._executingTriggerDepth--, r;\n      }\n    }\n    *_DebugFastTrigger(t, s, n, i) {\n      let r = false;\n      const e = t.GetMainRunningLayout(), o = e.GetEventSheet();\n      if (o) {\n        this._executingTriggerDepth++, this._runtime.PushCurrentLayout(e);\n        const a = o.deepIncludes();\n        for (let t2 = 0, e2 = a.length; t2 < e2; ++t2) {\n          const u = yield* a[t2]._DebugFastTrigger(s, n, i);\n          r = r || u;\n        }\n        const l = yield* o._DebugFastTrigger(s, n, i);\n        return r = r || l, this._runtime.PopCurrentLayout(), this._executingTriggerDepth--, r;\n      }\n    }\n    GetTriggerDepth() {\n      return this._executingTriggerDepth;\n    }\n    IsInTrigger() {\n      return 0 < this.GetTriggerDepth();\n    }\n    _IncTriggerDepth() {\n      return ++this._executingTriggerDepth;\n    }\n    _DecTriggerDepth() {\n      --this._executingTriggerDepth;\n    }\n    IsRunningEvents() {\n      return 0 < this._runningEventsDepth;\n    }\n    IsInEventEngine() {\n      return this.IsRunningEvents() || this.IsInTrigger();\n    }\n    _RunQueuedTriggers(t) {\n      for (const [e, s, n] of this._queuedTriggers) this._Trigger(t, e, s, n);\n      C32.clearArray(this._queuedTriggers);\n    }\n    BlockFlushingInstances(t) {\n      t ? this._blockFlushingDepth++ : this._blockFlushingDepth--;\n    }\n    IsFlushingBlocked() {\n      return 0 < this._blockFlushingDepth;\n    }\n    ClearSol(s) {\n      for (let t = 0, e = s.length; t < e; ++t) s[t].GetSolStack().Clear();\n    }\n    PushCleanSol(s) {\n      for (let t = 0, e = s.length; t < e; ++t) s[t].GetSolStack().PushClean();\n    }\n    PushCopySol(s) {\n      for (let t = 0, e = s.length; t < e; ++t) s[t].GetSolStack().PushCopy();\n    }\n    PopSol(s) {\n      for (let t = 0, e = s.length; t < e; ++t) s[t].GetSolStack().Pop();\n    }\n    GetDynamicSolModifiersSet(e) {\n      const s = /* @__PURE__ */ new Set(), n = this._eventStack.GetAllStackFrames(), i = this._eventStack.GetCurrentStackFrameIndex();\n      for (let t = 0; t <= i; ++t) {\n        const r = n[t].GetDynamicSolModifiers();\n        if (r) for (const o of r) e && e.has(o) || s.add(o);\n      }\n      return s;\n    }\n    PushCleanSolDynamic(t) {\n      const e = /* @__PURE__ */ new Set([...t]), s = this.GetDynamicSolModifiersSet(e);\n      if (0 < s.size) {\n        for (const n of s) n.GetSolStack().PushClean();\n        return [...s];\n      }\n      return null;\n    }\n    AddScheduledWait() {\n      const t = C32.New(C32.ScheduledWait, this);\n      return this._scheduledWaits.push(t), t;\n    }\n    scheduledWaits() {\n      return this._scheduledWaits;\n    }\n    RunScheduledWaits() {\n      if (this._scheduledWaits.length) {\n        const n = this.GetCurrentEventStackFrame();\n        let s = false;\n        this._runningEventsDepth++;\n        for (let t = 0, e = this._scheduledWaits.length; t < e; ++t) {\n          const i = this._scheduledWaits[t];\n          i._ShouldRun() && i._Run(n), i.ShouldRelease() && (s = true);\n        }\n        s && (this._FilterScheduledWaitsToRelease(), n.Reset(null)), this._runningEventsDepth--;\n      }\n    }\n    async DebugRunScheduledWaits() {\n      if (this._scheduledWaits.length) {\n        const n = this.GetCurrentEventStackFrame();\n        let s = false;\n        this._runningEventsDepth++;\n        for (let t = 0, e = this._scheduledWaits.length; t < e; ++t) {\n          const i = this._scheduledWaits[t];\n          i._ShouldRun() && await i._DebugRun(n), i.ShouldRelease() && (s = true);\n        }\n        s && (this._FilterScheduledWaitsToRelease(), n.Reset(null)), this._runningEventsDepth--;\n      }\n    }\n    _FilterScheduledWaitsToRelease() {\n      const t = C32.arrayFilterOut(this._scheduledWaits, (t2) => t2.ShouldRelease());\n      for (const e of t) e.Release();\n    }\n    ClearAllScheduledWaits() {\n      for (const t of this._scheduledWaits) t.Release();\n      C32.clearArray(this._scheduledWaits);\n    }\n    _OnInstancesReleased(t) {\n      for (const e of this._scheduledWaits) e.RemoveInstances(t);\n      for (const s of t) {\n        const n = this._instSignals.get(s);\n        if (this._instSignals.delete(s), n) for (const { resolve: i } of n.signalPromises.values()) i(true);\n      }\n    }\n    AddAsyncActionPromise(t) {\n      this._asyncActionPromises.push({ promise: t, triggerDepth: this.GetTriggerDepth() });\n    }\n    ClearAsyncActionPromises() {\n      C32.clearArray(this._asyncActionPromises);\n    }\n    ClearNestedAsyncActionPromises() {\n      const e = this.GetTriggerDepth();\n      this._asyncActionPromises = this._asyncActionPromises.filter((t) => t.triggerDepth <= e);\n    }\n    GetPromiseForAllAsyncActions() {\n      const t = Promise.all(this._asyncActionPromises.map((t2) => t2.promise));\n      return this._asyncActionPromises = [], t;\n    }\n    Signal(t) {\n      const e = t.toLowerCase();\n      this._signalTags.push(e), this._runtime.Trigger(C32.Plugins.System.Cnds.OnSignal, null), this._signalTags.pop();\n      for (const n of this._runtime.GetEventSheetManager().scheduledWaits()) n.IsSignal() && n.GetSignalTag() === e && n.SetSignalled();\n      const s = this._signalPromises.get(e);\n      s && (s.resolve(), this._signalPromises.delete(e));\n    }\n    WaitForSignal(t) {\n      const s = t.toLowerCase(), e = this._signalPromises.get(s);\n      if (e) return e.promise;\n      {\n        let e2 = null;\n        const n = new Promise((t2) => e2 = t2);\n        return this._signalPromises.set(s, { promise: n, resolve: e2 }), n;\n      }\n    }\n    GetCurrentSignalTag() {\n      if (0 === this._signalTags.length) throw new Error(\"not in a signal\");\n      return this._signalTags.at(-1);\n    }\n    _GetInstanceSignalState(t) {\n      let e = this._instSignals.get(t);\n      return e || (e = { signalTags: [], signalPromises: /* @__PURE__ */ new Map() }, this._instSignals.set(t, e)), e;\n    }\n    InstanceSignal(t, e) {\n      const s = this._GetInstanceSignalState(t), n = e.toLowerCase();\n      s.signalTags.push(n), this._runtime.Trigger(t.GetPlugin().GetConstructor().Cnds.OnInstanceSignal, t), s.signalTags.pop();\n      for (const r of this._runtime.GetEventSheetManager().scheduledWaits()) r.IsInstanceSignals() && r.GetSignalTag() === n && r.SetInstanceSignalled(t);\n      const i = s.signalPromises.get(n);\n      i && (i.resolve(false), s.signalPromises.delete(n)), 0 === s.signalTags.length && 0 === s.signalPromises.size && this._instSignals.delete(t);\n    }\n    WaitForInstanceSignal(t, e) {\n      const s = this._GetInstanceSignalState(t), n = e.toLowerCase(), i = s.signalPromises.get(n);\n      if (i) return i.promise;\n      {\n        let e2 = null;\n        const r = new Promise((t2) => e2 = t2);\n        return s.signalPromises.set(n, { promise: r, resolve: e2 }), r;\n      }\n    }\n    GetCurrentInstanceSignalTag(t) {\n      const e = this._GetInstanceSignalState(t);\n      if (e && 0 !== e.signalTags.length) return e.signalTags.at(-1);\n      throw new Error(\"not in a signal\");\n    }\n    _SaveToJson() {\n      return { \"groups\": this._SaveGroupsToJson(), \"cnds\": this._SaveCndsToJson(), \"acts\": this._SaveActsToJson(), \"vars\": this._SaveVarsToJson(), \"waits\": this._SaveScheduledWaitsToJson() };\n    }\n    _LoadFromJson(t) {\n      this._LoadGroupsFromJson(t[\"groups\"]), this._LoadCndsFromJson(t[\"cnds\"]), this._LoadActsFromJson(t[\"acts\"]), this._LoadVarsFromJson(t[\"vars\"]), this._LoadScheduledWaitsFromJson(t[\"waits\"]);\n    }\n    _SaveGroupsToJson() {\n      const t = {};\n      for (const e of this.GetAllGroups()) t[e.GetSID().toString()] = e.IsGroupActive();\n      return t;\n    }\n    _LoadGroupsFromJson(t) {\n      for (const [e, s] of Object.entries(t)) {\n        const n = parseInt(e, 10), i = this.GetEventGroupBySID(n);\n        i && i.SetGroupActive(s);\n      }\n    }\n    _SaveCndsToJson() {\n      const t = {};\n      for (const [e, s] of this._cndsBySid) {\n        const n = s._SaveToJson();\n        n && (t[e.toString()] = n);\n      }\n      return t;\n    }\n    _LoadCndsFromJson(t) {\n      const e = /* @__PURE__ */ new Map();\n      for (const [s, n] of Object.entries(t)) e.set(parseInt(s, 10), n);\n      for (const [i, r] of this._cndsBySid) r._LoadFromJson(e.get(i) || null);\n    }\n    _SaveActsToJson() {\n      const t = {};\n      for (const [e, s] of this._actsBySid) {\n        const n = s._SaveToJson();\n        n && (t[e.toString()] = n);\n      }\n      return t;\n    }\n    _LoadActsFromJson(t) {\n      const e = /* @__PURE__ */ new Map();\n      for (const [s, n] of Object.entries(t)) e.set(parseInt(s, 10), n);\n      for (const [i, r] of this._actsBySid) r._LoadFromJson(e.get(i) || null);\n    }\n    _SaveVarsToJson() {\n      const t = {};\n      for (const [e, s] of this._eventVarsBySid) s.IsConstant() || !s.IsGlobal() && !s.IsStatic() || (t[e.toString()] = s.GetValue());\n      return t;\n    }\n    _LoadVarsFromJson(t) {\n      for (const [e, s] of Object.entries(t)) {\n        const n = parseInt(e, 10), i = this.GetEventVariableBySID(n);\n        i && i.SetValue(s);\n      }\n    }\n    _SaveScheduledWaitsToJson() {\n      return this._scheduledWaits.filter((t) => !t.IsPromise()).map((t) => t._SaveToJson());\n    }\n    _LoadScheduledWaitsFromJson(t) {\n      this.ClearAllScheduledWaits();\n      for (const e of t) {\n        const s = C32.ScheduledWait._CreateFromJson(this, e);\n        s && this._scheduledWaits.push(s);\n      }\n    }\n    _GetPerfRecords() {\n      return [...this._runtime.GetLayoutManager().runningLayouts()].map((t) => t.GetEventSheet()).filter((t) => t).map((t) => t._GetPerfRecord());\n    }\n    FindFirstFunctionBlockParent(t) {\n      for (; t; ) {\n        const e = t.GetScopeParent();\n        if (e instanceof C32.FunctionBlock) return e;\n        t = e;\n      }\n      return null;\n    }\n    _InvokeFunctionFromJS(t, e) {\n      Array.isArray(e) || (e = []);\n      const s = this.GetFunctionBlockByName(t.toLowerCase());\n      if (!s) return null;\n      if (!s.IsEnabled()) return s.GetDefaultReturnValue();\n      const n = s.GetFunctionParameters();\n      if (e.length < n.length) for (e = e.slice(0); e.push(n[e.length].GetInitialValue()), e.length < n.length; ) ;\n      const i = s.GetEventBlock();\n      return i.RunAsExpressionFunctionCall(i.GetSolModifiersIncludingParents(), false, s.GetReturnType(), s.GetDefaultReturnValue(), ...e);\n    }\n  };\n}\nvar SortSolArray2;\nvar IsSolArrayIdentical2;\n{\n  const C32 = self.C3;\n  C32.EventSheet = class extends C32.DefendedBase {\n    constructor(e, t) {\n      super(), this._eventSheetManager = e, this._runtime = e.GetRuntime(), this._name = t[0], this._events = [], this._triggers = /* @__PURE__ */ new Map(), this._fastTriggers = /* @__PURE__ */ new Map(), this._eventsByDisplayNumber = /* @__PURE__ */ new Map(), this._hasRun = false, this._shallowIncludes = [], this._deepIncludes = [], this._alreadyIncludedSheets = /* @__PURE__ */ new Set();\n      for (const s of t[1]) this._CreateEvent(s, null, this._events);\n      this._perfRecord = this._runtime.IsDebug() ? { type: \"sheet\", name: this._name, totalTimeCounter: 0, children: [] } : null;\n    }\n    Release() {\n      this._eventSheetManager = null, this._runtime = null;\n    }\n    _CreateEvent(e, t, s) {\n      switch (e[0]) {\n        case 0:\n        case 3:\n          this._CreateEventBlock(e, t, s);\n          break;\n        case 1:\n          this._CreateEventVariable(e, t, s);\n          break;\n        case 2:\n          this._CreateInclude(e, t, s);\n          break;\n        case 4:\n          this._CreateFunctionBlock(e, t);\n          break;\n        case 5:\n          this._CreateScriptBlock(e, t, s);\n          break;\n        case 6:\n          this._CreateCustomACEBlock(e, t);\n          break;\n        default:\n          throw new Error(\"invalid event type\");\n      }\n    }\n    _CreateEventBlock(e, t, s) {\n      const n = C32.EventBlock.Create(this, t, e);\n      if (n.IsOrBlock()) {\n        s.push(n);\n        const r = n.GetConditions();\n        for (let e2 = 0, t2 = r.length; e2 < t2; ++e2) r[e2].IsTrigger() && this._InitTrigger(n, e2);\n      } else n.IsTrigger() ? this._InitTrigger(n, 0) : s.push(n);\n    }\n    _CreateFunctionBlock(e, t) {\n      const s = C32.FunctionBlock.CreateFunctionBlock(this, t, e);\n      this._eventSheetManager._RegisterFunctionBlock(s);\n    }\n    _CreateCustomACEBlock(e, t) {\n      const s = C32.FunctionBlock.CreateCustomACEBlock(this, t, e);\n      this._eventSheetManager._RegisterFunctionBlock(s);\n    }\n    _CreateEventVariable(e, t, s) {\n      const n = C32.EventVariable.Create(this, t, e);\n      s.push(n);\n    }\n    _CreateInclude(e, t, s) {\n      const n = C32.EventInclude.Create(this, t, e);\n      s.push(n);\n    }\n    _CreateScriptBlock(e, t, s) {\n      const n = C32.EventScript.Create(this, t, e);\n      s.push(n);\n    }\n    _InitTrigger(n, r) {\n      n.IsOrBlock() || this._eventSheetManager._AddTriggerToPostInit(n);\n      const i = n.GetConditionAt(r), l = i._GetFunc(), o = i.GetObjectClass();\n      if (i.IsFastTrigger()) {\n        let e = this._fastTriggers.get(o);\n        e || (e = /* @__PURE__ */ new Map(), this._fastTriggers.set(o, e));\n        const a = i.GetFastTriggerValue().toLowerCase();\n        let t = e.get(l), s = (t || (t = /* @__PURE__ */ new Map(), e.set(l, t)), t.get(a));\n        s || (s = [], t.set(a, s)), s.push([n, r]);\n      } else {\n        let e = this._triggers.get(o);\n        e || (e = { methodMap: /* @__PURE__ */ new Map(), behaviors: /* @__PURE__ */ new Map() }, this._triggers.set(o, e));\n        const c = i.GetBehaviorType();\n        let t, s = (c ? (t = e.behaviors.get(c)) || (t = /* @__PURE__ */ new Map(), e.behaviors.set(c, t)) : t = e.methodMap, t.get(l));\n        s || (s = [], t.set(l, s)), s.push([n, r]);\n      }\n    }\n    _PostInit() {\n      const s = this._events;\n      for (let e = 0, t = s.length; e < t; ++e) {\n        const n = e < t - 1 && s[e + 1] instanceof C32.EventBlock && s[e + 1].IsElseBlock();\n        s[e]._PostInit(n);\n      }\n    }\n    _AddShallowInclude(e) {\n      this._shallowIncludes.push(e);\n    }\n    _UpdateDeepIncludes() {\n      C32.clearArray(this._deepIncludes), this._AddDeepIncludes(this), this._alreadyIncludedSheets.clear();\n    }\n    _AddDeepIncludes(e) {\n      const t = e._deepIncludes, s = e._alreadyIncludedSheets;\n      for (const n of this._shallowIncludes) {\n        const r = n.GetIncludeSheet();\n        n.IsActive() && e !== r && !s.has(r) && (s.add(r), r._AddDeepIncludes(e), t.push(r));\n      }\n    }\n    deepIncludes() {\n      return this._deepIncludes;\n    }\n    GetEventSheetManager() {\n      return this._eventSheetManager;\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetName() {\n      return this._name;\n    }\n    _RegisterEventByDisplayNumber(e, t) {\n      this._eventsByDisplayNumber.set(t, e);\n    }\n    _GetEventByDisplayNumber(e) {\n      return this._eventsByDisplayNumber.get(e) || null;\n    }\n    _ResetHasRunFlag() {\n      this._hasRun = false;\n    }\n    Run() {\n      if (!this._hasRun) {\n        const e = this._runtime, t = e.IsCPUProfiling(), s = t ? performance.now() : 0, n = (this._hasRun = true, this.GetEventSheetManager()), r = n.GetCurrentEventStackFrame();\n        for (const i of this._events) i.Run(r), n.ClearSol(i.GetSolModifiers()), n.ClearAsyncActionPromises(), e.FlushPendingInstances();\n        r.Reset(null), t && (this._perfRecord.totalTimeCounter += performance.now() - s);\n      }\n    }\n    *DebugRun() {\n      if (!this._hasRun) {\n        this._hasRun = true;\n        const e = this._runtime, t = this.GetEventSheetManager(), s = t.GetCurrentEventStackFrame();\n        for (const n of this._events) yield* n.DebugRun(s), t.ClearSol(n.GetSolModifiers()), t.ClearAsyncActionPromises(), e.FlushPendingInstances();\n        s.Reset(null);\n      }\n    }\n    _Trigger(s, n, r) {\n      if (!n) return this._TriggerForClass(s, n, null, null);\n      {\n        const i = n.GetObjectClass();\n        let e = false, t = this._TriggerForClass(s, n, i, r);\n        e = e || t;\n        for (const l of i.GetFamilies()) t = this._TriggerForClass(s, n, l, r), e = e || t;\n      }\n    }\n    _TriggerForClass(e, t, s, n) {\n      const r = this._triggers.get(s);\n      if (!r) return false;\n      const i = n ? r.behaviors.get(n) : r.methodMap;\n      if (!i) return false;\n      const l = i.get(e);\n      if (!l) return false;\n      let o = false;\n      for (const [a, c] of l) {\n        const u = this._ExecuteTrigger(t, a, c);\n        o = o || u;\n      }\n      return o;\n    }\n    *_DebugTrigger(s, n, r) {\n      if (!n) return yield* this._DebugTriggerForClass(s, n, null, null);\n      {\n        const i = n.GetObjectClass();\n        let e = false, t = yield* this._DebugTriggerForClass(s, n, i, r);\n        e = e || t;\n        for (const l of i.GetFamilies()) t = yield* this._DebugTriggerForClass(s, n, l, r), e = e || t;\n      }\n    }\n    *_DebugTriggerForClass(e, t, s, n) {\n      const r = this._triggers.get(s);\n      if (!r) return false;\n      const i = n ? r.behaviors.get(n) : r.methodMap;\n      if (!i) return false;\n      const l = i.get(e);\n      if (!l) return false;\n      let o = false;\n      for (const [a, c] of l) {\n        let e2;\n        e2 = a.DebugCanRunFast() ? this._ExecuteTrigger(t, a, c) : yield* this._DebugExecuteTrigger(t, a, c), o = o || e2;\n      }\n      return o;\n    }\n    _FastTrigger(e, t, s) {\n      const n = t.GetObjectClass(), r = this._fastTriggers.get(n);\n      if (!r) return false;\n      const i = r.get(e);\n      if (!i) return false;\n      const l = i.get(s);\n      if (!l) return false;\n      let o = false;\n      for (let e2 = 0, t2 = l.length; e2 < t2; ++e2) {\n        const a = l[e2], c = this._ExecuteTrigger(null, a[0], a[1]);\n        o = o || c;\n      }\n      return o;\n    }\n    *_DebugFastTrigger(e, t, s) {\n      const n = t.GetObjectClass(), r = this._fastTriggers.get(n);\n      if (!r) return false;\n      const i = r.get(e);\n      if (!i) return false;\n      const l = i.get(s);\n      if (!l) return false;\n      let o = false;\n      for (let t2 = 0, e2 = l.length; t2 < e2; ++t2) {\n        const a = l[t2], c = a[0], u = a[1];\n        let e3;\n        e3 = c.DebugCanRunFast() ? this._ExecuteTrigger(null, c, u) : yield* this._DebugExecuteTrigger(null, c, u), o = o || e3;\n      }\n      return o;\n    }\n    _ExecuteTrigger(e, t, s) {\n      const n = this._runtime, r = this._eventSheetManager, i = r.GetCurrentEvent(), l = r.GetEventStack(), o = r.GetTriggerDepth();\n      let a = false;\n      i && r.PushCleanSol(i.GetSolModifiersIncludingParents()), r.PushCleanSol(t.GetSolModifiersIncludingParents());\n      const c = 1 < o, u = (c && r.GetLocalVarStack().Push(), l.Push(t));\n      if (e) {\n        const h = t.GetConditions()[s].GetObjectClass(), _ = h.GetCurrentSol();\n        _.SetSinglePicked(e), e.IsInContainer() && e.SetSiblingsSinglePicked();\n      }\n      let g = true;\n      if (t.GetParent()) {\n        const d = t.GetTriggerParents();\n        for (let e2 = 0, t2 = d.length; e2 < t2; ++e2) if (!d[e2].RunPreTrigger(u)) {\n          g = false;\n          break;\n        }\n      }\n      return g && (t.IsOrBlock() ? t.RunOrBlockTrigger(u, s) : t.Run(u), a = u.GetLastEventTrue()), l.Pop(), c && r.GetLocalVarStack().Pop(), r.PopSol(t.GetSolModifiersIncludingParents()), i && r.PopSol(i.GetSolModifiersIncludingParents()), i || 1 !== o || (r.ClearAsyncActionPromises(), r.IsFlushingBlocked()) || n.FlushPendingInstances(), a;\n    }\n    *_DebugExecuteTrigger(e, t, s) {\n      const n = this._runtime, r = this._eventSheetManager, i = r.GetCurrentEvent(), l = r.GetEventStack(), o = r.GetTriggerDepth();\n      let a = false;\n      i && r.PushCleanSol(i.GetSolModifiersIncludingParents()), r.PushCleanSol(t.GetSolModifiersIncludingParents());\n      const c = 1 < o, u = (c && r.GetLocalVarStack().Push(), l.Push(t));\n      if (e) {\n        const h = t.GetConditions()[s].GetObjectClass(), _ = h.GetCurrentSol();\n        _.SetSinglePicked(e), e.IsInContainer() && e.SetSiblingsSinglePicked();\n      }\n      let g = true;\n      if (t.GetParent()) {\n        const d = t.GetTriggerParents();\n        for (let e2 = 0, t2 = d.length; e2 < t2; ++e2) if (!(yield* d[e2].DebugRunPreTrigger(u))) {\n          g = false;\n          break;\n        }\n      }\n      return g && (t.IsOrBlock() ? yield* t.DebugRunOrBlockTrigger(u, s) : yield* t.DebugRun(u), a = u.GetLastEventTrue()), l.Pop(), c && r.GetLocalVarStack().Pop(), r.PopSol(t.GetSolModifiersIncludingParents()), i && r.PopSol(i.GetSolModifiersIncludingParents()), i || 1 !== o || (r.ClearAsyncActionPromises(), r.IsFlushingBlocked()) || n.FlushPendingInstances(), a;\n    }\n    _GetPerfRecord() {\n      return this._perfRecord;\n    }\n  };\n}\n{\n  let NoActions = function(t, e) {\n    return true;\n  };\n  NoActions2 = NoActions;\n  const C32 = self.C3, EMPTY_ARRAY = [];\n  function* DebugNoActions(t, e) {\n    return true;\n  }\n  C32.EventBlock = class extends C32.DefendedBase {\n    constructor(t, e, n) {\n      super(), this._eventSheet = t, this._runtime = t.GetRuntime(), this._parent = e, this._scopeParent = null, this._eventStack = this._runtime.GetEventSheetManager().GetEventStack(), this._solModifiers = [], this._solModifiersIncludingParents = [], this._hasGotSolModifiersIncludingParents = false, this._isSolWriterAfterCnds = false, this._isTopLevelGroup = false, this._hasElseBlock = false, this._isOrBlock = !!n[2], this._isElseBlock = false, this._triggerParents = null, this._conditions = [], this._actions = [], this._subEvents = [], this._RunActions = NoActions, this._DebugRunActions = DebugNoActions, this._isGroup = false, this._isInitiallyActive = false, this._groupName = \"\", this._isGroupActive = false, this._containedIncludes = null, this._perfRecord = null, this._sid = n[4], this._displayNumber = n[5], this._eventSheet._RegisterEventByDisplayNumber(this, this._displayNumber), this._debugData = this._runtime.IsDebug() ? { isBreakpoint: n[3][0], isBreakable: n[3][1], canRunAllConditionsFast: false, canRunAllActionsFast: false, canRunAllSubEventsFast: false, canRunSelfFast: false } : null, this.GetEventSheetManager()._RegisterEventBlock(this), 3 === n[0] && this._InitGroup(n[1]);\n      let s = 0;\n      for (const i of n[6]) {\n        const o = C32.Condition.Create(this, i, s++);\n        this._conditions.push(o), this._AddSolModifier(o.GetObjectClass());\n      }\n      s = 0;\n      for (const r of n[7]) {\n        const u = C32.Action.Create(this, r, s++);\n        this._actions.push(u);\n      }\n      if (9 === n.length) {\n        const l = n[8];\n        for (const a of l) this._eventSheet._CreateEvent(a, this, this._subEvents);\n      }\n      this._conditions.length && (this._isElseBlock = null === this._conditions[0].GetObjectClass() && this._conditions[0]._GetFunc() === C32.Plugins.System.Cnds.Else), 0 === this._conditions.length && (this._conditions = EMPTY_ARRAY), 0 === this._actions.length && (this._actions = EMPTY_ARRAY), 0 === this._subEvents.length && (this._subEvents = EMPTY_ARRAY);\n    }\n    static Create(t, e, n) {\n      return C32.New(C32.EventBlock, t, e, n);\n    }\n    _InitGroup(t) {\n      this._isGroup = true, this._isInitiallyActive = !!t[0], this._isGroupActive = this._isInitiallyActive, this._groupName = t[1].toLowerCase(), this._containedIncludes = [], this.GetEventSheetManager()._RegisterGroup(this), this._runtime.IsDebug() && (this._perfRecord = { type: \"group\", name: t[1], totalTimeCounter: 0, children: [] });\n    }\n    _AddContainedInclude(t) {\n      this._containedIncludes.push(t);\n    }\n    _AddContainerSolModifierToList(t, e) {\n      for (const n of t.GetContainer().objectTypes()) e.includes(n) || e.push(n);\n    }\n    _AddSolModifierToList(t, e) {\n      if (t) if (e.includes(t) || e.push(t), t.IsFamily()) for (const n of t.GetFamilyMembers()) n.IsInContainer() && this._AddContainerSolModifierToList(n, e);\n      else t.IsInContainer() && this._AddContainerSolModifierToList(t, e);\n    }\n    _AddSolModifier(t) {\n      this._AddSolModifierToList(t, this._solModifiers);\n    }\n    _AddParentSolModifier(t) {\n      this._AddSolModifierToList(t, this._solModifiersIncludingParents);\n    }\n    SetAllSolModifiers() {\n      this._solModifiers = this._runtime.GetAllObjectClasses();\n    }\n    _PostInit(t) {\n      this._hasElseBlock = !!t, this._IdentifyTopLevelGroup(), this._IdentifyTriggerParents();\n      for (const e of this._conditions) e._PostInit();\n      if (0 < this._actions.length) {\n        let t2 = false;\n        for (const s of this._actions) s._PostInit(), s.HasReturnType() && (t2 = true);\n        t2 ? (this._RunActions = this._RunActions_ReturnValue, this._DebugRunActions = this._DebugRunActions_ReturnValue) : (this._RunActions = this._RunActions_Fast, this._DebugRunActions = this._DebugRunActions_Fast);\n      }\n      const n = this._subEvents;\n      for (let t2 = 0, e = n.length; t2 < e; ++t2) {\n        const i = t2 < e - 1 && n[t2 + 1] instanceof C32.EventBlock && n[t2 + 1].IsElseBlock();\n        n[t2]._PostInit(i);\n      }\n      this._debugData && this._UpdateCanRunFast(), this._perfRecord && this._GetPerfRecordParent()._GetPerfRecord().children.push(this._perfRecord);\n    }\n    _GetPerfRecord() {\n      return this._perfRecord;\n    }\n    _GetPerfRecordParent() {\n      let t = this.GetParent();\n      for (; t; ) {\n        if (t.IsGroup()) return t;\n        t = t.GetParent();\n      }\n      return this._eventSheet;\n    }\n    _UpdateCanRunFast() {\n      const t = this._debugData;\n      t.canRunAllConditionsFast = this._conditions.every((t2) => t2.DebugCanRunFast()), t.canRunAllActionsFast = this._actions.every((t2) => t2.DebugCanRunFast()), t.canRunAllSubEventsFast = this._subEvents.every((t2) => t2.DebugCanRunFast()), t.canRunSelfFast = t.canRunAllConditionsFast && t.canRunAllActionsFast && t.canRunAllSubEventsFast;\n    }\n    _UpdateCanRunFastRecursive() {\n      let t = this;\n      for (; t._UpdateCanRunFast(), t = t.GetParent(); ) ;\n    }\n    _IdentifyTopLevelGroup() {\n      if (this.IsGroup()) {\n        let t = this.GetParent();\n        for (this._isTopLevelGroup = true; t; ) {\n          if (!t.IsGroup()) {\n            this._isTopLevelGroup = false;\n            break;\n          }\n          t = t.GetParent();\n        }\n      }\n    }\n    _IdentifySolModifiersIncludingParents() {\n      const t = this._runtime.GetAllObjectClasses();\n      if (this._solModifiers === t) this._solModifiersIncludingParents = t;\n      else {\n        this._solModifiersIncludingParents = C32.cloneArray(this._solModifiers);\n        let t2 = this.GetParent();\n        for (; t2; ) {\n          for (const n of t2._solModifiers) this._AddParentSolModifier(n);\n          t2 = t2.GetParent();\n        }\n        const e = this.GetEventSheetManager();\n        this._solModifiers = e._DeduplicateSolModifierList(this._solModifiers), this._solModifiersIncludingParents = e._DeduplicateSolModifierList(this._solModifiersIncludingParents);\n      }\n    }\n    _IdentifyTriggerParents() {\n      if (this.HasAnyTriggeredCondition()) {\n        this._triggerParents = [];\n        let t = this.GetParent();\n        for (; t; ) this._triggerParents.push(t), t = t.GetParent();\n        this._triggerParents.reverse();\n      }\n    }\n    SetSolWriterAfterCnds() {\n      this._isSolWriterAfterCnds = true, this._parent && this._parent.SetSolWriterAfterCnds();\n    }\n    IsSolWriterAfterCnds() {\n      return this._isSolWriterAfterCnds;\n    }\n    GetSolModifiers() {\n      return this._solModifiers;\n    }\n    GetSolModifiersIncludingParents() {\n      return this._hasGotSolModifiersIncludingParents || (this._hasGotSolModifiersIncludingParents = true, this._IdentifySolModifiersIncludingParents()), this._solModifiersIncludingParents;\n    }\n    HasSolModifier(t) {\n      return this._solModifiers.includes(t);\n    }\n    GetTriggerParents() {\n      return this._triggerParents;\n    }\n    GetEventSheet() {\n      return this._eventSheet;\n    }\n    GetEventSheetManager() {\n      return this._eventSheet.GetEventSheetManager();\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetParent() {\n      return this._parent;\n    }\n    _SetScopeParent(t) {\n      this._scopeParent = t;\n    }\n    GetScopeParent() {\n      return this._scopeParent || this._parent;\n    }\n    GetDisplayNumber() {\n      return this._displayNumber;\n    }\n    IsDebugBreakable() {\n      return this._debugData && this._debugData.isBreakable;\n    }\n    IsDebugBreakpoint() {\n      return this.IsDebugBreakable() && this._debugData.isBreakpoint;\n    }\n    _SetDebugBreakpoint(t) {\n      this._debugData.isBreakpoint = !!t, this._UpdateCanRunFastRecursive();\n    }\n    IsGroup() {\n      return this._isGroup;\n    }\n    IsTopLevelGroup() {\n      return this._isTopLevelGroup;\n    }\n    IsElseBlock() {\n      return this._isElseBlock;\n    }\n    HasElseBlock() {\n      return this._hasElseBlock;\n    }\n    GetGroupName() {\n      return this._groupName;\n    }\n    IsGroupActive() {\n      return this._isGroupActive;\n    }\n    ResetInitialActivation() {\n      this.SetGroupActive(this._isInitiallyActive);\n    }\n    SetGroupActive(t) {\n      if (t = !!t, !this._isGroup) throw new Error(\"not a group\");\n      if (this._isGroupActive !== t) {\n        this._isGroupActive = t;\n        for (const e of this._containedIncludes) e.UpdateActive();\n        if (this._containedIncludes.length) {\n          const n = this._runtime.GetCurrentLayout(), s = n.GetEventSheet();\n          s && s._UpdateDeepIncludes();\n        }\n      }\n    }\n    GetSID() {\n      return this._sid;\n    }\n    IsOrBlock() {\n      return this._isOrBlock;\n    }\n    IsTrigger() {\n      return this._conditions.length && this._conditions[0].IsTrigger();\n    }\n    IsForFunctionBlock() {\n      return this._scopeParent && this._scopeParent instanceof C32.FunctionBlock;\n    }\n    HasAnyTriggeredCondition() {\n      return this.IsForFunctionBlock() || this._conditions.some((t) => t.IsTrigger());\n    }\n    GetConditions() {\n      return this._conditions;\n    }\n    GetConditionCount() {\n      return this._conditions.length;\n    }\n    GetConditionAt(t) {\n      if ((t = Math.floor(t)) < 0 || t >= this._conditions.length) throw new RangeError(\"invalid condition index\");\n      return this._conditions[t];\n    }\n    GetConditionByDebugIndex(t) {\n      return this.GetConditionAt(t);\n    }\n    IsFirstConditionOfType(t) {\n      let e = t.GetIndex();\n      if (0 !== e) {\n        --e;\n        const n = t.IsSystemOrSingleGlobalCondition() ? t.GetFirstObjectParameterObjectClass() : t.GetObjectClass();\n        for (; 0 <= e; --e) {\n          const s = this._conditions[e];\n          if (n === s.GetObjectClass() || s.IsSystemOrSingleGlobalCondition() && s.GetFirstObjectParameterObjectClass() === n) return false;\n        }\n      }\n      return true;\n    }\n    GetActions() {\n      return this._actions;\n    }\n    GetActionCount() {\n      return this._actions.length;\n    }\n    GetActionAt(t) {\n      if ((t = Math.floor(t)) < 0 || t >= this._actions.length) throw new RangeError(\"invalid action index\");\n      return this._actions[t];\n    }\n    GetActionByDebugIndex(e) {\n      e = Math.floor(e);\n      const t = this._actions.find((t2) => t2.GetDebugIndex() === e);\n      if (t) return t;\n      throw new RangeError(\"invalid action debug index\");\n    }\n    _HasActionIndex(t) {\n      return 0 <= (t = Math.floor(t)) && t < this._actions.length;\n    }\n    GetSubEvents() {\n      return this._subEvents;\n    }\n    _GetAllLocalVariablesInScope() {\n      return this._subEvents.filter((t) => t instanceof C32.EventVariable);\n    }\n    RunPreTrigger(n) {\n      n.SetCurrentEvent(this);\n      const s = this._conditions;\n      let i = 0 === s.length;\n      for (let t = 0, e = s.length; t < e; ++t) {\n        const o = s[t];\n        if (n.SetConditionIndex(t), o.IsLooping()) throw new Error(\"trigger cannot be used as sub-event to a loop\");\n        if (o.Run()) i = true;\n        else if (!this._isOrBlock) return false;\n      }\n      return !this._isOrBlock || i;\n    }\n    RunOrBlockTrigger(t, e) {\n      t.SetCurrentEvent(this), t.SetConditionIndex(e), this._conditions[e].Run() && (this._RunActions(t, 0) && this._RunSubEvents(t), t.SetLastEventTrue(true));\n    }\n    *DebugRunPreTrigger(n) {\n      n.SetCurrentEvent(this);\n      const s = this._conditions;\n      let i = 0 === s.length;\n      for (let e = 0, t = s.length; e < t; ++e) {\n        const o = s[e];\n        if (n.SetConditionIndex(e), o.IsLooping()) throw new Error(\"trigger cannot be used as sub-event to a loop\");\n        let t2;\n        if (t2 = o.DebugCanRunFast() ? o.Run() : yield* o.DebugRun()) i = true;\n        else if (!this._isOrBlock) return false;\n      }\n      return !this._isOrBlock || i;\n    }\n    *DebugRunOrBlockTrigger(e, t) {\n      e.SetCurrentEvent(this), e.SetConditionIndex(t);\n      const n = this._conditions[t];\n      let s;\n      if (s = n.DebugCanRunFast() ? n.Run() : yield* n.DebugRun()) {\n        let t2;\n        (t2 = this.DebugCanRunActionsFast() ? this._RunActions(e, 0) : yield* this._DebugRunActions(e, 0)) && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield* this._DebugRunSubEvents()), e.SetLastEventTrue(true);\n      }\n    }\n    Run(t) {\n      t.SetCurrentEvent(this), this._isElseBlock || t.SetElseBranchRan(false), this._isOrBlock ? this._RunOrBlock(t) : this._RunAndBlock(t);\n    }\n    *DebugRun(t) {\n      (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), t.SetCurrentEvent(this), this._isElseBlock || t.SetElseBranchRan(false), this._isOrBlock ? yield* this._DebugRunOrBlock(t) : yield* this._DebugRunAndBlock(t);\n    }\n    _RunOrBlock(n) {\n      const s = this._conditions;\n      let i = 0 === s.length;\n      for (let t = 0, e = s.length; t < e; ++t) {\n        const o = s[t];\n        if (!o.IsTrigger()) {\n          n.SetConditionIndex(t);\n          const r = o.Run();\n          i = i || r;\n        }\n      }\n      n.SetLastEventTrue(i), i && (this._RunActions(n, 0) && this._RunSubEvents(n), this._hasElseBlock) && n.SetElseBranchRan(true);\n    }\n    *_DebugRunOrBlock(n) {\n      const s = this._conditions;\n      let i = 0 === s.length;\n      for (let e = 0, t = s.length; e < t; ++e) {\n        const o = s[e];\n        if (!o.IsTrigger()) {\n          n.SetConditionIndex(e);\n          let t2;\n          t2 = o.DebugCanRunFast() ? o.Run() : yield* o.DebugRun(), i = i || t2;\n        }\n      }\n      if (n.SetLastEventTrue(i), i) {\n        let t;\n        (t = this.DebugCanRunActionsFast() ? this._RunActions(n, 0) : yield* this._DebugRunActions(n, 0)) && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield* this._DebugRunSubEvents()), this._hasElseBlock && n.SetElseBranchRan(true);\n      }\n    }\n    _RunAndBlock(n) {\n      const s = this._conditions;\n      for (let t = 0, e = s.length; t < e; ++t) {\n        const i = s[t], o = (n.SetConditionIndex(t), i.Run());\n        if (!o) return void n.SetLastEventTrue(false);\n      }\n      n.SetLastEventTrue(true), this._RunActions(n, 0) && this._RunSubEvents(n), n.GetLastEventTrue() && this._hasElseBlock && n.SetElseBranchRan(true);\n    }\n    *_DebugRunAndBlock(n) {\n      const s = this._conditions;\n      for (let e = 0, t2 = s.length; e < t2; ++e) {\n        const i = s[e];\n        n.SetConditionIndex(e);\n        let t3;\n        if (!(t3 = i.DebugCanRunFast() ? i.Run() : yield* i.DebugRun())) return void n.SetLastEventTrue(false);\n      }\n      n.SetLastEventTrue(true);\n      let t;\n      (t = this.DebugCanRunActionsFast() ? this._RunActions(n, 0) : yield* this._DebugRunActions(n, 0)) && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield* this._DebugRunSubEvents()), n.GetLastEventTrue() && this._hasElseBlock && n.SetElseBranchRan(true);\n    }\n    _RunActions_Fast(n, s) {\n      const i = this._actions;\n      for (let t = s, e = i.length; t < e; ++t) {\n        const o = i[t];\n        n.SetActionIndex(t), o.Run();\n      }\n      return true;\n    }\n    *_DebugRunActions_Fast(n, s) {\n      const i = this._actions;\n      for (let t = s, e = i.length; t < e; ++t) {\n        const o = i[t];\n        n.SetActionIndex(t), o.DebugCanRunFast() ? o.Run() : yield* o.DebugRun();\n      }\n      return true;\n    }\n    _RunActions_ReturnValue(n, s) {\n      const i = this.GetEventSheetManager(), o = this._actions;\n      for (let t = s, e = o.length; t < e; ++t) {\n        const r = o[t], u = (n.SetActionIndex(t), r.Run());\n        if (r.CanBailOut() && true === u) return false;\n        r.IsAsync() && u instanceof Promise && i.AddAsyncActionPromise(u);\n      }\n      return true;\n    }\n    *_DebugRunActions_ReturnValue(n, s) {\n      const i = this.GetEventSheetManager(), o = this._actions;\n      for (let e = s, t = o.length; e < t; ++e) {\n        const r = o[e];\n        n.SetActionIndex(e);\n        let t2;\n        if (t2 = r.DebugCanRunFast() ? r.Run() : yield* r.DebugRun(), r.CanBailOut() && true === t2) return false;\n        r.IsAsync() && t2 instanceof Promise && i.AddAsyncActionPromise(t2);\n      }\n      return true;\n    }\n    _ResumeActionsAndSubEvents(t) {\n      this._RunActions(t, t.GetActionIndex()) && this._RunSubEvents();\n    }\n    *_DebugResumeActionsAndSubEvents(t) {\n      (yield* this._DebugRunActions(t, t.GetActionIndex())) && (yield* this._DebugRunSubEvents());\n    }\n    _RunSubEvents() {\n      if (this._subEvents.length) {\n        const t = this.IsGroup() && this._runtime.IsCPUProfiling(), e = t ? performance.now() : 0, n = this._eventStack, s = n.Push(this);\n        this._isSolWriterAfterCnds ? this._RunSubEvents_SolWriterAfterCnds(s) : this._RunSubEvents_Fast(s), n.Pop(), t && (this._perfRecord.totalTimeCounter += performance.now() - e);\n      }\n    }\n    _RunSubEvents_SolWriterAfterCnds(s) {\n      const i = this._isGroup, o = this._isTopLevelGroup, r = this.GetEventSheetManager(), u = this._subEvents;\n      for (let t = 0, e = u.length, n = e - 1; t < e; ++t) {\n        const l = u[t], a = l.GetSolModifiers(), h = !o || !i && t < n;\n        h && r.PushCopySol(a), l.Run(s), h ? r.PopSol(a) : r.ClearSol(a);\n      }\n    }\n    _RunSubEvents_Fast(n) {\n      const s = this._subEvents;\n      for (let t = 0, e = s.length; t < e; ++t) s[t].Run(n);\n    }\n    *_DebugRunSubEvents() {\n      if (this._subEvents.length) {\n        const t = this._eventStack, e = t.Push(this);\n        this._isSolWriterAfterCnds ? yield* this._DebugRunSubEvents_SolWriterAfterCnds(e) : yield* this._DebugRunSubEvents_Fast(e), t.Pop();\n      }\n    }\n    *_DebugRunSubEvents_SolWriterAfterCnds(s) {\n      const i = this._isGroup, o = this._isTopLevelGroup, r = this.GetEventSheetManager(), u = this._subEvents;\n      for (let t = 0, e = u.length, n = e - 1; t < e; ++t) {\n        const l = u[t], a = l.GetSolModifiers(), h = !o || !i && t < n;\n        h && r.PushCopySol(a), yield* l.DebugRun(s), h ? r.PopSol(a) : r.ClearSol(a);\n      }\n    }\n    *_DebugRunSubEvents_Fast(n) {\n      const s = this._subEvents;\n      for (let t = 0, e = s.length; t < e; ++t) yield* s[t].DebugRun(n);\n    }\n    Retrigger(n, s) {\n      s.ResetQuick();\n      const i = this._conditions;\n      if (!this.IsOrBlock()) for (let t = n.GetConditionIndex() + 1, e = i.length; t < e; ++t) {\n        const o = i[t], r = (s.SetConditionIndex(t), o.Run());\n        if (!r) return false;\n      }\n      return this._RunActions(s, 0) && this._RunSubEvents(s), true;\n    }\n    *DebugRetrigger(n, s) {\n      s.ResetQuick();\n      const i = this._conditions;\n      if (!this.IsOrBlock()) for (let e = n.GetConditionIndex() + 1, t2 = i.length; e < t2; ++e) {\n        const o = i[e];\n        s.SetConditionIndex(e);\n        let t3;\n        if (!(t3 = o.DebugCanRunFast() ? o.Run() : yield* o.DebugRun())) return false;\n      }\n      let t;\n      return (t = this.DebugCanRunActionsFast() ? this._RunActions(s, 0) : yield* this._DebugRunActions(s, 0)) && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield* this._DebugRunSubEvents()), true;\n    }\n    DebugCanRunFast() {\n      return !this.IsDebugBreakpoint() && !this._runtime.DebugBreakNext() && this._debugData.canRunSelfFast;\n    }\n    DebugCanRunActionsFast() {\n      return !this._runtime.DebugBreakNext() && this._debugData.canRunAllActionsFast;\n    }\n    DebugCanRunSubEventsFast() {\n      return !this._runtime.DebugBreakNext() && this._debugData.canRunAllSubEventsFast;\n    }\n    _CheckParentsOKToRun(n) {\n      if (this.GetParent()) {\n        const s = this.GetTriggerParents();\n        for (let t = 0, e = s.length; t < e; ++t) if (!s[t].RunPreTrigger(n)) return false;\n      }\n      return true;\n    }\n    *_DebugCheckParentsOKToRun(n) {\n      if (this.GetParent()) {\n        const s = this.GetTriggerParents();\n        for (let t = 0, e = s.length; t < e; ++t) if (!(yield* s[t].DebugRunPreTrigger(n))) return false;\n      }\n      return true;\n    }\n    _EvaluateFunctionCallParameters(t, e, n) {\n      if (0 < e.length) if (n) {\n        const s = e.map((t2) => t2.Get(0));\n        t.GetLocalVarStack().Push(), this._scopeParent.SetFunctionParameters(s);\n      } else this._scopeParent.EvaluateFunctionParameters(e);\n      else n && t.GetLocalVarStack().Push();\n    }\n    RunAsFunctionCall(t, e, n, s) {\n      let i, o;\n      const r = 0 < t.length;\n      let u = null;\n      const l = this._runtime, a = this._eventStack, h = l.GetEventSheetManager(), c = this._scopeParent, _ = c.IsAsync(), d = h._IncTriggerDepth(), g = 1 < d;\n      if (this._EvaluateFunctionCallParameters(h, e, g), r && (n ? h.PushCopySol(t) : h.PushCleanSol(t)), null !== s) {\n        if (s.copyFromObjectClass) {\n          const b = n ? s.copyFromObjectClass.GetCurrentSol() : s.copyFromObjectClass.GetSolStack().GetOneBelowCurrentSol(), R = s.copyToObjectClass.GetCurrentSol();\n          R.SetArrayPicked(b.GetInstances()), R.ClearElseInstances(), n || s.copyToObjectClass.ApplySolToContainer();\n        } else if (s.pickObjectClass) {\n          const C = s.pickObjectClass.GetCurrentSol();\n          C.SetArrayPicked(s.pickInstances), C.ClearElseInstances();\n        }\n        s.pushCleanSolDynamic && (u = h.PushCleanSolDynamic(t));\n      }\n      const S = a.Push(this);\n      return n && S.SetDynamicSolModifiers(t), this._CheckParentsOKToRun(S) && (S.SetCurrentEvent(this), _ && ([o, i] = c.StartAsyncFunctionCall()), this._RunAndBlock(S), _) && c.MaybeFinishAsyncFunctionCall(o), a.Pop(), g && h.GetLocalVarStack().Pop(), null !== u && h.PopSol(u), r && h.PopSol(t), h._DecTriggerDepth(), _ || h.ClearNestedAsyncActionPromises(), i;\n    }\n    *DebugRunAsFunctionCall(t, e, n, s) {\n      let i, o;\n      (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext()) && (yield this);\n      const r = 0 < t.length;\n      let u = null;\n      const l = this._runtime, a = this._eventStack, h = l.GetEventSheetManager(), c = this._scopeParent, _ = c.IsAsync(), d = h._IncTriggerDepth(), g = 1 < d;\n      if (this._EvaluateFunctionCallParameters(h, e, g), r && (n ? h.PushCopySol(t) : h.PushCleanSol(t)), null !== s) {\n        if (s.copyFromObjectClass) {\n          const b = n ? s.copyFromObjectClass.GetCurrentSol() : s.copyFromObjectClass.GetSolStack().GetOneBelowCurrentSol(), R = s.copyToObjectClass.GetCurrentSol();\n          R.SetArrayPicked(b.GetInstances()), R.ClearElseInstances(), n || s.copyToObjectClass.ApplySolToContainer();\n        } else if (s.pickObjectClass) {\n          const C = s.pickObjectClass.GetCurrentSol();\n          C.SetArrayPicked(s.pickInstances), C.ClearElseInstances();\n        }\n        s.pushCleanSolDynamic && (u = h.PushCleanSolDynamic(t));\n      }\n      const S = a.Push(this);\n      return n && S.SetDynamicSolModifiers(t), (yield* this._DebugCheckParentsOKToRun(S)) && (S.SetCurrentEvent(this), _ && ([o, i] = c.StartAsyncFunctionCall()), yield* this._DebugRunAndBlock(S), _) && c.MaybeFinishAsyncFunctionCall(o), a.Pop(), g && h.GetLocalVarStack().Pop(), null !== u && h.PopSol(u), r && h.PopSol(t), h._DecTriggerDepth(), _ || h.ClearNestedAsyncActionPromises(), i;\n    }\n    RunAsMappedFunctionCall(t, e) {\n      const n = this.GetSolModifiersIncludingParents(), s = 0 < n.length, i = this._runtime, o = this._eventStack, r = i.GetEventSheetManager(), u = r._IncTriggerDepth(), l = 1 < u, a = (l && r.GetLocalVarStack().Push(), this._scopeParent.SetFunctionParameters(t), s && (e ? r.PushCopySol(n) : r.PushCleanSol(n)), o.Push(this));\n      this._CheckParentsOKToRun(a) && (a.SetCurrentEvent(this), this._RunAndBlock(a)), o.Pop(), l && r.GetLocalVarStack().Pop(), s && r.PopSol(n), r._DecTriggerDepth(), r.ClearNestedAsyncActionPromises();\n    }\n    *DebugRunAsMappedFunctionCall(t, e) {\n      (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext()) && (yield this);\n      const n = this.GetSolModifiersIncludingParents(), s = 0 < n.length, i = this._runtime, o = this._eventStack, r = i.GetEventSheetManager(), u = r._IncTriggerDepth(), l = 1 < u, a = (l && r.GetLocalVarStack().Push(), this._scopeParent.SetFunctionParameters(t), s && (e ? r.PushCopySol(n) : r.PushCleanSol(n)), o.Push(this));\n      (yield* this._DebugCheckParentsOKToRun(a)) && (a.SetCurrentEvent(this), yield* this._DebugRunAndBlock(a)), o.Pop(), l && r.GetLocalVarStack().Pop(), s && r.PopSol(n), r._DecTriggerDepth(), r.ClearNestedAsyncActionPromises();\n    }\n    RunAsExpressionFunctionCall(t, e, n, s, ...i) {\n      let o, r;\n      const u = 0 < t.length, l = this._runtime, a = this._eventStack, h = l.GetEventSheetManager(), c = this._scopeParent, _ = c.IsAsync(), d = h._IncTriggerDepth(), g = 1 < d, S = (g && h.GetLocalVarStack().Push(), 0 < i.length && this._scopeParent.SetFunctionParameters(i), u && (e ? h.PushCopySol(t) : h.PushCleanSol(t)), a.Push(this));\n      return S.InitCallFunctionExpression(n, s), a.PushExpFunc(S), l.SetDebuggingEnabled(false), this._CheckParentsOKToRun(S) && (S.SetCurrentEvent(this), _ && ([r, o] = c.StartAsyncFunctionCall()), this._RunAndBlock(S), _) && c.MaybeFinishAsyncFunctionCall(r), l.SetDebuggingEnabled(true), a.Pop(), a.PopExpFunc(), g && h.GetLocalVarStack().Pop(), u && h.PopSol(t), h._DecTriggerDepth(), _ || h.ClearNestedAsyncActionPromises(), o || S.GetFunctionReturnValue();\n    }\n  };\n}\nvar NoActions2;\n{\n  const C32 = self.C3, EMPTY_SOL_MODIFIERS = [];\n  let hadUserScriptException = false;\n  C32.EventScript = class extends C32.DefendedBase {\n    constructor(e, t, i) {\n      super();\n      const r = e.GetRuntime(), n = e.GetEventSheetManager(), s = (this._eventSheet = e, this._eventSheetManager = n, this._runtime = e.GetRuntime(), this._parent = t, r.GetObjectReference(i[1]));\n      this._func = s, this._displayNumber = i[2], this._eventSheet._RegisterEventByDisplayNumber(this, this._displayNumber), this._debugData = r.IsDebug() ? { isBreakpoint: i[3][0], isBreakable: i[3][1] } : null;\n    }\n    static Create(e, t, i) {\n      return C32.New(C32.EventScript, e, t, i);\n    }\n    _PostInit() {\n      const e = this._func, t = this._runtime.GetEventSheetManager()._GetLocalVariablesScriptInterface(this);\n      this._func = e.bind(null, this._runtime.GetIRuntime(), t);\n    }\n    GetParent() {\n      return this._parent;\n    }\n    GetScopeParent() {\n      return this._parent;\n    }\n    GetEventSheet() {\n      return this._eventSheet;\n    }\n    GetDisplayNumber() {\n      return this._displayNumber;\n    }\n    IsDebugBreakable() {\n      return this._debugData && this._debugData.isBreakable;\n    }\n    IsDebugBreakpoint() {\n      return this.IsDebugBreakable() && this._debugData.isBreakpoint;\n    }\n    _SetDebugBreakpoint(e) {\n      this._debugData.isBreakpoint = !!e;\n    }\n    IsElseBlock() {\n      return false;\n    }\n    GetSolModifiers() {\n      return EMPTY_SOL_MODIFIERS;\n    }\n    GetSolModifiersIncludingParents() {\n      return this._parent ? this._parent.GetSolModifiersIncludingParents() : EMPTY_SOL_MODIFIERS;\n    }\n    Run(e) {\n      e.SetCurrentEvent(this), this._eventSheetManager.AddAsyncActionPromise(this._RunUserScript());\n    }\n    async _RunUserScript() {\n      try {\n        await this._func();\n      } catch (e) {\n        console.error(`Unhandled exception running script %c${this.GetEventSheet().GetName()}, event ${this.GetDisplayNumber()}:`, \"font-size: 1.2em; font-weight: bold;\", e), self.C3Debugger && self.C3Debugger._SetLastErrorScript(this), hadUserScriptException || (console.info(\"%cTip:%c run this to highlight in Construct the last script that had an error: %cgoToLastErrorScript()\", \"font-weight: bold; text-decoration: underline\", \"\", \"font-weight: bold\"), hadUserScriptException = true);\n      }\n    }\n    *DebugRun(e) {\n      e.SetCurrentEvent(this), (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this.Run(e);\n    }\n    DebugCanRunFast() {\n      return !this.IsDebugBreakpoint() && !this._runtime.DebugBreakNext();\n    }\n    static HadUserScriptException() {\n      return hadUserScriptException;\n    }\n    static SetHadUserScriptException() {\n      hadUserScriptException = true;\n    }\n  };\n}\n{\n  const C32 = self.C3, assert = self.assert;\n  C32.FunctionBlock = class extends C32.DefendedBase {\n    constructor(t, e, s) {\n      super(), this._eventSheet = t, this._runtime = t.GetRuntime(), this._parent = e, this._functionType = 0, this._functionName = \"\", this._returnType = 0, this._functionParameters = [], this._isEnabled = true, this._aceName = \"\", this._objectClass = null, this._hasOverrides = false, this._innerLocalVariables = [], this._isCopyPicked = false, this._isAsync = false, this._nextAsyncId = 0, this._currentAsyncId = -1, this._asyncMap = /* @__PURE__ */ new Map(), this._eventBlock = C32.EventBlock.Create(t, e, s), this._eventBlock._SetScopeParent(this);\n    }\n    InitFunctionBlock(t) {\n      this._functionType = 0, this._functionName = t[0], this._returnType = t[1], this._functionParameters = t[2].map((t2) => C32.EventVariable.Create(this._eventSheet, this, t2)), this._isEnabled = t[3], this._isAsync = t[4], this._isCopyPicked = t[5];\n    }\n    InitCustomACEBlock(t) {\n      this._functionType = 1, this._aceName = t[1], this._objectClass = this._runtime.GetObjectClassByIndex(t[2]), this._eventBlock._AddSolModifier(this._objectClass), this._functionName = this._objectClass.GetName() + \".\" + this._aceName, this._returnType = t[3], this._functionParameters = t[4].map((t2) => C32.EventVariable.Create(this._eventSheet, this, t2)), this._isEnabled = t[5], this._isAsync = t[6], this._isCopyPicked = t[7], this._objectClass.AddCustomAction(this);\n    }\n    static CreateFunctionBlock(t, e, s) {\n      const n = C32.New(C32.FunctionBlock, t, e, s), i = s[1];\n      return n.InitFunctionBlock(i), n;\n    }\n    static CreateCustomACEBlock(t, e, s) {\n      const n = C32.New(C32.FunctionBlock, t, e, s), i = s[1];\n      return n.InitCustomACEBlock(i), n;\n    }\n    _CheckOverrideState() {\n      if (this._objectClass && this._objectClass.IsFamily()) {\n        for (const t of this._objectClass.GetFamilyMembers()) if (t.HasOwnCustomActionByName(this._aceName)) {\n          this._hasOverrides = true;\n          break;\n        }\n      }\n    }\n    _PostInit() {\n      for (const t of this._functionParameters) t._PostInit();\n      this._eventBlock._PostInit(false);\n    }\n    GetFunctionType() {\n      return this._functionType;\n    }\n    _GetAllLocalVariablesInScope() {\n      return this._functionParameters;\n    }\n    GetFunctionParameters() {\n      return this._functionParameters;\n    }\n    GetFunctionParameterCount() {\n      return this._functionParameters.length;\n    }\n    _RegisterLocalVariable(t) {\n      this._innerLocalVariables.push(t);\n    }\n    _GetAllInnerLocalVariables() {\n      return this._innerLocalVariables;\n    }\n    EvaluateFunctionParameters(s) {\n      const n = this._functionParameters;\n      for (let t = 0, e = n.length; t < e; ++t) n[t].SetValue(s[t].Get(0));\n    }\n    SetFunctionParameters(s) {\n      const n = this._functionParameters;\n      for (let t = 0, e = n.length; t < e; ++t) n[t].SetValue(s[t]);\n    }\n    CaptureFunctionParameters() {\n      return this._functionParameters.map((t) => t.GetValue());\n    }\n    GetParent() {\n      return this._parent;\n    }\n    GetScopeParent() {\n      return this._parent;\n    }\n    GetFunctionName() {\n      return this._functionName;\n    }\n    GetACEName() {\n      return this._aceName;\n    }\n    HasCustomACEOverrides() {\n      return this._hasOverrides;\n    }\n    GetReturnType() {\n      return this._returnType;\n    }\n    GetObjectClass() {\n      return this._objectClass;\n    }\n    IsEnabled() {\n      return this._isEnabled;\n    }\n    GetDefaultReturnValue() {\n      switch (this._returnType) {\n        case 0:\n          return null;\n        case 2:\n          return \"\";\n        default:\n          return 0;\n      }\n    }\n    GetEventBlock() {\n      return this._eventBlock;\n    }\n    IsCopyPicked() {\n      return this._isCopyPicked;\n    }\n    IsAsync() {\n      return this._isAsync;\n    }\n    StartAsyncFunctionCall() {\n      const t = this._nextAsyncId++;\n      this._currentAsyncId = t;\n      let e;\n      const s = new Promise((t2) => e = t2);\n      return this._asyncMap.set(t, { resolve: e, pauseCount: 0 }), [t, s];\n    }\n    MaybeFinishAsyncFunctionCall(t) {\n      const e = this._asyncMap.get(t);\n      0 === e.pauseCount && (e.resolve(), this._asyncMap.delete(t)), this._currentAsyncId = -1;\n    }\n    PauseCurrentAsyncFunction() {\n      const t = this._asyncMap.get(this._currentAsyncId);\n      return t.pauseCount++, this._currentAsyncId;\n    }\n    ResumeAsyncFunction(t) {\n      this._currentAsyncId = t;\n      const e = this._asyncMap.get(t);\n      e.pauseCount--;\n    }\n    RunAsFamilyCustomActionWithOverrides(t, e) {\n      const s = /* @__PURE__ */ new Map(), n = [];\n      for (const i of this._objectClass.GetCurrentSol().GetInstances()) {\n        const c = i.GetObjectClass();\n        if (c.HasOwnCustomActionByName(this._aceName)) {\n          const a = s.get(c);\n          Array.isArray(a) ? a.push(i) : s.set(c, [i]);\n        } else n.push(i);\n      }\n      if (0 < n.length && this._eventBlock.RunAsFunctionCall(t, e, this._isCopyPicked, { pickObjectClass: this._objectClass, pickInstances: n }), 0 < s.size) for (const [r, o] of s) {\n        const u = r.GetOwnCustomActionByName(this._aceName).GetEventBlock(), h = [.../* @__PURE__ */ new Set([...t, ...u.GetSolModifiers()])];\n        u.RunAsFunctionCall(h, e, this._isCopyPicked, { pickObjectClass: r, pickInstances: o });\n      }\n    }\n    *DebugRunAsFamilyCustomActionWithOverrides(t, e) {\n      const s = /* @__PURE__ */ new Map(), n = [];\n      for (const i of this._objectClass.GetCurrentSol().GetInstances()) {\n        const c = i.GetObjectClass();\n        if (c.HasOwnCustomActionByName(this._aceName)) {\n          const a = s.get(c);\n          Array.isArray(a) ? a.push(i) : s.set(c, [i]);\n        } else n.push(i);\n      }\n      if (0 < n.length && (yield* this._eventBlock.DebugRunAsFunctionCall(t, e, this._isCopyPicked, { pickObjectClass: this._objectClass, pickInstances: n })), 0 < s.size) for (const [r, o] of s) {\n        const u = r.GetOwnCustomActionByName(this._aceName).GetEventBlock(), h = [.../* @__PURE__ */ new Set([...t, ...u.GetSolModifiers()])];\n        yield* u.DebugRunAsFunctionCall(h, e, this._isCopyPicked, { pickObjectClass: r, pickInstances: o });\n      }\n    }\n  };\n}\n{\n  const C32 = self.C3, EMPTY_SOL_MODIFIERS = [];\n  C32.EventVariable = class extends C32.DefendedBase {\n    constructor(t, e, s) {\n      super();\n      const i = t.GetEventSheetManager();\n      this._eventSheet = t, this._eventSheetManager = i, this._runtime = t.GetRuntime(), this._parent = e, this._localVarStack = i.GetLocalVarStack(), this._name = s[1], this._type = s[2], this._initialValue = s[3], this._isStatic = !!s[4], this._isConstant = !!s[5], this._isFunctionParameter = e instanceof C32.FunctionBlock, this._sid = s[6], this._jsPropName = this._runtime.GetJsPropName(s[8]), this._scriptSetter = (t2) => this.SetValue(t2), this._scriptGetter = () => this.GetValue(), this._hasSingleValue = !this._parent || this._isStatic || this._isConstant, this._value = this._initialValue, this._localIndex = -1, this.IsBoolean() && (this._value = this._value ? 1 : 0), !this.IsLocal() || this.IsStatic() || this.IsConstant() || (this._localIndex = i._GetNextLocalVarIndex(this)), i._RegisterEventVariable(this);\n    }\n    static Create(t, e, s) {\n      return C32.New(C32.EventVariable, t, e, s);\n    }\n    _PostInit() {\n      if (this.IsLocal() && !this.IsStatic() && !this.IsConstant() && !this.IsFunctionParameter()) {\n        const t = this._eventSheetManager.FindFirstFunctionBlockParent(this);\n        t && t._RegisterLocalVariable(this);\n      }\n    }\n    GetName() {\n      return this._name;\n    }\n    GetJsPropName() {\n      return this._jsPropName;\n    }\n    GetParent() {\n      return this._parent;\n    }\n    GetScopeParent() {\n      return this.GetParent();\n    }\n    IsGlobal() {\n      return !this.GetParent();\n    }\n    IsLocal() {\n      return !this.IsGlobal();\n    }\n    IsFunctionParameter() {\n      return this._isFunctionParameter;\n    }\n    IsStatic() {\n      return this._isStatic;\n    }\n    IsConstant() {\n      return this._isConstant;\n    }\n    IsNumber() {\n      return 0 === this._type;\n    }\n    IsString() {\n      return 1 === this._type;\n    }\n    IsBoolean() {\n      return 2 === this._type;\n    }\n    IsElseBlock() {\n      return false;\n    }\n    GetSID() {\n      return this._sid;\n    }\n    GetInitialValue() {\n      return this._initialValue;\n    }\n    GetSolModifiers() {\n      return EMPTY_SOL_MODIFIERS;\n    }\n    Run(t) {\n      !this.IsLocal() || this.IsStatic() || this.IsConstant() || this.SetValue(this.GetInitialValue());\n    }\n    DebugCanRunFast() {\n      return true;\n    }\n    *DebugRun(t) {\n      this.Run(t);\n    }\n    SetValue(t) {\n      this.IsNumber() ? \"number\" != typeof t && (t = parseFloat(t)) : this.IsString() ? \"string\" != typeof t && (t = t.toString()) : this.IsBoolean() && (t = t ? 1 : 0), this._hasSingleValue ? this._value = t : this._localVarStack.GetCurrent()[this._localIndex] = t;\n    }\n    GetValue() {\n      return this._hasSingleValue ? this._value : this._localVarStack.GetCurrent()[this._localIndex];\n    }\n    GetTypedValue() {\n      let t = this.GetValue();\n      return t = this.IsBoolean() ? !!t : t;\n    }\n    ResetToInitialValue() {\n      this._value = this._initialValue;\n    }\n    _GetScriptInterfaceDescriptor() {\n      return { configurable: false, enumerable: true, get: this._scriptGetter, set: this._scriptSetter };\n    }\n  };\n}\n{\n  const C32 = self.C3, assert = self.assert, EMPTY_SOL_MODIFIERS = [];\n  C32.EventInclude = class extends C32.DefendedBase {\n    constructor(e, t, n) {\n      super();\n      const s = e.GetEventSheetManager();\n      this._eventSheet = e, this._eventSheetManager = s, this._runtime = e.GetRuntime(), this._parent = t, this._includeSheet = null, this._includeSheetName = n[1], this._isActive = true;\n    }\n    static Create(e, t, n) {\n      return C32.New(C32.EventInclude, e, t, n);\n    }\n    _PostInit() {\n      this._includeSheet = this._eventSheetManager.GetEventSheetByName(this._includeSheetName), this._eventSheet._AddShallowInclude(this);\n      let e = this.GetParent();\n      for (; e; ) e instanceof C32.EventBlock && e.IsGroup() && e._AddContainedInclude(this), e = e.GetParent();\n      this.UpdateActive(), this._runtime.IsDebug() && this._eventSheet._GetPerfRecord().children.push(this._includeSheet._GetPerfRecord());\n    }\n    GetParent() {\n      return this._parent;\n    }\n    GetSolModifiers() {\n      return EMPTY_SOL_MODIFIERS;\n    }\n    GetIncludeSheet() {\n      return this._includeSheet;\n    }\n    Run(e) {\n      const t = !!this.GetParent(), n = this._runtime.GetAllObjectClasses();\n      t && this._eventSheetManager.PushCleanSol(n), this._includeSheet.Run(), t && this._eventSheetManager.PopSol(n);\n    }\n    *DebugRun(e) {\n      const t = !!this.GetParent(), n = this._runtime.GetAllObjectClasses();\n      t && this._eventSheetManager.PushCleanSol(n), yield* this._includeSheet.DebugRun(), t && this._eventSheetManager.PopSol(n);\n    }\n    DebugCanRunFast() {\n      return false;\n    }\n    IsActive() {\n      return this._isActive;\n    }\n    UpdateActive() {\n      let e = this.GetParent();\n      for (; e; ) {\n        if (e instanceof C32.EventBlock && e.IsGroup() && !e.IsGroupActive()) return void (this._isActive = false);\n        e = e.GetParent();\n      }\n      this._isActive = true;\n    }\n  };\n}\n{\n  let WrapIndex = function(e, t) {\n    return t <= e ? e % t : (e < 0 && (e <= -t && (e %= t), e < 0) && (e += t), e);\n  };\n  WrapIndex2 = WrapIndex;\n  const C32 = self.C3, assert = self.assert;\n  C32.ExpNode = class extends C32.DefendedBase {\n    constructor(e) {\n      super(), this._owner = e, this._runtime = e.GetRuntime();\n    }\n    _PostInit() {\n    }\n    static CreateNode(e, t) {\n      const s = t[0], n = [BehaviorExpressionNode, ObjectExpressionNode, InstVarExpressionNode, EventVarExpNode, SystemExpressionExpNode, CallFunctionExpressionExpNode];\n      return C32.New(n[s], e, t);\n    }\n  };\n  class SystemExpressionExpNode extends C32.ExpNode {\n    constructor(e, t) {\n      super(e), this._systemPlugin = this._runtime.GetSystemPlugin(), this._func = this._runtime.GetObjectReference(t[1]), this._func !== C32.Plugins.System.Exps.random && this._func !== C32.Plugins.System.Exps.choose || this._owner.SetVariesPerInstance();\n    }\n    GetBoundMethod() {\n      return this._systemPlugin._GetBoundACEMethod(this._func, this._systemPlugin);\n    }\n  }\n  class CallFunctionExpressionExpNode extends C32.ExpNode {\n    constructor(e, t) {\n      super(e), this._functionBlock = null, this._functionName = t[1], this._owner.SetVariesPerInstance();\n    }\n    _PostInit() {\n      const e = this._runtime.GetEventSheetManager(), t = (this._functionBlock = e.GetFunctionBlockByName(this._functionName), this._functionName = null, this._owner.GetEventBlock()), s = this._functionBlock.GetEventBlock();\n      this._combinedSolModifiers = [.../* @__PURE__ */ new Set([...t.GetSolModifiersIncludingParents(), ...s.GetSolModifiersIncludingParents()])], this._combinedSolModifiers = e._DeduplicateSolModifierList(this._combinedSolModifiers);\n    }\n    GetBoundMethod() {\n      const e = this._functionBlock;\n      if (e.IsEnabled()) {\n        const t = e.GetEventBlock();\n        return C32.EventBlock.prototype.RunAsExpressionFunctionCall.bind(t, this._combinedSolModifiers, e.IsCopyPicked(), e.GetReturnType(), e.GetDefaultReturnValue());\n      }\n      {\n        const s = e.GetDefaultReturnValue();\n        return () => s;\n      }\n    }\n  }\n  class ObjectExpressionNode extends C32.ExpNode {\n    constructor(e, t) {\n      super(e), this._objectClass = this._runtime.GetObjectClassByIndex(t[1]), this._func = this._runtime.GetObjectReference(t[2]), this._returnsString = !!t[3], this._eventStack = this._runtime.GetEventSheetManager().GetEventStack(), this._owner._MaybeVaryFor(this._objectClass);\n    }\n    GetBoundMethod() {\n      return this._objectClass.GetPlugin()._GetBoundACEMethod(this._func, this._objectClass.GetSingleGlobalInstance().GetSdkInstance());\n    }\n    ExpObject(...e) {\n      const t = this._objectClass, s = t.GetCurrentSol().GetExpressionInstances(), n = s.length;\n      if (0 === n) return this._returnsString ? \"\" : 0;\n      const r = WrapIndex(this._owner.GetSolIndex(), n);\n      return this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(t), this._func.apply(s[r].GetSdkInstance(), e);\n    }\n    ExpObject_InstExpr(e, ...t) {\n      const s = this._objectClass, n = s.GetInstances(), r = n.length;\n      if (0 === r || \"number\" != typeof e) return this._returnsString ? \"\" : 0;\n      const i = WrapIndex(e, r);\n      return this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(s), this._func.apply(n[i].GetSdkInstance(), t);\n    }\n  }\n  class InstVarExpressionNode extends C32.ExpNode {\n    constructor(e, t) {\n      super(e), this._objectClass = this._runtime.GetObjectClassByIndex(t[1]), this._varIndex = t[3], this._returnsString = !!t[2], this._owner._MaybeVaryFor(this._objectClass);\n    }\n    ExpInstVar() {\n      const e = this._objectClass.GetCurrentSol().GetExpressionInstances(), t = e.length;\n      if (0 === t) return this._returnsString ? \"\" : 0;\n      const s = WrapIndex(this._owner.GetSolIndex(), t);\n      return e[s]._GetInstanceVariableValueUnchecked(this._varIndex);\n    }\n    ExpInstVar_Family() {\n      const e = this._objectClass, t = e.GetCurrentSol().GetExpressionInstances(), s = t.length;\n      if (0 === s) return this._returnsString ? \"\" : 0;\n      const n = WrapIndex(this._owner.GetSolIndex(), s), r = t[n], i = r.GetObjectClass().GetFamilyInstanceVariableOffset(e.GetFamilyIndex());\n      return r._GetInstanceVariableValueUnchecked(this._varIndex + i);\n    }\n    ExpInstVar_InstExpr(e) {\n      const t = this._objectClass, s = t.GetInstances(), n = s.length;\n      if (0 === n || \"number\" != typeof e) return this._returnsString ? \"\" : 0;\n      const r = WrapIndex(e, n), i = s[r];\n      let o = 0;\n      return t.IsFamily() && (o = i.GetObjectClass().GetFamilyInstanceVariableOffset(t.GetFamilyIndex())), i._GetInstanceVariableValueUnchecked(this._varIndex + o);\n    }\n  }\n  class BehaviorExpressionNode extends C32.ExpNode {\n    constructor(e, t) {\n      super(e), this._objectClass = this._runtime.GetObjectClassByIndex(t[1]), this._behaviorType = this._objectClass.GetBehaviorTypeByName(t[2]), this._behaviorIndex = this._objectClass.GetBehaviorIndexByName(t[2]), this._func = this._runtime.GetObjectReference(t[3]), this._returnsString = !!t[4], this._eventStack = this._runtime.GetEventSheetManager().GetEventStack(), this._owner._MaybeVaryFor(this._objectClass);\n    }\n    ExpBehavior(...e) {\n      const t = this._objectClass, s = t.GetCurrentSol().GetExpressionInstances(), n = s.length;\n      if (0 === n) return this._returnsString ? \"\" : 0;\n      const r = WrapIndex(this._owner.GetSolIndex(), n), i = (this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(t), s[r]);\n      let o = 0;\n      return t.IsFamily() && (o = i.GetObjectClass().GetFamilyBehaviorOffset(t.GetFamilyIndex())), this._func.apply(i.GetBehaviorInstances()[this._behaviorIndex + o].GetSdkInstance(), e);\n    }\n    ExpBehavior_InstExpr(e, ...t) {\n      const s = this._objectClass, n = s.GetInstances(), r = n.length;\n      if (0 === r || \"number\" != typeof e) return this._returnsString ? \"\" : 0;\n      const i = WrapIndex(e, r), o = (this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(s), n[i]);\n      let a = 0;\n      return s.IsFamily() && (a = o.GetObjectClass().GetFamilyBehaviorOffset(s.GetFamilyIndex())), this._func.apply(o.GetBehaviorInstances()[this._behaviorIndex + a].GetSdkInstance(), t);\n    }\n  }\n  class EventVarExpNode extends C32.ExpNode {\n    constructor(e, t) {\n      super(e), this._eventVar = null, this._eventVarSid = t[1];\n    }\n    _PostInit() {\n      this._eventVar = this._runtime.GetEventSheetManager().GetEventVariableBySID(this._eventVarSid);\n    }\n    GetVar() {\n      return this._eventVar;\n    }\n  }\n}\nvar WrapIndex2;\n{\n  let GetExpressionFunc = function(t) {\n    const e = self.C3_ExpressionFuncs[t];\n    if (e) return e;\n    throw new Error(\"invalid expression number\");\n  };\n  GetExpressionFunc2 = GetExpressionFunc;\n  const C32 = self.C3, assert = self.assert;\n  C32.Parameter = class extends C32.DefendedBase {\n    constructor(t, e, s) {\n      super(), this._owner = t, this._index = s, this._type = e, this.Get = null, this._variesPerInstance = false, this._isConstant = false;\n    }\n    static Create(t, e, s) {\n      const r = e[0], n = [ExpressionParameter, StringExpressionParameter, FileParameter, ComboParameter, ObjectParameter, LayerExpressionParameter, LayoutParameter, ExpressionParameter, ComboParameter, ComboParameter, InstVarParameter, EventVarParameter, FileParameter, VariadicParameter, StringExpressionParameter, TimelineParameter, BooleanParameter, FunctionParameter, EaseParameter, TilemapBrushParameter, TemplateExpressionParameter, FlowchartParameter];\n      return C32.New(n[r], t, r, s, e);\n    }\n    _PostInit() {\n    }\n    SetVariesPerInstance() {\n      this._variesPerInstance = true;\n    }\n    _MaybeVaryFor(t) {\n      this._variesPerInstance || !t || t.GetPlugin().IsSingleGlobal() || (this._variesPerInstance = true);\n    }\n    VariesPerInstance() {\n      return this._variesPerInstance;\n    }\n    GetIndex() {\n      return this._index;\n    }\n    GetRuntime() {\n      return this._owner.GetRuntime();\n    }\n    GetEventBlock() {\n      return this._owner.GetEventBlock();\n    }\n    IsConstant() {\n      return this._isConstant;\n    }\n    IsObjectParameter() {\n      return 4 === this._type;\n    }\n  };\n  class ExpressionParameter extends C32.Parameter {\n    constructor(t, e, s, r) {\n      super(t, e, s), this._solIndex = 0;\n      const n = r[1];\n      this._expressionNumber = n[0], this._numberedNodes = [], this._expressionFunc = null;\n      for (let t2 = 1, e2 = n.length; t2 < e2; ++t2) this._numberedNodes.push(C32.ExpNode.CreateNode(this, n[t2]));\n      this._numberedNodes.length ? this.Get = this.GetExpression : (this.Get = GetExpressionFunc(this._expressionNumber), this._isConstant = true);\n    }\n    _GetNode(t) {\n      if (t < 0 || t >= this._numberedNodes.length) throw new RangeError(\"invalid numbered node\");\n      return this._numberedNodes[t];\n    }\n    _PostInit() {\n      for (const e of this._numberedNodes) e._PostInit();\n      const t = GetExpressionFunc(this._expressionNumber);\n      this._numberedNodes.length ? this._expressionFunc = t(this) : this._expressionFunc = t;\n    }\n    GetSolIndex() {\n      return this._solIndex;\n    }\n    GetExpression(t) {\n      return this._solIndex = t, this._expressionFunc();\n    }\n  }\n  class StringExpressionParameter extends ExpressionParameter {\n    constructor(t, e, s, r) {\n      super(t, e, s, r), this.Get = this.GetStringExpression, 14 === e && (this.GetEventBlock().SetAllSolModifiers(), this._owner instanceof C32.Action) && this.GetEventBlock().SetSolWriterAfterCnds();\n    }\n    GetStringExpression(t) {\n      this._solIndex = t;\n      const e = this._expressionFunc();\n      return \"string\" == typeof e ? e : \"\";\n    }\n    _GetFastTriggerValue() {\n      return GetExpressionFunc(this._expressionNumber)();\n    }\n  }\n  class LayerExpressionParameter extends ExpressionParameter {\n    constructor(t, e, s, r) {\n      super(t, e, s, r), 2 <= t.GetImplementationSdkVersion() ? this.Get = this.GetILayer : this.Get = this.GetLayer, this._isConstant = false;\n    }\n    GetLayer(t) {\n      this._solIndex = t;\n      const e = this._expressionFunc(), s = this.GetRuntime().GetCurrentLayout();\n      return s.GetLayer(e);\n    }\n    GetILayer(t) {\n      const e = this.GetLayer(t);\n      return e ? e.GetILayer() : null;\n    }\n  }\n  class ComboParameter extends C32.Parameter {\n    constructor(t, e, s, r) {\n      super(t, e, s), this._combo = r[1], this.Get = this.GetCombo, this._isConstant = true;\n    }\n    GetCombo() {\n      return this._combo;\n    }\n  }\n  class BooleanParameter extends C32.Parameter {\n    constructor(t, e, s, r) {\n      super(t, e, s), this._bool = r[1], this.Get = this.GetBoolean, this._isConstant = true;\n    }\n    GetBoolean() {\n      return this._bool;\n    }\n  }\n  class ObjectParameter extends C32.Parameter {\n    constructor(t, e, s, r) {\n      super(t, e, s), this._objectClass = this.GetRuntime().GetObjectClassByIndex(r[1]), 2 <= t.GetImplementationSdkVersion() ? this.Get = this.GetIObjectClass : this.Get = this.GetObjectClass;\n      const n = this.GetEventBlock();\n      n._AddSolModifier(this._objectClass), this._owner instanceof C32.Action ? n.SetSolWriterAfterCnds() : n.GetParent() && n.GetParent().SetSolWriterAfterCnds(), this._isConstant = true;\n    }\n    GetObjectClass() {\n      return this._objectClass;\n    }\n    GetIObjectClass() {\n      return this._objectClass ? this._objectClass.GetIObjectClass() : null;\n    }\n  }\n  class LayoutParameter extends C32.Parameter {\n    constructor(t, e, s, r) {\n      super(t, e, s), this._layout = this.GetRuntime().GetLayoutManager().GetLayoutByName(r[1]), 2 <= t.GetImplementationSdkVersion() ? this.Get = this.GetILayout : this.Get = this.GetLayout, this._isConstant = true;\n    }\n    GetLayout() {\n      return this._layout;\n    }\n    GetILayout() {\n      return this._layout ? this._layout.GetILayout() : null;\n    }\n  }\n  class TimelineParameter extends C32.Parameter {\n    constructor(t, e, s, r) {\n      super(t, e, s), this._timeline = this.GetRuntime().GetTimelineManager().GetTimelineByName(r[1]), 2 <= t.GetImplementationSdkVersion() ? this.Get = this.GetITimelineState : this.Get = this.GetTimeline, this._isConstant = true;\n    }\n    GetTimeline() {\n      return this._timeline;\n    }\n    GetITimelineState() {\n      return this._timeline ? this._timeline.GetITimelineState() : null;\n    }\n  }\n  class FileParameter extends C32.Parameter {\n    constructor(t, e, s, r) {\n      super(t, e, s), this._fileInfo = r[1], this.Get = this.GetFile, this._isConstant = true;\n    }\n    GetFile() {\n      return this._fileInfo;\n    }\n  }\n  class InstVarParameter extends C32.Parameter {\n    constructor(t, e, s, r) {\n      super(t, e, s), this._instVarIndex = r[1];\n      const n = this._owner.GetObjectClass();\n      !(this._owner instanceof C32.Condition && this._owner.IsStatic()) && n && n.IsFamily() ? (this.Get = this.GetFamilyInstanceVariable, this.SetVariesPerInstance()) : (this.Get = this.GetInstanceVariable, this._isConstant = true);\n    }\n    GetInstanceVariable() {\n      return this._instVarIndex;\n    }\n    GetFamilyInstanceVariable(t) {\n      t = t || 0;\n      const e = this._owner.GetObjectClass(), s = e.GetCurrentSol(), r = s.GetInstances();\n      let n = null;\n      if (r.length) n = r[t % r.length].GetObjectClass();\n      else if (s.HasAnyElseInstances()) {\n        const i = s.GetElseInstances();\n        n = i[t % i.length].GetObjectClass();\n      } else {\n        if (!(0 < e.GetInstanceCount())) return 0;\n        {\n          const a = e.GetInstances();\n          n = a[t % a.length].GetObjectClass();\n        }\n      }\n      return this._instVarIndex + n.GetFamilyInstanceVariableOffset(e.GetFamilyIndex());\n    }\n  }\n  class EventVarParameter extends C32.Parameter {\n    constructor(t, e, s, r) {\n      super(t, e, s), this._eventVarSid = r[1], this._eventVar = null, 2 <= t.GetImplementationSdkVersion() ? this.Get = this.GetIEventVariable : this.Get = this.GetEventVariable, this._isConstant = true;\n    }\n    _PostInit() {\n      this._eventVar = this.GetRuntime().GetEventSheetManager().GetEventVariableBySID(this._eventVarSid);\n    }\n    GetEventVariable() {\n      return this._eventVar;\n    }\n    GetIEventVariable() {\n      return null;\n    }\n  }\n  class FunctionParameter extends C32.Parameter {\n    constructor(t, e, s, r) {\n      super(t, e, s), this._functionBlockName = r[1], this._functionBlock = null, 2 <= t.GetImplementationSdkVersion() ? this.Get = this.GetIFunction : this.Get = this.GetFunction, this._isConstant = true;\n    }\n    _PostInit() {\n      this._functionBlock = this.GetRuntime().GetEventSheetManager().GetFunctionBlockByName(this._functionBlockName), this._functionBlockName = null;\n    }\n    GetFunction() {\n      return this._functionBlock;\n    }\n    GetIFunction() {\n      return null;\n    }\n  }\n  class VariadicParameter extends C32.Parameter {\n    constructor(t, e, s, r) {\n      super(t, e, s), this._subParams = [], this._variadicRet = [], this._isConstant = true;\n      for (let t2 = 1, e2 = r.length; t2 < e2; ++t2) {\n        const n = C32.Parameter.Create(this._owner, r[t2], 0);\n        this._subParams.push(n), this._variadicRet.push(0), n.IsConstant() || (this._isConstant = false);\n      }\n      this.Get = this.GetVariadic;\n    }\n    _PostInit() {\n      for (const t of this._subParams) t._PostInit();\n    }\n    GetVariadic() {\n      const s = this._subParams, r = this._variadicRet;\n      for (let t = 0, e = s.length; t < e; ++t) r[t] = s[t].Get(0);\n      return r;\n    }\n  }\n  class EaseParameter extends C32.Parameter {\n    constructor(t, e, s, r) {\n      super(t, e, s), this._easeIndex = r[1], this.Get = this.GetEase, this._isConstant = true;\n    }\n    GetEase() {\n      return this._easeIndex;\n    }\n  }\n  class TilemapBrushParameter extends C32.Parameter {\n    constructor(t, e, s, r) {\n      super(t, e, s), this._brushIndex = r[1], this.Get = this.GetTilemapBrush, this._isConstant = true;\n    }\n    GetTilemapBrush() {\n      return this._brushIndex;\n    }\n  }\n  class TemplateExpressionParameter extends ExpressionParameter {\n    constructor(t, e, s, r) {\n      super(t, e, s, r), this.Get = this.GetTemplateName, this._isConstant = false;\n    }\n    GetTemplateName() {\n      return this._expressionFunc();\n    }\n  }\n  class FlowchartParameter extends C32.Parameter {\n    constructor(t, e, s, r) {\n      super(t, e, s), this._flowchartDataItem = this.GetRuntime().GetFlowchartManager().GetFlowchartDataItemByName(r[1]), this.Get = this.GetFlowchartName, this._isConstant = true;\n    }\n    GetFlowchartName() {\n      return this._flowchartDataItem.GetName();\n    }\n  }\n}\nvar GetExpressionFunc2;\n{\n  let EvalParams = function(s, n) {\n    for (let t = 0, e = s.length; t < e; ++t) n[t] = s[t].Get(0);\n  };\n  EvalParams2 = EvalParams;\n  const C32 = self.C3, assert = self.assert;\n  const EMPTY_PARAMS_ARRAY = [], noop = function() {\n  };\n  C32.Condition = class extends C32.DefendedBase {\n    constructor(t, s, e) {\n      if (super(), this._eventBlock = t, this._runtime = t.GetRuntime(), this._index = e, this._func = this._runtime.GetObjectReference(s[1]), this._isTrigger = 0 < s[3], this._isFastTrigger = 2 === s[3], this._isLooping = !!s[4], this._isInverted = !!s[5], this._isStatic = !!s[6], this._sid = s[7], this._isInOrBlock = this._eventBlock.IsOrBlock(), this._objectClass = null, this._behaviorType = null, this._behaviorIndex = -1, this._systemPlugin = null, this.Run = noop, this.DebugRun = noop, this._parameters = [], this._results = [], this._anyParamVariesPerInstance = false, this._savedData = null, this._unsavedData = null, this._debugData = this._runtime.IsDebug() ? { isBreakpoint: s[8][0], canDebug: s[8][1] } : null, -1 === s[0] ? this._systemPlugin = this._runtime.GetSystemPlugin() : (this._objectClass = this._runtime.GetObjectClassByIndex(s[0]), s[2] && (this._behaviorType = this._objectClass.GetBehaviorTypeByName(s[2]), this._behaviorIndex = this._objectClass.GetBehaviorIndexByName(s[2])), this._eventBlock.GetParent() && this._eventBlock.GetParent().SetSolWriterAfterCnds()), 10 === s.length) {\n        let e2 = s[9];\n        for (let t2 of e2) this._parameters.push(C32.Parameter.Create(this, t2, this._parameters.length)), this._results.push(0);\n      }\n      0 === this._parameters.length && (this._parameters = EMPTY_PARAMS_ARRAY, this._results = EMPTY_PARAMS_ARRAY), this._eventBlock.GetEventSheetManager()._RegisterCondition(this);\n    }\n    static Create(t, e, s) {\n      return C32.New(C32.Condition, t, e, s);\n    }\n    _PostInit() {\n      for (const t of this._parameters) t._PostInit(), t.VariesPerInstance() && (this._anyParamVariesPerInstance = true);\n      this._isFastTrigger ? (this.Run = this._RunFastTrigger, this.DebugRun = this._DebugRunFastTrigger) : this._systemPlugin ? (this._SetSystemRunMethod(), this.DebugRun = this._DebugRunSystem) : this._objectClass.GetPlugin().IsSingleGlobal() ? (this._SetSingleGlobalRunMethod(), this.DebugRun = this._DebugRunSingleGlobal) : this._isStatic ? (this.Run = this._RunStatic, this.DebugRun = this._DebugRunStatic) : (this.Run = this._RunObject, this.DebugRun = this._DebugRunObject);\n    }\n    _SetSystemRunMethod() {\n      const t = this._systemPlugin, e = this._systemPlugin;\n      this._SetRunMethodForBoundFunc(t, e, this._RunSystem);\n    }\n    _SetSingleGlobalRunMethod() {\n      const t = this._objectClass.GetPlugin(), e = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();\n      this._SetRunMethodForBoundFunc(t, e, this._RunSingleGlobal);\n    }\n    _SetRunMethodForBoundFunc(t, e, s) {\n      const n = this._func, i = this._isInverted, r = this._parameters;\n      if (0 === r.length) {\n        const a = t._GetBoundACEMethod(n, e);\n        i ? this.Run = function() {\n          return C32.xor(a(), i);\n        } : this.Run = a;\n      } else if (1 === r.length) {\n        const h = r[0];\n        if (!i && h.IsConstant()) this.Run = t._GetBoundACEMethod_1param(n, e, h.Get(0));\n        else {\n          const o = t._GetBoundACEMethod(n, e);\n          this.Run = function() {\n            return C32.xor(o(h.Get(0)), i);\n          };\n        }\n      } else if (2 === r.length) {\n        const l = r[0], u = r[1];\n        if (!i && l.IsConstant() && u.IsConstant()) this.Run = t._GetBoundACEMethod_2params(n, e, l.Get(0), u.Get(0));\n        else {\n          const _ = t._GetBoundACEMethod(n, e);\n          this.Run = function() {\n            return C32.xor(_(l.Get(0), u.Get(0)), i);\n          };\n        }\n      } else if (3 === r.length) {\n        const c = r[0], g = r[1], d = r[2];\n        if (!i && c.IsConstant() && g.IsConstant() && d.IsConstant()) this.Run = t._GetBoundACEMethod_3params(n, e, c.Get(0), g.Get(0), d.Get(0));\n        else {\n          const I = t._GetBoundACEMethod(n, e);\n          this.Run = function() {\n            return C32.xor(I(c.Get(0), g.Get(0), d.Get(0)), i);\n          };\n        }\n      } else this.Run = s;\n    }\n    GetSID() {\n      return this._sid;\n    }\n    _GetFunc() {\n      return this._func;\n    }\n    GetObjectClass() {\n      return this._objectClass;\n    }\n    GetBehaviorType() {\n      return this._behaviorType;\n    }\n    GetImplementationAddon() {\n      return this._behaviorType ? this._behaviorType.GetBehavior() : this._objectClass ? this._objectClass.GetPlugin() : null;\n    }\n    GetImplementationSdkVersion() {\n      const t = this.GetImplementationAddon();\n      return t ? t.GetSdkVersion() : 1;\n    }\n    GetEventBlock() {\n      return this._eventBlock;\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetIndex() {\n      return this._index;\n    }\n    GetDebugIndex() {\n      return this.GetIndex();\n    }\n    IsTrigger() {\n      return this._isTrigger;\n    }\n    IsFastTrigger() {\n      return this._isFastTrigger;\n    }\n    IsInverted() {\n      return this._isInverted;\n    }\n    IsLooping() {\n      return this._isLooping;\n    }\n    IsStatic() {\n      return this._isStatic;\n    }\n    IsBreakpoint() {\n      return this._debugData.isBreakpoint;\n    }\n    IsSystemCondition() {\n      return !!this._systemPlugin;\n    }\n    IsSystemOrSingleGlobalCondition() {\n      return this.IsSystemCondition() || this._objectClass.GetPlugin().IsSingleGlobal();\n    }\n    GetFirstObjectParameterObjectClass() {\n      for (const t of this._parameters) if (t.IsObjectParameter()) return t.GetObjectClass();\n      return null;\n    }\n    _SetBreakpoint(t) {\n      this._debugData.isBreakpoint = !!t, this._eventBlock._UpdateCanRunFastRecursive();\n    }\n    _DebugReturnsGenerator() {\n      return this._debugData.canDebug;\n    }\n    DebugCanRunFast() {\n      return !this.IsBreakpoint() && !this._runtime.DebugBreakNext() && !this._DebugReturnsGenerator();\n    }\n    GetSavedDataMap() {\n      return this._savedData || (this._savedData = /* @__PURE__ */ new Map()), this._savedData;\n    }\n    GetUnsavedDataMap() {\n      return this._unsavedData || (this._unsavedData = /* @__PURE__ */ new Map()), this._unsavedData;\n    }\n    _RunSystem() {\n      const t = this._results;\n      return EvalParams(this._parameters, t), C32.xor(this._func.apply(this._systemPlugin, t), this._isInverted);\n    }\n    *_DebugRunSystem() {\n      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {\n        const e = this._results;\n        EvalParams(this._parameters, e);\n        let t = this._func.apply(this._systemPlugin, e);\n        return C32.IsIterator(t) && (t = yield* t), C32.xor(t, this._isInverted);\n      }\n      return this.Run();\n    }\n    _RunSingleGlobal() {\n      const t = this._results, e = (EvalParams(this._parameters, t), this._objectClass.GetSingleGlobalInstance().GetSdkInstance());\n      return C32.xor(this._func.apply(e, t), this._isInverted);\n    }\n    *_DebugRunSingleGlobal() {\n      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {\n        const e = this._results, s = (EvalParams(this._parameters, e), this._objectClass.GetSingleGlobalInstance().GetSdkInstance());\n        let t = this._func.apply(s, e);\n        return C32.IsIterator(t) && (t = yield* t), C32.xor(t, this._isInverted);\n      }\n      return this.Run();\n    }\n    _RunFastTrigger() {\n      return true;\n    }\n    *_DebugRunFastTrigger() {\n      return (this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), true;\n    }\n    _GetStaticConditionThis() {\n      return this._behaviorType ? 2 <= this._behaviorType.GetBehavior().GetSdkVersion() ? this._behaviorType.GetIBehaviorType() : this._behaviorType : 2 <= this._objectClass.GetPlugin().GetSdkVersion() ? this._objectClass.GetIObjectClass() : this._objectClass;\n    }\n    _RunStatic() {\n      const t = this._results, e = (EvalParams(this._parameters, t), this._func.apply(this._GetStaticConditionThis(), t));\n      return this._objectClass.ApplySolToContainer(), e;\n    }\n    *_DebugRunStatic() {\n      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {\n        const e = this._results;\n        EvalParams(this._parameters, e);\n        let t = this._func.apply(this._GetStaticConditionThis(), e);\n        return C32.IsIterator(t) && (t = yield* t), this._objectClass.ApplySolToContainer(), t;\n      }\n      return this.Run();\n    }\n    _RunObject() {\n      const s = this._parameters, n = this._results, t = this._objectClass.GetCurrentSol();\n      for (let t2 = 0, e = s.length; t2 < e; ++t2) {\n        const i = s[t2];\n        i.VariesPerInstance() || (n[t2] = i.Get(0));\n      }\n      return t.IsSelectAll() ? this._RunObject_FirstFilter(t) : this._RunObject_NextFilter(t);\n    }\n    *_DebugRunObject() {\n      return (this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._RunObject();\n    }\n    _EvaluateVaryingParameters(s) {\n      const n = this._parameters, i = this._results;\n      for (let t = 0, e = n.length; t < e; ++t) {\n        const r = n[t];\n        r.VariesPerInstance() && (i[t] = r.Get(s));\n      }\n    }\n    _RunObject_FirstFilter(s) {\n      const t = this._objectClass, n = t.IsFamily(), i = t.GetFamilyIndex(), r = this._behaviorIndex, a = 0 <= r, h = t.GetInstances(), o = this._anyParamVariesPerInstance, l = this._results, u = this._func, _ = this._isInverted, c = this._isInOrBlock && !this._isTrigger;\n      s.ClearArrays();\n      for (let e = 0, t2 = h.length; e < t2; ++e) {\n        const g = h[e];\n        o && this._EvaluateVaryingParameters(e);\n        let t3;\n        if (a) {\n          const d = n ? g.GetObjectClass().GetFamilyBehaviorOffset(i) : 0;\n          t3 = u.apply(g.GetBehaviorInstances()[r + d].GetSdkInstance(), l);\n        } else t3 = u.apply(g.GetSdkInstance(), l);\n        C32.xor(t3, _) ? s._PushInstance(g) : c && s._PushElseInstance(g);\n      }\n      return t.FinishCondition(true), s._SetSelectAll(false), t.ApplySolToContainer(), s.HasAnyInstances();\n    }\n    _RunObject_NextFilter(t) {\n      const e = this._objectClass, s = e.IsFamily(), n = e.GetFamilyIndex(), i = e.IsInContainer(), r = this._behaviorIndex, a = 0 <= r, h = this._anyParamVariesPerInstance, o = this._results, l = this._func, u = this._isInverted, _ = this._isInOrBlock && !this._isTrigger, c = t._GetOwnInstances(), g = t._GetOwnElseInstances(), d = _ && !this._eventBlock.IsFirstConditionOfType(this), I = d ? g : c;\n      let G = 0, b = false;\n      for (let e2 = 0, t2 = I.length; e2 < t2; ++e2) {\n        const p = I[e2];\n        h && this._EvaluateVaryingParameters(e2);\n        let t3;\n        if (a) {\n          const C = s ? p.GetObjectClass().GetFamilyBehaviorOffset(n) : 0;\n          t3 = l.apply(p.GetBehaviorInstances()[r + C].GetSdkInstance(), o);\n        } else t3 = l.apply(p.GetSdkInstance(), o);\n        C32.xor(t3, u) ? (b = true, d ? (c.push(p), i && p._PushSiblingsToSolInstances()) : (I[G] = p, i && p._SetSiblingsToSolInstancesIndex(G), ++G)) : d ? (I[G] = p, i && p._SetSiblingsToSolElseInstancesIndex(G), ++G) : _ && (g.push(p), i) && p._PushSiblingsToSolElseInstances();\n      }\n      C32.truncateArray(I, G), i && e._TruncateContainerSols(d, G);\n      const m = b;\n      return d && !b && (b = this._OrBlockCheckInstances(c)), e.FinishCondition(m || _), _ ? b : t.HasAnyInstances();\n    }\n    _OrBlockCheckInstances(s) {\n      const t = this._objectClass, n = t.IsFamily(), i = t.GetFamilyIndex(), r = this._anyParamVariesPerInstance, a = this._behaviorIndex, h = 0 <= a, o = this._results, l = this._func, u = this._isInverted;\n      for (let e = 0, t2 = s.length; e < t2; ++e) {\n        const _ = s[e];\n        r && this._EvaluateVaryingParameters(e);\n        let t3;\n        if (h) {\n          const c = n ? _.GetObjectClass().GetFamilyBehaviorOffset(i) : 0;\n          t3 = l.apply(_.GetBehaviorInstances()[a + c].GetSdkInstance(), o);\n        } else t3 = l.apply(_.GetSdkInstance(), o);\n        if (C32.xor(t3, u)) return true;\n      }\n      return false;\n    }\n    ReevaluateParameter(t, e) {\n      return this._parameters[t].Get(e);\n    }\n    GetFastTriggerValue() {\n      const t = this._parameters;\n      if (t.length) return t[0]._GetFastTriggerValue();\n      throw new Error(\"no parameters\");\n    }\n    _SaveToJson() {\n      if (!this._savedData || !this._savedData.size) return null;\n      const e = {};\n      for (const [s, n] of this._savedData.entries()) {\n        let t = n;\n        \"collmemory\" === s && (t = [...n.entries()].map((t2) => [t2[0].GetUID(), t2[1].GetUID(), t2[2]])), e[s] = t;\n      }\n      return { \"ex\": e };\n    }\n    _LoadFromJson(t) {\n      if (this._savedData && (this._savedData.clear(), this._savedData = null), t) {\n        const e = this._runtime, s = t[\"ex\"];\n        if (s) {\n          const n = this.GetSavedDataMap();\n          n.clear();\n          for (const [i, r] of Object.entries(s)) {\n            let t2 = r;\n            \"collmemory\" === i && (t2 = C32.New(C32.PairMap, r.map((t3) => [e.GetInstanceByUID(t3[0]), e.GetInstanceByUID(t3[1]), t3[2]]).filter((t3) => t3[0] && t3[1]))), n.set(i, t2);\n          }\n        }\n      }\n    }\n  };\n}\nvar EvalParams2;\n{\n  let EvalParams = function(s, n) {\n    for (let t = 0, e = s.length; t < e; ++t) n[t] = s[t].Get(0);\n  };\n  EvalParams2 = EvalParams;\n  const C32 = self.C3, assert = self.assert;\n  const EMPTY_PARAMS_ARRAY = [], noop = function() {\n  }, noopGenerator = function* () {\n  }, FLAG_CANPICKANYOBJECTCLASS = 1, FLAG_COPYPICKED = 2, FLAG_CUSTOM_ACE = 4, FLAG_IS_ASYNC = 8, FLAG_CAN_BAIL_OUT = 16;\n  C32.Action = class extends C32.DefendedBase {\n    constructor(t, e, s) {\n      super();\n      const n = (this._eventBlock = t).GetRuntime(), i = (this._runtime = n, this._index = s, this._sid = 4 <= e.length ? e[3] : -1, this._actionType = 5 <= e.length ? 255 & e[4] : 0, this._flags = 5 <= e.length ? e[4] >> 8 : 0, this._func = null, this._objectClass = null, this._behaviorType = null, this._behaviorIndex = -1, this._systemPlugin = null, this._callFunctionName = \"\", this._callCustomAceObjectClass = null, this._callEventBlock = null, this.Run = noop, this.DebugRun = noop, this._parameters = [], this._results = [], this._anyParamVariesPerInstance = false, this._savedData = null, this._unsavedData = null, -3 === e[0]), a = i ? e[2] : e[5];\n      if (this._debugData = n.IsDebug() || i ? { isBreakpoint: a[0], canDebug: a[1], index: a[2] } : null, -1 === e[0]) this._systemPlugin = n.GetSystemPlugin(), this._func = n.GetObjectReference(e[1]);\n      else if (-2 === e[0]) this._callFunctionName = e[1];\n      else if (i) {\n        const r = n.GetObjectReference(e[1]);\n        this._func = r, this.Run = this.RunUserScript, this.DebugRun = this.DebugRunUserScript, this._flags |= FLAG_IS_ASYNC;\n      } else this._objectClass = n.GetObjectClassByIndex(e[0]), this._flags & FLAG_CUSTOM_ACE ? (this._callFunctionName = e[1], this._callCustomAceObjectClass = n.GetObjectClassByIndex(e[2])) : (e[2] && (this._behaviorType = this._objectClass.GetBehaviorTypeByName(e[2]), this._behaviorIndex = this._objectClass.GetBehaviorIndexByName(e[2])), this._func = n.GetObjectReference(e[1]));\n      if (7 === e.length) {\n        const o = e[6];\n        for (const e2 of o) this._parameters.push(C32.Parameter.Create(this, e2, this._parameters.length)), this._results.push(0);\n      }\n      0 === this._parameters.length && (this._parameters = EMPTY_PARAMS_ARRAY, this._results = EMPTY_PARAMS_ARRAY), this.CanPickAnyObjectClass() && (this._eventBlock.SetAllSolModifiers(), this._eventBlock.SetSolWriterAfterCnds()), this._eventBlock.GetEventSheetManager()._RegisterAction(this);\n    }\n    static Create(t, e, s) {\n      return C32.New(C32.Action, t, e, s);\n    }\n    _PostInit() {\n      for (const t of this._parameters) t._PostInit(), t.VariesPerInstance() && (this._anyParamVariesPerInstance = true);\n      if (this._systemPlugin) this._SetSystemRunMethod(), this.DebugRun = this._DebugRunSystem;\n      else if (this._callFunctionName) this._flags & FLAG_CUSTOM_ACE ? this._SetCallCustomActionRunMethod() : this._SetCallFunctionRunMethod(), this._callFunctionName = \"\", this._callCustomAceObjectClass = null;\n      else if (this.Run === this.RunUserScript) {\n        const e = this._func, s = this._runtime.GetEventSheetManager()._GetLocalVariablesScriptInterface(this._eventBlock);\n        this._func = e.bind(null, this._runtime.GetIRuntime(), s);\n      } else this._behaviorType ? this.IsAsync() ? (this.Run = this._RunBehavior_Async, this.DebugRun = this._DebugRunBehavior_Async) : (this.Run = this._RunBehavior, this.DebugRun = this._DebugRunBehavior) : this._objectClass.GetPlugin().IsSingleGlobal() ? (this._SetSingleGlobalRunMethod(), this.DebugRun = this._DebugRunSingleGlobal) : this.IsStatic() ? (this.Run = this._RunObject_Static, this.DebugRun = this._DebugRunObject_Static) : this.IsAsync() ? (this.Run = this._RunObject_Async, this.DebugRun = this._DebugRunObject_Async) : this.CallBeforeAfterHooks() ? (this.Run = this._RunObject_BeforeAfterHooks, this.DebugRun = this._DebugRunObject_BeforeAfterHooks) : this._parameters.length ? this._parameters.every((t) => t.VariesPerInstance()) ? (this.Run = this._RunObject_AllParamsVary, this.DebugRun = this._DebugRunObject_AllParamsVary) : this._anyParamVariesPerInstance ? (this.Run = this._RunObject_SomeParamsVary, this.DebugRun = this._DebugRunObject_SomeParamsVary) : this._parameters.every((t) => t.IsConstant()) ? (EvalParams(this._parameters, this._results), this.Run = this._RunObject_ParamsConst, this.DebugRun = this._DebugRunObject_ParamsConst) : (this.Run = this._RunObject_ParamsDontVary, this.DebugRun = this._DebugRunObject_ParamsDontVary) : (this.Run = this._RunObject_ParamsConst, this.DebugRun = this._DebugRunObject_ParamsConst);\n    }\n    _SetSystemRunMethod() {\n      const t = this._systemPlugin, e = this._systemPlugin;\n      this._SetRunMethodForBoundFunc(t, e, this._RunSystem);\n    }\n    _SetSingleGlobalRunMethod() {\n      const t = this._objectClass.GetPlugin(), e = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();\n      this._SetRunMethodForBoundFunc(t, e, this._RunSingleGlobal);\n    }\n    _SetCallFunctionRunMethod() {\n      const t = this._eventBlock.GetEventSheetManager(), s = t.GetFunctionBlockByName(this._callFunctionName);\n      if (s.IsEnabled()) {\n        const n = 0 != (this._flags & FLAG_COPYPICKED);\n        this._callEventBlock = s.GetEventBlock();\n        let e = [.../* @__PURE__ */ new Set([...this._eventBlock.GetSolModifiersIncludingParents(), ...this._callEventBlock.GetSolModifiersIncludingParents()])];\n        e = t._DeduplicateSolModifierList(e);\n        const i = !s.IsCopyPicked() && this._HasCopyPickedParent() ? { pushCleanSolDynamic: true } : null;\n        if (this.Run = C32.EventBlock.prototype.RunAsFunctionCall.bind(this._callEventBlock, e, this._parameters, n, i), this._runtime.IsDebug()) {\n          const a = this;\n          this.DebugRun = function* () {\n            (a.IsBreakpoint() || a._runtime.DebugBreakNext()) && (yield a);\n            const t2 = yield* a._callEventBlock.DebugRunAsFunctionCall(e, a._parameters, n, i);\n            return t2;\n          };\n        } else this.DebugRun = noopGenerator;\n      } else this.Run = noop, this.DebugRun = noopGenerator;\n    }\n    _SetCallCustomActionRunMethod() {\n      const t = this._eventBlock.GetEventSheetManager(), n = t.GetCustomActionBlockByName(this._callCustomAceObjectClass, this._callFunctionName);\n      if (n.IsEnabled()) {\n        const i = 0 != (this._flags & FLAG_COPYPICKED);\n        this._callEventBlock = n.GetEventBlock();\n        let e = [.../* @__PURE__ */ new Set([...this._eventBlock.GetSolModifiersIncludingParents(), ...this._callEventBlock.GetSolModifiersIncludingParents(), this._objectClass, n.GetObjectClass()])];\n        e = t._DeduplicateSolModifierList(e);\n        const a = !this._objectClass.IsFamily() && !n.GetObjectClass().IsFamily(), r = !this._objectClass.IsFamily() && n.GetObjectClass().IsFamily(), o = this._objectClass.IsFamily();\n        let s = null;\n        if (!n.IsCopyPicked() && this._HasCopyPickedParent() && ((s = s || {}).pushCleanSolDynamic = true), !r && i || ((s = s || {}).copyFromObjectClass = this._objectClass, s.copyToObjectClass = n.GetObjectClass()), a || r || o && !n.HasCustomACEOverrides() ? this.Run = C32.EventBlock.prototype.RunAsFunctionCall.bind(this._callEventBlock, e, this._parameters, i, s) : o && (this.Run = C32.FunctionBlock.prototype.RunAsFamilyCustomActionWithOverrides.bind(n, e, this._parameters)), this._runtime.IsDebug()) {\n          const l = this;\n          a || r || o && !n.HasCustomACEOverrides() ? this.DebugRun = function* () {\n            (l.IsBreakpoint() || l._runtime.DebugBreakNext()) && (yield l);\n            const t2 = yield* l._callEventBlock.DebugRunAsFunctionCall(e, l._parameters, i, s);\n            return t2;\n          } : o && (this.DebugRun = function* () {\n            (l.IsBreakpoint() || l._runtime.DebugBreakNext()) && (yield l);\n            const t2 = yield* n.DebugRunAsFamilyCustomActionWithOverrides(e, l._parameters);\n            return t2;\n          });\n        } else this.DebugRun = noopGenerator;\n      } else this.Run = noop, this.DebugRun = noopGenerator;\n    }\n    _SetRunMethodForBoundFunc(t, e, s) {\n      const n = this._func, i = this._parameters;\n      if (0 === i.length) this.Run = t._GetBoundACEMethod(n, e);\n      else if (1 === i.length) {\n        const a = i[0];\n        if (a.IsConstant()) this.Run = t._GetBoundACEMethod_1param(n, e, a.Get(0));\n        else {\n          const r = t._GetBoundACEMethod(n, e);\n          this.Run = function() {\n            return r(a.Get(0));\n          };\n        }\n      } else if (2 === i.length) {\n        const o = i[0], l = i[1];\n        if (o.IsConstant() && l.IsConstant()) this.Run = t._GetBoundACEMethod_2params(n, e, o.Get(0), l.Get(0));\n        else {\n          const h = t._GetBoundACEMethod(n, e);\n          this.Run = function() {\n            return h(o.Get(0), l.Get(0));\n          };\n        }\n      } else if (3 === i.length) {\n        const u = i[0], c = i[1], _ = i[2];\n        if (u.IsConstant() && c.IsConstant() && _.IsConstant()) this.Run = t._GetBoundACEMethod_3params(n, e, u.Get(0), c.Get(0), _.Get(0));\n        else {\n          const b = t._GetBoundACEMethod(n, e);\n          this.Run = function() {\n            return b(u.Get(0), c.Get(0), _.Get(0));\n          };\n        }\n      } else this.Run = s;\n    }\n    GetSID() {\n      return this._sid;\n    }\n    IsAsync() {\n      return 0 != (this._flags & FLAG_IS_ASYNC);\n    }\n    CanBailOut() {\n      return 0 != (this._flags & FLAG_CAN_BAIL_OUT);\n    }\n    CallBeforeAfterHooks() {\n      return 1 === this._actionType;\n    }\n    IsStatic() {\n      return 2 === this._actionType;\n    }\n    CanPickAnyObjectClass() {\n      return 0 != (this._flags & FLAG_CANPICKANYOBJECTCLASS);\n    }\n    HasReturnType() {\n      return this.IsAsync() || this.CanBailOut();\n    }\n    GetObjectClass() {\n      return this._objectClass;\n    }\n    GetImplementationAddon() {\n      return this._behaviorType ? this._behaviorType.GetBehavior() : this._objectClass ? this._objectClass.GetPlugin() : null;\n    }\n    GetImplementationSdkVersion() {\n      const t = this.GetImplementationAddon();\n      return t ? t.GetSdkVersion() : 1;\n    }\n    GetEventBlock() {\n      return this._eventBlock;\n    }\n    _HasCopyPickedParent() {\n      let t = this._eventBlock;\n      do {\n        if (t instanceof C32.FunctionBlock && t.IsCopyPicked()) return true;\n      } while (t = t.GetScopeParent());\n      return false;\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetIndex() {\n      return this._index;\n    }\n    GetDebugIndex() {\n      return this._debugData.index;\n    }\n    IsBreakpoint() {\n      return this._debugData.isBreakpoint;\n    }\n    _SetBreakpoint(t) {\n      this._debugData.isBreakpoint = !!t, this._eventBlock._UpdateCanRunFastRecursive();\n    }\n    _DebugReturnsGenerator() {\n      return this._debugData.canDebug;\n    }\n    DebugCanRunFast() {\n      return !this.IsBreakpoint() && !this._runtime.DebugBreakNext() && !this._DebugReturnsGenerator();\n    }\n    GetSavedDataMap() {\n      return this._savedData || (this._savedData = /* @__PURE__ */ new Map()), this._savedData;\n    }\n    GetUnsavedDataMap() {\n      return this._unsavedData || (this._unsavedData = /* @__PURE__ */ new Map()), this._unsavedData;\n    }\n    _RunSystem() {\n      const t = this._results;\n      return EvalParams(this._parameters, t), this._func.apply(this._systemPlugin, t);\n    }\n    *_DebugRunSystem() {\n      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {\n        const t = this._results, e = (EvalParams(this._parameters, t), yield* this._func.apply(this._systemPlugin, t));\n        return e;\n      }\n      return this.Run();\n    }\n    _RunSingleGlobal() {\n      const t = this._results;\n      return EvalParams(this._parameters, t), this._func.apply(this._objectClass.GetSingleGlobalInstance().GetSdkInstance(), t);\n    }\n    *_DebugRunSingleGlobal() {\n      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {\n        const t = this._results, e = (EvalParams(this._parameters, t), yield* this._func.apply(this._objectClass.GetSingleGlobalInstance().GetSdkInstance(), t));\n        return e;\n      }\n      return this.Run();\n    }\n    _RunObject_ParamsConst() {\n      const s = this._results, n = this._objectClass.GetCurrentSol().GetInstances();\n      for (let t = 0, e = n.length; t < e; ++t) this._func.apply(n[t].GetSdkInstance(), s);\n    }\n    *_DebugRunObject_ParamsConst() {\n      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {\n        const s = this._results, n = this._objectClass.GetCurrentSol().GetInstances();\n        for (let t = 0, e = n.length; t < e; ++t) yield* this._func.apply(n[t].GetSdkInstance(), s);\n      } else this._RunObject_ParamsConst();\n    }\n    _RunObject_ParamsDontVary() {\n      const s = this._results, n = (EvalParams(this._parameters, s), this._objectClass.GetCurrentSol().GetInstances());\n      for (let t = 0, e = n.length; t < e; ++t) this._func.apply(n[t].GetSdkInstance(), s);\n    }\n    *_DebugRunObject_ParamsDontVary() {\n      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {\n        const s = this._results, n = (EvalParams(this._parameters, s), this._objectClass.GetCurrentSol().GetInstances());\n        for (let t = 0, e = n.length; t < e; ++t) yield* this._func.apply(n[t].GetSdkInstance(), s);\n      } else this._RunObject_ParamsDontVary();\n    }\n    _RunObject_AllParamsVary() {\n      const n = this._parameters, i = this._results, e = this._func, a = this._objectClass.GetCurrentSol().GetInstances();\n      for (let s = 0, t = a.length; s < t; ++s) {\n        const r = a[s];\n        for (let t2 = 0, e2 = n.length; t2 < e2; ++t2) i[t2] = n[t2].Get(s);\n        e.apply(r.GetSdkInstance(), i);\n      }\n    }\n    *_DebugRunObject_AllParamsVary() {\n      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {\n        const n = this._parameters, i = this._results, e = this._func, a = this._objectClass.GetCurrentSol().GetInstances();\n        for (let s = 0, t = a.length; s < t; ++s) {\n          const r = a[s];\n          for (let t2 = 0, e2 = n.length; t2 < e2; ++t2) i[t2] = n[t2].Get(s);\n          yield* e.apply(r.GetSdkInstance(), i);\n        }\n      } else this._RunObject_AllParamsVary();\n    }\n    _RunObject_SomeParamsVary() {\n      const n = this._parameters, i = this._results, e = this._func, a = this._objectClass.GetCurrentSol().GetInstances();\n      for (let t = 0, e2 = n.length; t < e2; ++t) {\n        const s = n[t];\n        s.VariesPerInstance() || (i[t] = s.Get(0));\n      }\n      for (let s = 0, t = a.length; s < t; ++s) {\n        const r = a[s];\n        for (let t2 = 0, e2 = n.length; t2 < e2; ++t2) {\n          const o = n[t2];\n          o.VariesPerInstance() && (i[t2] = o.Get(s));\n        }\n        e.apply(r.GetSdkInstance(), i);\n      }\n    }\n    *_DebugRunObject_SomeParamsVary() {\n      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {\n        const n = this._parameters, i = this._results, e = this._func, a = this._objectClass.GetCurrentSol().GetInstances();\n        for (let t = 0, e2 = n.length; t < e2; ++t) {\n          const s = n[t];\n          s.VariesPerInstance() || (i[t] = s.Get(0));\n        }\n        for (let s = 0, t = a.length; s < t; ++s) {\n          const r = a[s];\n          for (let t2 = 0, e2 = n.length; t2 < e2; ++t2) {\n            const o = n[t2];\n            o.VariesPerInstance() && (i[t2] = o.Get(s));\n          }\n          yield* e.apply(r.GetSdkInstance(), i);\n        }\n      } else this._RunObject_SomeParamsVary();\n    }\n    _RunObject_BeforeAfterHooks() {\n      const n = this._parameters, i = this._results, e = this._func, t = this._objectClass, s = t.GetSdkType(), a = t.GetCurrentSol().GetInstances();\n      s.BeforeRunAction(e);\n      for (let s2 = 0, t2 = a.length; s2 < t2; ++s2) {\n        const r = a[s2];\n        for (let t3 = 0, e2 = n.length; t3 < e2; ++t3) i[t3] = n[t3].Get(s2);\n        e.apply(r.GetSdkInstance(), i);\n      }\n      s.AfterRunAction(e);\n    }\n    *_DebugRunObject_BeforeAfterHooks() {\n      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {\n        const n = this._parameters, i = this._results, e = this._func, t = this._objectClass, s = t.GetSdkType(), a = t.GetCurrentSol().GetInstances();\n        s.BeforeRunAction(e);\n        for (let s2 = 0, t2 = a.length; s2 < t2; ++s2) {\n          const r = a[s2];\n          for (let t3 = 0, e2 = n.length; t3 < e2; ++t3) i[t3] = n[t3].Get(s2);\n          yield* e.apply(r.GetSdkInstance(), i);\n        }\n        s.AfterRunAction(e);\n      } else this._RunObject_BeforeAfterHooks();\n    }\n    _GetStaticActionThis() {\n      return this._behaviorType ? 2 <= this._behaviorType.GetBehavior().GetSdkVersion() ? this._behaviorType.GetIBehaviorType() : this._behaviorType : 2 <= this._objectClass.GetPlugin().GetSdkVersion() ? this._objectClass.GetIObjectClass() : this._objectClass;\n    }\n    _RunObject_Static() {\n      const t = this._results;\n      return EvalParams(this._parameters, t), this._func.apply(this._GetStaticActionThis(), t);\n    }\n    *_DebugRunObject_Static() {\n      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {\n        const e = this._results;\n        EvalParams(this._parameters, e);\n        let t = this._func.apply(this._GetStaticActionThis(), e);\n        return t = C32.IsIterator(t) ? yield* t : t;\n      }\n      return this._RunObject_Static();\n    }\n    _RunBehavior() {\n      const t = this._objectClass, e = t.IsFamily(), n = t.GetFamilyIndex(), i = this._parameters, a = this._anyParamVariesPerInstance, r = this._results, o = this._func, l = this._behaviorIndex, h = t.GetCurrentSol().GetInstances();\n      for (let t2 = 0, e2 = i.length; t2 < e2; ++t2) {\n        const s = i[t2];\n        s.VariesPerInstance() || (r[t2] = s.Get(0));\n      }\n      for (let s = 0, t2 = h.length; s < t2; ++s) {\n        const u = h[s];\n        if (a) for (let t3 = 0, e2 = i.length; t3 < e2; ++t3) {\n          const _ = i[t3];\n          _.VariesPerInstance() && (r[t3] = _.Get(s));\n        }\n        const c = e ? u.GetObjectClass().GetFamilyBehaviorOffset(n) : 0;\n        o.apply(u.GetBehaviorInstances()[l + c].GetSdkInstance(), r);\n      }\n    }\n    *_DebugRunBehavior() {\n      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {\n        const t = this._objectClass, e = t.IsFamily(), n = t.GetFamilyIndex(), i = this._parameters, a = this._anyParamVariesPerInstance, r = this._results, o = this._func, l = this._behaviorIndex, h = t.GetCurrentSol().GetInstances();\n        for (let t2 = 0, e2 = i.length; t2 < e2; ++t2) {\n          const s = i[t2];\n          s.VariesPerInstance() || (r[t2] = s.Get(0));\n        }\n        for (let s = 0, t2 = h.length; s < t2; ++s) {\n          const u = h[s];\n          if (a) for (let t3 = 0, e2 = i.length; t3 < e2; ++t3) {\n            const _ = i[t3];\n            _.VariesPerInstance() && (r[t3] = _.Get(s));\n          }\n          const c = e ? u.GetObjectClass().GetFamilyBehaviorOffset(n) : 0;\n          yield* o.apply(u.GetBehaviorInstances()[l + c].GetSdkInstance(), r);\n        }\n      } else this._RunBehavior();\n    }\n    _RunObject_Async() {\n      const n = this._parameters, i = this._results, e = this._func, a = this._objectClass.GetCurrentSol().GetInstances(), r = [];\n      for (let s = 0, t = a.length; s < t; ++s) {\n        const o = a[s];\n        for (let t2 = 0, e2 = n.length; t2 < e2; ++t2) i[t2] = n[t2].Get(s);\n        r.push(e.apply(o.GetSdkInstance(), i));\n      }\n      return Promise.all(r);\n    }\n    *_DebugRunObject_Async() {\n      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {\n        const n = this._parameters, i = this._results, e = this._func, a = this._objectClass.GetCurrentSol().GetInstances(), r = [];\n        for (let s = 0, t = a.length; s < t; ++s) {\n          const o = a[s];\n          for (let t2 = 0, e2 = n.length; t2 < e2; ++t2) i[t2] = n[t2].Get(s);\n          r.push(yield* e.apply(o.GetSdkInstance(), i));\n        }\n        return Promise.all(r);\n      }\n      return this._RunObject_Async();\n    }\n    _RunBehavior_Async() {\n      const t = this._objectClass, e = t.IsFamily(), n = t.GetFamilyIndex(), i = this._parameters, a = this._results, r = this._func, o = this._behaviorIndex, l = t.GetCurrentSol().GetInstances(), h = [];\n      for (let s = 0, t2 = l.length; s < t2; ++s) {\n        const u = l[s];\n        for (let t3 = 0, e2 = i.length; t3 < e2; ++t3) a[t3] = i[t3].Get(s);\n        const c = e ? u.GetObjectClass().GetFamilyBehaviorOffset(n) : 0;\n        h.push(r.apply(u.GetBehaviorInstances()[o + c].GetSdkInstance(), a));\n      }\n      return Promise.all(h);\n    }\n    *_DebugRunBehavior_Async() {\n      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {\n        const t = this._objectClass, e = t.IsFamily(), n = t.GetFamilyIndex(), i = this._parameters, a = this._results, r = this._func, o = this._behaviorIndex, l = t.GetCurrentSol().GetInstances(), h = [];\n        for (let s = 0, t2 = l.length; s < t2; ++s) {\n          const u = l[s];\n          for (let t3 = 0, e2 = i.length; t3 < e2; ++t3) a[t3] = i[t3].Get(s);\n          const c = e ? u.GetObjectClass().GetFamilyBehaviorOffset(n) : 0;\n          h.push(yield* r.apply(u.GetBehaviorInstances()[o + c].GetSdkInstance(), a));\n        }\n        return Promise.all(h);\n      }\n      return this._RunBehavior_Async();\n    }\n    async RunUserScript() {\n      try {\n        await this._func();\n      } catch (t) {\n        console.error(`Unhandled exception running script %c${this._eventBlock.GetEventSheet().GetName()}, event ${this._eventBlock.GetDisplayNumber()}, action ${this.GetDebugIndex() + 1}:`, \"font-size: 1.2em; font-weight: bold;\", t), self.C3Debugger && self.C3Debugger._SetLastErrorScript(this), C32.EventScript.HadUserScriptException() || (console.info(\"%cTip:%c run this to highlight in Construct the last script that had an error: %cgoToLastErrorScript()\", \"font-weight: bold; text-decoration: underline\", \"\", \"font-weight: bold\"), C32.EventScript.SetHadUserScriptException());\n      }\n    }\n    *DebugRunUserScript() {\n      return (this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this.RunUserScript();\n    }\n    _SaveToJson() {\n      return this._savedData && this._savedData.size ? { \"ex\": C32.ToSuperJSON(this._savedData) } : null;\n    }\n    _LoadFromJson(t) {\n      if (this._savedData && (this._savedData.clear(), this._savedData = null), t) {\n        const e = t[\"ex\"];\n        e && (this._savedData = C32.FromSuperJSON(e));\n      }\n    }\n  };\n}\nvar EvalParams2;\n{\n  let GetInst = function(t) {\n    return t instanceof IInstance ? runtime._UnwrapScriptInterface(t) : t.GetInstance();\n  }, GetWorldInfo = function(t) {\n    return GetInst(t).GetWorldInfo();\n  }, GetInst_SDKv2 = function(t) {\n    return runtime._UnwrapScriptInterface(t);\n  }, GetWorldInfo_SDKv2 = function(t) {\n    return GetInst_SDKv2(t).GetWorldInfo();\n  }, GetObjectClass = function(t) {\n    return t instanceof IObjectClass ? runtime._UnwrapScriptInterface(t) : t;\n  }, GetLayer = function(t) {\n    return t instanceof ILayer ? runtime._UnwrapScriptInterface(t) : t;\n  }, CollMemory_Add = function(t, e, n, o) {\n    const s = e.GetUID(), i = n.GetUID();\n    s < i ? t.Set(e, n, o) : t.Set(n, e, o);\n  }, CollMemory_Remove = function(t, e, n) {\n    const o = e.GetUID(), s = n.GetUID();\n    o < s ? t.Delete(e, n) : t.Delete(n, e);\n  }, CollMemory_RemoveInstance = function(t, e) {\n    t.DeleteEither(e);\n  }, CollMemory_Get = function(t, e, n) {\n    const o = e.GetUID(), s = n.GetUID();\n    return o < s ? t.Get(e, n) : t.Get(n, e);\n  }, DoOverlapCondition = function(t, e, n, o) {\n    if (!e) return false;\n    const s = 0 !== n || 0 !== o, i = t.GetWorldInfo(), r = runtime.GetCollisionEngine(), a = runtime.GetCurrentCondition(), l = a.GetEventBlock().IsOrBlock(), c = a.GetObjectClass(), u = a.IsInverted(), S = e.GetCurrentSol(), f = c !== e;\n    rPickType = e, needsCollisionFinish = f && !u;\n    let G, d = 0, I = 0, C = rPickFromElseInstances = false;\n    S.IsSelectAll() ? (tempRect.copy(i.GetBoundingBox()), tempRect.offset(n, o), r.GetCollisionCandidates(i.GetLayer(), e, tempRect, tempCandidates2), G = tempCandidates2) : !l || runtime.IsCurrentConditionFirst() && !S._GetOwnElseInstances().length && S._GetOwnInstances().length ? G = S._GetOwnInstances() : (G = S._GetOwnElseInstances(), rPickFromElseInstances = true), s && (d = i.GetX(), I = i.GetY(), i.OffsetXY(n, o), i.SetBboxChanged());\n    for (const h of G) if (r.TestOverlap(t, h)) {\n      if (C = true, u) break;\n      f && rToPick.add(h);\n    }\n    return s && (i.SetXY(d, I), i.SetBboxChanged()), C32.clearArray(tempCandidates2), C;\n  }, FinishCollisionConditionPicking = function(t) {\n    const e = runtime.GetCurrentEvent().IsOrBlock(), n = rPickType.GetCurrentSol(), o = n._GetOwnInstances(), s = n._GetOwnElseInstances();\n    n.IsSelectAll() ? (n.SetSetPicked(rToPick), e && (C32.clearArray(s), n.AddElseInstances(rToPick, rPickType.GetInstances()))) : e ? rPickFromElseInstances ? n.TransferElseInstancesToOwn(rToPick) : (n.AddElseInstances(rToPick, o), n.SetSetPicked(rToPick)) : n.SetSetPicked(rToPick), rPickType.ApplySolToContainer();\n  }, FinishCollisionCondition = function(t, e) {\n    needsCollisionFinish && (e && FinishCollisionConditionPicking(t), rToPick.clear(), rPickType = null, needsCollisionFinish = false);\n  }, PickByUID_Normal = function(t, e) {\n    const n = runtime.GetInstanceByUID(e);\n    if (n) {\n      const o = t.GetCurrentSol();\n      if (o.IsSelectAll() || o._GetOwnInstances().includes(n)) {\n        if (t.IsFamily()) {\n          if (n.GetObjectClass().BelongsToFamily(t)) return o.PickOne(n), t.ApplySolToContainer(), true;\n        } else if (n.GetObjectClass() === t) return o.PickOne(n), t.ApplySolToContainer(), true;\n      }\n    }\n    return false;\n  }, PickByUID_Inverted = function(t, o) {\n    const s = t.GetCurrentSol();\n    if (s.IsSelectAll()) {\n      s._SetSelectAll(false), s.ClearArrays();\n      const n = t.GetInstances();\n      for (let t2 = 0, e = n.length; t2 < e; ++t2) {\n        const i = n[t2];\n        i.GetUID() === o ? s._PushElseInstance(i) : s._PushInstance(i);\n      }\n      return t.ApplySolToContainer(), !!s._GetOwnInstances().length;\n    }\n    {\n      const r = s._GetOwnInstances();\n      let n = 0;\n      for (let t2 = 0, e = r.length; t2 < e; ++t2) {\n        const a = r[t2];\n        (r[n] = a).GetUID() === o ? s._PushElseInstance(a) : ++n;\n      }\n      return C32.truncateArray(r, n), t.ApplySolToContainer(), !!r.length;\n    }\n  };\n  GetInst2 = GetInst, GetWorldInfo2 = GetWorldInfo, GetInst_SDKv22 = GetInst_SDKv2, GetWorldInfo_SDKv22 = GetWorldInfo_SDKv2, GetObjectClass2 = GetObjectClass, GetLayer2 = GetLayer, CollMemory_Add2 = CollMemory_Add, CollMemory_Remove2 = CollMemory_Remove, CollMemory_RemoveInstance2 = CollMemory_RemoveInstance, CollMemory_Get2 = CollMemory_Get, DoOverlapCondition2 = DoOverlapCondition, FinishCollisionConditionPicking2 = FinishCollisionConditionPicking, FinishCollisionCondition2 = FinishCollisionCondition, PickByUID_Normal2 = PickByUID_Normal, PickByUID_Inverted2 = PickByUID_Inverted;\n  const C32 = self.C3, tempColor = new C32.Color(), AnySDK = {}, SDKv1 = {}, SDKv2 = {};\n  let runtime = null;\n  C32.CommonACES_SetRuntime = function(t) {\n    runtime = t;\n  };\n  const IInstance = self.IInstance, IObjectClass = self.IObjectClass, ILayer = self.ILayer;\n  SDKv1.CompareX = function(t, e) {\n    return C32.compare(this.GetWorldInfo().GetX(), t, e);\n  }, SDKv2.CompareX = function(t, e) {\n    return C32.compare(this.x, t, e);\n  }, SDKv1.CompareY = function(t, e) {\n    return C32.compare(this.GetWorldInfo().GetY(), t, e);\n  }, SDKv2.CompareY = function(t, e) {\n    return C32.compare(this.y, t, e);\n  }, SDKv1.IsOnScreen = function() {\n    return this.GetWorldInfo().IsInViewport2();\n  }, SDKv2.IsOnScreen = function() {\n    return this.isOnScreen();\n  }, AnySDK.IsOutsideLayout = function() {\n    const t = GetWorldInfo(this), e = t.GetLayout(), n = t.GetBoundingBox();\n    return n.getRight() < 0 || n.getBottom() < 0 || n.getLeft() > e.GetWidth() || n.getTop() > e.GetHeight();\n  }, AnySDK.PickDistance = function(n, o, s) {\n    const t = GetObjectClass(this), e = t.GetCurrentSol(), i = e.GetInstances();\n    if (!i.length) return false;\n    let r = i[0], a = r.GetWorldInfo(), l = r, c = C32.distanceSquared(a.GetX(), a.GetY(), o, s);\n    for (let t2 = 1, e2 = i.length; t2 < e2; ++t2) {\n      r = i[t2], a = r.GetWorldInfo();\n      const u = C32.distanceSquared(a.GetX(), a.GetY(), o, s);\n      (0 === n && u < c || 1 === n && u > c) && (c = u, l = r);\n    }\n    return e.PickOne(l), true;\n  }, SDKv1.SetX = function(t) {\n    const e = this.GetWorldInfo();\n    e.GetX() !== t && (e.SetX(t), e.SetBboxChanged());\n  }, SDKv2.SetX = function(t) {\n    this.x = +t;\n  }, SDKv1.SetY = function(t) {\n    const e = this.GetWorldInfo();\n    e.GetY() !== t && (e.SetY(t), e.SetBboxChanged());\n  }, SDKv2.SetY = function(t) {\n    this.y = +t;\n  }, SDKv1.SetPos = function(t, e) {\n    const n = this.GetWorldInfo();\n    n.EqualsXY(t, e) || (n.SetXY(t, e), n.SetBboxChanged());\n  }, SDKv2.SetPos = function(t, e) {\n    this.setPosition(t, e);\n  }, AnySDK.SetPosToObject = function(t, e) {\n    if (t = GetObjectClass(t)) {\n      const n = GetInst(this), o = t.GetPairedInstance(n);\n      if (o) {\n        const [s, i] = o.GetImagePoint(e), r = n.GetWorldInfo();\n        r.GetX() === s && r.GetY() === i || (r.SetXY(s, i), r.SetBboxChanged());\n      }\n    }\n  }, AnySDK.MoveForward = function(t) {\n    if (0 !== t) {\n      const e = GetWorldInfo(this);\n      e.OffsetXY(e.GetCosAngle() * t, e.GetSinAngle() * t), e.SetBboxChanged();\n    }\n  }, SDKv1.MoveAtAngle = function(t, e) {\n    if (0 !== e) {\n      const n = this.GetWorldInfo();\n      t = C32.toRadians(t), n.OffsetXY(Math.cos(t) * e, Math.sin(t) * e), n.SetBboxChanged();\n    }\n  }, SDKv2.MoveAtAngle = function(t, e) {\n    0 !== e && (t = C32.toRadians(t), this.offsetPosition(Math.cos(t) * e, Math.sin(t) * e));\n  }, SDKv1.GetX = function() {\n    return this.GetWorldInfo().GetX();\n  }, SDKv2.GetX = function() {\n    return this.x;\n  }, SDKv1.GetY = function() {\n    return this.GetWorldInfo().GetY();\n  }, SDKv2.GetY = function() {\n    return this.y;\n  }, AnySDK.GetDt = function() {\n    return runtime.GetDt(GetInst(this));\n  }, SDKv1.CompareWidth = function(t, e) {\n    return C32.compare(this.GetWorldInfo().GetWidth(), t, e);\n  }, SDKv2.CompareWidth = function(t, e) {\n    return C32.compare(this.width, t, e);\n  }, SDKv1.CompareHeight = function(t, e) {\n    return C32.compare(this.GetWorldInfo().GetHeight(), t, e);\n  }, SDKv2.CompareHeight = function(t, e) {\n    return C32.compare(this.height, t, e);\n  }, SDKv1.SetWidth = function(t) {\n    const e = this.GetWorldInfo();\n    e.GetWidth() !== t && (e.SetWidth(t), e.SetBboxChanged());\n  }, SDKv2.SetWidth = function(t) {\n    this.width = t;\n  }, SDKv1.SetHeight = function(t) {\n    const e = this.GetWorldInfo();\n    e.GetHeight() !== t && (e.SetHeight(t), e.SetBboxChanged());\n  }, SDKv2.SetHeight = function(t) {\n    this.height = t;\n  }, SDKv1.SetSize = function(t, e) {\n    const n = GetWorldInfo(this);\n    n.GetWidth() === t && n.GetHeight() === e || (n.SetSize(t, e), n.SetBboxChanged());\n  }, SDKv2.SetSize = function(t, e) {\n    this.setSize(t, e);\n  }, SDKv1.GetWidth = function() {\n    return this.GetWorldInfo().GetWidth();\n  }, SDKv2.GetWidth = function() {\n    return this.width;\n  }, SDKv1.GetHeight = function() {\n    return this.GetWorldInfo().GetHeight();\n  }, SDKv2.GetHeight = function() {\n    return this.height;\n  }, AnySDK.GetBboxLeft = function() {\n    return GetWorldInfo(this).GetBoundingBox().getLeft();\n  }, AnySDK.GetBboxTop = function() {\n    return GetWorldInfo(this).GetBoundingBox().getTop();\n  }, AnySDK.GetBboxRight = function() {\n    return GetWorldInfo(this).GetBoundingBox().getRight();\n  }, AnySDK.GetBboxBottom = function() {\n    return GetWorldInfo(this).GetBoundingBox().getBottom();\n  }, AnySDK.GetBboxMidX = function() {\n    const t = GetWorldInfo(this).GetBoundingBox();\n    return (t.getLeft() + t.getRight()) / 2;\n  }, AnySDK.GetBboxMidY = function() {\n    const t = GetWorldInfo(this).GetBoundingBox();\n    return (t.getTop() + t.getBottom()) / 2;\n  }, AnySDK.IsAngleWithin = function(t, e) {\n    return C32.angleDiff(GetWorldInfo(this).GetAngle(), C32.toRadians(e)) <= C32.toRadians(t);\n  }, AnySDK.IsAngleClockwiseFrom = function(t) {\n    return C32.angleClockwise(GetWorldInfo(this).GetAngle(), C32.toRadians(t));\n  }, AnySDK.IsBetweenAngles = function(t, e) {\n    const n = C32.toRadians(t), o = C32.toRadians(e), s = GetWorldInfo(this).GetAngle(), i = !C32.angleClockwise(o, n);\n    return i ? !(!C32.angleClockwise(s, n) && C32.angleClockwise(s, o)) : C32.angleClockwise(s, n) && !C32.angleClockwise(s, o);\n  }, SDKv1.SetAngle = function(t) {\n    const e = this.GetWorldInfo(), n = C32.clampAngle(C32.toRadians(t));\n    isNaN(n) || e.GetAngle() === n || (e.SetAngle(n), e.SetBboxChanged());\n  }, SDKv2.SetAngle = function(t) {\n    this.angleDegrees = t;\n  }, AnySDK.RotateClockwise = function(t) {\n    if (!isNaN(t) && 0 !== t) {\n      const e = GetWorldInfo(this);\n      e.SetAngle(e.GetAngle() + C32.toRadians(t)), e.SetBboxChanged();\n    }\n  }, AnySDK.RotateCounterclockwise = function(t) {\n    if (!isNaN(t) && 0 !== t) {\n      const e = GetWorldInfo(this);\n      e.SetAngle(e.GetAngle() - C32.toRadians(t)), e.SetBboxChanged();\n    }\n  }, AnySDK.RotateTowardAngle = function(t, e) {\n    const n = GetWorldInfo(this), o = n.GetAngle(), s = C32.angleRotate(o, C32.toRadians(e), C32.toRadians(t));\n    isNaN(s) || o === s || (n.SetAngle(s), n.SetBboxChanged());\n  }, AnySDK.RotateTowardPosition = function(t, e, n) {\n    const o = GetWorldInfo(this), s = o.GetAngle(), i = e - o.GetX(), r = n - o.GetY(), a = Math.atan2(r, i), l = C32.angleRotate(s, a, C32.toRadians(t));\n    isNaN(l) || s === l || (o.SetAngle(l), o.SetBboxChanged());\n  }, AnySDK.SetTowardPosition = function(t, e) {\n    const n = GetWorldInfo(this), o = n.GetAngle(), s = t - n.GetX(), i = e - n.GetY(), r = Math.atan2(i, s);\n    isNaN(r) || o === r || (n.SetAngle(r), n.SetBboxChanged());\n  }, SDKv1.GetAngle = function() {\n    return C32.toDegrees(this.GetWorldInfo().GetAngle());\n  }, SDKv2.GetAngle = function() {\n    return this.angleDegrees;\n  }, AnySDK.CompareOpacity = function(t, e) {\n    return C32.compare(C32.roundToDp(100 * GetWorldInfo(this).GetOpacity(), 6), t, e);\n  }, SDKv1.IsVisible = function() {\n    return this.GetWorldInfo().IsVisible();\n  }, SDKv2.IsVisible = function() {\n    return this.isVisible;\n  }, AnySDK.SetVisible = function(t) {\n    const e = GetWorldInfo(this);\n    t = 2 === t ? !e.IsVisible() : 0 !== t, e.IsVisible() !== t && (e.SetVisible(t), runtime.UpdateRender());\n  }, AnySDK.SetOpacity = function(t) {\n    const e = C32.clamp(t / 100, 0, 1), n = GetWorldInfo(this);\n    if (n.GetTransformWithParentOpacity()) {\n      if (n._GetSceneGraphInfo().GetOwnOpacity() === e) return;\n    } else if (n.GetOpacity() === e) return;\n    n.SetOpacity(e), runtime.UpdateRender();\n  }, AnySDK.SetDefaultColor = function(t) {\n    tempColor.setFromRgbValue(t);\n    const e = GetWorldInfo(this);\n    e.GetUnpremultipliedColor().equalsIgnoringAlpha(tempColor) || (e.SetUnpremultipliedColor(tempColor), runtime.UpdateRender());\n  }, AnySDK.GetColor = function() {\n    const t = GetWorldInfo(this).GetUnpremultipliedColor();\n    return C32.PackRGBAEx(t.getR(), t.getG(), t.getB(), t.getA());\n  }, AnySDK.GetOpacity = function() {\n    return C32.roundToDp(100 * GetWorldInfo(this).GetOpacity(), 6);\n  }, AnySDK.IsOnLayer = function(t) {\n    return !!(t = GetLayer(t)) && GetWorldInfo(this).GetLayer() === t;\n  }, AnySDK.PickTopBottom = function(n) {\n    const t = GetObjectClass(this), e = t.GetCurrentSol(), o = e.GetInstances();\n    if (!o.length) return false;\n    let s = o[0], i = s;\n    for (let t2 = 1, e2 = o.length; t2 < e2; ++t2) {\n      const s2 = o[t2], r = s2.GetWorldInfo(), a = i.GetWorldInfo(), l = r.GetLayer().GetIndex(), c = a.GetLayer().GetIndex();\n      0 === n ? (c < l || l === c && r.GetZIndex() > a.GetZIndex()) && (i = s2) : (l < c || l === c && r.GetZIndex() < a.GetZIndex()) && (i = s2);\n    }\n    return e.PickOne(i), true;\n  }, SDKv1.CompareZElevation = function(t, e, n) {\n    const o = this.GetWorldInfo(), s = 0 === t ? o.GetZElevation() : o.GetTotalZElevation();\n    return C32.compare(s, e, n);\n  }, SDKv2.CompareZElevation = function(t, e, n) {\n    const o = 0 === t ? this.zElevation : this.totalZElevation;\n    return C32.compare(o, e, n);\n  }, SDKv1.MoveToTop = function() {\n    this.GetWorldInfo().ZOrderMoveToTop();\n  }, SDKv2.MoveToTop = function() {\n    this.moveToTop();\n  }, SDKv1.MoveToBottom = function() {\n    this.GetWorldInfo().ZOrderMoveToBottom();\n  }, SDKv2.MoveToBottom = function() {\n    this.moveToBottom();\n  }, AnySDK.MoveToLayer = function(t) {\n    (t = GetLayer(t)) && GetWorldInfo(this).ZOrderMoveToLayer(t);\n  }, AnySDK.ZMoveToObject = function(t, e) {\n    const n = 0 === t;\n    if (e = GetObjectClass(e)) {\n      const o = GetInst(this), s = e.GetFirstPicked(o);\n      s && o.GetWorldInfo().ZOrderMoveAdjacentToInstance(s, n);\n    }\n  }, SDKv1.SetZElevation = function(t) {\n    const e = this.GetWorldInfo();\n    e.GetZElevation() !== t && (e.SetZElevation(t), runtime.UpdateRender());\n  }, SDKv2.SetZElevation = function(t) {\n    this.zElevation = t;\n  }, AnySDK.LayerNumber = function() {\n    return GetWorldInfo(this).GetLayer().GetIndex();\n  }, AnySDK.LayerName = function() {\n    return GetWorldInfo(this).GetLayer().GetName();\n  }, SDKv1.ZIndex = function() {\n    return this.GetWorldInfo().GetZIndex();\n  }, SDKv2.ZIndex = function() {\n    return this.zIndex;\n  }, SDKv1.ZElevation = function() {\n    return this.GetWorldInfo().GetZElevation();\n  }, SDKv2.ZElevation = function() {\n    return this.zElevation;\n  }, SDKv1.TotalZElevation = function() {\n    return this.GetWorldInfo().GetTotalZElevation();\n  }, SDKv2.TotalZElevation = function() {\n    return this.totalZElevation;\n  }, AnySDK.IsEffectEnabled = function(t) {\n    const e = GetInst(this), n = e.GetObjectClass().GetEffectList().GetEffectTypeByName(t);\n    if (n) {\n      const o = n.GetIndex(), s = e.GetWorldInfo().GetInstanceEffectList();\n      return s.IsEffectIndexActive(o);\n    }\n  }, AnySDK.SetEffectEnabled = function(t, e) {\n    const n = GetInst(this), o = n.GetObjectClass().GetEffectList().GetEffectTypeByName(e);\n    if (o) {\n      const s = o.GetIndex(), i = 1 === t, r = n.GetWorldInfo().GetInstanceEffectList();\n      r.IsEffectIndexActive(s) !== i && (r.SetEffectIndexActive(s, i), r.UpdateActiveEffects(), runtime.UpdateRender());\n    }\n  }, AnySDK.SetEffectParam = function(t, e, n) {\n    const o = GetInst(this), s = o.GetObjectClass().GetEffectList().GetEffectTypeByName(t);\n    if (s) {\n      e = Math.floor(e);\n      const i = s.GetShaderProgram().GetParameterType(e);\n      if (i) {\n        \"color\" === i ? (tempColor.setFromRgbValue(n), n = tempColor) : \"percent\" === i && (n /= 100);\n        const r = s.GetIndex(), a = o.GetWorldInfo().GetInstanceEffectList(), l = a.SetEffectParameter(r, e, n);\n        l && a.IsEffectIndexActive(r) && runtime.UpdateRender();\n      }\n    }\n  };\n  const tempRect = C32.New(C32.Rect), tempCandidates1 = [], tempCandidates2 = [];\n  let needsCollisionFinish = false, rPickType = null, rPickFromElseInstances = false;\n  const rToPick = /* @__PURE__ */ new Set();\n  function* DebugOnCollision(o) {\n    if (o) {\n      const t = this.GetRuntime(), s = t.GetCollisionEngine(), i = t.GetEventSheetManager(), r = i.GetEventStack(), a = i.GetCurrentCondition(), l = a.GetObjectClass(), c = a.GetSavedDataMap(), u = a.GetUnsavedDataMap(), S = r.GetCurrentStackFrame(), f = t.GetTickCount(), G = f - 1, d = S.GetCurrentEvent(), I = r.Push(d);\n      let n = c.get(\"collmemory\");\n      n || (n = C32.New(C32.PairMap), c.set(\"collmemory\", n)), u.get(\"collisionCreatedDestroyCallback\") || (u.set(\"collisionCreatedDestroyCallback\", true), t.Dispatcher().addEventListener(\"instancedestroy\", (t2) => CollMemory_RemoveInstance(n, t2.instance)));\n      const C = l.GetCurrentSol(), h = o.GetCurrentSol(), m = C.GetInstances();\n      let e = null;\n      for (let t2 = 0; t2 < m.length; ++t2) {\n        const g = m[t2];\n        h.IsSelectAll() ? (s.GetCollisionCandidates(g.GetWorldInfo().GetLayer(), o, g.GetWorldInfo().GetBoundingBox(), tempCandidates1), e = tempCandidates1, s.AddRegisteredCollisionCandidates(g, o, e)) : e = h.GetInstances();\n        for (let t3 = 0; t3 < e.length; ++t3) {\n          const y = e[t3];\n          if (s.TestOverlap(g, y) || s.CheckRegisteredCollision(g, y)) {\n            const p = CollMemory_Get(n, g, y);\n            let t4 = false, e2 = -2;\n            \"number\" == typeof p && (t4 = true, e2 = p);\n            const D = !t4 || e2 < G;\n            if (CollMemory_Add(n, g, y, f), D) {\n              const A = d.GetSolModifiers(), v = (i.PushCopySol(A), l.GetCurrentSol()), b = o.GetCurrentSol();\n              if (v._SetSelectAll(false), b._SetSelectAll(false), l === o) {\n                const K = v._GetOwnInstances();\n                C32.clearArray(K), K.push(g), K.push(y), l.ApplySolToContainer();\n              } else {\n                const O = v._GetOwnInstances(), E = b._GetOwnInstances();\n                C32.clearArray(O), C32.clearArray(E), O.push(g), E.push(y), l.ApplySolToContainer(), o.ApplySolToContainer();\n              }\n              yield* d.DebugRetrigger(S, I), i.PopSol(A);\n            }\n          } else CollMemory_Remove(n, g, y);\n        }\n        C32.clearArray(tempCandidates1);\n      }\n      r.Pop();\n    }\n    return false;\n  }\n  AnySDK.OnCollision = function(o) {\n    const t = GetObjectClass(this), s = (o = GetObjectClass(o), t.GetRuntime());\n    if (s.IsDebugging()) return DebugOnCollision.call(t, o);\n    if (o) {\n      const i = s.GetCollisionEngine(), r = s.GetEventSheetManager(), a = r.GetEventStack(), l = r.GetCurrentCondition(), c = l.GetObjectClass(), u = l.GetSavedDataMap(), S = l.GetUnsavedDataMap(), f = a.GetCurrentStackFrame(), G = s.GetTickCount(), d = G - 1, I = f.GetCurrentEvent(), C = a.Push(I);\n      let n = u.get(\"collmemory\");\n      n || (n = C32.New(C32.PairMap), u.set(\"collmemory\", n)), S.get(\"collisionCreatedDestroyCallback\") || (S.set(\"collisionCreatedDestroyCallback\", true), s.Dispatcher().addEventListener(\"instancedestroy\", (t2) => CollMemory_RemoveInstance(n, t2.instance)));\n      const h = c.GetCurrentSol(), m = o.GetCurrentSol(), g = h.GetInstances();\n      let e = null;\n      for (let t2 = 0; t2 < g.length; ++t2) {\n        const y = g[t2];\n        m.IsSelectAll() ? (i.GetCollisionCandidates(y.GetWorldInfo().GetLayer(), o, y.GetWorldInfo().GetBoundingBox(), tempCandidates1), e = tempCandidates1, i.AddRegisteredCollisionCandidates(y, o, e)) : e = m.GetInstances();\n        for (let t3 = 0; t3 < e.length; ++t3) {\n          const p = e[t3];\n          if (i.TestOverlap(y, p) || i.CheckRegisteredCollision(y, p)) {\n            const D = CollMemory_Get(n, y, p);\n            let t4 = false, e2 = -2;\n            \"number\" == typeof D && (t4 = true, e2 = D);\n            const A = !t4 || e2 < d;\n            if (CollMemory_Add(n, y, p, G), A) {\n              const v = I.GetSolModifiers(), b = (r.PushCopySol(v), c.GetCurrentSol()), K = o.GetCurrentSol();\n              if (b._SetSelectAll(false), K._SetSelectAll(false), c === o) {\n                const O = b._GetOwnInstances();\n                C32.clearArray(O), O.push(y), O.push(p), c.ApplySolToContainer();\n              } else {\n                const E = b._GetOwnInstances(), T = K._GetOwnInstances();\n                C32.clearArray(E), C32.clearArray(T), E.push(y), T.push(p), c.ApplySolToContainer(), o.ApplySolToContainer();\n              }\n              I.Retrigger(f, C), r.PopSol(v);\n            }\n          } else CollMemory_Remove(n, y, p);\n        }\n        C32.clearArray(tempCandidates1);\n      }\n      a.Pop();\n    }\n    return false;\n  }, AnySDK.IsOverlapping = function(t) {\n    return t = GetObjectClass(t), DoOverlapCondition(GetInst(this), t, 0, 0);\n  }, AnySDK.IsOverlappingOffset = function(t, e, n) {\n    return t = GetObjectClass(t), DoOverlapCondition(GetInst(this), t, e, n);\n  }, AnySDK.OnHierarchyReady = function() {\n    return true;\n  }, AnySDK.HasParent = function() {\n    return GetWorldInfo(this).HasParent();\n  }, AnySDK.HasChildren = function() {\n    return GetWorldInfo(this).HasChildren();\n  }, AnySDK.PickParent = function(n, o) {\n    const t = GetObjectClass(this), e = (n = GetObjectClass(n), t.GetRuntime()), s = this.GetCurrentSol(), i = s.GetInstances();\n    if (0 === i.length) return false;\n    const r = n.GetCurrentSol();\n    let a = r.GetInstances();\n    if (r.IsSelectAll()) {\n      const u = [...e.instancesPendingCreateForObjectClass(n)];\n      0 < u.length && (a = a.concat(u));\n    }\n    if (0 === a.length) return false;\n    const l = r.IsSelectAll() ? null : new Set(a), c = /* @__PURE__ */ new Set();\n    for (let t2 = 0, e2 = i.length; t2 < e2; ++t2) {\n      const S = i[t2];\n      if (1 === o) for (const f of S.parents()) f.BelongsToObjectClass(n) && (null === l || l.has(f)) && c.add(f);\n      else {\n        let t3;\n        if (0 === o) {\n          if (null === (t3 = S.GetParent())) continue;\n        } else t3 = S.GetTopParent();\n        t3.BelongsToObjectClass(n) && (null === l || l.has(t3)) && c.add(t3);\n      }\n    }\n    return 0 !== c.size && (r.SetSetPicked(c), n.ApplySolToContainer(), true);\n  }, AnySDK.PickChildren = function(n, o) {\n    const t = GetObjectClass(this), e = (n = GetObjectClass(n), t.GetRuntime()), s = t.GetCurrentSol(), i = s.GetInstances();\n    if (0 === i.length) return false;\n    const r = n.GetCurrentSol();\n    let a = r.GetInstances();\n    if (r.IsSelectAll()) {\n      const u = [...e.instancesPendingCreateForObjectClass(n)];\n      0 < u.length && (a = a.concat(u));\n    }\n    if (0 === a.length) return false;\n    const l = r.IsSelectAll() ? null : new Set(a), c = /* @__PURE__ */ new Set();\n    for (let t2 = 0, e2 = i.length; t2 < e2; ++t2) {\n      const S = i[t2];\n      2 !== o || S.HasChildren() || !S.BelongsToObjectClass(n) || null !== l && !l.has(S) || c.add(S);\n      for (const f of 0 === o ? S.children() : S.allChildren()) 2 === o && f.HasChildren() || f.BelongsToObjectClass(n) && (null === l || l.has(f)) && c.add(f);\n    }\n    return 0 !== c.size && (r.SetSetPicked(c), n.ApplySolToContainer(), true);\n  }, AnySDK.PickNthChild = function(n, o, s) {\n    const t = GetObjectClass(this), e = (n = GetObjectClass(n), t.GetRuntime()), i = t.GetCurrentSol(), r = i.GetInstances();\n    if (0 === r.length) return false;\n    const a = n.GetCurrentSol();\n    let l = a.GetInstances();\n    if (a.IsSelectAll()) {\n      const S = [...e.instancesPendingCreateForObjectClass(n)];\n      0 < S.length && (l = l.concat(S));\n    }\n    if (0 === l.length) return false;\n    const c = a.IsSelectAll() ? null : new Set(l), u = [];\n    for (let t2 = 0, e2 = r.length; t2 < e2; ++t2) {\n      const f = r[t2];\n      if (0 === o) {\n        const G = f.GetChildAt(s);\n        null !== G && G.BelongsToObjectClass(n) && (null === c || c.has(G)) && u.push(G);\n      } else if (1 === o) {\n        for (const d of f.children()) if (d.BelongsToObjectClass(n)) {\n          if (0 === s) {\n            null !== c && !c.has(d) || u.push(d);\n            break;\n          }\n          --s;\n        }\n      }\n    }\n    return 0 !== u.length && (a.SetArrayPicked(u), n.ApplySolToContainer(), true);\n  }, AnySDK.CompareChildCount = function(t, e, n) {\n    const o = GetInst(this);\n    switch (t) {\n      case 0:\n      default:\n        return C32.compare(o.GetChildCount(), e, n);\n      case 1:\n        return C32.compare(o.GetAllChildCount(), e, n);\n    }\n  }, AnySDK.AddChild = function(t, e, n, o, s, i, r, a, l, c) {\n    t = GetObjectClass(t);\n    const u = GetInst(this), S = runtime.GetCurrentAction().GetObjectClass();\n    for (const f of t.allCorrespondingInstances(u, S)) {\n      if (!f.GetPlugin().SupportsSceneGraph()) return;\n      u.AddChild(f, { transformX: e, transformY: n, transformWidth: o, transformHeight: s, transformAngle: i, transformOpacity: r, transformZElevation: a, transformVisibility: l, destroyWithParent: c });\n    }\n  }, AnySDK.RemoveChild = function(t) {\n    t = GetObjectClass(t);\n    const e = GetInst(this), n = runtime.GetCurrentAction().GetObjectClass();\n    for (const o of t.allCorrespondingInstances(e, n)) e.RemoveChild(o);\n  }, AnySDK.RemoveFromParent = function() {\n    const t = GetInst(this);\n    if (t.HasParent()) {\n      const e = t.GetParent();\n      e.RemoveChild(t);\n    }\n  }, AnySDK.ParentUID = function() {\n    const t = GetInst(this).GetParent();\n    return t ? t.GetUID() : -1;\n  }, AnySDK.ChildCount = function() {\n    return GetInst(this).GetChildCount();\n  }, AnySDK.AllChildCount = function() {\n    return GetInst(this).GetAllChildCount();\n  }, AnySDK.SetMeshSize = function(t, e) {\n    t = Math.floor(t), e = Math.floor(e);\n    const n = GetWorldInfo(this);\n    t < 2 || e < 2 || !isFinite(t) || !isFinite(e) ? (n.ReleaseMesh(), n.SetBboxChanged()) : n.CreateMesh(t, e);\n  }, AnySDK.SetMeshPoint = function(t, e, n, o, s, i, r, a) {\n    const l = GetWorldInfo(this), c = l.SetMeshPoint(t, e, { mode: 0 === n ? \"absolute\" : \"relative\", x: o, y: s, zElevation: i, u: r, v: a });\n    c && l.SetBboxChanged();\n  }, AnySDK.MeshColumns = function() {\n    const t = GetWorldInfo(this);\n    return t.HasMesh() ? t.GetSourceMesh().GetHSize() : 0;\n  }, AnySDK.MeshRows = function() {\n    const t = GetWorldInfo(this);\n    return t.HasMesh() ? t.GetSourceMesh().GetVSize() : 0;\n  }, AnySDK.SetElementVisible = function(t) {\n    const e = GetWorldInfo(this);\n    t = 2 === t ? !e.IsVisible() : 0 !== t, e.IsVisible() !== t && e.SetVisible(t);\n  }, AnySDK.SetElementCSSStyle = function(t, e) {\n    this instanceof self.IInstance ? this.setElementCSSStyle(t, e) : this.SetElementCSSStyle(t, e);\n  }, AnySDK.SetElementAttribute = function(t, e) {\n    this instanceof self.IInstance ? this.setElementAttribute(t, \"\" + e) : this.SetElementAttribute(t, \"\" + e);\n  }, AnySDK.RemoveElementAttribute = function(t) {\n    this instanceof self.IInstance ? this.removeElementAttribute(t) : this.RemoveElementAttribute(t);\n  }, AnySDK.SetElementFocus = function() {\n    this instanceof self.IInstance ? this.focusElement() : this.FocusElement();\n  }, AnySDK.SetElementBlur = function() {\n    this instanceof self.IInstance ? this.blurElement() : this.BlurElement();\n  }, AnySDK.IsElementFocused = function() {\n    return this instanceof self.IInstance ? this.isElementFocused() : this.IsElementFocused();\n  }, AnySDK.SetElementEnabled = function(t) {\n    this instanceof self.IInstance ? this._setEnabled(0 !== t) : this._SetEnabled(0 !== t);\n  }, AnySDK.IsElementEnabled = function() {\n    return this instanceof self.IInstance ? this._isEnabled() : this._IsEnabled();\n  }, SDKv1.CompareInstanceVar = function(t, e, n) {\n    return C32.compare(this.GetInstance().GetInstanceVariableValue(t), e, n);\n  }, SDKv2.CompareInstanceVar = function(t, e, n) {\n    return C32.compare(GetInst_SDKv2(this).GetInstanceVariableValue(t), e, n);\n  }, SDKv1.IsBoolInstanceVarSet = function(t) {\n    return !!this.GetInstance().GetInstanceVariableValue(t);\n  }, SDKv2.IsBoolInstanceVarSet = function(t) {\n    return !!GetInst_SDKv2(this).GetInstanceVariableValue(t);\n  }, AnySDK.PickInstVarHiLow = function(n, o) {\n    const s = GetObjectClass(this), t = s.GetCurrentSol(), i = t.GetInstances();\n    if (!i.length) return false;\n    const r = s.IsFamily();\n    let a = null, l = 0;\n    for (let t2 = 0, e = i.length; t2 < e; ++t2) {\n      const c = i[t2], u = r ? c.GetObjectClass().GetFamilyInstanceVariableOffset(s.GetFamilyIndex()) : 0, S = c.GetInstanceVariableValue(u + o);\n      (null === a || 0 === n && S < l || 1 === n && S > l) && (l = S, a = c);\n    }\n    return t.PickOne(a), true;\n  }, AnySDK.PickByUID = function(t) {\n    const e = GetObjectClass(this);\n    return (e.GetRuntime().GetCurrentCondition().IsInverted() ? PickByUID_Inverted : PickByUID_Normal)(e, t);\n  }, AnySDK.HasTags = function(t) {\n    const e = new Set(C32.splitStringAndNormalize(t)), n = GetInst(this).GetTagsSet();\n    return e.isSubsetOf(n);\n  }, AnySDK.Tags = function() {\n    return GetInst(this).GetTagsString();\n  }, AnySDK.TagsCount = function() {\n    return GetInst(this).GetTagsSet().size;\n  }, AnySDK.TagAt = function(t) {\n    return GetInst(this).GetTagAt(t);\n  }, AnySDK.ChangeTags = function(t, e) {\n    const n = C32.splitStringAndNormalize(e);\n    if (0 !== n.length) {\n      const o = GetInst(this), s = new Set(o.GetTagsSet());\n      if (0 === t) for (const i of n) s.add(i);\n      else if (1 === t) for (const r of n) s.delete(r);\n      o.SetTagsSet(s);\n    }\n  }, AnySDK.Destroy = function() {\n    runtime.DestroyInstance(GetInst(this));\n  }, AnySDK.OnCreated = function() {\n    return true;\n  }, AnySDK.OnDestroyed = function() {\n    return true;\n  }, SDKv1.SetInstanceVar = function(t, e) {\n    this.GetInstance().SetInstanceVariableValue(t, e);\n  }, SDKv2.SetInstanceVar = function(t, e) {\n    GetInst_SDKv2(this).SetInstanceVariableValue(t, e);\n  }, SDKv1.AddInstanceVar = function(t, e) {\n    const n = this.GetInstance(), o = n.GetInstanceVariableValue(t);\n    \"number\" == typeof o && \"number\" != typeof e ? e = parseFloat(e) : \"string\" == typeof o && \"string\" != typeof e && (e = e.toString()), n.SetInstanceVariableValue(t, o + e);\n  }, SDKv2.AddInstanceVar = function(t, e) {\n    const n = GetInst_SDKv2(this), o = n.GetInstanceVariableValue(t);\n    \"number\" == typeof o && \"number\" != typeof e ? e = parseFloat(e) : \"string\" == typeof o && \"string\" != typeof e && (e = e.toString()), n.SetInstanceVariableValue(t, o + e);\n  }, SDKv1.SubInstanceVar = function(t, e) {\n    const n = this.GetInstance(), o = n.GetInstanceVariableValue(t);\n    \"number\" == typeof o && (\"number\" != typeof e && (e = parseFloat(e)), n.SetInstanceVariableValue(t, o - e));\n  }, SDKv2.SubInstanceVar = function(t, e) {\n    const n = GetInst_SDKv2(this), o = n.GetInstanceVariableValue(t);\n    \"number\" == typeof o && (\"number\" != typeof e && (e = parseFloat(e)), n.SetInstanceVariableValue(t, o - e));\n  }, SDKv1.SetBoolInstanceVar = function(t, e) {\n    this.GetInstance().SetInstanceVariableValue(t, e ? 1 : 0);\n  }, SDKv2.SetBoolInstanceVar = function(t, e) {\n    GetInst_SDKv2(this).SetInstanceVariableValue(t, e ? 1 : 0);\n  }, SDKv1.ToggleBoolInstanceVar = function(t) {\n    const e = this.GetInstance();\n    e.SetInstanceVariableValue(t, 0 === e.GetInstanceVariableValue(t) ? 1 : 0);\n  }, SDKv2.ToggleBoolInstanceVar = function(t) {\n    const e = GetInst_SDKv2(this);\n    e.SetInstanceVariableValue(t, 0 === e.GetInstanceVariableValue(t) ? 1 : 0);\n  }, AnySDK.LoadFromJsonString = function(t) {\n    let e;\n    try {\n      e = JSON.parse(t);\n    } catch (t2) {\n      return void console.error(\"Failed to load from JSON string: \", t2);\n    }\n    const n = GetInst(this), o = \"state\";\n    runtime.ClearIntancesNeedingAfterLoad(), n._OnBeforeLoad(o), n.LoadFromJson(e, o), runtime.DoAfterLoad(o, { setFromJson: true });\n  }, AnySDK.AsJSON = function() {\n    return JSON.stringify(GetInst(this).SaveToJson(\"state\"));\n  }, AnySDK.ObjectTypeName = function() {\n    return GetInst(this).GetObjectClass().GetName();\n  }, AnySDK.Count = function() {\n    const t = runtime.GetCurrentEventStackFrame().GetExpressionObjectClass();\n    let e = t.GetInstanceCount();\n    for (const n of runtime.instancesPendingCreateForObjectClass(t)) ++e;\n    return e;\n  }, AnySDK.PickedCount = function() {\n    return runtime.GetCurrentEventStackFrame().GetExpressionObjectClass().GetCurrentSol().GetInstances().length;\n  }, SDKv1.GetIID = function() {\n    return this.GetInstance().GetIID();\n  }, SDKv2.GetIID = function() {\n    return GetInst_SDKv2(this).GetIID();\n  }, SDKv1.GetUID = function() {\n    return this.GetInstance().GetUID();\n  }, SDKv2.GetUID = function() {\n    return GetInst_SDKv2(this).GetUID();\n  }, AnySDK.OnInstanceSignal = function(t) {\n    const e = GetInst(this);\n    return t.toLowerCase() === runtime.GetEventSheetManager().GetCurrentInstanceSignalTag(e);\n  }, AnySDK.InstanceSignal = function(t) {\n    const e = GetInst(this);\n    runtime.GetEventSheetManager().InstanceSignal(e, t);\n  }, AnySDK.InstanceWaitForSignal = function(t) {\n    const e = GetObjectClass(this);\n    return runtime.GetEventSheetManager().AddScheduledWait().InitInstanceSignals(e.GetCurrentSol().GetInstances(), t), true;\n  }, AnySDK.TemplateName = function() {\n    return GetInst(this).GetTemplateName();\n  }, C32.AddCommonACEs = function(t, e, n) {\n    const o = t[1], s = t[3], i = t[4], r = t[5], a = t[6], l = t[7], c = t[8], u = t[10], S = t[11], f = t[12], G = t[13], d = t[14], I = t[15], C = t[16], h = e.Cnds, m = e.Acts, g = e.Exps, y = Object.assign({}, AnySDK, 2 <= n ? SDKv2 : SDKv1);\n    s && (h.CompareX = y.CompareX, h.CompareY = y.CompareY, h.IsOnScreen = y.IsOnScreen, h.IsOutsideLayout = y.IsOutsideLayout, h.PickDistance = y.PickDistance, m.SetX = y.SetX, m.SetY = y.SetY, m.SetPos = y.SetPos, m.SetPosToObject = y.SetPosToObject, m.MoveForward = y.MoveForward, m.MoveAtAngle = y.MoveAtAngle, g.X = y.GetX, g.Y = y.GetY, g.dt = y.GetDt), i && (h.CompareWidth = y.CompareWidth, h.CompareHeight = y.CompareHeight, m.SetWidth = y.SetWidth, m.SetHeight = y.SetHeight, m.SetSize = y.SetSize, g.Width = y.GetWidth, g.Height = y.GetHeight, g.BBoxLeft = y.GetBboxLeft, g.BBoxTop = y.GetBboxTop, g.BBoxRight = y.GetBboxRight, g.BBoxBottom = y.GetBboxBottom, g.BBoxMidX = y.GetBboxMidX, g.BBoxMidY = y.GetBboxMidY), r && (h.AngleWithin = y.IsAngleWithin, h.IsClockwiseFrom = y.IsAngleClockwiseFrom, h.IsBetweenAngles = y.IsBetweenAngles, m.SetAngle = y.SetAngle, m.RotateClockwise = y.RotateClockwise, m.RotateCounterclockwise = y.RotateCounterclockwise, m.RotateTowardAngle = y.RotateTowardAngle, m.RotateTowardPosition = y.RotateTowardPosition, m.SetTowardPosition = y.SetTowardPosition, g.Angle = y.GetAngle), a && (h.IsVisible = y.IsVisible, h.CompareOpacity = y.CompareOpacity, m.SetVisible = y.SetVisible, m.SetOpacity = y.SetOpacity, m.SetDefaultColor = y.SetDefaultColor, g.Opacity = y.GetOpacity, g.ColorValue = y.GetColor), l && (h.IsOnLayer = y.IsOnLayer, h.PickTopBottom = y.PickTopBottom, h.CompareZElevation = y.CompareZElevation, m.MoveToTop = y.MoveToTop, m.MoveToBottom = y.MoveToBottom, m.MoveToLayer = y.MoveToLayer, m.ZMoveToObject = y.ZMoveToObject, m.SetZElevation = y.SetZElevation, g.LayerNumber = y.LayerNumber, g.LayerName = y.LayerName, g.ZIndex = y.ZIndex, g.ZElevation = y.ZElevation, g.TotalZElevation = y.TotalZElevation), c && (h.IsEffectEnabled = y.IsEffectEnabled, m.SetEffectEnabled = y.SetEffectEnabled, m.SetEffectParam = y.SetEffectParam), G && (h.OnHierarchyReady = y.OnHierarchyReady, h.HasParent = y.HasParent, h.HasChildren = y.HasChildren, h.PickParent = y.PickParent, h.PickChildren = y.PickChildren, h.PickNthChild = y.PickNthChild, h.CompareChildCount = y.CompareChildCount, m.AddChild = y.AddChild, m.RemoveChild = y.RemoveChild, m.RemoveFromParent = y.RemoveFromParent, g.ParentUID = y.ParentUID, g.ChildCount = y.ChildCount, g.AllChildCount = y.AllChildCount), d && (m.SetMeshSize = y.SetMeshSize, m.SetMeshPoint = y.SetMeshPoint, g.MeshColumns = y.MeshColumns, g.MeshRows = y.MeshRows), u && (h.IsVisible = y.IsVisible, m.SetVisible = y.SetElementVisible, m.SetCSSStyle = y.SetElementCSSStyle, m.SetElemAttribute = y.SetElementAttribute, m.RemoveElemAttribute = y.RemoveElementAttribute), S && (h.IsFocused = y.IsElementFocused, m.SetFocus = y.SetElementFocus, m.SetBlur = y.SetElementBlur), f && (h.IsEnabled = y.IsElementEnabled, m.SetEnabled = y.SetElementEnabled), I && (h.OnCollision = y.OnCollision, h.IsOverlapping = y.IsOverlapping, h.IsOverlappingOffset = y.IsOverlappingOffset, e.FinishCollisionCondition = FinishCollisionCondition), o || (h.CompareInstanceVar = y.CompareInstanceVar, h.IsBoolInstanceVarSet = y.IsBoolInstanceVarSet, h.PickInstVarHiLow = y.PickInstVarHiLow, h.PickByUID = y.PickByUID, h.HasTags = y.HasTags, m.SetInstanceVar = y.SetInstanceVar, m.AddInstanceVar = y.AddInstanceVar, m.SubInstanceVar = y.SubInstanceVar, m.SetBoolInstanceVar = y.SetBoolInstanceVar, m.ToggleBoolInstanceVar = y.ToggleBoolInstanceVar, m.ChangeTags = y.ChangeTags, h.OnCreated = y.OnCreated, h.OnDestroyed = y.OnDestroyed, m.Destroy = y.Destroy, m.LoadFromJsonString || (m.LoadFromJsonString = y.LoadFromJsonString), g.AsJSON || (g.AsJSON = y.AsJSON), g.Count = y.Count, g.PickedCount = y.PickedCount, g.IID = y.GetIID, g.UID = y.GetUID, g.ObjectTypeName = y.ObjectTypeName, g.Tags = y.Tags, g.TagsCount = y.TagsCount, g.TagAt = y.TagAt, h.OnInstanceSignal = y.OnInstanceSignal, m.InstanceSignal = y.InstanceSignal, m.InstanceWaitForSignal = y.InstanceWaitForSignal), C && (g.TemplateName = y.TemplateName);\n  };\n}\nvar GetInst2;\nvar GetWorldInfo2;\nvar GetInst_SDKv22;\nvar GetWorldInfo_SDKv22;\nvar GetObjectClass2;\nvar GetLayer2;\nvar CollMemory_Add2;\nvar CollMemory_Remove2;\nvar CollMemory_RemoveInstance2;\nvar CollMemory_Get2;\nvar DoOverlapCondition2;\nvar FinishCollisionConditionPicking2;\nvar FinishCollisionCondition2;\nvar PickByUID_Normal2;\nvar PickByUID_Inverted2;\n{\n  const C32 = self.C3;\n  C32.ScheduledWait = class extends C32.DefendedBase {\n    constructor(t) {\n      super(), this._eventSheetManager = t, this._type = \"\", this._time = -1, this._signalTag = \"\", this._isSignalled = false, this._event = null, this._actIndex = 0, this._solModifiers = [], this._dynamicSolModifiers = null, this._sols = /* @__PURE__ */ new Map(), this._pendingInstances = null, this._callingFunctionBlock = null, this._asyncId = -1, this._functionParameters = null, this._functionInnerLocalVars = null, this._shouldRelease = false;\n    }\n    Release() {\n      this._type = \"\", this._time = -1, this._signalTag = \"\", this._event = null, this._callingFunctionBlock = null, this._functionParameters = null, this._functionInnerLocalVars = null, this._asyncId = -1, C32.clearArray(this._solModifiers), this._dynamicSolModifiers && (this._dynamicSolModifiers.clear(), this._dynamicSolModifiers = null);\n      for (const t of this._sols.values()) t.Release();\n      this._sols.clear(), this._pendingInstances = null;\n    }\n    _Init() {\n      const t = this._eventSheetManager, e = t.GetRuntime().GetAllObjectClasses(), s = t.GetCurrentEventStackFrame(), i = (this._event = s.GetCurrentEvent(), this._actIndex = s.GetActionIndex() + 1, t.FindFirstFunctionBlockParent(this._event));\n      i && (this._callingFunctionBlock = i, this._functionParameters = i.CaptureFunctionParameters(), this._functionInnerLocalVars = i._GetAllInnerLocalVariables().map((t2) => t2.GetValue()), i.IsAsync()) && (this._asyncId = i.PauseCurrentAsyncFunction());\n      for (const a of e) {\n        const l = a.GetCurrentSol();\n        l.IsSelectAll() && !this._event.HasSolModifier(a) || (this._solModifiers.push(a), this._sols.set(a, C32.New(C32.SolState, l)));\n      }\n      const n = t.GetDynamicSolModifiersSet();\n      this._dynamicSolModifiers = 0 < n.size ? n : null;\n    }\n    InitTimer(t) {\n      this._type = \"timer\", this._Init(), this._time = this._eventSheetManager.GetRuntime().GetGameTime() + t;\n    }\n    InitWallTimer(t) {\n      this._type = \"walltimer\", this._Init(), this._time = this._eventSheetManager.GetRuntime().GetWallTime() + t;\n    }\n    InitSignal(t) {\n      this._type = \"signal\", this._Init(), this._signalTag = t.toLowerCase();\n    }\n    InitInstanceSignals(t, e) {\n      this._type = \"instance-signals\", this._Init(), this._signalTag = e.toLowerCase(), this._pendingInstances = new Set(t);\n    }\n    InitPromise(t) {\n      this._type = \"promise\", this._Init(), t.then(() => this.SetSignalled()).catch((t2) => {\n        console.warn(\"[C3 runtime] Promise rejected in 'Wait for previous actions to complete': \", t2), this.SetSignalled();\n      });\n    }\n    IsTimer() {\n      return \"timer\" === this._type;\n    }\n    IsWallTimer() {\n      return \"walltimer\" === this._type;\n    }\n    IsSignal() {\n      return \"signal\" === this._type;\n    }\n    IsInstanceSignals() {\n      return \"instance-signals\" === this._type;\n    }\n    IsPromise() {\n      return \"promise\" === this._type;\n    }\n    GetSignalTag() {\n      return this._signalTag;\n    }\n    IsSignalled() {\n      return this._isSignalled;\n    }\n    SetSignalled() {\n      this._isSignalled = true;\n    }\n    SetInstanceSignalled(t) {\n      this._pendingInstances.delete(t), 0 === this._pendingInstances.size && this.SetSignalled();\n    }\n    _ShouldRun() {\n      return this.IsTimer() ? this._time <= this._eventSheetManager.GetRuntime().GetGameTime() : this.IsWallTimer() ? this._time <= this._eventSheetManager.GetRuntime().GetWallTime() : this.IsSignalled();\n    }\n    _RestoreState(t) {\n      t._Restore(this._event, this._actIndex);\n      for (const [s, i] of this._sols.entries()) {\n        const n = s.GetCurrentSol();\n        i._Restore(n);\n      }\n      this._dynamicSolModifiers && t.SetDynamicSolModifiers([...this._dynamicSolModifiers]);\n      const e = this._callingFunctionBlock;\n      e && (e.SetFunctionParameters(this._functionParameters), e._GetAllInnerLocalVariables().map((t2, e2) => t2.SetValue(this._functionInnerLocalVars[e2])), e.IsAsync()) && e.ResumeAsyncFunction(this._asyncId);\n    }\n    _Run(t) {\n      this._RestoreState(t), this._event._ResumeActionsAndSubEvents(t), this._callingFunctionBlock && this._callingFunctionBlock.IsAsync() && this._callingFunctionBlock.MaybeFinishAsyncFunctionCall(this._asyncId), this._eventSheetManager.ClearSol(this._solModifiers), this._shouldRelease = true;\n    }\n    async _DebugRun(t) {\n      this._RestoreState(t);\n      for (const e of this._event._DebugResumeActionsAndSubEvents(t)) await this._eventSheetManager.GetRuntime().DebugBreak(e);\n      this._callingFunctionBlock && this._callingFunctionBlock.IsAsync() && this._callingFunctionBlock.MaybeFinishAsyncFunctionCall(this._asyncId), this._eventSheetManager.ClearSol(this._solModifiers), this._shouldRelease = true;\n    }\n    ShouldRelease() {\n      return this._shouldRelease;\n    }\n    RemoveInstances(t) {\n      for (const e of this._sols.values()) e.RemoveInstances(t);\n      if (\"instance-signals\" === this._type) {\n        for (const s of t) this._pendingInstances.delete(s);\n        0 === this._pendingInstances.size && this.SetSignalled();\n      }\n    }\n    _SaveToJson() {\n      const t = {}, e = { \"wt\": this._type, \"t\": this._time, \"st\": this._signalTag, \"s\": this._isSignalled, \"ev\": this._event.GetSID(), \"sm\": this._solModifiers.map((t2) => t2.GetSID()), \"dsm\": this._dynamicSolModifiers ? [...this._dynamicSolModifiers].map((t2) => t2.GetSID()) : null, \"sols\": t };\n      this._event._HasActionIndex(this._actIndex) && (e[\"act\"] = this._event.GetActionAt(this._actIndex).GetSID());\n      for (const [s, i] of this._sols) t[s.GetSID().toString()] = i._SaveToJson();\n      return \"instance-signals\" === this._type && (e[\"pi\"] = [...this._pendingInstances].map((t2) => t2.GetUID())), e;\n    }\n    static _CreateFromJson(t, e) {\n      const s = t.GetRuntime(), i = t.GetEventBlockBySID(e[\"ev\"]);\n      if (!i) return null;\n      let n = 0;\n      if (e.hasOwnProperty(\"act\")) {\n        const l = t.GetActionBySID(e[\"act\"]);\n        if (!l) return null;\n        n = l.GetIndex();\n      }\n      const a = C32.New(C32.ScheduledWait, t);\n      a._time = e[\"t\"], e.hasOwnProperty(\"wt\") ? a._type = e[\"wt\"] : a._type = -1 === a._time ? \"signal\" : \"timer\", a._signalTag = e[\"st\"], a._isSignalled = e[\"s\"], a._event = i, a._actIndex = n;\n      for (const o of e[\"sm\"]) {\n        const c = s.GetObjectClassBySID(o);\n        c && a._solModifiers.push(c);\n      }\n      if (Array.isArray(e[\"dsm\"])) for (const r of e[\"dsm\"]) {\n        const h = s.GetObjectClassBySID(r);\n        h && (a._dynamicSolModifiers || (a._dynamicSolModifiers = /* @__PURE__ */ new Set()), a._dynamicSolModifiers.add(h));\n      }\n      for (const [_, d] of Object.entries(e[\"sols\"])) {\n        const u = parseInt(_, 10), S = s.GetObjectClassBySID(u);\n        if (S) {\n          const m = C32.New(C32.SolState, null);\n          m._LoadFromJson(t, d), a._sols.set(S, m);\n        }\n      }\n      if (\"instance-signals\" === a._type) {\n        a._pendingInstances = /* @__PURE__ */ new Set();\n        for (const I of e[\"pi\"]) {\n          const g = s.GetInstanceByUID(I);\n          g && a._pendingInstances.add(g);\n        }\n      }\n      return a;\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.SolState = class extends C32.DefendedBase {\n    constructor(s) {\n      super(), this._objectClass = null, this._isSelectAll = true, this._instances = [], s && (this._objectClass = s.GetObjectClass(), this._isSelectAll = s.IsSelectAll(), C32.shallowAssignArray(this._instances, s._GetOwnInstances()));\n    }\n    Release() {\n      this._objectClass = null, C32.clearArray(this._instances);\n    }\n    _Restore(s) {\n      s._SetSelectAll(this._isSelectAll), C32.shallowAssignArray(s._GetOwnInstances(), this._instances);\n    }\n    RemoveInstances(s) {\n      C32.arrayRemoveAllInSet(this._instances, s);\n    }\n    _SaveToJson() {\n      return { \"sa\": this._isSelectAll, \"insts\": this._instances.map((s) => s.GetUID()) };\n    }\n    _LoadFromJson(s, e) {\n      const t = s.GetRuntime();\n      this._isSelectAll = !!e[\"sa\"], C32.clearArray(this._instances);\n      for (const n of e[\"insts\"]) {\n        const l = t.GetInstanceByUID(n);\n        l && this._instances.push(l);\n      }\n    }\n  };\n}\n{\n  let GetNextParamMap = function(e, t) {\n    let s = e.get(t);\n    return s || (s = /* @__PURE__ */ new Map(), e.set(t, s)), s;\n  };\n  GetNextParamMap2 = GetNextParamMap;\n  const C32 = self.C3;\n  C32.SDKPluginBase = class extends C32.DefendedBase {\n    constructor(e) {\n      super(), this._runtime = e.runtime, this._name = e.name ?? \"\", this._isSingleGlobal = !!e.isSingleGlobal, this._isWorldType = !!e.isWorld, this._isRotatable = !!e.isRotatable, this._mustPredraw = !!e.mustPredraw, this._hasEffects = !!e.hasEffects, this._supportsSceneGraph = !!e.supportsSceneGraph, this._supportsMesh = !!e.supportsMesh, this._isHTMLElementType = !!e.isHTMLElementType, this._is3d = !!e.is3d, this._sdkVersion = e.sdkVersion, this._singleGlobalObjectClass = null, this._boundACEMethodCache = /* @__PURE__ */ new Map(), this._boundACEMethodCache_1param = /* @__PURE__ */ new Map(), this._boundACEMethodCache_2params = /* @__PURE__ */ new Map(), this._boundACEMethodCache_3params = /* @__PURE__ */ new Map(), this._scriptInterfaceClass = e.scriptInterfaceClass, this._iPlugin = null;\n    }\n    Release() {\n      this._runtime = null;\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetName() {\n      return this._name;\n    }\n    OnCreate() {\n    }\n    GetConstructor() {\n      return (2 <= this.GetSdkVersion() ? this._iPlugin : this).constructor;\n    }\n    GetSdkVersion() {\n      return this._sdkVersion;\n    }\n    GetScriptInterfaceClass(e = false) {\n      let t = this._scriptInterfaceClass;\n      return t = e && \"function\" != typeof t && 2 <= this.GetSdkVersion() ? globalThis.ISDKPluginBase : t;\n    }\n    IsSingleGlobal() {\n      return this._isSingleGlobal;\n    }\n    IsWorldType() {\n      return this._isWorldType;\n    }\n    IsHTMLElementType() {\n      return this._isHTMLElementType;\n    }\n    Is3D() {\n      return this._is3d;\n    }\n    IsRotatable() {\n      return this._isRotatable;\n    }\n    MustPreDraw() {\n      return this._mustPredraw;\n    }\n    HasEffects() {\n      return this._hasEffects;\n    }\n    SupportsSceneGraph() {\n      return this._supportsSceneGraph;\n    }\n    SupportsMesh() {\n      return this._supportsMesh;\n    }\n    _GetBoundACEMethod(e, t) {\n      if (!t) throw new Error(\"missing 'this' binding\");\n      let s = this._boundACEMethodCache.get(e);\n      return s || (s = e.bind(t), this._boundACEMethodCache.set(e, s)), s;\n    }\n    _GetBoundACEMethod_1param(e, t, s) {\n      if (!t) throw new Error(\"missing 'this' binding\");\n      const i = GetNextParamMap(this._boundACEMethodCache_1param, e);\n      let n = i.get(s);\n      return n || (n = e.bind(t, s), i.set(s, n)), n;\n    }\n    _GetBoundACEMethod_2params(e, t, s, i) {\n      if (!t) throw new Error(\"missing 'this' binding\");\n      const n = GetNextParamMap(this._boundACEMethodCache_2params, e), r = GetNextParamMap(n, s);\n      let a = r.get(i);\n      return a || (a = e.bind(t, s, i), r.set(i, a)), a;\n    }\n    _GetBoundACEMethod_3params(e, t, s, i, n) {\n      if (!t) throw new Error(\"missing 'this' binding\");\n      const r = GetNextParamMap(this._boundACEMethodCache_3params, e), a = GetNextParamMap(r, s), l = GetNextParamMap(a, i);\n      let o = l.get(n);\n      return o || (o = e.bind(t, s, i, n), l.set(n, o)), o;\n    }\n    _SetSingleGlobalObjectClass(e) {\n      if (!this.IsSingleGlobal()) throw new Error(\"must be single-global plugin\");\n      this._singleGlobalObjectClass = e;\n    }\n    GetSingleGlobalObjectClass() {\n      if (this.IsSingleGlobal()) return this._singleGlobalObjectClass;\n      throw new Error(\"must be single-global plugin\");\n    }\n    GetSingleGlobalInstance() {\n      if (this.IsSingleGlobal()) return this._singleGlobalObjectClass.GetSingleGlobalInstance();\n      throw new Error(\"must be single-global plugin\");\n    }\n    _InitScriptInterface() {\n      const e = this.GetSdkVersion(), t = (C32.AddonManager._PushInitObject(this, e), this.GetScriptInterfaceClass(true));\n      if (t) {\n        if (this._iPlugin = new t(), !(this._iPlugin instanceof self.IPlugin)) throw new TypeError(\"plugin class must derive from IPlugin\");\n      } else this._iPlugin = new self.IPlugin();\n      C32.AddonManager._PopInitObject(e);\n    }\n    GetIPlugin() {\n      return this._iPlugin;\n    }\n  };\n}\nvar GetNextParamMap2;\n{\n  const C32 = self.C3;\n  C32.SDKDOMPluginBase = class extends C32.SDKPluginBase {\n    constructor(e, s) {\n      super(e), this._domComponentId = s, this._nextElementId = 0, this._instMap = /* @__PURE__ */ new Map(), this.AddElementMessageHandler(\"elem-focused\", (e2) => e2._OnElemFocused()), this.AddElementMessageHandler(\"elem-blurred\", (e2) => {\n        e2 && e2._OnElemBlurred();\n      });\n    }\n    Release() {\n      super.Release();\n    }\n    _AddElement(e) {\n      const s = this._nextElementId++;\n      return this._instMap.set(s, e), s;\n    }\n    _RemoveElement(e) {\n      this._instMap.delete(e);\n    }\n    AddElementMessageHandler(e, t) {\n      this._runtime.AddDOMComponentMessageHandler(this._domComponentId, e, (e2) => {\n        const s = this._instMap.get(e2[\"elementId\"]);\n        t(s, e2);\n      });\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.SDKTypeBase = class extends C32.DefendedBase {\n    constructor(e) {\n      super(), this._objectClass = e, this._runtime = e.GetRuntime(), this._plugin = e.GetPlugin();\n    }\n    Release() {\n      this._objectClass = null, this._runtime = null, this._plugin = null;\n    }\n    GetObjectClass() {\n      return this._objectClass;\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetPlugin() {\n      return this._plugin;\n    }\n    GetImageInfo() {\n      return this._objectClass.GetImageInfo();\n    }\n    OnCreate() {\n    }\n    FinishCondition(e) {\n    }\n    BeforeRunAction(e) {\n    }\n    AfterRunAction(e) {\n    }\n    LoadTextures(e) {\n    }\n    ReleaseTextures() {\n    }\n    OnDynamicTextureLoadComplete() {\n    }\n    PreloadTexturesWithInstances(e) {\n    }\n    LoadTilemapData() {\n    }\n    GetScriptInterfaceClass() {\n      return null;\n    }\n    DispatchScriptEvent(e, t, s) {\n      const n = C32.New(C32.Event, e, t);\n      n.objectClass = this, s && Object.assign(n, s), this.GetObjectClass().DispatchUserScriptEvent(n);\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.SDKInstanceBase = class extends C32.DefendedBase {\n    constructor(e, t) {\n      super(), this._inst = e, this._domComponentId = t, this._wrapperComponentId = null, this._runtime = e.GetRuntime(), this._objectClass = this._inst.GetObjectClass(), this._sdkType = this._objectClass.GetSdkType(), this._tickFunc = null, this._tick2Func = null, this._isTicking = false, this._isTicking2 = false, this._disposables = null, this._wasReleased = false;\n    }\n    Release() {\n      this._wasReleased = true, this._StopTicking(), this._StopTicking2(), this._tickFunc = null, this._tick2Func = null, this._disposables && (this._disposables.Release(), this._disposables = null), this._inst = null, this._runtime = null, this._objectClass = null, this._sdkType = null;\n    }\n    WasReleased() {\n      return this._wasReleased;\n    }\n    GetInstance() {\n      return this._inst;\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetObjectClass() {\n      return this._objectClass;\n    }\n    GetPlugin() {\n      return this._sdkType.GetPlugin();\n    }\n    GetSdkType() {\n      return this._sdkType;\n    }\n    GetScriptInterface() {\n      return this._inst.GetInterfaceClass();\n    }\n    Trigger(e) {\n      return this._runtime.Trigger(e, this._inst, null);\n    }\n    DebugTrigger(e) {\n      return this._runtime.DebugTrigger(e, this._inst, null);\n    }\n    TriggerAsync(e) {\n      return this._runtime.TriggerAsync(e, this._inst, null);\n    }\n    FastTrigger(e, t) {\n      return this._runtime.FastTrigger(e, this._inst, t);\n    }\n    DebugFastTrigger(e, t) {\n      return this._runtime.DebugFastTrigger(e, this._inst, t);\n    }\n    ScheduleTriggers(e) {\n      return this._runtime.ScheduleTriggers(e);\n    }\n    AddDOMMessageHandler(e, t) {\n      this._runtime.AddDOMComponentMessageHandler(this._domComponentId, e, t);\n    }\n    AddDOMMessageHandlers(e) {\n      for (const [t, i] of e) this.AddDOMMessageHandler(t, i);\n    }\n    PostToDOM(e, t) {\n      this._runtime.PostComponentMessageToDOM(this._domComponentId, e, t);\n    }\n    PostToDOMAsync(e, t) {\n      return this._runtime.PostComponentMessageToDOMAsync(this._domComponentId, e, t);\n    }\n    _PostToDOMMaybeSync(e, t) {\n      if (!this._runtime.IsInWorker()) return window[\"c3_runtimeInterface\"][\"_OnMessageFromRuntime\"]({ \"type\": \"event\", \"component\": this._domComponentId, \"handler\": e, \"data\": t, \"responseId\": null });\n      this.PostToDOM(e, t);\n    }\n    SetWrapperExtensionComponentId(e) {\n      if (!e) throw new Error(\"cannot set empty component id\");\n      this._wrapperComponentId = e;\n    }\n    IsWrapperExtensionAvailable() {\n      if (this._wrapperComponentId) return this._runtime.HasWrapperComponentId(this._wrapperComponentId);\n      throw new Error(\"wrapper extension component id not set\");\n    }\n    AddWrapperExtensionMessageHandler(e, t) {\n      if (!this._wrapperComponentId) throw new Error(\"wrapper extension component id not set\");\n      this._runtime.AddWrapperExtensionMessageHandler(this._wrapperComponentId, e, t);\n    }\n    AddWrapperExtensionMessageHandlers(e) {\n      for (const [t, i] of e) this.AddWrapperExtensionMessageHandler(t, i);\n    }\n    SendWrapperExtensionMessage(e, t) {\n      if (!this._wrapperComponentId) throw new Error(\"wrapper extension component id not set\");\n      this._runtime.SendWrapperExtensionMessage(this._wrapperComponentId, e, t);\n    }\n    SendWrapperExtensionMessageAsync(e, t) {\n      if (this._wrapperComponentId) return this._runtime.SendWrapperExtensionMessageAsync(this._wrapperComponentId, e, t);\n      throw new Error(\"wrapper extension component id not set\");\n    }\n    Tick() {\n    }\n    Tick2() {\n    }\n    _StartTicking() {\n      if (!this._isTicking) {\n        if (!this._tickFunc) if (this._runtime.IsDebug()) {\n          const t = globalThis.C3Debugger, i = this.GetPlugin();\n          this._tickFunc = () => {\n            const e = performance.now();\n            this.Tick(), t.AddIndividualPluginTickTime(i, performance.now() - e);\n          };\n        } else this._tickFunc = () => this.Tick();\n        this._runtime.Dispatcher().addEventListener(\"tick\", this._tickFunc), this._isTicking = true;\n      }\n    }\n    _StopTicking() {\n      this._isTicking && (this._runtime.Dispatcher().removeEventListener(\"tick\", this._tickFunc), this._isTicking = false);\n    }\n    IsTicking() {\n      return this._isTicking;\n    }\n    _StartTicking2() {\n      if (!this._isTicking2) {\n        if (!this._tick2Func) if (this._runtime.IsDebug()) {\n          const t = globalThis.C3Debugger, i = this.GetPlugin();\n          this._tick2Func = () => {\n            const e = performance.now();\n            this.Tick2(), t.AddIndividualPluginTickTime(i, performance.now() - e);\n          };\n        } else this._tick2Func = () => this.Tick2();\n        this._runtime.Dispatcher().addEventListener(\"tick2\", this._tick2Func), this._isTicking2 = true;\n      }\n    }\n    _StopTicking2() {\n      this._isTicking2 && (this._runtime.Dispatcher().removeEventListener(\"tick2\", this._tick2Func), this._isTicking2 = false);\n    }\n    IsTicking2() {\n      return this._isTicking2;\n    }\n    GetDebuggerProperties() {\n      return [];\n    }\n    SaveToJson() {\n      return null;\n    }\n    LoadFromJson(e) {\n    }\n    GetPropertyValueByIndex(e) {\n    }\n    SetPropertyValueByIndex(e, t) {\n    }\n    OffsetPropertyValueByIndex(e, t, i) {\n      if (0 !== t) {\n        const n = this.GetPropertyValueByIndex(e);\n        if (\"number\" != typeof n) throw new Error(\"expected number\");\n        this.SetPropertyValueByIndex(e, n + t, i);\n      }\n    }\n    SetPropertyColorOffsetValueByIndex(e, t, i, n) {\n    }\n    CallAction(e, ...t) {\n      e.call(this, ...t);\n    }\n    CallExpression(e, ...t) {\n      return e.call(this, ...t);\n    }\n    GetScriptInterfaceClass() {\n      return null;\n    }\n    DispatchScriptEvent(e, t, i) {\n      if (this._inst.HasScriptInterface()) {\n        const n = this.GetScriptInterface(), s = C32.New(C32.Event, e, t);\n        s.instance = n, i && Object.assign(s, i), n.dispatchEvent(s);\n      }\n    }\n    MustPreDraw() {\n      return false;\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.SDKWorldInstanceBase = class extends C32.SDKInstanceBase {\n    constructor(e, t) {\n      super(e, t), this._worldInfo = e.GetWorldInfo(), this._renderercontextlost_handler = null, this._renderercontextrestored_handler = null;\n    }\n    Release() {\n      if (this._renderercontextlost_handler) {\n        const e = this._runtime.Dispatcher();\n        e.removeEventListener(\"renderercontextlost\", this._renderercontextlost_handler), e.removeEventListener(\"renderercontextrestored\", this._renderercontextrestored_handler), this._renderercontextlost_handler = null, this._renderercontextrestored_handler = null;\n      }\n      this._worldInfo = null, super.Release();\n    }\n    HandleWebGLContextLoss() {\n      this.HandleRendererContextLoss();\n    }\n    OnWebGLContextLost() {\n    }\n    OnWebGLContextRestored() {\n    }\n    HandleRendererContextLoss() {\n      if (!this._renderercontextlost_handler) {\n        this._renderercontextlost_handler = () => this.OnRendererContextLost(), this._renderercontextrestored_handler = () => this.OnRendererContextRestored();\n        const e = this._runtime.Dispatcher();\n        e.addEventListener(\"renderercontextlost\", this._renderercontextlost_handler), e.addEventListener(\"renderercontextrestored\", this._renderercontextrestored_handler);\n      }\n    }\n    OnRendererContextLost() {\n      this.OnWebGLContextLost();\n    }\n    OnRendererContextRestored() {\n      this.OnWebGLContextRestored();\n    }\n    GetWorldInfo() {\n      return this._worldInfo;\n    }\n    IsOriginalSizeKnown() {\n      return false;\n    }\n    GetOriginalWidth() {\n      if (!this.IsOriginalSizeKnown()) throw new Error(\"original size not known\");\n      const e = this.GetCurrentImageInfo();\n      if (e) return e.GetWidth();\n    }\n    GetOriginalHeight() {\n      if (!this.IsOriginalSizeKnown()) throw new Error(\"original size not known\");\n      const e = this.GetCurrentImageInfo();\n      if (e) return e.GetHeight();\n    }\n    GetCurrentImageInfo() {\n      return null;\n    }\n    GetCurrentSurfaceSize() {\n      const e = this.GetCurrentImageInfo();\n      if (e) {\n        const t = e.GetTexture();\n        if (t) return [t.GetWidth(), t.GetHeight()];\n      }\n      return [100, 100];\n    }\n    GetCurrentTexRect() {\n      const e = this.GetCurrentImageInfo();\n      return e ? e.GetTexRect() : null;\n    }\n    GetCurrentTexQuad() {\n      const e = this.GetCurrentImageInfo();\n      return e ? e.GetTexQuad() : null;\n    }\n    IsCurrentTexRotated() {\n      const e = this.GetCurrentImageInfo();\n      return !!e && e.IsRotated();\n    }\n    GetImagePoint(e) {\n      const t = this._inst.GetWorldInfo();\n      return [t.GetX(), t.GetY(), t.GetTotalZElevation()];\n    }\n    LoadTilemapData(e, t, r) {\n    }\n    TestPointOverlapTile(e, t) {\n    }\n    RendersToOwnZPlane() {\n      return true;\n    }\n  };\n}\n{\n  const C32 = self.C3, tempRect = C32.New(C32.Rect);\n  C32.SDKDOMInstanceBase = class extends C32.SDKWorldInstanceBase {\n    constructor(e, t) {\n      super(e, t), this._elementId = this.GetPlugin()._AddElement(this), this._isElementShowing = true, this._elemHasFocus = false, this._autoFontSize = false, this._autoFontSizeOffset = -0.2, this._lastRect = C32.New(C32.Rect, 0, 0, -1, -1);\n      const s = this._runtime.GetCanvasManager();\n      this._lastWindowWidth = s.GetLastWidth(), this._lastWindowHeight = s.GetLastHeight(), this._lastHTMLIndex = -1, this._lastHTMLZIndex = -1, this._isPendingUpdateState = false, this._StartTicking();\n    }\n    Release() {\n      this.GetPlugin()._RemoveElement(this._elementId), this.PostToDOMElement(\"destroy\"), this._elementId = -1, super.Release();\n    }\n    _GetElementInDOMMode() {\n      if (this._runtime.IsInWorker()) throw new Error(\"not valid in worker mode\");\n      return this._PostToDOMElementMaybeSync(\"get-element\");\n    }\n    PostToDOMElement(e, t) {\n      (t = t || {})[\"elementId\"] = this._elementId, this.PostToDOM(e, t);\n    }\n    _PostToDOMElementMaybeSync(e, t) {\n      return (t = t || {})[\"elementId\"] = this._elementId, this._PostToDOMMaybeSync(e, t);\n    }\n    PostToDOMElementAsync(e, t) {\n      return (t = t || {})[\"elementId\"] = this._elementId, this.PostToDOMAsync(e, t);\n    }\n    CreateElement(e) {\n      e = e || {};\n      const t = this.GetWorldInfo();\n      e[\"elementId\"] = this._elementId, e[\"isVisible\"] = t.IsVisible(), e[\"htmlIndex\"] = t.GetLayer().GetHTMLIndex(), e[\"htmlZIndex\"] = t.GetHTMLZIndex(), Object.assign(e, this.GetElementState()), this._isElementShowing = !!e[\"isVisible\"], this._PostToDOMMaybeSync(\"create\", e), this._UpdatePosition(true);\n    }\n    SetElementVisible(e) {\n      this._isElementShowing !== (e = !!e) && (this._isElementShowing = e, this.PostToDOMElement(\"set-visible\", { \"isVisible\": e }));\n    }\n    Tick() {\n      this._UpdatePosition(false);\n    }\n    _ShouldPreserveElement() {\n      const e = this._runtime.GetCanvasManager().GetFullscreenMode();\n      return \"Android\" === C32.Platform.OS && (\"scale-inner\" === e || \"scale-outer\" === e || \"crop\" === e);\n    }\n    _UpdatePosition(n) {\n      if (!this.GetInstance().IsDestroyed()) {\n        const l = this.GetWorldInfo(), o = l.GetLayer(), h = l.GetBoundingBox();\n        let [e, t] = o.LayerToCanvasCss(h.getLeft(), h.getTop()), [s, i] = o.LayerToCanvasCss(h.getRight(), h.getBottom());\n        const a = this._runtime.GetCanvasManager(), m = a.GetCssWidth(), d = a.GetCssHeight();\n        if (l.IsVisible() && o.IsVisible()) if (!this._ShouldPreserveElement() && (s <= 0 || i <= 0 || m <= e || d <= t)) this.SetElementVisible(false);\n        else {\n          tempRect.set(e, t, s, i);\n          const r = a.GetLastWidth(), _ = a.GetLastHeight(), c = o.GetHTMLIndex(), u = l.GetHTMLZIndex();\n          if (!n && tempRect.equals(this._lastRect) && this._lastWindowWidth === r && this._lastWindowHeight === _ && this._lastHTMLIndex === c && this._lastHTMLZIndex === u) this.SetElementVisible(true);\n          else {\n            this._lastRect.copy(tempRect), this._lastWindowWidth = r, this._lastWindowHeight = _, this._lastHTMLIndex = c, this._lastHTMLZIndex = u, this.SetElementVisible(true);\n            let e2 = null;\n            this._autoFontSize && (e2 = o.GetDisplayScale() + this._autoFontSizeOffset), this.PostToDOMElement(\"update-position\", { \"left\": Math.round(this._lastRect.getLeft()), \"top\": Math.round(this._lastRect.getTop()), \"width\": Math.round(this._lastRect.width()), \"height\": Math.round(this._lastRect.height()), \"htmlIndex\": c, \"htmlZIndex\": u, \"fontSize\": e2 });\n          }\n        }\n        else this.SetElementVisible(false);\n      }\n    }\n    FocusElement() {\n      this._PostToDOMElementMaybeSync(\"focus\", { \"focus\": true });\n    }\n    BlurElement() {\n      this._PostToDOMElementMaybeSync(\"focus\", { \"focus\": false });\n    }\n    _OnElemFocused() {\n      this._elemHasFocus = true;\n    }\n    _OnElemBlurred() {\n      this._elemHasFocus = false;\n    }\n    IsElementFocused() {\n      return this._elemHasFocus;\n    }\n    SetElementCSSStyle(e, t) {\n      this.PostToDOMElement(\"set-css-style\", { \"prop\": C32.CSSToCamelCase(e), \"val\": t });\n    }\n    SetElementAttribute(e, t) {\n      this.PostToDOMElement(\"set-attribute\", { \"name\": e, \"val\": t });\n    }\n    RemoveElementAttribute(e) {\n      this.PostToDOMElement(\"remove-attribute\", { \"name\": e });\n    }\n    UpdateElementState() {\n      this._isPendingUpdateState || (this._isPendingUpdateState = true, Promise.resolve().then(() => {\n        this._isPendingUpdateState = false, this.PostToDOMElement(\"update-state\", this.GetElementState());\n      }));\n    }\n    GetElementState() {\n    }\n    GetElementId() {\n      return this._elementId;\n    }\n  };\n}\n{\n  const C32 = self.C3, IBehavior = self.IBehavior;\n  C32.SDKBehaviorBase = class extends C32.DefendedBase {\n    constructor(e) {\n      super(), this._runtime = e.runtime, this._name = e.name ?? \"\", this._myObjectClasses = C32.New(C32.ArraySet), this._myInstances = C32.New(C32.ArraySet), this._sdkVersion = e.sdkVersion, this._scriptInterfaceClass = e.scriptInterfaceClass, this._iBehavior = null;\n    }\n    Release() {\n      this._myInstances.Release(), this._myObjectClasses.Release(), this._runtime = null;\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetName() {\n      return this._name;\n    }\n    OnCreate() {\n    }\n    GetSdkVersion() {\n      return this._sdkVersion;\n    }\n    GetScriptInterfaceClass(e = false) {\n      let s = this._scriptInterfaceClass;\n      return s = e && \"function\" != typeof s && 2 <= this.GetSdkVersion() ? globalThis.ISDKBehaviorBase : s;\n    }\n    _AddObjectClass(e) {\n      this._myObjectClasses.Add(e);\n    }\n    GetObjectClasses() {\n      return this._myObjectClasses.GetArray();\n    }\n    _AddInstance(e) {\n      this._myInstances.Add(e);\n    }\n    _RemoveInstance(e) {\n      this._myInstances.Delete(e);\n    }\n    GetInstances() {\n      return this._myInstances.GetArray();\n    }\n    _InitScriptInterface() {\n      const e = this.GetSdkVersion(), s = (C32.AddonManager._PushInitObject(this, e), this.GetScriptInterfaceClass(true));\n      if (s) {\n        if (this._iBehavior = new s(), !(this._iBehavior instanceof IBehavior)) throw new TypeError(\"behavior class must derive from IBehavior\");\n      } else this._iBehavior = new IBehavior();\n      C32.AddonManager._PopInitObject(e);\n    }\n    GetIBehavior() {\n      return this._iBehavior;\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.SDKBehaviorTypeBase = class extends C32.DefendedBase {\n    constructor(e) {\n      super(), this._runtime = e.GetRuntime(), this._behaviorType = e, this._objectClass = e.GetObjectClass(), this._behavior = e.GetBehavior(), this._behavior._AddObjectClass(this._objectClass);\n    }\n    Release() {\n      this._runtime = null, this._behaviorType = null, this._objectClass = null, this._behavior = null;\n    }\n    OnCreate() {\n    }\n    GetBehaviorType() {\n      return this._behaviorType;\n    }\n    GetObjectClass() {\n      return this._objectClass;\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetBehavior() {\n      return this._behavior;\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.SDKBehaviorInstanceBase = class extends C32.DefendedBase {\n    constructor(t, i) {\n      super(), this._behInst = t, this._domComponentId = i, this._inst = t.GetObjectInstance(), this._runtime = t.GetRuntime(), this._behaviorType = t.GetBehaviorType(), this._sdkType = this._behaviorType.GetSdkType(), this._isTicking = false, this._isTicking2 = false, this._isPostTicking = false, this._disposables = null;\n    }\n    Release() {\n      this._StopTicking(), this._StopTicking2(), this._StopPostTicking(), this._disposables && (this._disposables.Release(), this._disposables = null), this._behInst = null, this._inst = null, this._runtime = null, this._behaviorType = null, this._sdkType = null;\n    }\n    GetBehavior() {\n      return this._behaviorType.GetBehavior();\n    }\n    GetBehaviorInstance() {\n      return this._behInst;\n    }\n    GetObjectInstance() {\n      return this._inst;\n    }\n    GetObjectClass() {\n      return this._inst.GetObjectClass();\n    }\n    GetWorldInfo() {\n      return this._inst.GetWorldInfo();\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetBehaviorType() {\n      return this._behaviorType;\n    }\n    GetSdkType() {\n      return this._sdkType;\n    }\n    GetScriptInterface() {\n      return this._behInst.GetScriptInterface();\n    }\n    Trigger(t) {\n      return this._runtime.Trigger(t, this._inst, this._behaviorType);\n    }\n    DebugTrigger(t) {\n      return this._runtime.DebugTrigger(t, this._inst, this._behaviorType);\n    }\n    TriggerAsync(t) {\n      return this._runtime.TriggerAsync(t, this._inst, this._behaviorType);\n    }\n    PostCreate() {\n    }\n    Tick() {\n    }\n    Tick2() {\n    }\n    PostTick() {\n    }\n    _StartTicking() {\n      this._isTicking || (this._runtime._AddBehInstToTick(this), this._isTicking = true);\n    }\n    _StopTicking() {\n      this._isTicking && (this._runtime._RemoveBehInstToTick(this), this._isTicking = false);\n    }\n    IsTicking() {\n      return this._isTicking;\n    }\n    _StartTicking2() {\n      this._isTicking2 || (this._runtime._AddBehInstToTick2(this), this._isTicking2 = true);\n    }\n    _StopTicking2() {\n      this._isTicking2 && (this._runtime._RemoveBehInstToTick2(this), this._isTicking2 = false);\n    }\n    IsTicking2() {\n      return this._isTicking2;\n    }\n    _StartPostTicking() {\n      this._isPostTicking || (this._runtime._AddBehInstToPostTick(this), this._isPostTicking = true);\n    }\n    _StopPostTicking() {\n      this._isPostTicking && (this._runtime._RemoveBehInstToPostTick(this), this._isPostTicking = false);\n    }\n    IsPostTicking() {\n      return this._isPostTicking;\n    }\n    GetDebuggerProperties() {\n      return [];\n    }\n    AddDOMMessageHandler(t, i) {\n      this._runtime.AddDOMComponentMessageHandler(this._domComponentId, t, i);\n    }\n    OnSpriteFrameChanged(t, i) {\n    }\n    SaveToJson() {\n      return null;\n    }\n    LoadFromJson(t) {\n    }\n    GetPropertyValueByIndex(t) {\n    }\n    SetPropertyValueByIndex(t, i) {\n    }\n    OffsetPropertyValueByIndex(t, i) {\n      if (0 !== i) {\n        const e = this.GetPropertyValueByIndex(t);\n        if (\"number\" != typeof e) throw new Error(\"expected number\");\n        this.SetPropertyValueByIndex(t, e + i);\n      }\n    }\n    SetPropertyColorOffsetValueByIndex(t, i, e, s) {\n    }\n    CallAction(t, ...i) {\n      t.call(this, ...i);\n    }\n    CallExpression(t, ...i) {\n      return t.call(this, ...i);\n    }\n    GetScriptInterfaceClass() {\n      return null;\n    }\n    DispatchScriptEvent(t, i, e) {\n      if (this._behInst.HasScriptInterface()) {\n        const s = this.GetScriptInterface(), n = C32.New(C32.Event, t, i);\n        n.behaviorInstance = s, n.instance = s.instance, e && Object.assign(n, e), s.dispatchEvent(n);\n      }\n    }\n  };\n}\n{\n  let ValidateInternalAPIToken = function(t) {\n    if (t !== internalApiToken) throw new Error(\"invalid internal API token\");\n  };\n  ValidateInternalAPIToken2 = ValidateInternalAPIToken;\n  const C32 = self.C3, internalApiToken = (C32.Plugins = {}, C32.Behaviors = {}, C32._GetInternalAPIToken());\n  let initObjectStack = [], initObjectStack2 = [], initPropertiesStack = [], originalPushInitObject = null, originalPopInitObject = null, originalGetInitObject = null, originalGetInitObject2 = null;\n  const pluginsByCtor = /* @__PURE__ */ new Map(), behaviorsByCtor = /* @__PURE__ */ new Map();\n  C32.AddonManager = class extends C32.DefendedBase {\n    constructor(t, e) {\n      super(), this._runtime = t, this._allPlugins = [], this._systemPlugin = null, this._allBehaviors = [], this._delayCreateBehaviors = /* @__PURE__ */ new Map(), this._solidBehavior = null, this._jumpthruBehavior = null, this._wrapperComponentIds = new Set(e);\n    }\n    CreatePlugin(t) {\n      const e = t[19], i = this._runtime.GetObjectReference(t[0]);\n      if (!i) throw new Error(\"missing plugin\");\n      C32.AddCommonACEs(t, i, e);\n      const n = 2 <= e ? C32.SDKPluginBase : i, r = C32.New(n, { runtime: this._runtime, isSingleGlobal: t[1], isWorld: t[2], isRotatable: t[5], hasEffects: t[8], mustPredraw: t[9], supportsSceneGraph: t[13], supportsMesh: t[14], isHTMLElementType: t[17], is3d: t[18], sdkVersion: e, name: t[20], scriptInterfaceClass: 2 <= e ? i : null });\n      r.OnCreate(), this._allPlugins.push(r), pluginsByCtor.set(i, r);\n    }\n    CreateSystemPlugin() {\n      this._systemPlugin = C32.New(C32.Plugins.System, { runtime: this._runtime, isSingleGlobal: true }), this._systemPlugin.OnCreate();\n    }\n    CreateBehavior(t) {\n      const i = t[1], n = t[2], r = this._runtime.GetObjectReference(t[0]);\n      if (!r) throw new Error(\"missing behavior\");\n      this._delayCreateBehaviors.set(r, () => {\n        const t2 = 2 <= i ? C32.SDKBehaviorBase : r, e = C32.New(t2, { runtime: this._runtime, name: n, sdkVersion: i, scriptInterfaceClass: 2 <= i ? r : null });\n        e.OnCreate(), this._allBehaviors.push(e), behaviorsByCtor.set(r, e), !this._solidBehavior && C32.Behaviors.solid && e instanceof C32.Behaviors.solid ? this._solidBehavior = e : !this._jumpthruBehavior && C32.Behaviors.jumpthru && e instanceof C32.Behaviors.jumpthru && (this._jumpthruBehavior = e), e._InitScriptInterface();\n      });\n    }\n    _DelayCreateBehavior(t) {\n      const e = this._delayCreateBehaviors.get(t);\n      e && (e(), this._delayCreateBehaviors.delete(t));\n    }\n    static _PushInitObject(t, e = 1) {\n      if (C32.AddonManager._PushInitObject !== originalPushInitObject) throw new Error(\"invalid method\");\n      1 === e && initObjectStack.push(t), initObjectStack2.push(t);\n    }\n    static _PopInitObject(t = 1) {\n      if (C32.AddonManager._PopInitObject !== originalPopInitObject) throw new Error(\"invalid method\");\n      1 === t && initObjectStack.pop(), initObjectStack2.pop();\n    }\n    static _GetInitObject() {\n      if (C32.AddonManager._GetInitObject !== originalGetInitObject) throw new Error(\"invalid method\");\n      if (0 === initObjectStack.length) throw new Error(\"no init object set\");\n      return initObjectStack.at(-1);\n    }\n    static _GetInitObject2(t) {\n      if (C32.AddonManager._GetInitObject2 !== originalGetInitObject2) throw new Error(\"invalid method\");\n      if (ValidateInternalAPIToken(t), 0 === initObjectStack2.length) throw new Error(\"no init object set\");\n      return initObjectStack2.at(-1);\n    }\n    static _PushInitProperties(t) {\n      initPropertiesStack.push(t);\n    }\n    static _PopInitProperties() {\n      initPropertiesStack.pop();\n    }\n    static _GetInitProperties() {\n      if (0 === initPropertiesStack.length) throw new Error(\"no init properties set\");\n      return initPropertiesStack.at(-1);\n    }\n    _InitAddonScriptInterfaces() {\n      for (const t of this._allPlugins) t._InitScriptInterface();\n    }\n    static GetPluginByConstructorFunction(t) {\n      return pluginsByCtor.get(t) || null;\n    }\n    static GetBehaviorByConstructorFunction(t) {\n      return behaviorsByCtor.get(t) || null;\n    }\n    GetSystemPlugin() {\n      return this._systemPlugin;\n    }\n    GetSolidBehavior() {\n      return this._solidBehavior;\n    }\n    GetJumpthruBehavior() {\n      return this._jumpthruBehavior;\n    }\n    HasWrapperComponentId(t) {\n      return this._wrapperComponentIds.has(t);\n    }\n  }, originalPushInitObject = C32.AddonManager._PushInitObject, originalPopInitObject = C32.AddonManager._PopInitObject, originalGetInitObject = C32.AddonManager._GetInitObject, originalGetInitObject2 = C32.AddonManager._GetInitObject2;\n}\nvar ValidateInternalAPIToken2;\n{\n  const C32 = self.C3, allImageInfos = /* @__PURE__ */ new Set();\n  C32.ImageInfo = class extends C32.DefendedBase {\n    constructor() {\n      super(), this._generation = 0, this._url = \"\", this._size = 0, this._offsetX = 0, this._offsetY = 0, this._width = 0, this._height = 0, this._isRotated = false, this._hasMetaData = false, this._imageAsset = null, this._textureState = \"\", this._rcTex = C32.New(C32.Rect), this._quadTex = C32.New(C32.Quad), this._blobUrl = \"\", this._iImageInfo = new self.IImageInfo(this), allImageInfos.add(this);\n    }\n    Release() {\n      this.ReleaseTexture(), this._imageAsset && 0 === this._imageAsset.GetRefCount() && this._imageAsset.Release(), this._imageAsset = null, allImageInfos.delete(this), this.ReleaseBlobURL();\n    }\n    static OnRendererContextLost() {\n      for (const t of allImageInfos) t._textureState = \"\", t._rcTex.set(0, 0, 0, 0), t._quadTex.setFromRect(t._rcTex);\n    }\n    LoadData(t) {\n      this._url = t[0], this._size = t[1], this._offsetX = t[2], this._offsetY = t[3], this._width = t[4], this._height = t[5], this._isRotated = t[6], this._hasMetaData = true;\n    }\n    LoadDynamicAsset(t, e) {\n      if (this._imageAsset) throw new Error(\"already loaded asset\");\n      this._url = e;\n      const s = {};\n      return C32.IsAbsoluteURL(e) && (s.loadPolicy = \"remote\"), this.LoadAsset(t, s), this._imageAsset.Load();\n    }\n    LoadDynamicBlobAsset(t, e) {\n      if (this._imageAsset) throw new Error(\"already loaded asset\");\n      this._url = \"\", this._size = e.size, this._imageAsset = C32.New(C32.ImageAsset, t.GetAssetManager(), { blob: e, size: this._size, loadPolicy: \"local\" });\n    }\n    ReplaceWith(t) {\n      if (t === this) throw new Error(\"cannot replace with self\");\n      this._generation++, this.ReleaseTexture(), this._url = t._url, this._size = t._size, this._offsetX = t._offsetX, this._offsetY = t._offsetY, this._width = t._width, this._height = t._height, this._isRotated = t._isRotated, this._hasMetaData = t._hasMetaData, this._imageAsset = t._imageAsset, this._textureState = t._textureState, this._rcTex = t._rcTex, this._quadTex = t._quadTex, this.ReleaseBlobURL();\n    }\n    GetURL() {\n      return this._url;\n    }\n    GetSize() {\n      return this._size;\n    }\n    GetOffsetX() {\n      return this._offsetX;\n    }\n    GetOffsetY() {\n      return this._offsetY;\n    }\n    IsRotated() {\n      return this._isRotated;\n    }\n    GetWidth() {\n      return this._width;\n    }\n    GetHeight() {\n      return this._height;\n    }\n    GetSheetWidth() {\n      return this._imageAsset.GetWidth();\n    }\n    GetSheetHeight() {\n      return this._imageAsset.GetHeight();\n    }\n    LoadAsset(t, e) {\n      if (this._imageAsset) throw new Error(\"already got asset\");\n      e = Object.assign({}, e, { url: this.GetURL(), size: this.GetSize() }), this._imageAsset = t.LoadImage(e);\n    }\n    IsLoaded() {\n      return this._imageAsset && this._imageAsset.IsLoaded();\n    }\n    async LoadStaticTexture(t, e) {\n      if (!this._imageAsset) throw new Error(\"no asset\");\n      if (this._textureState) throw new Error(\"already loaded texture\");\n      const s = this._generation, i = (this._textureState = \"loading\", await this._imageAsset.LoadStaticTexture(t, e));\n      if (this._generation !== s) return null;\n      if (!i) return this._textureState = \"\", null;\n      this._textureState = \"loaded\", this._hasMetaData || (this._width = i.GetWidth(), this._height = i.GetHeight(), this._hasMetaData = true);\n      const h = this._isRotated ? this._height : this._width, a = this._isRotated ? this._width : this._height;\n      return this._rcTex.set(this._offsetX, this._offsetY, this._offsetX + h, this._offsetY + a), this._rcTex.divide(i.GetWidth(), i.GetHeight()), this._quadTex.setFromRect(this._rcTex), this._isRotated && this._quadTex.rotatePointsAnticlockwise(), i;\n    }\n    ReleaseTexture() {\n      this._textureState && (this._imageAsset && this._imageAsset.ReleaseTexture(), this._textureState = \"\", this._rcTex.set(0, 0, 0, 0), this._quadTex.setFromRect(this._rcTex));\n    }\n    GetTexture() {\n      return this._imageAsset && \"loaded\" === this._textureState ? this._imageAsset.GetTexture() : null;\n    }\n    GetTexRect() {\n      return this._rcTex;\n    }\n    GetTexQuad() {\n      return this._quadTex;\n    }\n    GetIImageInfo() {\n      return this._iImageInfo;\n    }\n    GetImageAsset() {\n      return this._imageAsset;\n    }\n    async ExtractImageToCanvas(t) {\n      t = t || await this._imageAsset.LoadToDrawable();\n      const e = C32.CreateCanvas(this._width, this._height), s = e.getContext(\"2d\");\n      return this._isRotated ? (s.rotate(Math.PI / -2), s.translate(-this._height, 0), s.drawImage(t, this._offsetX, this._offsetY, this._height, this._width, 0, 0, this._height, this._width)) : s.drawImage(t, this._offsetX, this._offsetY, this._width, this._height, 0, 0, this._width, this._height), e;\n    }\n    async ExtractImageToBlobURL(t) {\n      if (!this._blobUrl) {\n        const e = await this.ExtractImageToCanvas(t), s = await C32.CanvasToBlob(e);\n        this._blobUrl = URL.createObjectURL(s);\n      }\n      return this._blobUrl;\n    }\n    ReleaseBlobURL() {\n      this._blobUrl && (URL.revokeObjectURL(this._blobUrl), this._blobUrl = \"\");\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.AnimationInfo = class extends C32.DefendedBase {\n    constructor(e) {\n      super(), this._name = e[0], this._speed = e[1], this._isLooping = !!e[2], this._repeatCount = e[3], this._repeatTo = e[4], this._isPingPong = !!e[5], this._sid = e[6], this._frames = e[7].map((e2) => C32.New(C32.AnimationFrameInfo, e2)), this._iAnimation = new self.IAnimation(this);\n    }\n    static CreateDynamic(e, t) {\n      const r = C32.New(C32.AnimationInfo, [t, 0, false, 0, 0, false, Math.floor(1e15 * Math.random()), []]);\n      return r._frames.push(C32.AnimationFrameInfo.CreateDynamic(e)), r;\n    }\n    Release() {\n      for (const e of this._frames) e.Release();\n      C32.clearArray(this._frames);\n    }\n    LoadAllAssets(e) {\n      for (const t of this._frames) t.GetImageInfo().LoadAsset(e);\n    }\n    LoadAllTextures(t, r) {\n      return Promise.all(this._frames.map((e) => e.GetImageInfo().LoadStaticTexture(t, r)));\n    }\n    ReleaseAllTextures() {\n      for (const e of this._frames) e.GetImageInfo().ReleaseTexture();\n    }\n    GetName() {\n      return this._name;\n    }\n    GetSID() {\n      return this._sid;\n    }\n    GetFrameCount() {\n      return this._frames.length;\n    }\n    GetFrames() {\n      return this._frames;\n    }\n    GetFrameAt(e) {\n      if ((e = Math.floor(e)) < 0 || e >= this._frames.length) throw new RangeError(\"invalid frame\");\n      return this._frames[e];\n    }\n    InsertFrameAt(e, t) {\n      (t = Math.floor(t)) < 0 ? this._frames.unshift(e) : t >= this._frames.length ? this._frames.push(e) : this._frames.splice(t, 0, e);\n    }\n    RemoveFrameAt(e) {\n      if ((e = Math.floor(e)) < 0 || e >= this._frames.length) throw new RangeError(\"invalid frame\");\n      this._frames[e].Release(), this._frames.splice(e, 1);\n    }\n    GetFrameIndexByTag(r) {\n      for (let e = 0, t = this._frames.length; e < t; ++e) if (C32.equalsNoCase(this._frames[e].GetTag(), r)) return e;\n      return -1;\n    }\n    FrameTagOrIndexToIndex(e) {\n      if (\"string\" != typeof e) return e;\n      {\n        const t = this.GetFrameIndexByTag(e);\n        if (-1 === t) throw new Error(\"cannot find animation frame with tag \" + e);\n        return t;\n      }\n    }\n    GetSpeed() {\n      return this._speed;\n    }\n    IsLooping() {\n      return this._isLooping;\n    }\n    GetRepeatCount() {\n      return this._repeatCount;\n    }\n    GetRepeatTo() {\n      return this._repeatTo;\n    }\n    IsPingPong() {\n      return this._isPingPong;\n    }\n    GetIAnimation() {\n      return this._iAnimation;\n    }\n  };\n}\n{\n  const C32 = self.C3, EMPTY_IMAGE_BLOB = (() => {\n    const e = atob(\"iVBORw0KGgoAAAANSUhEUgAAAGQAAABkAQMAAABKLAcXAAAAAXNSR0IArs4c6QAAAANQTFRFAAAAp3o92gAAAAF0Uk5TAEDm2GYAAAATSURBVBgZYxgFo2AUjIJRQFcAAAV4AAHcRQIbAAAAAElFTkSuQmCC\"), n = new Uint8Array(e.length);\n    for (let t = 0, i = e.length; t < i; ++t) n[t] = e.charCodeAt(t);\n    return new Blob([n], { type: \"image/png\" });\n  })();\n  C32.AnimationFrameInfo = class extends C32.DefendedBase {\n    constructor(t) {\n      super(), this._imageInfo = C32.New(C32.ImageInfo), this._imageInfo.LoadData(t), this._duration = t[7], this._origin = C32.New(C32.Vector2, t[8], t[9]), this._imagePoints = t[10].map((t2) => C32.New(C32.ImagePoint, this, t2)), this._imagePointsByName = /* @__PURE__ */ new Map();\n      for (const e of this._imagePoints) this._imagePointsByName.set(e.GetName().toLowerCase(), e);\n      this._collisionPoly = null;\n      const i = t[11];\n      6 <= i.length && (this._collisionPoly = C32.New(C32.CollisionPoly, i)), this._tag = t[12] || \"\", this._iAnimationFrame = new self.IAnimationFrame(this);\n    }\n    static CreateDynamic(t) {\n      const i = C32.New(C32.AnimationFrameInfo, [\"\", 0, 0, 0, 100, 100, false, 1, 0, 0, [], [], \"\"]);\n      return i._imageInfo.LoadDynamicBlobAsset(t, EMPTY_IMAGE_BLOB), i;\n    }\n    Release() {\n      this._collisionPoly && (this._collisionPoly.Release(), this._collisionPoly = null), this._imageInfo.Release(), this._imageInfo = null;\n    }\n    GetImageInfo() {\n      return this._imageInfo;\n    }\n    GetDuration() {\n      return this._duration;\n    }\n    GetOriginX() {\n      return this._origin.getX();\n    }\n    GetOriginY() {\n      return this._origin.getY();\n    }\n    GetCollisionPoly() {\n      return this._collisionPoly;\n    }\n    GetImagePointByName(t) {\n      return this._imagePointsByName.get(t.toLowerCase()) || null;\n    }\n    GetImagePointByIndex(t) {\n      return (t = Math.floor(t)) < 0 || t >= this._imagePoints.length ? null : this._imagePoints[t];\n    }\n    GetImagePointCount() {\n      return this._imagePoints.length;\n    }\n    GetTag() {\n      return this._tag;\n    }\n    GetIAnimationFrame() {\n      return this._iAnimationFrame;\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.ImagePoint = class extends C32.DefendedBase {\n    constructor(e, t) {\n      super(), this._afi = e, this._name = t[0], this._pos = C32.New(C32.Vector2, t[1], t[2]);\n    }\n    Release() {\n    }\n    GetName() {\n      return this._name;\n    }\n    GetX() {\n      return this._pos.getX();\n    }\n    GetY() {\n      return this._pos.getY();\n    }\n    GetVec2() {\n      return this._pos;\n    }\n  };\n}\n{\n  const C32 = self.C3, C3Debugger = self.C3Debugger, IObjectClass = self.IObjectClass, assert = self.assert;\n  C32.ObjectClass = class extends C32.DefendedBase {\n    constructor(e, t, s) {\n      super();\n      const i = e.GetObjectReference(s[1]), [n, a] = (this._runtime = e, this._plugin = C32.AddonManager.GetPluginByConstructorFunction(i), this._sdkType = null, this._instSdkCtor = i.Instance, this._index = t, this._sid = s[11], this._name = s[0], this._jsPropName = this._runtime.GetJsPropName(s[14]), this._isGlobal = !!s[9], this._isFamily = !!s[2], this._isOnLoaderLayout = !!s[10], this._instVars = s[3].map((t2) => ({ sid: t2[0], type: t2[1], name: t2[2], jsPropName: e.GetJsPropName(t2[3]) })), this._behaviorsCount = s[4], this._effectsCount = s[5], this._isWorldType = this._plugin.IsWorldType(), this._dispatcher = C32.New(C32.Event.Dispatcher), this._effectList = null, e.GetCollisionEngine().GetCollisionCellSize());\n      if (this._collisionGrid = C32.New(C32.SparseGrid, n, a), this._anyCollisionCellChanged = true, this._familyMembers = null, this._familyMembersSet = null, this._familyIndex = -1, this._families = null, this._familiesSet = null, this._familyInstVarMap = null, this._familyBehaviorMap = null, this._familyEffectMap = null, this._isInContainer = false, this._container = null, this._behaviorTypes = s[8].map((t2) => C32.BehaviorType.Create(this, t2)), this._behaviorTypesIncludingInherited = [], this._behaviorsByName = /* @__PURE__ */ new Map(), this._behaviorNameToIndex = /* @__PURE__ */ new Map(), this._usedBehaviorCtors = /* @__PURE__ */ new Set(), this._customActionMap = /* @__PURE__ */ new Map(), this._solStack = C32.New(C32.SolStack, this), this._defaultInstanceData = null, this._defaultLayerIndex = 0, this._isContained = false, this._container = null, this._imageInfo = null, this._animations = null, this._animationsByName = null, this._animationsBySid = null, this._textureRefCount = 0, this._savedData = /* @__PURE__ */ new Map(), this._unsavedData = /* @__PURE__ */ new Map(), this._instances = [], this._worldInfosByLayer = /* @__PURE__ */ new Map(), this._iidsStale = true, this._plugin.HasEffects() && (this._effectList = C32.New(C32.EffectList, this, s[12])), s[6] && (this._imageInfo = C32.New(C32.ImageInfo), this._imageInfo.LoadData(s[6])), s[7]) {\n        this._animations = s[7].map((t2) => C32.New(C32.AnimationInfo, t2)), this._animationsByName = /* @__PURE__ */ new Map(), this._animationsBySid = /* @__PURE__ */ new Map();\n        for (const h of this._animations) this._animationsByName.set(h.GetName().toLowerCase(), h), this._animationsBySid.set(h.GetSID(), h);\n      }\n      this._isFamily ? (this._familyMembers = [], this._familyMembersSet = /* @__PURE__ */ new Set(), this._familyIndex = this._runtime._GetNextFamilyIndex()) : (this._families = [], this._familiesSet = /* @__PURE__ */ new Set(), this._familyInstVarMap = [], this._familyBehaviorMap = [], this._familyEffectMap = []);\n      const r = this._plugin.GetSdkVersion();\n      if (r < 2 && (this._sdkType = C32.New(i.Type, this, s[15]), !(this._sdkType instanceof C32.SDKTypeBase))) throw new Error(\"v1 sdk type must derive from SDKTypeBase\");\n      this._iObjectClass = null, this._instanceUserScriptClass = null, this._userScriptDispatcher = C32.New(C32.Event.Dispatcher), C32.AddonManager._PushInitObject(this, r);\n      let o;\n      if (o = 2 <= r ? (o = i.Type) || globalThis.ISDKObjectTypeBase : this._sdkType.GetScriptInterfaceClass()) {\n        if (this._iObjectClass = new o(r < 2 ? this : null), r < 2 && !(this._iObjectClass instanceof IObjectClass)) throw new TypeError(\"script interface class must derive from IObjectClass\");\n        if (2 <= r && !(this._iObjectClass instanceof globalThis.ISDKObjectTypeBase)) throw new TypeError(\"script interface class must derive from ISDKObjectTypeBase\");\n      } else this._iObjectClass = new IObjectClass();\n      if (C32.AddonManager._PopInitObject(r), s[13]) {\n        const l = s[13];\n        if (l) {\n          const _ = l[0], c = l[1], u = l[2];\n          this._sdkType.LoadTilemapData(_, c, u);\n        }\n      }\n      this._runtime.UsesLoaderLayout() && !this._isFamily && !this._isOnLoaderLayout && this._isWorldType || this.OnCreate(), this._plugin.IsSingleGlobal() && (this._plugin._SetSingleGlobalObjectClass(this), this._CreateSingleGlobalInstance(s)), this._loadInstancesJson = null;\n    }\n    static Create(t, e, s) {\n      return C32.New(C32.ObjectClass, t, e, s);\n    }\n    Release() {\n      if (this._dispatcher.Release(), this._dispatcher = null, this._imageInfo && (this._imageInfo.Release(), this._imageInfo = null), this._animations) {\n        for (const t of this._animations) t.Release();\n        C32.clearArray(this._animations), this._animationsByName.clear(), this._animationsBySid.clear();\n      }\n      this._loadInstancesJson = null, this._solStack.Release(), this._solStack = null, this._savedData.clear(), this._unsavedData.clear(), this._container = null, this._runtime = null;\n    }\n    _LoadFamily(s) {\n      for (let t = 1, e = s.length; t < e; ++t) {\n        const i = this._runtime.GetObjectClassByIndex(s[t]);\n        this._familyMembers.push(i), this._familyMembersSet.add(i), i._families.push(this), i._familiesSet.add(this);\n      }\n    }\n    _SetContainer(t) {\n      this._isInContainer = true, this._container = t;\n    }\n    IsInContainer() {\n      return this._isInContainer;\n    }\n    GetContainer() {\n      return this._container;\n    }\n    _OnAfterCreate() {\n      let t = 0;\n      if (!this._isFamily) for (const e of this._families) for (const s of e.GetBehaviorTypes()) {\n        const i = s.GetName().toLowerCase();\n        this._behaviorsByName.set(i, s), this._behaviorNameToIndex.set(i, t), this._behaviorTypesIncludingInherited.push(s), ++t;\n      }\n      for (const n of this.GetBehaviorTypes()) {\n        const a = n.GetName().toLowerCase();\n        this._behaviorsByName.set(a, n), this._behaviorNameToIndex.set(a, t), this._behaviorTypesIncludingInherited.push(n), ++t;\n      }\n      for (const r of this._behaviorTypesIncludingInherited) this._usedBehaviorCtors.add(r.GetBehavior().constructor);\n      if (!this._isFamily && this._families.length) {\n        const o = this._runtime.GetFamilyCount(), h = (C32.extendArray(this._familyInstVarMap, o, 0), C32.extendArray(this._familyBehaviorMap, o, 0), C32.extendArray(this._familyEffectMap, o, 0), []);\n        let t2 = 0, e = 0, s = 0;\n        for (const l of this._families) {\n          const _ = l.GetFamilyIndex(), c = (this._familyInstVarMap[_] = t2, t2 += l.GetInstanceVariablesCount(), this._familyBehaviorMap[_] = e, e += l.GetBehaviorTypesCount(), this._familyEffectMap[_] = s, s += l.GetEffectTypesCount(), l.GetEffectList());\n          if (c && this._effectList) for (const u of c.GetAllEffectTypes()) h.push(u.Clone(this._effectList));\n        }\n        this._effectList && this._effectList.PrependEffectTypes(h);\n      }\n    }\n    _CreateSingleGlobalInstance(t) {\n      const e = this._runtime._GetNewUID(), s = C32.New(C32.Instance, { runtime: this._runtime, objectType: this, uid: e });\n      s._CreateSdkInstance(t[16], []), this._runtime._MapInstanceByUID(e, s), this._instances.push(s);\n    }\n    GetSdkType() {\n      return this._sdkType;\n    }\n    IsOnLoaderLayout() {\n      return this._isOnLoaderLayout;\n    }\n    Dispatcher() {\n      return this._dispatcher;\n    }\n    OnCreate() {\n      this._isFamily || (this._sdkType ? this._sdkType.OnCreate() : this._iObjectClass._onCreate());\n    }\n    HasLoadedTextures() {\n      return 0 < this._textureRefCount;\n    }\n    async LoadTextures(t) {\n      this._isFamily || (this._textureRefCount++, 1 === this._textureRefCount && (this._sdkType ? await this._sdkType.LoadTextures(t) : await this._iObjectClass._loadTextures(this._runtime.GetCanvasManager().GetIRenderer())));\n    }\n    ReleaseTextures() {\n      if (!this._isFamily) {\n        if (this._textureRefCount--, this._textureRefCount < 0) throw new Error(\"released textures too many times\");\n        0 === this._textureRefCount && (this._sdkType ? this._sdkType.ReleaseTextures() : this._iObjectClass._releaseTextures(this._runtime.GetCanvasManager().GetIRenderer()));\n      }\n    }\n    OnDynamicTextureLoadComplete() {\n      if (this._isFamily) throw new Error(\"not applicable to family\");\n      this._sdkType ? this._sdkType.OnDynamicTextureLoadComplete() : this._iObjectClass._onDynamicTextureLoadComplete();\n    }\n    async PreloadTexturesWithInstances(t) {\n      this._isFamily || (this._sdkType ? await this._sdkType.PreloadTexturesWithInstances(t) : await this._iObjectClass._preloadTexturesWithInstances(this._runtime.GetCanvasManager().GetIRenderer()));\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetPlugin() {\n      return this._plugin;\n    }\n    GetInstanceSdkCtor() {\n      return this._instSdkCtor;\n    }\n    GetName() {\n      return this._name;\n    }\n    GetJsPropName() {\n      return this._jsPropName;\n    }\n    GetIndex() {\n      return this._index;\n    }\n    GetSID() {\n      return this._sid;\n    }\n    IsFamily() {\n      return this._isFamily;\n    }\n    IsGlobal() {\n      return this._isGlobal;\n    }\n    IsWorldType() {\n      return this._isWorldType;\n    }\n    GetFamilyIndex() {\n      return this._familyIndex;\n    }\n    GetBehaviorTypes() {\n      return this._behaviorTypes;\n    }\n    GetBehaviorTypesCount() {\n      return this._behaviorsCount;\n    }\n    UsesBehaviorByCtor(t) {\n      return t && this._usedBehaviorCtors.has(t);\n    }\n    GetInstanceVariablesCount() {\n      return this._instVars.length;\n    }\n    GetInstanceVariableSIDs() {\n      return this._instVars.map((t) => t.sid);\n    }\n    GetInstanceVariableIndexBySID(e) {\n      return this._instVars.findIndex((t) => t.sid === e);\n    }\n    GetInstanceVariableIndexByName(e) {\n      return this._instVars.findIndex((t) => t.name === e);\n    }\n    _GetAllInstanceVariableNames() {\n      return this._instVars.map((t) => t.name);\n    }\n    _GetAllInstanceVariableJsPropNames() {\n      return this._instVars.map((t) => t.jsPropName);\n    }\n    GetInstanceVariableType(t) {\n      if ((t = Math.floor(t)) < 0 || t >= this._instVars.length) throw new RangeError(\"invalid instance variable index\");\n      return this._instVars[t].type;\n    }\n    GetInstanceVariableName(t) {\n      if ((t = Math.floor(t)) < 0 || t >= this._instVars.length) throw new RangeError(\"invalid instance variable index\");\n      return this._instVars[t].name;\n    }\n    GetEffectTypesCount() {\n      return this._effectsCount;\n    }\n    GetBehaviorTypesIncludingInherited() {\n      return this._behaviorTypesIncludingInherited;\n    }\n    GetBehaviorTypeByName(t) {\n      return this._behaviorsByName.get(t.toLowerCase()) || null;\n    }\n    GetBehaviorIndexByName(t) {\n      const e = this._behaviorNameToIndex.get(t.toLowerCase());\n      return void 0 === e ? -1 : e;\n    }\n    GetEffectList() {\n      return this._effectList;\n    }\n    HasEffects() {\n      return this._plugin.HasEffects();\n    }\n    UsesEffects() {\n      return this._effectList && this._effectList.HasAnyEffectType();\n    }\n    GetSolStack() {\n      return this._solStack;\n    }\n    GetCurrentSol() {\n      return this._solStack.GetCurrentSol();\n    }\n    GetImageInfo() {\n      return this._imageInfo;\n    }\n    SetDefaultInstanceData(t) {\n      this._defaultInstanceData = t;\n    }\n    GetDefaultInstanceData() {\n      return this._defaultInstanceData;\n    }\n    _SetDefaultLayerIndex(t) {\n      this._defaultLayerIndex = t;\n    }\n    GetDefaultLayerIndex() {\n      return this._defaultLayerIndex;\n    }\n    GetAnimations() {\n      return this._animations;\n    }\n    GetAnimationCount() {\n      return this._animations.length;\n    }\n    GetFamilies() {\n      return this._families;\n    }\n    BelongsToFamily(t) {\n      return this._familiesSet.has(t);\n    }\n    GetFamilyMembers() {\n      return this._familyMembers;\n    }\n    FamilyHasMember(t) {\n      return this._familyMembersSet.has(t);\n    }\n    GetFamilyBehaviorOffset(t) {\n      return this._familyBehaviorMap[t];\n    }\n    GetFamilyInstanceVariableOffset(t) {\n      return this._familyInstVarMap[t];\n    }\n    AddCustomAction(t) {\n      this._customActionMap.set(t.GetACEName().toLowerCase(), t);\n    }\n    HasOwnCustomActionByName(t) {\n      return !!this.GetOwnCustomActionByName(t);\n    }\n    GetOwnCustomActionByName(t) {\n      const e = this._customActionMap.get(t.toLowerCase());\n      return e && e.IsEnabled() ? e : null;\n    }\n    GetAllAnimations() {\n      return this._animations;\n    }\n    GetAnimationByName(t) {\n      if (this._animations) return this._animationsByName.get(t.toLowerCase()) || null;\n      throw new Error(\"no animations\");\n    }\n    GetAnimationBySID(t) {\n      if (this._animations) return this._animationsBySid.get(t) || null;\n      throw new Error(\"no animations\");\n    }\n    AddAnimation(t) {\n      if (this.GetAnimationByName(t)) throw new Error(`animation name '${t}' already exists`);\n      const e = C32.AnimationInfo.CreateDynamic(this.GetRuntime(), t);\n      return this._animations.push(e), this._animationsByName.set(e.GetName().toLowerCase(), e), this._animationsBySid.set(e.GetSID(), e), e;\n    }\n    RemoveAnimation(t) {\n      const e = this.GetAnimationByName(t);\n      if (!e) throw new Error(`animation name '${t}' does not exist`);\n      if (1 === this._animations.length) throw new Error(\"cannot remove last animation\");\n      const s = this._animations.indexOf(e);\n      this._animations.splice(s, 1), this._animationsByName.delete(e.GetName().toLowerCase()), this._animationsBySid.delete(e.GetSID()), e.Release();\n    }\n    GetFirstAnimation() {\n      if (this._animations) return this._animations[0];\n      throw new Error(\"no animations\");\n    }\n    GetFirstAnimationFrame() {\n      return this.GetFirstAnimation().GetFrameAt(0);\n    }\n    GetDefaultInstanceSize() {\n      if (this._animations) {\n        const t = this.GetFirstAnimationFrame().GetImageInfo();\n        return [t.GetWidth(), t.GetHeight()];\n      }\n      return this._imageInfo ? [this._imageInfo.GetWidth(), this._imageInfo.GetHeight()] : [100, 100];\n    }\n    GetSingleGlobalInstance() {\n      if (this._plugin.IsSingleGlobal()) return this._instances[0];\n      throw new Error(\"not a single-global plugin\");\n    }\n    GetInstances() {\n      return this._instances;\n    }\n    *instances() {\n      yield* this._instances;\n    }\n    *instancesIncludingPendingCreate() {\n      yield* this._instances, yield* this._runtime.instancesPendingCreateForObjectClass(this);\n    }\n    GetInstanceCount() {\n      return this._instances.length;\n    }\n    _AddInstance(t) {\n      this._instances.push(t);\n    }\n    _SetIIDsStale() {\n      this._iidsStale = true;\n    }\n    _UpdateIIDs() {\n      if (this._iidsStale && !this._isFamily) {\n        const s = this._instances;\n        let e = 0;\n        for (let t2 = s.length; e < t2; ++e) s[e]._SetIID(e);\n        const t = this._runtime._GetInstancesPendingCreate();\n        for (const i of t) i.GetObjectClass() === this && i._SetIID(e++);\n        this._iidsStale = false;\n      }\n    }\n    GetInstanceByIID(t) {\n      const e = this._instances;\n      if (t < e.length) return e[t];\n      t -= e.length;\n      const s = this._runtime._GetInstancesPendingCreate();\n      for (const i of s) if (i.GetObjectClass() === this) {\n        if (0 === t) return i;\n        --t;\n      }\n      return null;\n    }\n    GetFirstPicked(t) {\n      if (t && t.IsInContainer() && t.GetObjectClass() !== this) {\n        for (const s of t.siblings()) if (s.GetObjectClass() === this) return s;\n      }\n      const e = this.GetCurrentSol().GetInstances();\n      return e.length ? e[0] : null;\n    }\n    GetPairedInstance(t) {\n      const e = this.GetCurrentSol().GetInstances();\n      return 0 < e.length ? e[t.GetIID() % e.length] : null;\n    }\n    *allCorrespondingInstances(t, e) {\n      const s = this.GetCurrentSol().GetInstances(), i = s.length, n = e.GetCurrentSol(), a = e.GetCurrentSol().GetInstances(), r = a.length;\n      let o = t.GetIID();\n      !e.IsFamily() && n.IsSelectAll() || (o = a.indexOf(t));\n      const h = Math.ceil(i / r), l = i % r;\n      let _ = 0, c = 0;\n      c = 0 == l || o < l ? (_ = o * h, h) : (_ = l * h + (o - l) * (h - 1), h - 1);\n      for (let t2 = _, e2 = _ + c; t2 < e2; ++t2) yield s[t2];\n    }\n    FinishCondition(t) {\n      this._sdkType?.FinishCondition(t);\n    }\n    ApplySolToContainer() {\n      if (this._isInContainer && !this._isFamily) {\n        this._UpdateIIDs();\n        const t = this.GetCurrentSol(), e = t._GetOwnInstances(), s = t.IsSelectAll(), i = this._runtime.GetCurrentEventStackFrame(), n = i && i.GetCurrentEvent() && i.GetCurrentEvent().IsOrBlock();\n        for (const a of this._container.objectTypes()) if (a !== this) {\n          a._UpdateIIDs();\n          const r = a.GetCurrentSol();\n          if (r._SetSelectAll(s), !s) {\n            const o = r._GetOwnInstances();\n            C32.clearArray(o);\n            for (const h of e) o.push(a.GetInstanceByIID(h.GetIID()));\n            if (n) {\n              const l = t._GetOwnElseInstances(), _ = r._GetOwnElseInstances();\n              C32.clearArray(_);\n              for (const c of l) _.push(a.GetInstanceByIID(c.GetIID()));\n            }\n          }\n        }\n      }\n    }\n    _TruncateContainerSols(t, e) {\n      for (const s of this.GetContainer().objectTypes()) {\n        const i = s.GetCurrentSol();\n        t ? C32.truncateArray(i._GetOwnElseInstances(), e) : C32.truncateArray(i._GetOwnInstances(), e);\n      }\n    }\n    _GetCollisionCellGrid() {\n      return this._collisionGrid;\n    }\n    _SetAnyCollisionCellChanged(t) {\n      this._anyCollisionCellChanged = !!t;\n    }\n    _UpdateAllCollisionCells() {\n      if (this._anyCollisionCellChanged && this._isWorldType) {\n        for (const t of this._instances) t.GetWorldInfo()._UpdateCollisionCell();\n        for (const e of this._runtime._GetInstancesPendingCreate()) e.GetObjectClass() === this && e.GetWorldInfo()._UpdateCollisionCell();\n        this._anyCollisionCellChanged = false;\n      }\n    }\n    _OnWorldInstanceLayerChanged(e, t, s) {\n      if (t) {\n        const i = this._worldInfosByLayer.get(t);\n        i && (i.delete(e), 0 === i.size) && this._worldInfosByLayer.delete(t);\n      }\n      if (s) {\n        let t2 = this._worldInfosByLayer.get(s);\n        t2 || (t2 = /* @__PURE__ */ new Set(), this._worldInfosByLayer.set(s, t2)), t2.add(e);\n      }\n    }\n    layersHasInstancesOn() {\n      if (this.IsFamily()) {\n        const t = /* @__PURE__ */ new Set();\n        for (const e of this._familyMembers) for (const s of e.layersHasInstancesOn()) t.add(s);\n        return t.values();\n      }\n      return this._worldInfosByLayer.keys();\n    }\n    GetSavedDataMap() {\n      return this._savedData || (this._savedData = /* @__PURE__ */ new Map()), this._savedData;\n    }\n    GetUnsavedDataMap() {\n      return this._unsavedData || (this._unsavedData = /* @__PURE__ */ new Map()), this._unsavedData;\n    }\n    HasSolidBehavior() {\n      return this.UsesBehaviorByCtor(C32.Behaviors.solid);\n    }\n    HasJumpthruBehavior() {\n      return this.UsesBehaviorByCtor(C32.Behaviors.jumpthru);\n    }\n    HasNoSaveBehavior() {\n      return this.UsesBehaviorByCtor(C32.Behaviors.NoSave);\n    }\n    HasPersistBehavior() {\n      return this.UsesBehaviorByCtor(C32.Behaviors.Persist);\n    }\n    _SaveToJson() {\n      const t = { \"instances\": this._instances.map((t2) => t2.SaveToJson()) };\n      return this._savedData && this._savedData.size && (t[\"ex\"] = C32.ToSuperJSON(this._savedData)), t;\n    }\n    _LoadFromJson(t, s) {\n      this._savedData && (this._savedData.clear(), this._savedData = null);\n      const e = t[\"ex\"], i = (e && (this._savedData = C32.FromSuperJSON(e)), this._instances), n = t[\"instances\"];\n      for (let t2 = 0, e2 = Math.min(i.length, n.length); t2 < e2; ++t2) i[t2].LoadFromJson(n[t2]);\n      for (let t2 = n.length, e2 = i.length; t2 < e2; ++t2) this._runtime.DestroyInstance(i[t2]);\n      for (let e2 = i.length, t2 = n.length; e2 < t2; ++e2) {\n        const a = n[e2];\n        let t3 = null;\n        if (!this.IsWorldType() || (t3 = this._runtime.GetMainRunningLayout().GetLayerBySID(a[\"w\"][\"l\"]))) {\n          const r = this._runtime.CreateInstanceFromData(this._defaultInstanceData || this, t3, false, 0, 0, true);\n          r.LoadFromJson(a), s && s.add(r);\n        }\n      }\n      this._loadInstancesJson = n, this._SetIIDsStale();\n    }\n    _GetLoadInstancesJson() {\n      return this._loadInstancesJson;\n    }\n    _ClearLoadInstancesJson() {\n      this._loadInstancesJson = null;\n    }\n    _SetupSceneGraphConnectionsOnChangeOfLayout() {\n      for (let t = 0, e = this._instances; t < e; ++t) this._instances[t]._SetupSceneGraphConnectionsOnChangeOfLayout();\n    }\n    GetIObjectClass() {\n      return this._iObjectClass;\n    }\n    UserScriptDispatcher() {\n      return this._userScriptDispatcher;\n    }\n    _GetUserScriptInstanceClass() {\n      return this._instanceUserScriptClass;\n    }\n    _SetUserScriptInstanceClass(t) {\n      this._instanceUserScriptClass = t;\n    }\n    DispatchUserScriptEvent(t) {\n      const e = this._runtime, s = e.IsDebug() && !e.GetEventSheetManager().IsInEventEngine();\n      s && C3Debugger.StartMeasuringScriptTime(), this._userScriptDispatcher.dispatchEvent(t), s && C3Debugger.AddScriptTime();\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.Container = class extends C32.DefendedBase {\n    constructor(e, t) {\n      super(), this._runtime = e, this._objectTypes = t;\n      for (const s of this._objectTypes) s._SetContainer(this);\n    }\n    Release() {\n      this._runtime = null;\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetObjectTypes() {\n      return this._objectTypes;\n    }\n    objectTypes() {\n      return this._objectTypes;\n    }\n    HasAnyWorldType() {\n      return this._objectTypes.some((e) => e.IsWorldType());\n    }\n  };\n}\n{\n  const C32 = self.C3, C3Debugger = self.C3Debugger, IInstance = self.IInstance, originalAddonManager = C32.AddonManager, EMPTY_ARRAY = [];\n  let nextPuid = 0;\n  const savedDataMaps = /* @__PURE__ */ new WeakMap(), unsavedDataMaps = /* @__PURE__ */ new WeakMap(), FLAG_DESTROYED = 1, FLAG_TILEMAP = 2, FLAG_MUST_PREDRAW = 4, FLAG_SOLID_ENABLED = 8, FLAG_JUMPTHRU_ENABLED = 16, FLAG_MUST_MITIGATE_Z_FIGHTING = 32, FLAG_IS_DRAWING_WITH_EFFECTS = 64;\n  C32.Instance = class extends C32.DefendedBase {\n    constructor(t) {\n      if (C32.AddonManager !== originalAddonManager) throw new Error(\"invalid addon manager\");\n      super(), this._runtime = t.runtime, this._objectType = t.objectType, this._worldInfo = null, this._sdkInst = null, this._iScriptInterface = null, this._iid = 0, this._uid = t.uid, this._puid = nextPuid++, this._flags = 0, this._tagsSet = null;\n      const e = C32.splitStringAndNormalize(t.tags), s = (0 < e.length && (this._tagsSet = new Set(e)), this._instVarValues = EMPTY_ARRAY, this._behaviorInstances = EMPTY_ARRAY, this._objectType.GetBehaviorTypesIncludingInherited()), n = (0 < s.length && (this._behaviorInstances = s.map((t2, e2) => C32.New(C32.BehaviorInstance, { runtime: this._runtime, behaviorType: t2, instance: this, index: e2 }))), this._siblings = this._objectType.IsInContainer() ? [] : null, this._timeScale = -1, this._dispatcher = null, this.GetPlugin());\n      if (n.MustPreDraw() && (this._flags |= FLAG_MUST_PREDRAW), n.IsWorldType()) if (this._worldInfo = C32.New(C32.WorldInfo, this, t.layer), t.worldData) this._worldInfo.Init(t.worldData);\n      else {\n        this._worldInfo.InitNoData();\n        const [i, r] = this._objectType.GetDefaultInstanceSize();\n        this._worldInfo.SetSize(i, r), this.GetObjectClass().UsesEffects() && this._worldInfo.GetInstanceEffectList().LoadDefaultEffectParameters();\n      }\n      t.instVarData ? this._LoadInstanceVariableData(t.instVarData) : this._LoadDefaultInstanceVariables();\n    }\n    Release() {\n      if (this._iScriptInterface && (this._iScriptInterface._release(), this._iScriptInterface = null), 0 < this._behaviorInstances.length) {\n        for (const s of this._behaviorInstances) s.Release();\n        C32.clearArray(this._behaviorInstances);\n      }\n      this._sdkInst && (this._sdkInst.Release(), this._sdkInst = null);\n      const t = savedDataMaps.get(this), e = (t && (t.clear(), savedDataMaps.delete(this)), unsavedDataMaps.get(this));\n      e && (e.clear(), unsavedDataMaps.delete(this)), this._siblings && C32.clearArray(this._siblings), this._dispatcher && (this._dispatcher.Release(), this._dispatcher = null), this._tagsSet && this._tagsSet.clear(), this._tagsSet = null, this._runtime = null, this._objectType = null, 0 < this._instVarValues.length && C32.clearArray(this._instVarValues), this._worldInfo && (this._worldInfo.Release(), this._worldInfo = null);\n    }\n    _LoadInstanceVariableData(t) {\n      0 < t.length && (this._instVarValues = [], C32.shallowAssignArray(this._instVarValues, t));\n    }\n    _LoadDefaultInstanceVariables() {\n      const e = this._objectType.GetInstanceVariablesCount();\n      if (0 !== e) {\n        this._instVarValues = [];\n        const s = [0, 0, \"\"];\n        for (let t = 0; t < e; ++t) this._instVarValues.push(s[this._objectType.GetInstanceVariableType(t)]);\n      }\n    }\n    _CreateSdkInstance(t, s) {\n      if (this._sdkInst) throw new Error(\"already got sdk instance\");\n      for (let t2 = 0, e2 = this._behaviorInstances.length; t2 < e2; ++t2) {\n        const n = this._behaviorInstances[t2];\n        n._CreateSdkInstance(s ? s[t2] : null);\n      }\n      const e = this.GetPlugin().GetSdkVersion();\n      if (e < 2) {\n        if (this._sdkInst = C32.New(this._objectType.GetInstanceSdkCtor(), this, t), !(this._sdkInst instanceof C32.SDKInstanceBase)) throw new Error(\"sdk type must derive from SDKInstanceBase\");\n        !this.GetPlugin().IsWorldType() && this._objectType._GetUserScriptInstanceClass() && this.GetInterfaceClass();\n      } else {\n        const i = this.GetPlugin().GetScriptInterfaceClass();\n        this._InitUserScriptInterface(i.Instance, t);\n      }\n    }\n    GetSdkInstance() {\n      return this._sdkInst ?? this._iScriptInterface;\n    }\n    GetWorldInfo() {\n      return this._worldInfo;\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetTimeScale() {\n      return this._timeScale;\n    }\n    GetActiveTimeScale() {\n      const t = this._timeScale;\n      return -1 === t ? this.GetRuntime().GetTimeScale() : t;\n    }\n    SetTimeScale(t) {\n      ((t = +t) < 0 || !isFinite(t)) && (t = 0), this._timeScale = t, this.GetObjectClass().UsesEffects() && this._runtime._SetTrackingInstanceTime(this, true);\n    }\n    RestoreTimeScale() {\n      this._timeScale = -1, this.GetObjectClass().UsesEffects() && this._runtime._SetTrackingInstanceTime(this, false);\n    }\n    GetInstanceGameTime() {\n      return this._runtime._GetInstanceGameTime(this);\n    }\n    Dispatcher() {\n      return this._dispatcher || (this._dispatcher = C32.New(C32.Event.Dispatcher)), this._dispatcher;\n    }\n    Draw(t) {\n      this._sdkInst ? this._sdkInst.Draw(t) : this._iScriptInterface._draw(this._runtime.GetCanvasManager().GetIRenderer());\n    }\n    OnCreate(t) {\n      this._sdkInst.OnCreate(t);\n    }\n    _SetHasTilemap() {\n      this._flags |= FLAG_TILEMAP;\n    }\n    HasTilemap() {\n      return 0 != (this._flags & FLAG_TILEMAP);\n    }\n    _MarkDestroyed() {\n      this._flags |= FLAG_DESTROYED;\n    }\n    IsDestroyed() {\n      return 0 != (this._flags & FLAG_DESTROYED);\n    }\n    MustPreDraw() {\n      return 0 != (this._flags & FLAG_MUST_PREDRAW) || this._sdkInst.MustPreDraw();\n    }\n    SetMustMitigateZFighting() {\n      this._flags |= FLAG_MUST_MITIGATE_Z_FIGHTING;\n    }\n    MustMitigateZFighting() {\n      return 0 != (this._flags & FLAG_MUST_MITIGATE_Z_FIGHTING);\n    }\n    _IsSolidEnabled() {\n      return 0 != (this._flags & FLAG_SOLID_ENABLED);\n    }\n    _SetSolidEnabled(t) {\n      t ? this._flags |= FLAG_SOLID_ENABLED : this._flags &= ~FLAG_SOLID_ENABLED;\n    }\n    _IsJumpthruEnabled() {\n      return 0 != (this._flags & FLAG_JUMPTHRU_ENABLED);\n    }\n    _SetJumpthruEnabled(t) {\n      t ? this._flags |= FLAG_JUMPTHRU_ENABLED : this._flags &= ~FLAG_JUMPTHRU_ENABLED;\n    }\n    _IsDrawingWithEffects() {\n      return 0 != (this._flags & FLAG_IS_DRAWING_WITH_EFFECTS);\n    }\n    _SetIsDrawingWithEffects(t) {\n      t ? this._flags |= FLAG_IS_DRAWING_WITH_EFFECTS : this._flags &= ~FLAG_IS_DRAWING_WITH_EFFECTS;\n    }\n    SetFlag(t, e) {\n      t <<= 16, e ? this._flags |= t : this._flags &= ~t;\n    }\n    GetFlag(t) {\n      return 0 != (this._flags & t << 16);\n    }\n    GetCurrentImageInfo() {\n      return this._sdkInst.GetCurrentImageInfo();\n    }\n    GetCurrentSurfaceSize() {\n      return this._sdkInst.GetCurrentSurfaceSize();\n    }\n    GetCurrentTexRect() {\n      return this._sdkInst.GetCurrentTexRect();\n    }\n    GetCurrentTexQuad() {\n      return this._sdkInst.GetCurrentTexQuad();\n    }\n    IsCurrentTexRotated() {\n      return this._sdkInst.IsCurrentTexRotated();\n    }\n    GetImagePoint(t) {\n      return this._sdkInst.GetImagePoint(t);\n    }\n    GetObjectClass() {\n      return this._objectType;\n    }\n    RendersToOwnZPlane() {\n      return this._sdkInst.RendersToOwnZPlane();\n    }\n    BelongsToObjectClass(t) {\n      return t.IsFamily() ? t.FamilyHasMember(this.GetObjectClass()) : this.GetObjectClass() === t;\n    }\n    CollectInstancesToPick(i, t, e) {\n      const s = (t2, e2) => {\n        const s2 = e2 || t2.GetObjectClass(), n = i.get(s2);\n        n ? n.add(t2) : i.set(s2, /* @__PURE__ */ new Set([t2]));\n      };\n      if (s(this, t), this.IsInContainer()) for (const n of this.siblings()) s(n);\n      if (e) for (const r of this.allChildren()) s(r);\n    }\n    VerifySupportsSceneGraph() {\n      if (!this.GetPlugin().SupportsSceneGraph()) throw new Error(\"object does not support scene graph\");\n    }\n    HasParent() {\n      return null !== this.GetParent();\n    }\n    GetParent() {\n      const t = this.GetWorldInfo();\n      if (!t) return null;\n      const e = t.GetParent();\n      return e ? e.GetInstance() : null;\n    }\n    GetTopParent() {\n      const t = this.GetWorldInfo();\n      if (!t) return null;\n      const e = t.GetTopParent();\n      return e ? e.GetInstance() : null;\n    }\n    *parents() {\n      const t = this.GetWorldInfo();\n      if (t) for (const e of t.parents()) yield e.GetInstance();\n    }\n    HasChild(t) {\n      if (t) {\n        for (const e of this.children()) if (e === t) return true;\n      }\n      return false;\n    }\n    HasChildren() {\n      const t = this.GetWorldInfo();\n      return !!t && t.HasChildren();\n    }\n    GetChildrenOfObjectClass(t) {\n      const e = this.GetWorldInfo();\n      if (!e) return [];\n      const s = t.GetName();\n      return e.GetChildren().map((t2) => t2.GetInstance()).filter((t2) => t2.GetObjectClass().GetName() === s);\n    }\n    GetChildren() {\n      const t = this.GetWorldInfo();\n      return t ? t.GetChildren().map((t2) => t2.GetInstance()) : [];\n    }\n    *children() {\n      const t = this.GetWorldInfo();\n      if (t) for (const e of t.children()) yield e.GetInstance();\n    }\n    *allChildren() {\n      const t = this.GetWorldInfo();\n      if (t) for (const e of t.allChildren()) yield e.GetInstance();\n    }\n    GetChildCount() {\n      const t = this.GetWorldInfo();\n      return t ? t.GetChildCount() : 0;\n    }\n    GetParentCount() {\n      return [...this.parents()].length;\n    }\n    GetAllChildCount() {\n      const t = this.GetWorldInfo();\n      return t ? t.GetAllChildCount() : 0;\n    }\n    GetChildAt(t) {\n      const e = this.GetWorldInfo();\n      if (!e) return null;\n      const s = e.GetChildAt(t);\n      return s ? s.GetInstance() : null;\n    }\n    GetIndexInParent() {\n      const t = this.GetWorldInfo();\n      if (!t) return NaN;\n      const e = t.GetParent();\n      return e ? e.GetChildIndex(t) : NaN;\n    }\n    HasChildWithUID(t) {\n      for (const e of this.GetWorldInfo().GetChildren()) if (e.GetInstance().GetUID() === t) return true;\n      return false;\n    }\n    AddChild(t, e) {\n      this.VerifySupportsSceneGraph(), t.VerifySupportsSceneGraph(), this.GetWorldInfo().AddChild(t.GetWorldInfo(), e || {});\n    }\n    RemoveChild(t) {\n      const e = this.GetWorldInfo();\n      e && e.RemoveChild(t.GetWorldInfo());\n    }\n    GetDestroyWithParent() {\n      const t = this.GetWorldInfo();\n      return !!t && t.GetDestroyWithParent();\n    }\n    SetupInitialSceneGraphConnections() {\n      const t = this.GetWorldInfo();\n      if (t) {\n        const e = t.GetSceneGraphChildrenExportData();\n        if (e) for (const s of e) {\n          const n = this._runtime.GetInstanceByUID(s[2]);\n          if (n) {\n            const i = s[3];\n            this.AddChild(n, { transformX: !!(i >> 0 & 1), transformY: !!(i >> 1 & 1), transformWidth: !!(i >> 2 & 1), transformHeight: !!(i >> 3 & 1), transformAngle: !!(i >> 4 & 1), destroyWithParent: !!(i >> 5 & 1), transformZElevation: !!(i >> 6 & 1), transformOpacity: !!(i >> 7 & 1), transformVisibility: !!(i >> 8 & 1) });\n          }\n        }\n      }\n    }\n    SetupPersistedSceneGraphConnections(t, e) {\n      const s = t.get(this);\n      if (s) for (const n of s[\"sceneGraphJson\"][\"children\"]) {\n        const i = e.get(n[\"index\"]);\n        if (i) {\n          const r = n[\"flags\"];\n          this.AddChild(i, { transformX: !!(r >> 0 & 1), transformY: !!(r >> 1 & 1), transformWidth: !!(r >> 2 & 1), transformHeight: !!(r >> 3 & 1), transformAngle: !!(r >> 4 & 1), destroyWithParent: !!(r >> 5 & 1), transformZElevation: !!(r >> 6 & 1), transformOpacity: !!(r >> 7 & 1), transformVisibility: !!(r >> 8 & 1) });\n        }\n      }\n    }\n    GetTemplateName() {\n      const t = this._runtime.GetTemplateManager();\n      return t ? t.GetInstanceTemplateName(this) : \"\";\n    }\n    IsInContainer() {\n      return null !== this._siblings;\n    }\n    _AddSibling(t) {\n      this._siblings.push(t);\n    }\n    GetSiblings() {\n      return this._siblings;\n    }\n    HasSibling(t) {\n      return !!this.GetSibling(t);\n    }\n    GetSibling(t) {\n      const e = this.siblings();\n      if (null === e || 0 === e.length) return false;\n      for (const s of e) if (s.GetObjectClass() === t) return s;\n      return null;\n    }\n    siblings() {\n      return this._siblings;\n    }\n    SetSiblingsSinglePicked() {\n      for (const t of this.siblings()) t.GetObjectClass().GetCurrentSol().SetSinglePicked(t);\n    }\n    _PushSiblingsToSolInstances() {\n      for (const t of this.siblings()) t.GetObjectClass().GetCurrentSol()._PushInstance(t);\n    }\n    _SetSiblingsToSolInstancesIndex(t) {\n      for (const e of this.siblings()) e.GetObjectClass().GetCurrentSol()._GetOwnInstances()[t] = e;\n    }\n    _PushSiblingsToSolElseInstances() {\n      for (const t of this.siblings()) t.GetObjectClass().GetCurrentSol()._PushElseInstance(t);\n    }\n    _SetSiblingsToSolElseInstancesIndex(t) {\n      for (const e of this.siblings()) e.GetObjectClass().GetCurrentSol()._GetOwnElseInstances()[t] = e;\n    }\n    GetPlugin() {\n      return this._objectType.GetPlugin();\n    }\n    _SetIID(t) {\n      this._iid = t;\n    }\n    GetIID() {\n      return this._objectType._UpdateIIDs(), this._iid;\n    }\n    GetUID() {\n      return this._uid;\n    }\n    GetPUID() {\n      return this._puid;\n    }\n    _SetTagsSetFromJson(t) {\n      t ? this.SetTagsSet(new Set(t)) : this._tagsSet = null;\n    }\n    SetTagsSet(t) {\n      if (0 === t.size) this._tagsSet = null;\n      else {\n        this._tagsSet ? this._tagsSet.clear() : this._tagsSet = /* @__PURE__ */ new Set();\n        for (const e of t) this._tagsSet.add(e);\n      }\n    }\n    GetTagsSet() {\n      return this._tagsSet ?? /* @__PURE__ */ new Set();\n    }\n    GetTagsString() {\n      return Array.from(this.GetTagsSet()).join(\" \");\n    }\n    GetTagAt(t) {\n      t = Math.floor(t);\n      for (const e of this.GetTagsSet()) {\n        if (0 === t) return e;\n        --t;\n      }\n      return \"\";\n    }\n    GetBehaviorInstances() {\n      return this._behaviorInstances;\n    }\n    GetBehaviorInstanceFromCtor(t) {\n      if (t) {\n        for (const e of this._behaviorInstances) if (e.GetBehavior() instanceof t) return e;\n      }\n      return null;\n    }\n    GetBehaviorSdkInstanceFromCtor(t) {\n      if (!t) return null;\n      const e = this.GetBehaviorInstanceFromCtor(t);\n      return e ? e.GetSdkInstance() : null;\n    }\n    GetBehaviorIndexBySID(s) {\n      const n = this._behaviorInstances;\n      for (let t = 0, e = n.length; t < e; ++t) if (n[t].GetBehaviorType().GetSID() === s) return t;\n      return -1;\n    }\n    GetAllInstanceVariableValues() {\n      return this._instVarValues;\n    }\n    _GetAllInstanceVariableNames() {\n      return this._objectType._GetAllInstanceVariableNames();\n    }\n    GetInstanceVariableCount() {\n      return this._instVarValues.length;\n    }\n    GetInstanceVariableValue(t) {\n      const e = this._instVarValues;\n      if ((t |= 0) < 0 || t >= e.length) throw new RangeError(\"invalid instance variable\");\n      return e[t];\n    }\n    _GetInstanceVariableValueUnchecked(t) {\n      return this._instVarValues[t];\n    }\n    _GetInstanceVariableTypedValue(t) {\n      const e = this._instVarValues[t];\n      return 0 === this._objectType.GetInstanceVariableType(t) ? !!e : e;\n    }\n    SetInstanceVariableValue(t, e) {\n      const s = this._instVarValues;\n      if ((t |= 0) < 0 || t >= s.length) throw new RangeError(\"invalid instance variable\");\n      const n = this._objectType.GetInstanceVariableType(t);\n      switch (n) {\n        case 0:\n          s[t] = e ? 1 : 0;\n          break;\n        case 1:\n          s[t] = \"number\" == typeof e ? e : parseFloat(e);\n          break;\n        case 2:\n          s[t] = \"string\" == typeof e ? e : e.toString();\n          break;\n        default:\n          throw new Error(\"unknown instance variable type\");\n      }\n    }\n    SetInstanceVariableOffset(t, e) {\n      if (0 !== e) {\n        const s = this._instVarValues;\n        if ((t |= 0) < 0 || t >= s.length) throw new RangeError(\"invalid instance variable\");\n        const n = s[t];\n        if (\"number\" != typeof n) throw \"boolean\" == typeof n ? new Error(\"can not set offset of boolean variable\") : \"string\" == typeof n ? new Error(\"can not set offset of string variable\") : new Error(\"unknown instance variable type\");\n        s[t] += \"number\" == typeof e ? e : parseFloat(e);\n      }\n    }\n    GetSavedDataMap() {\n      let t = savedDataMaps.get(this);\n      return t || (t = /* @__PURE__ */ new Map(), savedDataMaps.set(this, t)), t;\n    }\n    GetUnsavedDataMap() {\n      let t = unsavedDataMaps.get(this);\n      return t || (t = /* @__PURE__ */ new Map(), unsavedDataMaps.set(this, t)), t;\n    }\n    _HasAnyCreateDestroyHandler(t) {\n      const e = this.GetObjectClass();\n      if (e.UserScriptDispatcher().HasAnyHandlerFor(t)) return true;\n      for (const s of e.GetFamilies()) if (s.UserScriptDispatcher().HasAnyHandlerFor(t)) return true;\n      return !!this._runtime.UserScriptDispatcher().HasAnyHandlerFor(t);\n    }\n    _TriggerOnCreatedOnSelfAndRelated() {\n      const t = /* @__PURE__ */ new Set(), e = (t.add(this), this.GetWorldInfo());\n      if (e && e.HasChildren()) {\n        for (const s of this.allChildren()) if (t.add(s), s.IsInContainer()) for (const n of s.siblings()) t.add(n);\n      }\n      if (this.IsInContainer()) for (const i of this.siblings()) t.add(i);\n      for (const r of t.values()) r._TriggerOnCreated();\n      this._OnHierarchyReady();\n    }\n    _OnCreatedCommon() {\n      this._objectType._GetUserScriptInstanceClass() && this.GetInterfaceClass();\n      for (const t of this._behaviorInstances) t.PostCreate();\n    }\n    _OnCreatedForLoadingSavegame() {\n      this._OnCreatedCommon();\n    }\n    _TriggerOnCreated() {\n      if (this._OnCreatedCommon(), this._HasAnyCreateDestroyHandler(\"instancecreate\")) {\n        const t = this.GetObjectClass(), e = new C32.Event(\"instancecreate\");\n        e.instance = this.GetInterfaceClass(), t.DispatchUserScriptEvent(e);\n        for (const s of t.GetFamilies()) s.DispatchUserScriptEvent(e);\n        this._runtime.DispatchUserScriptEvent(e);\n      }\n      this._runtime.Trigger(this.GetPlugin().GetConstructor().Cnds.OnCreated, this, null);\n    }\n    _OnHierarchyReady() {\n      if (this.GetPlugin().SupportsSceneGraph()) {\n        if (this.DispatchUserScriptEvent(new C32.Event(\"hierarchyready\")), this._HasAnyCreateDestroyHandler(\"hierarchyready\")) {\n          const t = this.GetObjectClass(), e = new C32.Event(\"hierarchyready\");\n          e.instance = this.GetInterfaceClass(), t.DispatchUserScriptEvent(e);\n          for (const s of t.GetFamilies()) s.DispatchUserScriptEvent(e);\n          this._runtime.DispatchUserScriptEvent(e);\n        }\n        this._runtime.Trigger(this.GetPlugin().GetConstructor().Cnds.OnHierarchyReady, this, null);\n      }\n    }\n    _TriggerOnDestroyed() {\n      this._runtime.Trigger(this.GetPlugin().GetConstructor().Cnds.OnDestroyed, this, null);\n    }\n    _FireDestroyedScriptEvents(t) {\n      if (this._iScriptInterface) {\n        const e = new C32.Event(\"destroy\");\n        e.isEndingLayout = t, this.DispatchUserScriptEvent(e);\n      }\n      if (this._HasAnyCreateDestroyHandler(\"instancedestroy\")) {\n        const s = this.GetObjectClass(), n = new C32.Event(\"instancedestroy\");\n        n.instance = this.GetInterfaceClass(), n.isEndingLayout = t, s.DispatchUserScriptEvent(n);\n        for (const i of s.GetFamilies()) i.DispatchUserScriptEvent(n);\n        this._runtime.DispatchUserScriptEvent(n);\n      }\n    }\n    _GetDebuggerProperties() {\n      return this._sdkInst ? this._sdkInst.GetDebuggerProperties() : this._iScriptInterface._getDebuggerProperties();\n    }\n    SaveToJson(t = \"full\", e = null) {\n      const s = {}, n = (\"full\" === t ? s[\"uid\"] = this.GetUID() : s[\"c3\"] = true, this.GetTagsSet());\n      if (0 < n.size && (s[\"tags\"] = Array.from(n)), \"visual-state\" !== t) {\n        const r = savedDataMaps.get(this);\n        if (r && r.size && (s[\"ex\"] = C32.ToSuperJSON(r)), -1 !== this.GetTimeScale() && (s[\"mts\"] = this.GetTimeScale()), 0 < this._objectType.GetInstanceVariablesCount()) {\n          const a = {}, o = this._objectType.GetInstanceVariableSIDs();\n          for (let t2 = 0, e2 = this._instVarValues.length; t2 < e2; ++t2) a[o[t2].toString()] = this._instVarValues[t2];\n          s[\"ivs\"] = a;\n        }\n        if (this._behaviorInstances.length) {\n          const l = {};\n          for (const h of this._behaviorInstances) {\n            const c = h.SaveToJson(t);\n            c && (l[h.GetBehaviorType().GetSID().toString()] = c);\n          }\n          s[\"behs\"] = l;\n        }\n      }\n      this._worldInfo && (s[\"w\"] = this._worldInfo._SaveToJson(t, e));\n      const i = this._sdkInst ? this._sdkInst.SaveToJson() : this._iScriptInterface._saveToJson();\n      return i && (s[\"data\"] = i), s;\n    }\n    _OnBeforeLoad(t = \"full\", e) {\n      this._worldInfo && this._worldInfo._OnBeforeLoad(t);\n    }\n    _OnAfterLoad(t, e = \"full\", s = null) {\n      this._worldInfo && this._worldInfo._OnAfterLoad(t, e, s);\n    }\n    _OnAfterLoad2(t, e = \"full\", s = null) {\n      this._worldInfo && this._worldInfo._OnAfterLoad2(t, e, s);\n    }\n    _SetupSceneGraphConnectionsOnChangeOfLayout() {\n      this.GetPlugin().IsWorldType() && this._worldInfo._SetupSceneGraphConnectionsOnChangeOfLayout();\n    }\n    LoadFromJson(e, t = \"full\", s) {\n      if (\"full\" === t) this._uid = e[\"uid\"];\n      else if (!e[\"c3\"]) return;\n      if (this._SetTagsSetFromJson(e[\"tags\"]), \"visual-state\" !== t) {\n        let t2 = savedDataMaps.get(this);\n        t2 && (t2.clear(), savedDataMaps.delete(this));\n        const i = e[\"ex\"], r = (i && (t2 = C32.FromSuperJSON(i), savedDataMaps.set(this, t2)), this._timeScale = e.hasOwnProperty(\"mts\") ? e[\"mts\"] : -1, e[\"ivs\"]);\n        if (r) for (const [a, o] of Object.entries(r)) {\n          const l = parseInt(a, 10), h = this._objectType.GetInstanceVariableIndexBySID(l);\n          if (!(h < 0 || h >= this._instVarValues.length)) {\n            let t3 = o;\n            null === t3 && (t3 = NaN), this._instVarValues[h] = t3;\n          }\n        }\n      }\n      if (this.GetPlugin().IsWorldType()) {\n        const c = e[\"w\"];\n        if (c) {\n          const _ = c[\"l\"];\n          if (this._worldInfo.GetLayer().GetSID() !== _) {\n            const f = this._worldInfo.GetLayer(), d = f.GetLayout().GetLayerBySID(_);\n            d ? (this._worldInfo._SetLayer(d), f._RemoveInstance(this, true), d._AddInstance(this, true), d.SetZIndicesChanged(this), this._worldInfo.SetBboxChanged()) : \"full\" === t && this._runtime.DestroyInstance(this);\n          }\n          this._worldInfo._LoadFromJson(c, t);\n        }\n      }\n      if (\"visual-state\" !== t) {\n        const I = e[\"behs\"];\n        if (I) for (const [u, G] of Object.entries(I)) {\n          const p = parseInt(u, 10), S = this.GetBehaviorIndexBySID(p);\n          S < 0 || S >= this._behaviorInstances.length || this._behaviorInstances[S].LoadFromJson(G, t);\n        }\n      }\n      const n = e[\"data\"];\n      n && (this._sdkInst ? this._sdkInst.LoadFromJson(n, t) : this._iScriptInterface._loadFromJson(n));\n    }\n    GetInterfaceClass() {\n      return this._iScriptInterface || this._InitUserScriptInterface();\n    }\n    HasScriptInterface() {\n      return !!this._iScriptInterface;\n    }\n    _InitUserScriptInterface(t, e) {\n      const s = this._worldInfo ? t ? self.ISDKWorldInstanceBase : self.IWorldInstance : t ? self.ISDKInstanceBase : self.IInstance, n = t || this._sdkInst.GetScriptInterfaceClass(), i = this._objectType._GetUserScriptInstanceClass(), r = i || n || s, a = this.GetPlugin().GetSdkVersion();\n      if (C32.AddonManager._PushInitObject(this, a), C32.AddonManager._PushInitProperties(e), this._iScriptInterface = new r(), C32.AddonManager._PopInitProperties(), C32.AddonManager._PopInitObject(a), n && !(this._iScriptInterface instanceof s)) throw new TypeError(`script interface class '${n.name}' does not extend the right base class '${s.name}'`);\n      if (i) {\n        const o = n || s;\n        if (!(this._iScriptInterface instanceof o)) throw new TypeError(`setInstanceClass(): class '${i.name}' does not extend the right base class - check it extends the right class, e.g. globalThis.InstanceType.MyObjectName`);\n      }\n      return this._iScriptInterface;\n    }\n    _GetInstVarsScriptDescriptor(t) {\n      if (0 !== this._instVarValues.length) {\n        const s = {}, n = this._objectType._GetAllInstanceVariableJsPropNames();\n        for (let t2 = 0, e2 = n.length; t2 < e2; ++t2) s[n[t2]] = { configurable: false, enumerable: true, get: C32.Instance.prototype._GetInstanceVariableTypedValue.bind(this, t2), set: C32.Instance.prototype.SetInstanceVariableValue.bind(this, t2) };\n        const e = Object.create(Object.prototype, s);\n        t.instVars = { value: e, writable: false };\n      }\n    }\n    _GetBehaviorsScriptDescriptor(t) {\n      const e = this._behaviorInstances;\n      if (0 !== e.length) {\n        const s = {};\n        for (const i of e) s[i.GetBehaviorType().GetJsPropName()] = { value: i.GetScriptInterface(), writable: false };\n        const n = Object.create(Object.prototype, s);\n        t.behaviors = { value: n, writable: false };\n      }\n    }\n    DispatchUserScriptEvent(t) {\n      if (this.HasScriptInterface()) {\n        const e = this.GetInterfaceClass(), s = (t.instance = e, this._runtime), n = s.IsDebug() && !s.GetEventSheetManager().IsInEventEngine();\n        n && C3Debugger.StartMeasuringScriptTime(), e.dispatchEvent(t), n && C3Debugger.AddScriptTime();\n      }\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.SceneGraphInfo = class extends C32.DefendedBase {\n    constructor(s) {\n      super(), this._owner = s, this._parent = null, this._children = [], this._startWidth = s.GetWidth(), this._startHeight = s.GetHeight(), this._startScaleX = 1, this._startScaleY = 1, this._parentStartAngle = 0, this._ownOpacity = 1, this._startOpacity = s.GetOpacity(), this._tmpSceneGraphChildren = null, this._tmpSceneGraphChildrenIndexes = null, this._indexInParent = NaN, this._originalSizeKnown = false, this._originalWidth = NaN, this._originalHeight = NaN, this._on_instance_create = (t) => {\n        if (t.instance === this._parent.GetInstance()) {\n          const e = s.GetRuntime(), n = (e.Dispatcher().removeEventListener(\"instancecreate\", this._on_instance_create), this._parent.GetInstance().GetSdkInstance());\n          this._originalSizeKnown = !!n.IsOriginalSizeKnown(), this._originalWidth = this._originalSizeKnown ? n.GetOriginalWidth() : NaN, this._originalHeight = this._originalSizeKnown ? n.GetOriginalHeight() : NaN;\n        }\n      };\n    }\n    Release() {\n      this._parent = null, this._tmpSceneGraphChildren = null, this._tmpSceneGraphChildrenIndexes = null, this._indexInParent = NaN, this._originalSizeKnown = false, this._originalWidth = NaN, this._originalHeight = NaN, C32.clearArray(this._children);\n    }\n    SetParent(t) {\n      if (this._ownOpacity = this._owner.GetOpacity(), this._startOpacity = this._ownOpacity, this._parent = t, this._parentStartAngle = t ? t.GetAngle() : 0, this._parent) {\n        const e = this._owner, n = e.GetRuntime(), s = this._parent.GetInstance().GetPlugin().GetSdkVersion();\n        if (s < 2) {\n          const i = this._parent.GetInstance().GetSdkInstance();\n          i ? (this._originalSizeKnown = !!i.IsOriginalSizeKnown(), this._originalWidth = this._originalSizeKnown ? i.GetOriginalWidth() : NaN, this._originalHeight = this._originalSizeKnown ? i.GetOriginalHeight() : NaN) : this._parent.GetInstance().IsDestroyed() || n.Dispatcher().addEventListener(\"instancecreate\", this._on_instance_create);\n        } else this._originalSizeKnown = false, this._originalWidth = NaN, this._originalHeight = NaN;\n      } else this._originalSizeKnown = false, this._originalWidth = NaN, this._originalHeight = NaN;\n    }\n    GetParent() {\n      return this._parent;\n    }\n    HasChildren() {\n      return 0 < this._children.length;\n    }\n    GetChildren() {\n      return this._children;\n    }\n    _MaybeSortChildren() {\n      this.HasChildren() && 1 !== this._children.length && (this._tmpSceneGraphChildrenIndexes ? this._children.sort((t, e) => {\n        const n = this._tmpSceneGraphChildrenIndexes.get(t.GetInstance()), s = this._tmpSceneGraphChildrenIndexes.get(e.GetInstance());\n        return C32.IsFiniteNumber(n) && C32.IsFiniteNumber(s) ? n - s : 0;\n      }) : this._children.sort((t, e) => {\n        const n = t._GetSceneGraphInfo()._GetIndexInParent(), s = e._GetSceneGraphInfo()._GetIndexInParent();\n        return C32.IsFiniteNumber(n) && C32.IsFiniteNumber(s) ? n - s : 0;\n      }));\n    }\n    _GetIndexInParent() {\n      return this._indexInParent;\n    }\n    GetStartScaleX() {\n      return this._startScaleX;\n    }\n    SetStartScaleX(t) {\n      this._startScaleX = t;\n    }\n    GetStartScaleY() {\n      return this._startScaleY;\n    }\n    SetStartScaleY(t) {\n      this._startScaleY = t;\n    }\n    GetStartOpacity() {\n      return this._startOpacity;\n    }\n    GetOwnOpacity() {\n      return this._ownOpacity;\n    }\n    SetOwnOpacity(t) {\n      this._ownOpacity = t;\n    }\n    _GetStartWidth() {\n      return 0 === this._startWidth ? Number.EPSILON : this._startWidth;\n    }\n    _GetStartHeight() {\n      return 0 === this._startHeight ? Number.EPSILON : this._startHeight;\n    }\n    GetParentScaleX() {\n      if (this._owner.GetTransformWithParentWidth()) {\n        const n = this._parent;\n        let t = n.GetWidth(), e = n._GetSceneGraphInfo()._GetStartWidth();\n        return 0 === t && (t = Number.EPSILON), e === Number.EPSILON && t === Number.EPSILON ? 1 : e === Number.EPSILON && t !== Number.EPSILON && this._originalSizeKnown ? 1 + t / this._originalWidth : t / e;\n      }\n      return 1;\n    }\n    GetParentScaleY() {\n      if (this._owner.GetTransformWithParentHeight()) {\n        const n = this._parent;\n        let t = n.GetHeight(), e = n._GetSceneGraphInfo()._GetStartHeight();\n        return 0 === t && (t = Number.EPSILON), e === Number.EPSILON && t === Number.EPSILON ? 1 : e === Number.EPSILON && t !== Number.EPSILON && this._originalSizeKnown ? 1 + t / this._originalHeight : t / e;\n      }\n      return 1;\n    }\n    GetParentStartAngle() {\n      return 0;\n    }\n    _SaveToJsonProperties() {\n      return { \"sw\": this._startWidth, \"sh\": this._startHeight, \"sx\": this._startScaleX, \"sy\": this._startScaleY, \"psa\": this._parentStartAngle, \"oo\": this._ownOpacity, \"so\": this._startOpacity, \"pi\": this._owner.GetInstance().GetIndexInParent() };\n    }\n    _SaveToJson(t, e = null) {\n      const n = this._SaveToJsonProperties();\n      return e && e[\"selfOnly\"] ? Object.assign(n, { \"p\": null, \"c\": [] }) : Object.assign(n, { \"p\": this._GetParentJson(t), \"c\": this._GetChildrenJson(t) });\n    }\n    _GetFlagsString(t) {\n      let e = \"\";\n      return t.GetTransformWithParentX() && (e += \"x\"), t.GetTransformWithParentY() && (e += \"y\"), t.GetTransformWithParentWidth() && (e += \"w\"), t.GetTransformWithParentHeight() && (e += \"h\"), t.GetTransformWithParentAngle() && (e += \"a\"), t.GetTransformWithParentZElevation() && (e += \"z\"), t.GetDestroyWithParent() && (e += \"d\"), t.GetTransformWithParentOpacity() && (e += \"o\"), t.GetTransformWithParentVisibility() && (e += \"v\"), e;\n    }\n    _GetParentJson(t) {\n      return !this._parent || !this._parent.GetInstance() || this._parent.GetInstance().IsDestroyed() ? null : this._GetInstanceJson(this._parent, this._owner, t);\n    }\n    _GetChildrenJson(e) {\n      return this._children.map((t) => this._GetInstanceJson(t, t, e)).filter((t) => t);\n    }\n    _GetInstanceJson(t, e, n) {\n      const s = t.GetInstance();\n      if (s && s.IsDestroyed()) return null;\n      const i = {};\n      return i[\"uid\"] = s.GetUID(), i[\"f\"] = this._GetFlagsString(e), i[\"offsets\"] = e._SaveSceneGraphPropertiesToJson(), i[\"data\"] = C32.SceneGraphInfo.GetSceneGraphInstanceDataFromInstance(s), i[\"oci\"] = s.GetObjectClass().GetIndex(), \"state\" === n ? (i[\"inst\"] = s.SaveToJson(\"full\", { \"selfOnly\": true }), i[\"instIndex\"] = NaN) : (i[\"instIndex\"] = s.GetObjectClass().GetInstances().indexOf(s), i[\"inst\"] = null), i;\n    }\n    _LoadFromJson(t) {\n      this._startWidth = t[\"sw\"], this._startHeight = t[\"sh\"], this._startScaleX = t[\"sx\"], this._startScaleY = t[\"sy\"], this._parentStartAngle = t[\"psa\"], this._ownOpacity = t[\"oo\"], this._startOpacity = t[\"so\"], this._indexInParent = C32.IsFiniteNumber(t[\"pi\"]) ? t[\"pi\"] : NaN;\n    }\n    _SetTmpSceneGraphChildren(t, e) {\n      if (!t && !e && this._tmpSceneGraphChildren) for (const n of this._tmpSceneGraphChildren) n.IsDestroyed() || n.HasParent() || n.GetRuntime().DestroyInstance(n);\n      this._tmpSceneGraphChildren = t, this._tmpSceneGraphChildrenIndexes = e;\n    }\n    _OnAfterLoad(t, e) {\n      const n = this._owner, s = n.GetRuntime(), i = /* @__PURE__ */ new Set();\n      if (t[\"p\"] && !this._parent) {\n        const h = t[\"p\"][\"uid\"], o = s.GetInstanceByUID(h);\n        if (e?.setFromJson, o) {\n          const c = o.GetWorldInfo();\n          if (o.HasChild(n.GetInstance())) this._parent = c;\n          else {\n            o.HasChildWithUID(n.GetInstance().GetUID()) ? s.DestroyInstance(n.GetInstance()) : o.AddChild(n.GetInstance(), this._GetFlagsObj(t[\"p\"][\"f\"])), i.has(n) || (n._LoadSceneGraphPropertiesFromJson(t[\"p\"][\"offsets\"]), this._LoadInstancePropertiesFromJson(o, t[\"p\"], e)), i.add(n);\n            const l = o.GetWorldInfo();\n            l._GetSceneGraphInfo()._MaybeSortChildren();\n          }\n        } else if (C32.IsFiniteNumber(t[\"p\"][\"oci\"])) {\n          const d = s.GetObjectClassByIndex(t[\"p\"][\"oci\"]), G = (s.GetSystemPlugin(), s.CreateInstance(d, n.GetLayer(), 0, 0, true));\n          if (e?.setFromJson, G) {\n            const _ = this._GetInstanceData(t[\"p\"], s), I = (_ && G.LoadFromJson(_), G.GetWorldInfo()), p = (I.GetLayer().SortAndAddInstancesByZIndex(G), G.AddChild(n.GetInstance(), this._GetFlagsObj(t[\"p\"][\"f\"])), G.GetWorldInfo());\n            p._GetSceneGraphInfo()._MaybeSortChildren();\n          }\n        }\n      }\n      const r = [];\n      for (const S of t[\"c\"]) {\n        const f = S[\"uid\"], u = s.GetInstanceByUID(f);\n        u && r.push(u);\n      }\n      let a = 0;\n      for (const m of t[\"c\"]) {\n        const C = m[\"uid\"], N = s.GetInstanceByUID(C);\n        if (e?.setFromJson, N) {\n          if (this._tmpSceneGraphChildren) {\n            if (this._tmpSceneGraphChildren.includes(N)) {\n              const P = N;\n              if (P.GetObjectClass() !== N.GetObjectClass()) {\n                a++;\n                continue;\n              }\n              if (P.IsDestroyed()) {\n                a++;\n                continue;\n              }\n              const b = t[\"c\"][a];\n              if (!e?.setFromJson && this._HasAllChildrenOfType(P, r, n)) {\n                this._UpdateInstance(a, b, n, i, e), a++;\n                continue;\n              }\n              if (P.HasParent() && P.GetParent() !== n.GetInstance()) {\n                const W = this._CreateNewChildInstance(b, e);\n                this._AddAndSetChildInstance(W, b, i, e), a++;\n                continue;\n              }\n              this._AddAndSetChildInstance(P.GetWorldInfo(), b, i, e, true), a++;\n              continue;\n            }\n            if (this._tmpSceneGraphChildren[a]) {\n              const w = this._tmpSceneGraphChildren[a];\n              if (w.GetObjectClass() !== N.GetObjectClass()) {\n                a++;\n                continue;\n              }\n              if (w.IsDestroyed()) {\n                a++;\n                continue;\n              }\n              const A = t[\"c\"][a];\n              if (!e?.setFromJson && this._HasAllChildrenOfType(w, r, n)) {\n                this._UpdateInstance(a, A, n, i, e), a++;\n                continue;\n              }\n              if (w.HasParent() && w.GetParent() !== n.GetInstance()) {\n                const F = this._CreateNewChildInstance(A, e);\n                this._AddAndSetChildInstance(F, A, i, e), a++;\n                continue;\n              }\n              this._AddAndSetChildInstance(w.GetWorldInfo(), A, i, e, true), a++;\n              continue;\n            }\n          }\n          const g = N.GetObjectClass(), O = this._GetInstancesOfObjectClassCount(r, g), y = n.GetInstance().GetChildrenOfObjectClass(g).length;\n          if (O === y) {\n            const J = n.GetInstance().GetChildAt(a);\n            if (J) {\n              const L = J.GetWorldInfo();\n              L && (i.has(L) || (L._LoadSceneGraphPropertiesFromJson(m[\"offsets\"]), this._LoadInstancePropertiesFromJson(J, m, e)), i.add(L));\n            }\n            a++;\n            continue;\n          }\n          if (N.HasParent() && N.GetParent() !== n.GetInstance()) {\n            const x = this._CreateNewChildInstance(m, e);\n            this._AddAndSetChildInstance(x, m, i, e), a++;\n            continue;\n          }\n          this._AddAndSetChildInstance(N.GetWorldInfo(), m, i, e);\n        } else if (this._tmpSceneGraphChildren && this._tmpSceneGraphChildren[a]) {\n          const H = this._tmpSceneGraphChildren[a], j = s.GetObjectClassByIndex(this._GetObjectClassIndex(m));\n          if (H.GetObjectClass() !== j) {\n            a++;\n            continue;\n          }\n          if (H.IsDestroyed()) {\n            a++;\n            continue;\n          }\n          const D = t[\"c\"][a];\n          if (!e?.setFromJson && this._HasAllChildrenOfType(H, r, n)) {\n            this._UpdateInstance(a, D, n, i, e), a++;\n            continue;\n          }\n          if (H.HasParent() && H.GetParent() !== n.GetInstance()) {\n            const T = this._CreateNewChildInstance(D, e);\n            this._AddAndSetChildInstance(T, D, i, e), a++;\n            continue;\n          }\n          this._AddAndSetChildInstance(H.GetWorldInfo(), D, i, e);\n        } else {\n          const E = this._CreateNewChildInstance(m, e);\n          this._AddAndSetChildInstance(E, m, i, e);\n        }\n        a++;\n      }\n    }\n    _HasAllChildrenOfType(t, e, n) {\n      const s = t.GetObjectClass(), i = this._GetInstancesOfObjectClassCount(e, s), r = n.GetInstance().GetChildrenOfObjectClass(s).length;\n      return i === r;\n    }\n    _UpdateInstance(t, e, n, s, i) {\n      const r = n.GetInstance().GetChildAt(t, e);\n      if (r) {\n        const a = r.GetWorldInfo();\n        a && (s.has(a) || (a._LoadSceneGraphPropertiesFromJson(e[\"offsets\"]), this._LoadInstancePropertiesFromJson(r, e, i)), s.add(a));\n      }\n    }\n    _GetFlagsObj(t) {\n      const e = {};\n      return e.transformX = t.includes(\"x\"), e.transformY = t.includes(\"y\"), e.transformWidth = t.includes(\"w\"), e.transformHeight = t.includes(\"h\"), e.transformAngle = t.includes(\"a\"), e.transformZElevation = t.includes(\"z\"), e.destroyWithParent = t.includes(\"d\"), e.transformOpacity = t.includes(\"o\"), e.transformVisibility = t.includes(\"v\"), e;\n    }\n    _GetObjectClassIndex(t) {\n      return C32.IsFiniteNumber(t[\"oci\"]) ? t[\"oci\"] : t[1];\n    }\n    _CreateNewChildInstance(e, n) {\n      if (C32.IsFiniteNumber(e[\"oci\"])) {\n        const s = this._owner, i = s.GetRuntime();\n        let t;\n        if (e[\"data\"]) t = i.CreateInstanceFromData(e[\"data\"], s.GetLayer(), false, 0, 0, false, true);\n        else {\n          const r = i.GetObjectClassByIndex(e[\"oci\"]);\n          t = i.CreateInstance(r, s.GetLayer(), 0, 0, true);\n        }\n        if (n?.setFromJson, t) {\n          const a = this._GetInstanceData(e, i), h = (a && t.LoadFromJson(a), t.GetWorldInfo());\n          return h.GetLayer().SortAndAddInstancesByZIndex(t, true), h;\n        }\n      }\n    }\n    _AddAndSetChildInstance(t, e, n, s, i = true) {\n      const r = this._owner, a = r.AddChild(t, this._GetFlagsObj(e[\"f\"]));\n      a && i && (n.has(t) || (t._LoadSceneGraphPropertiesFromJson(e[\"offsets\"]), this._LoadInstancePropertiesFromJson(t.GetInstance(), e, s)), n.add(t)), this._MaybeSortChildren();\n    }\n    _LoadInstancePropertiesFromJson(t, e, n) {\n      let s = this._GetInstanceData(e, this._owner.GetRuntime());\n      s && ((s = JSON.parse(JSON.stringify(s)))[\"w\"] = null, t.LoadFromJson(s));\n    }\n    _GetInstancesOfObjectClassCount(t, e) {\n      return t.filter((t2) => t2.GetObjectClass().GetName() === e.GetName()).length;\n    }\n    _GetInstanceData(t, e) {\n      if (C32.IsFiniteNumber(t[\"instIndex\"])) {\n        const n = e.GetObjectClassByIndex(t[\"oci\"]), s = n._GetLoadInstancesJson();\n        return s ? s[t[\"instIndex\"]] : null;\n      }\n      return C32.IsString(t[\"inst\"]) ? JSON.parse(t[\"inst\"]) : t[\"inst\"] || void 0;\n    }\n    static GetSceneGraphInstanceDataFromInstance(t) {\n      let e = t.GetWorldInfo().GetLayer().GetInitialInstanceData(t.GetUID());\n      if (!e) return null;\n      e = JSON.parse(JSON.stringify(e));\n      const n = [];\n      for (const s of [...t.GetChildren()]) {\n        const i = s.GetWorldInfo();\n        n.push([i.GetLayout().GetSID(), i.GetLayer().GetIndex(), s.GetUID(), C32.SceneGraphInfo._GetFlagsNumber(i), s.GetObjectClass().IsInContainer() ? 1 : 0, i.GetZIndex(), C32.SceneGraphInfo.GetSceneGraphInstanceDataFromInstance(s)]);\n      }\n      return C32.IsArray(e[0][14]) ? e[0][14][1] = n : (e[0][14] = [], e[0][14][0] = C32.SceneGraphInfo._GetDefaultFlagsNumber(), e[0][14][1] = n, e[0][14][2] = t.GetWorldInfo().GetZIndex()), e;\n    }\n    static _GetFlagsNumber(t) {\n      let e = 0;\n      return (e |= Number(t.GetTransformWithParentVisibility()) << 8) | Number(t.GetTransformWithParentOpacity()) << 7 | Number(t.GetTransformWithParentZElevation()) << 6 | Number(t.GetDestroyWithParent()) << 5 | Number(t.GetTransformWithParentAngle()) << 4 | Number(t.GetTransformWithParentHeight()) << 3 | Number(t.GetTransformWithParentWidth()) << 2 | Number(t.GetTransformWithParentY()) << 1 | Number(t.GetTransformWithParentX()) << 0;\n    }\n    static _GetDefaultFlagsNumber(t) {\n      let e = 0;\n      return (e |= 256) | 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1, 511;\n    }\n  };\n}\n{\n  const C32 = self.C3, glMatrix = self.glMatrix, vec3 = glMatrix.vec3, vec4 = glMatrix.vec4, tempRect = C32.New(C32.Rect), tempQuad = C32.New(C32.Quad), bboxChangeEvent = C32.New(C32.Event, \"bboxchange\", false), tempColor = C32.New(C32.Color, 0, 0, 0, 0), tempCollisionPoly = C32.New(C32.CollisionPoly), DEFAULT_COLOR = C32.New(C32.Color, 1, 1, 1, 1), DEFAULT_RENDER_CELLS = C32.New(C32.Rect, 0, 0, -1, -1), DEFAULT_COLLISION_CELLS = C32.New(C32.Rect, 0, 0, -1, -1), VALID_SET_MESH_POINT_MODES = /* @__PURE__ */ new Set([\"absolute\", \"relative\"]), EMPTY_ARRAY = [];\n  let enableUpdateRendererStateGroup = true;\n  const FLAG_IS_VISIBLE = 1, FLAG_BBOX_CHANGED = 2, FLAG_ENABLE_BBOX_CHANGED_EVENT = 4, FLAG_COLLISION_ENABLED = 8, FLAG_COLLISION_CELL_CHANGED = 16, FLAG_SOLID_FILTER_INCLUSIVE = 32, FLAG_HAS_ANY_ACTIVE_EFFECT = 64, FLAG_IS_ROTATABLE = 128, FLAG_DESTROYED = 256, FLAG_DESTROY_WITH_PARENT = 512, FLAG_TRANSFORM_WITH_PARENT_X = 1024, FLAG_TRANSFORM_WITH_PARENT_Y = 2048, FLAG_TRANSFORM_WITH_PARENT_W = 4096, FLAG_TRANSFORM_WITH_PARENT_H = 8192, FLAG_TRANSFORM_WITH_PARENT_A = 16384, FLAG_TRANSFORM_WITH_PARENT_Z_ELEVATION = 32768, FLAG_TRANSFORM_WITH_PARENT_OPACITY = 1 << 22, FLAG_TRANSFORM_WITH_PARENT_VISIBILITY = 1 << 23, MASK_ALL_SCENE_GRAPH_FLAGS = FLAG_DESTROY_WITH_PARENT | FLAG_TRANSFORM_WITH_PARENT_X | FLAG_TRANSFORM_WITH_PARENT_Y | FLAG_TRANSFORM_WITH_PARENT_W | FLAG_TRANSFORM_WITH_PARENT_H | FLAG_TRANSFORM_WITH_PARENT_A | FLAG_TRANSFORM_WITH_PARENT_Z_ELEVATION | FLAG_TRANSFORM_WITH_PARENT_OPACITY | FLAG_TRANSFORM_WITH_PARENT_VISIBILITY, FLAG_MESH_CHANGED = 65536, FLAG_PHYSICS_BODY_CHANGED = 1 << 17, FLAG_SIN_COS_ANGLE_CHANGED = 1 << 18, FLAG_USE_POINTS_SHADER_PROGRAM = 1 << 19, FLAG_DRAW_BACK_FACE_ONLY = 1 << 20, FLAG_DRAW_NON_BACK_FACES_ONLY = 1 << 21, FLAG_BLEND_MODE_BIT_OFFSET = 26, FLAG_BLEND_MODE_MASK = 31 << FLAG_BLEND_MODE_BIT_OFFSET, sceneGraphExportDataMap = /* @__PURE__ */ new WeakMap(), sceneGraphZIndexMap = /* @__PURE__ */ new WeakMap();\n  C32.WorldInfo = class extends C32.DefendedBase {\n    constructor(t, e) {\n      super(), this._inst = t, this._objectClass = t.GetObjectClass(), this._runtime = t.GetRuntime(), this._layer = e, this._objectClass._OnWorldInstanceLayerChanged(this, null, e), this._zIndex = -1, this._htmlZIndex = -1, this._flags = FLAG_IS_VISIBLE | FLAG_BBOX_CHANGED | FLAG_COLLISION_ENABLED | FLAG_COLLISION_CELL_CHANGED | FLAG_MESH_CHANGED | FLAG_PHYSICS_BODY_CHANGED, this._objectClass.GetPlugin().IsRotatable() && (this._flags |= FLAG_IS_ROTATABLE), this._x = NaN, this._y = NaN, this._zElevation = NaN, this._w = NaN, this._h = NaN, this._depth = NaN, this._a = NaN, this._sinA = NaN, this._cosA = NaN, this._ox = NaN, this._oy = NaN, this._boundingBox = C32.New(C32.Rect), this._boundingQuad = C32.New(C32.Quad), this._collisionCells = DEFAULT_COLLISION_CELLS, this._renderCells = DEFAULT_RENDER_CELLS, this._sourceCollisionPoly = null, this._transformedPolyInfo = null, this._solidFilterTags = null, this._color = DEFAULT_COLOR, this._colorPremultiplied = DEFAULT_COLOR, this._stateGroup = null, this._instanceEffectList = null, this._inst.GetObjectClass().UsesEffects() && (this._instanceEffectList = C32.New(C32.InstanceEffectList, this._inst, this)), this._sceneGraphInfo = null, this._tmpSceneGraphChildren = null, this._tmpSceneGraphChildrenIndexes = null, this._tmpHierarchyPosition = -1, this._meshInfo = null;\n    }\n    _MarkDestroyed() {\n      this._flags |= FLAG_DESTROYED;\n    }\n    Release() {\n      if (this._objectClass._OnWorldInstanceLayerChanged(this, this._layer, null), this._stateGroup && (this._runtime.GetRenderer().ReleaseStateGroup(this._stateGroup), this._stateGroup = null), this._sourceCollisionPoly = null, this._transformedPolyInfo && (this._transformedPolyInfo.poly.Release(), this._transformedPolyInfo = null), this._solidFilterTags && (this._solidFilterTags.clear(), this._solidFilterTags = null), this.ReleaseMesh(), this._instanceEffectList && this._instanceEffectList.Release(), this.HasParent() && this.GetParent().RemoveChild(this), this.HasChildren()) {\n        const t = [...this.GetChildren()];\n        for (const e of t) this.RemoveChild(e);\n      }\n      this._ReleaseSceneGraphInfo(), this._ReleaseTmpSceneGraphInfo(), sceneGraphExportDataMap.delete(this), sceneGraphZIndexMap.delete(this), this._inst = null, this._objectClass = null, this._runtime = null, this._layer = null;\n    }\n    Init(t) {\n      if (enableUpdateRendererStateGroup = false, this.SetXY(t[0], t[1]), this.SetZElevation(t[2]), this.SetSize(t[3], t[4]), this._depth = 0, this.IsRotatable() ? this.SetAngle(t[6]) : this._a = 0, tempColor.setFromJSON(t[7]), this._SetColor(tempColor), this.SetOriginX(t[8]), this.SetOriginY(t[9]), this.SetBlendMode(t[10]), this._instanceEffectList && this._instanceEffectList._LoadEffectParameters(t[12]), t[14] && sceneGraphExportDataMap.set(this, { childrenData: t[14][1], zIndexData: t[14][2] }), t[15]) {\n        const e = t[15], i = (this.CreateMesh(e[0], e[1]), this.GetSourceMesh()), n = e[2];\n        for (let s = 0, t2 = n.length; s < t2; ++s) {\n          const r = n[s];\n          for (let t3 = 0, e2 = r.length; t3 < e2; ++t3) {\n            const h = r[t3], a = i.GetMeshPointAt(t3, s);\n            a.SetX(h[0]), a.SetY(h[1]), a.SetZElevation(h[2]), a.SetU(h[3]), a.SetV(h[4]);\n          }\n        }\n      }\n      if (t[16]) {\n        const s = t[16][0], o = t[16][1], l = !!o, _ = !l, G = this._runtime.GetTemplateManager();\n        l && G && G.MapInstanceToTemplateName(this.GetInstance(), o), _ && G && G.MapInstanceToTemplateName(this.GetInstance(), s);\n      }\n      enableUpdateRendererStateGroup = true, this._UpdateRendererStateGroup();\n    }\n    InitNoData() {\n      this._x = 0, this._y = 0, this._zElevation = 0, this._w = 0, this._h = 0, this._depth = 0, this._a = 0, this._sinA = 0, this._cosA = 1, this._ox = 0, this._oy = 0, this._UpdateRendererStateGroup();\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetObjectClass() {\n      return this._objectClass;\n    }\n    GetInstance() {\n      return this._inst;\n    }\n    _GetParentOffsetAngle() {\n      return this.GetTransformWithParentAngle() ? this._MaybeReflectAngleForMirrorFlip(this.GetParent()._GetAngleNoReflect() - this._sceneGraphInfo.GetParentStartAngle()) : 0;\n    }\n    SetX(t) {\n      if (t = +t, this.GetTransformWithParentX()) {\n        const e = this._sceneGraphInfo, s = t - this.GetX(), i = -this._GetParentOffsetAngle();\n        0 == i ? this._x += s / e.GetParentScaleX() : (this._x += Math.cos(i) * s / e.GetParentScaleX(), this.GetTransformWithParentY() && (this._y += Math.sin(i) * s / e.GetParentScaleY()));\n      } else this._x = t;\n    }\n    OffsetX(t, e = false) {\n      t = +t, !e && this.GetTransformWithParentX() ? this.SetX(this.GetX() + t) : this._x += t;\n    }\n    GetX() {\n      if (this.GetTransformWithParentX()) {\n        let t = this._x;\n        const e = this._sceneGraphInfo, s = this.GetParent(), i = this._GetParentOffsetAngle();\n        return 0 === i ? t *= e.GetParentScaleX() : (t = t * e.GetParentScaleX() * Math.cos(i), this.GetTransformWithParentY() && (t -= this._y * e.GetParentScaleY() * Math.sin(i))), s.GetX() + t;\n      }\n      return this._x;\n    }\n    SetY(t) {\n      if (t = +t, this.GetTransformWithParentY()) {\n        const e = this._sceneGraphInfo, s = t - this.GetY(), i = -this._GetParentOffsetAngle();\n        0 == i ? this._y += s / e.GetParentScaleY() : (this.GetTransformWithParentX() && (this._x -= Math.sin(i) * s / e.GetParentScaleX()), this._y += Math.cos(i) * s / e.GetParentScaleY());\n      } else this._y = t;\n    }\n    OffsetY(t, e = false) {\n      t = +t, !e && this.GetTransformWithParentY() ? this.SetY(this.GetY() + t) : this._y += t;\n    }\n    GetY() {\n      if (this.GetTransformWithParentY()) {\n        let t = this._y;\n        const e = this._sceneGraphInfo, s = this.GetParent(), i = this._GetParentOffsetAngle();\n        return 0 === i ? t *= e.GetParentScaleY() : (t = t * e.GetParentScaleY() * Math.cos(i), this.GetTransformWithParentX() && (t += this._x * e.GetParentScaleX() * Math.sin(i))), s.GetY() + t;\n      }\n      return this._y;\n    }\n    SetXY(t, e) {\n      if (t = +t, e = +e, this.GetTransformWithParentXOrY()) {\n        const s = this.GetTransformWithParentX(), i = this.GetTransformWithParentY(), n = this._sceneGraphInfo, r = t - this.GetX(), h = e - this.GetY(), a = -this._GetParentOffsetAngle();\n        if (0 == a) s ? this._x += r / n.GetParentScaleX() : this._x = t, i ? this._y += h / n.GetParentScaleY() : this._y = e;\n        else {\n          const o = Math.sin(a), l = Math.cos(a);\n          s ? this._x += i ? (l * r - o * h) / n.GetParentScaleX() : l * r / n.GetParentScaleX() : this._x = t, i ? this._y += s ? (o * r + l * h) / n.GetParentScaleY() : l * h / n.GetParentScaleY() : this._y = e;\n        }\n      } else this._x = t, this._y = e;\n    }\n    GetXY() {\n      return [this.GetX(), this.GetY()];\n    }\n    OffsetXY(t, e) {\n      t = +t, e = +e, this.GetTransformWithParentXOrY() ? this.SetXY(this.GetX() + t, this.GetY() + e) : (this._x += t, this._y += e);\n    }\n    EqualsXY(t, e) {\n      return this.GetX() === t && this.GetY() === e;\n    }\n    SetZElevation(t) {\n      if (t = +t, this.GetTransformWithParentZElevation() && (t -= this.GetParent().GetZElevation()), this._zElevation !== t) {\n        this._zElevation = t, this._UpdateZElevation();\n        const e = this.GetLayer();\n        0 !== this._zElevation && e._SetAnyInstanceZElevated(), e.SetZIndicesChanged(this);\n      }\n    }\n    _UpdateZElevation() {\n      if (this._UpdateRendererStateGroup(), this.HasChildren()) {\n        const s = this.GetChildren();\n        for (let t = 0, e = s.length; t < e; t++) {\n          const i = s[t];\n          i.GetTransformWithParentZElevation() && i._UpdateZElevation();\n        }\n      }\n    }\n    OffsetZElevation(t) {\n      this.SetZElevation(this.GetZElevation() + t);\n    }\n    GetZElevation() {\n      return this.GetTransformWithParentZElevation() ? this.GetParent().GetZElevation() + this._zElevation : this._zElevation;\n    }\n    GetTotalZElevation() {\n      return this.GetLayer().GetZElevation() + this.GetZElevation();\n    }\n    IsOriginalSizeKnown() {\n      const t = this.GetInstance().GetPlugin().GetSdkVersion();\n      return t < 2 && this.GetInstance().GetSdkInstance().IsOriginalSizeKnown();\n    }\n    SetWidth(t) {\n      if (t = +t, this.GetTransformWithParentWidth()) {\n        const e = this.GetWidth();\n        0 === e ? this._w = Number.EPSILON : this._w *= t / e;\n      } else this._w = t;\n      this._MarkSinCosAngleChanged();\n    }\n    OffsetWidth(t, e) {\n      t = +t, !e && this.GetTransformWithParentWidth() ? this.SetWidth(this.GetWidth() + t) : this._w += t, this._MarkSinCosAngleChanged();\n    }\n    GetWidth() {\n      if (this.GetTransformWithParentWidth()) {\n        const t = this.GetParent(), e = t.GetWidth(), s = t._GetSceneGraphInfo()._GetStartWidth();\n        return s === Number.EPSILON ? (this._GetSceneGraphInfo()._GetStartWidth() + e) * this._w : e * this._w;\n      }\n      return this._w;\n    }\n    SetHeight(t) {\n      if (t = +t, this.GetTransformWithParentHeight()) {\n        const e = this.GetHeight();\n        0 === e ? this._h = Number.EPSILON : this._h *= t / e;\n      } else this._h = t;\n      this._MarkSinCosAngleChanged();\n    }\n    OffsetHeight(t, e) {\n      t = +t, !e && this.GetTransformWithParentHeight() ? this.SetHeight(this.GetHeight() + t) : this._h += t, this._MarkSinCosAngleChanged();\n    }\n    GetHeight() {\n      if (this.GetTransformWithParentHeight()) {\n        const t = this.GetParent(), e = t.GetHeight(), s = t._GetSceneGraphInfo()._GetStartHeight();\n        return s === Number.EPSILON ? (this._GetSceneGraphInfo()._GetStartHeight() + e) * this._h : e * this._h;\n      }\n      return this._h;\n    }\n    SetSize(t, e) {\n      if (t = +t, e = +e, this.GetTransformWithParentWidth()) {\n        const s = this.GetWidth();\n        0 === s ? this._w = Number.EPSILON : this._w *= t / s;\n      } else this._w = t;\n      if (this.GetTransformWithParentHeight()) {\n        const i = this.GetHeight();\n        0 === i ? this._h = Number.EPSILON : this._h *= e / i;\n      } else this._h = e;\n      this._MarkSinCosAngleChanged();\n    }\n    GetSize() {\n      return [this.GetWidth(), this.GetHeight()];\n    }\n    GetDepth() {\n      return this._depth;\n    }\n    SetDepth(t) {\n      if (t < 0) throw new RangeError(\"invalid depth\");\n      this._depth = t;\n    }\n    GetSceneGraphScale() {\n      if (this.HasParent()) {\n        const t = this._sceneGraphInfo;\n        return Math.min(t.GetParentScaleX(), t.GetParentScaleY());\n      }\n      return 1;\n    }\n    IsRotatable() {\n      return 0 != (this._flags & FLAG_IS_ROTATABLE);\n    }\n    SetAngle(t) {\n      t = +t, this.IsRotatable() && (this.GetTransformWithParentAngle() && (t -= this.GetParent().GetAngle()), t = C32.clampAngle(t), this._a !== t) && (this._a = t, this._MarkSinCosAngleChanged());\n    }\n    OffsetAngle(t) {\n      0 !== (t = +t) && this.IsRotatable() && (this._a = C32.clampAngle(this._a + t), this._MarkSinCosAngleChanged());\n    }\n    _MarkSinCosAngleChanged() {\n      if (this._flags |= FLAG_SIN_COS_ANGLE_CHANGED, this.HasChildren()) {\n        const s = this.GetChildren();\n        for (let t = 0, e = s.length; t < e; t++) s[t]._MarkSinCosAngleChanged();\n      }\n    }\n    GetAngle() {\n      return this.GetTransformWithParentAngle() && this.IsRotatable() ? this._MaybeReflectAngleForMirrorFlip(C32.clampAngle(this.GetParent()._GetAngleNoReflect() + this._a)) : this._a;\n    }\n    _GetAngleNoReflect() {\n      return this.GetTransformWithParentAngle() && this.IsRotatable() ? C32.clampAngle(this.GetParent()._GetAngleNoReflect() + this._a) : this._a;\n    }\n    _MaybeReflectAngleForMirrorFlip(t) {\n      return this.GetTransformWithParentWidth() && this.GetTopParent().GetWidth() < 0 && (t = C32.clampAngle(C32.angleReflect(t, this.GetTopParent().GetAngle() + Math.PI))), t = this.GetTransformWithParentHeight() && this.GetTopParent().GetHeight() < 0 ? C32.angleReflect(t, this.GetTopParent().GetAngle()) : t;\n    }\n    _NeedsReflectAngleForMirrorOrFlip() {\n      const t = this.GetParent();\n      return !!(this.GetTransformWithParentWidth() && t.GetWidth() < 0) || !!(this.GetTransformWithParentHeight() && t.GetHeight() < 0);\n    }\n    _NeedsReflectAngleForMirrorAndFlip() {\n      const t = this.GetParent();\n      return !!(this.GetTransformWithParentWidth() && t.GetWidth() < 0 && this.GetTransformWithParentHeight() && t.GetHeight() < 0);\n    }\n    _MaybeUpdateSinCosAngle() {\n      const t = this._flags;\n      if (0 != (t & FLAG_SIN_COS_ANGLE_CHANGED)) {\n        const e = this.GetAngle();\n        this._sinA = Math.sin(e), this._cosA = Math.cos(e), this._flags = t & ~FLAG_SIN_COS_ANGLE_CHANGED;\n      }\n    }\n    GetSinAngle() {\n      return this._MaybeUpdateSinCosAngle(), this._sinA;\n    }\n    GetCosAngle() {\n      return this._MaybeUpdateSinCosAngle(), this._cosA;\n    }\n    SetOriginX(t) {\n      this._ox = +t;\n    }\n    OffsetOriginX(t) {\n      this._ox += +t;\n    }\n    GetOriginX() {\n      return this._ox;\n    }\n    SetOriginY(t) {\n      this._oy = +t;\n    }\n    OffsetOriginY(t) {\n      this._oy += +t;\n    }\n    GetOriginY() {\n      return this._oy;\n    }\n    _SetColor(t) {\n      this._color.equals(t) || (this._color === DEFAULT_COLOR ? (this._color = C32.New(C32.Color, t), this._colorPremultiplied = C32.New(C32.Color, t), this._colorPremultiplied.premultiply()) : t.equalsRgba(1, 1, 1, 1) ? (this._color = DEFAULT_COLOR, this._colorPremultiplied = DEFAULT_COLOR) : (this._color.set(t), this._colorPremultiplied.set(t), this._colorPremultiplied.premultiply()), this._UpdateRendererStateGroup());\n    }\n    SetOpacity(t) {\n      if (t = C32.clamp(+t, 0, 1), this.GetTransformWithParentOpacity()) {\n        if (this._GetSceneGraphInfo().GetOwnOpacity() === t) return;\n        this._GetSceneGraphInfo().SetOwnOpacity(t), t = this.GetOpacity();\n      } else if (this._color.a === t) return;\n      this._SetColorWithOpacity(t);\n    }\n    _SetOpacityOfChildren() {\n      if (this.HasChildren()) {\n        const s = this.GetChildren();\n        for (let t = 0, e = s.length; t < e; t++) {\n          const i = s[t];\n          i._SetColorWithOpacity(i.GetOpacity());\n        }\n      }\n    }\n    _SetColorWithOpacity(t) {\n      tempColor.copyRgb(this._color), tempColor.a = t, this._SetColor(tempColor), this._SetOpacityOfChildren();\n    }\n    OffsetOpacity(t) {\n      this.GetTransformWithParentOpacity() ? this.SetOpacity(this._GetSceneGraphInfo().GetOwnOpacity() + t) : this.SetOpacity(this.GetOpacity() + t);\n    }\n    GetOpacity() {\n      return this.GetTransformWithParentOpacity() ? this.GetParent().GetOpacity() * this._GetSceneGraphInfo().GetOwnOpacity() : this._color.a;\n    }\n    SetUnpremultipliedColor(t) {\n      this._color.equalsIgnoringAlpha(t) || (tempColor.copyRgb(t), tempColor.a = this.GetOpacity(), this._SetColor(tempColor));\n    }\n    SetUnpremultipliedColorRGB(t, e, s) {\n      tempColor.setRgb(t, e, s), this.SetUnpremultipliedColor(tempColor);\n    }\n    OffsetUnpremultipliedColorRGB(t, e, s) {\n      0 === t && 0 === e && 0 === s || (tempColor.copyRgb(this._color), tempColor.r += t, tempColor.g += e, tempColor.b += s, this.SetUnpremultipliedColor(tempColor));\n    }\n    GetUnpremultipliedColor() {\n      return this._color;\n    }\n    GetPremultipliedColor() {\n      return this._colorPremultiplied;\n    }\n    GetDestroyWithParent() {\n      return 0 != (this._flags & FLAG_DESTROY_WITH_PARENT);\n    }\n    SetDestroyWithParent(t) {\n      this._SetFlag(FLAG_DESTROY_WITH_PARENT, t);\n    }\n    GetTransformWithParentX() {\n      return 0 != (this._flags & FLAG_TRANSFORM_WITH_PARENT_X);\n    }\n    SetTransformWithParentX(t) {\n      this._SetFlag(FLAG_TRANSFORM_WITH_PARENT_X, t);\n    }\n    GetTransformWithParentY() {\n      return 0 != (this._flags & FLAG_TRANSFORM_WITH_PARENT_Y);\n    }\n    GetTransformWithParentXOrY() {\n      return 0 != (this._flags & (FLAG_TRANSFORM_WITH_PARENT_X | FLAG_TRANSFORM_WITH_PARENT_Y));\n    }\n    SetTransformWithParentY(t) {\n      this._SetFlag(FLAG_TRANSFORM_WITH_PARENT_Y, t);\n    }\n    GetTransformWithParentWidth() {\n      return 0 != (this._flags & FLAG_TRANSFORM_WITH_PARENT_W);\n    }\n    SetTransformWithParentWidth(t) {\n      this._SetFlag(FLAG_TRANSFORM_WITH_PARENT_W, t);\n    }\n    GetTransformWithParentHeight() {\n      return 0 != (this._flags & FLAG_TRANSFORM_WITH_PARENT_H);\n    }\n    SetTransformWithParentHeight(t) {\n      this._SetFlag(FLAG_TRANSFORM_WITH_PARENT_H, t);\n    }\n    GetTransformWithParentAngle() {\n      return 0 != (this._flags & FLAG_TRANSFORM_WITH_PARENT_A);\n    }\n    SetTransformWithParentAngle(t) {\n      this._SetFlag(FLAG_TRANSFORM_WITH_PARENT_A, t);\n    }\n    GetTransformWithParentZElevation() {\n      return 0 != (this._flags & FLAG_TRANSFORM_WITH_PARENT_Z_ELEVATION);\n    }\n    SetTransformWithParentZElevation(t) {\n      this._SetFlag(FLAG_TRANSFORM_WITH_PARENT_Z_ELEVATION, t);\n    }\n    GetTransformWithParentOpacity() {\n      return 0 != (this._flags & FLAG_TRANSFORM_WITH_PARENT_OPACITY);\n    }\n    SetTransformWithParentOpacity(t) {\n      this._SetFlag(FLAG_TRANSFORM_WITH_PARENT_OPACITY, t);\n    }\n    GetTransformWithParentVisibility() {\n      return 0 != (this._flags & FLAG_TRANSFORM_WITH_PARENT_VISIBILITY);\n    }\n    SetTransformWithParentVisibility(t) {\n      this._SetFlag(FLAG_TRANSFORM_WITH_PARENT_VISIBILITY, t);\n    }\n    _ClearAllSceneGraphFlags() {\n      this._flags &= ~MASK_ALL_SCENE_GRAPH_FLAGS;\n    }\n    AddChild(t, e) {\n      if (t === this) return false;\n      if (t.HasParent()) return false;\n      if (this._HasChildRecursive(t)) return false;\n      if (this._HasAnyParent(t)) return false;\n      const s = t.GetX(), i = t.GetY(), n = t.GetWidth(), r = t.GetHeight(), h = t.GetAngle(), a = t.GetZElevation(), o = t.GetOpacity(), l = (t._SetParent(this), t.SetTransformWithParentX(e.transformX), t.SetTransformWithParentY(e.transformY), t.SetTransformWithParentWidth(e.transformWidth), t.SetTransformWithParentHeight(e.transformHeight), t.SetTransformWithParentAngle(e.transformAngle), t.SetTransformWithParentZElevation(e.transformZElevation), t.SetTransformWithParentOpacity(e.transformOpacity), t.SetTransformWithParentVisibility(e.transformVisibility), t.SetDestroyWithParent(e.destroyWithParent), s - this.GetX()), _ = i - this.GetY(), G = -this.GetAngle(), c = Math.cos(G), d = Math.sin(G);\n      if (e.transformX && (e.transformAngle ? t._x = l * c - _ * d : t._x = l, e.transformWidth)) {\n        const S = this.GetWidth() / this._sceneGraphInfo._GetStartWidth();\n        0 != S && (t._x /= S);\n      }\n      if (e.transformY && (e.transformAngle ? t._y = l * d + _ * c : t._y = _, e.transformHeight)) {\n        const f = this.GetHeight() / this._sceneGraphInfo._GetStartHeight();\n        0 != f && (t._y /= f);\n      }\n      if (e.transformWidth) {\n        const p = this.GetWidth();\n        0 === p || p === Number.EPSILON ? (t._w = 1, t._sceneGraphInfo.SetStartScaleX(1)) : (t._w = n / this.GetWidth(), t._sceneGraphInfo.SetStartScaleX(t._w));\n      }\n      if (e.transformHeight) {\n        const C = this.GetHeight();\n        0 === C || C === Number.EPSILON ? (t._h = 1, t._sceneGraphInfo.SetStartScaleY(1)) : (t._h = r / this.GetHeight(), t._sceneGraphInfo.SetStartScaleY(t._h));\n      }\n      return e.transformAngle && (t._a = h - this.GetAngle()), e.transformZElevation && (t._zElevation = a - this.GetZElevation()), e.transformOpacity && t._sceneGraphInfo.SetOwnOpacity(o), e.transformVisibility && t.SetVisible(this.IsVisible()), this._AddChildToSceneGraphInfo(t), this.SetBboxChanged(), this._SetOpacityOfChildren(), true;\n    }\n    RemoveChild(t) {\n      if (t.GetParent() === this) {\n        const e = t.GetX(), s = t.GetY(), i = t.GetWidth(), n = t.GetHeight(), r = t.GetAngle(), h = t.GetZElevation(), a = t.GetOpacity();\n        t._SetParent(null), t._ClearAllSceneGraphFlags(), t.SetXY(e, s), t.SetSize(i, n), t.SetAngle(r), t.SetZElevation(h), t.SetOpacity(a), this._RemoveChildFromSceneGraphInfo(t), this.SetBboxChanged();\n      }\n    }\n    GetTmpHierarchyPosition() {\n      return this._tmpHierarchyPosition;\n    }\n    _ResetAllSceneGraphState() {\n      this._BuildTmpSceneGraphData();\n      const t = [...this.children()];\n      for (const s of t) this.RemoveChild(s);\n      const e = this.GetParent();\n      e && e.RemoveChild(this), this._ClearAllSceneGraphFlags();\n    }\n    _BuildTmpSceneGraphData() {\n      if (this._SetTmpHierarchyPosition(), !this._tmpSceneGraphChildren) {\n        const e = [...this.children()];\n        e.length && (this._tmpSceneGraphChildren = [], this._tmpSceneGraphChildrenIndexes = /* @__PURE__ */ new WeakMap());\n        let t2 = 0;\n        for (const s of e) {\n          const i = s.GetInstance();\n          this._tmpSceneGraphChildren.push(i), this._tmpSceneGraphChildrenIndexes.set(i, t2), t2++;\n        }\n      }\n      const t = this.GetParent();\n      t && t._BuildTmpSceneGraphData();\n    }\n    _SetTmpHierarchyPosition() {\n      if (-1 === this._tmpHierarchyPosition) {\n        const t = [...this.parents()];\n        this._tmpHierarchyPosition = t.length;\n        for (const s of t) s._SetTmpHierarchyPosition();\n        const e = [...this.children()];\n        for (const i of e) i._SetTmpHierarchyPosition();\n      }\n    }\n    _ReleaseTmpSceneGraphInfo() {\n      this._tmpSceneGraphChildren && (this._tmpSceneGraphChildren.length = 0), this._tmpSceneGraphChildren = null, this._tmpSceneGraphChildrenIndexes = null;\n      const t = this.GetParent();\n      t && t._ReleaseTmpSceneGraphInfo(), this._tmpHierarchyPosition = -1;\n    }\n    HasParent() {\n      return null !== this.GetParent();\n    }\n    GetParent() {\n      const t = this._sceneGraphInfo;\n      return null !== t ? t.GetParent() : null;\n    }\n    GetTopParent() {\n      let t = this;\n      for (; t.HasParent(); ) t = t.GetParent();\n      return t;\n    }\n    *parents() {\n      let t = this.GetParent();\n      for (; t; ) yield t, t = t.GetParent();\n    }\n    HasChild(t) {\n      return this.GetChildren().includes(t);\n    }\n    HasChildren() {\n      const t = this._sceneGraphInfo;\n      return null !== t && t.HasChildren();\n    }\n    GetChildren() {\n      const t = this._sceneGraphInfo;\n      return null !== t ? t.GetChildren() : EMPTY_ARRAY;\n    }\n    children() {\n      return this.GetChildren();\n    }\n    *allChildren() {\n      for (const t of this.children()) yield t, yield* t.allChildren();\n    }\n    GetChildCount() {\n      return this.GetChildren().length;\n    }\n    GetAllChildCount() {\n      return [...this.allChildren()].length;\n    }\n    GetChildAt(t) {\n      const e = this.GetChildren();\n      return (t = Math.floor(+t)) < 0 || t >= e.length ? null : e[t];\n    }\n    GetChildIndex(e) {\n      if (e) {\n        const s = this.GetChildren();\n        if (s) {\n          for (let t = 0; t < s.length; t++) if (e === s[t]) return t;\n        }\n      }\n      return NaN;\n    }\n    _CreateSceneGraphInfo(t) {\n      this._sceneGraphInfo || (this._sceneGraphInfo = C32.New(C32.SceneGraphInfo, this)), t && this._sceneGraphInfo.SetParent(t);\n    }\n    _GetSceneGraphInfo() {\n      return this._sceneGraphInfo;\n    }\n    _ReleaseSceneGraphInfo() {\n      this._sceneGraphInfo && (this._sceneGraphInfo.Release(), this._sceneGraphInfo = null);\n    }\n    _SetParent(t) {\n      t ? (t._CreateSceneGraphInfo(null), this._CreateSceneGraphInfo(t)) : (this._sceneGraphInfo && this._sceneGraphInfo.SetParent(null), this.HasChildren() || this._ReleaseSceneGraphInfo());\n    }\n    _HasAnyParent(t) {\n      if (!this.HasParent()) return false;\n      const e = this.GetParent();\n      return e === t || e._HasAnyParent(t);\n    }\n    _HasChildRecursive(t) {\n      if (this.HasChild(t)) return true;\n      for (const e of this.GetChildren()) if (e._HasChildRecursive(t)) return true;\n      return false;\n    }\n    _AddChildToSceneGraphInfo(t) {\n      this._sceneGraphInfo.GetChildren().push(t);\n    }\n    _RemoveChildFromSceneGraphInfo(t) {\n      const e = this._sceneGraphInfo.GetChildren(), s = e.indexOf(t);\n      -1 !== s && e.splice(s, 1), 0 !== e.length || this.HasParent() || this._ReleaseSceneGraphInfo(), t.HasChildren() || t._ReleaseSceneGraphInfo();\n    }\n    GetSceneGraphChildrenExportData() {\n      const t = sceneGraphExportDataMap.get(this);\n      return t ? t.childrenData : null;\n    }\n    GetSceneGraphZIndexExportData() {\n      const t = sceneGraphExportDataMap.get(this);\n      return t ? t.zIndexData : NaN;\n    }\n    GetSceneGraphZIndex() {\n      const t = sceneGraphZIndexMap.get(this);\n      return C32.IsFiniteNumber(t) ? t : NaN;\n    }\n    SetSceneGraphZIndex(t) {\n      sceneGraphZIndexMap.set(this, t);\n    }\n    SetUsePointsShaderProgram() {\n      this._SetFlag(FLAG_USE_POINTS_SHADER_PROGRAM, true), this._UpdateRendererStateGroup();\n    }\n    _UpdateRendererStateGroup() {\n      if (enableUpdateRendererStateGroup) {\n        const e = this._runtime.GetRenderer();\n        this._stateGroup && e.ReleaseStateGroup(this._stateGroup);\n        let t;\n        t = 0 != (this._flags & FLAG_USE_POINTS_SHADER_PROGRAM) ? e.GetPointsRenderingProgram() || \"<point>\" : e.GetTextureFillShaderProgram() || \"<default>\", this._stateGroup = e.AcquireStateGroup(t, this.GetBlendMode(), this._colorPremultiplied, this.GetZElevation());\n      }\n    }\n    GetRendererStateGroup() {\n      return this._stateGroup;\n    }\n    HasDefaultColor() {\n      return this._color === DEFAULT_COLOR;\n    }\n    SetBlendMode(t) {\n      if ((t |= 0) < 0 || 31 < t) throw new RangeError(\"invalid blend mode\");\n      this.GetBlendMode() !== t && (this._flags = this._flags & ~FLAG_BLEND_MODE_MASK | t << FLAG_BLEND_MODE_BIT_OFFSET, this._UpdateRendererStateGroup());\n    }\n    GetBlendMode() {\n      return (this._flags & FLAG_BLEND_MODE_MASK) >> FLAG_BLEND_MODE_BIT_OFFSET;\n    }\n    _SetLayer(t, e) {\n      const s = e && this._layer !== t;\n      s && this._RemoveFromRenderCells(), this._objectClass._OnWorldInstanceLayerChanged(this, this._layer, t), this._layer = t, s && this._UpdateRenderCell(), 0 !== this.GetZElevation() && this._layer._SetAnyInstanceZElevated();\n    }\n    GetLayer() {\n      return this._layer;\n    }\n    GetLayout() {\n      return this.GetLayer().GetLayout();\n    }\n    _SetZIndex(t) {\n      this._zIndex = 0 | t;\n    }\n    GetZIndex() {\n      return this._layer._UpdateZIndices(), this._zIndex;\n    }\n    _SetHTMLZIndex(t) {\n      this._htmlZIndex = 0 | t;\n    }\n    GetHTMLZIndex() {\n      return this._layer._UpdateHTMLZIndices(), this._htmlZIndex;\n    }\n    _GetLastCachedZIndex() {\n      return this._zIndex;\n    }\n    _SetFlag(t, e) {\n      e ? this._flags |= t : this._flags &= ~t;\n    }\n    IsVisible() {\n      return 0 != (this._flags & FLAG_IS_VISIBLE);\n    }\n    SetVisible(t) {\n      if (this._SetFlag(FLAG_IS_VISIBLE, t), this.HasChildren()) for (const e of this.GetChildren()) e.GetTransformWithParentVisibility() && e.SetVisible(t);\n    }\n    IsCollisionEnabled() {\n      return 0 != (this._flags & FLAG_COLLISION_ENABLED);\n    }\n    SetCollisionEnabled(t) {\n      t = !!t, this.IsCollisionEnabled() !== t && (this._SetFlag(FLAG_COLLISION_ENABLED, t), t ? this.SetBboxChanged() : this._RemoveFromCollisionCells());\n    }\n    SetSolidCollisionFilter(t, e) {\n      if (this._SetFlag(FLAG_SOLID_FILTER_INCLUSIVE, t), this._solidFilterTags && this._solidFilterTags.clear(), e.trim()) {\n        this._solidFilterTags || (this._solidFilterTags = /* @__PURE__ */ new Set());\n        for (const s of e.split(\" \")) s && this._solidFilterTags.add(s.toLowerCase());\n      } else this._solidFilterTags = null;\n    }\n    IsSolidCollisionAllowed(t) {\n      const e = 0 != (this._flags & FLAG_SOLID_FILTER_INCLUSIVE), s = this._solidFilterTags;\n      if (t && s) {\n        for (const i of s) if (t.has(i)) return e;\n      }\n      return !e;\n    }\n    SetBboxChanged() {\n      if (this._flags |= FLAG_BBOX_CHANGED | FLAG_COLLISION_CELL_CHANGED | FLAG_MESH_CHANGED, this._objectClass._SetAnyCollisionCellChanged(true), this._runtime.UpdateRender(), this._layer.UsesRenderCells() && (this.CalculateBbox(this._boundingBox, this._boundingQuad, true), this._flags &= ~FLAG_BBOX_CHANGED, this._UpdateRenderCell()), 0 != (this._flags & FLAG_ENABLE_BBOX_CHANGED_EVENT) && this._inst.Dispatcher().dispatchEvent(bboxChangeEvent), null !== this._sceneGraphInfo) {\n        const s = this._sceneGraphInfo.GetChildren();\n        for (let t = 0, e = s.length; t < e; ++t) s[t].SetBboxChanged();\n      }\n    }\n    CalculateBbox(t, e, s) {\n      const i = this.GetX(), n = this.GetY(), r = this.GetWidth(), h = this.GetHeight(), a = this.GetAngle();\n      t.setWH(i - this._ox * r, n - this._oy * h, r, h), s && this.HasMesh() && this._ExpandBboxForMesh(t), 0 === a ? e.setFromRect(t) : (t.offset(-i, -n), e.setFromRotatedRectPrecalc(t, this.GetSinAngle(), this.GetCosAngle()), e.offset(i, n), e.getBoundingBox(t)), t.normalize();\n    }\n    _UpdateBbox() {\n      const t = this._flags;\n      0 != (t & FLAG_BBOX_CHANGED) && (this.CalculateBbox(this._boundingBox, this._boundingQuad, true), this._flags = t & ~FLAG_BBOX_CHANGED);\n    }\n    GetBoundingBox() {\n      return this._UpdateBbox(), this._boundingBox;\n    }\n    GetBoundingQuad() {\n      return this._UpdateBbox(), this._boundingQuad;\n    }\n    PixelRoundQuad(t) {\n      const e = this.GetX(), s = this.GetY(), i = Math.round(e) - e, n = Math.round(s) - s;\n      return 0 == i && 0 == n ? t : (tempQuad.copy(t), tempQuad.offset(i, n), tempQuad);\n    }\n    OverwriteBoundingBox(t) {\n      this._boundingBox.copy(t), this._boundingQuad.setFromRect(this._boundingBox), this._flags &= ~FLAG_BBOX_CHANGED, this._UpdateCollisionCell(), this._UpdateRenderCell();\n    }\n    SetBboxChangeEventEnabled(t) {\n      this._SetFlag(FLAG_ENABLE_BBOX_CHANGED_EVENT, t);\n    }\n    IsBboxChangeEventEnabled() {\n      return 0 != (this._flags & FLAG_ENABLE_BBOX_CHANGED_EVENT);\n    }\n    IsInViewport(t, e, s) {\n      return e && 0 !== this.GetDepth() ? this.IsInViewport3D(this.GetLayer()._GetViewFrustum()) : 0 === this.GetZElevation() || s ? t.intersectsRect(this.GetBoundingBox()) : this._IsInViewport_ZElevated();\n    }\n    _IsInViewport_ZElevated() {\n      const t = this.GetLayer(), e = this.GetTotalZElevation();\n      return !(e >= t.Get2DCameraZ()) && (t.GetViewportForZ(e, tempRect), tempRect.intersectsRect(this.GetBoundingBox()));\n    }\n    IsInViewport3D(t) {\n      const e = this.GetBoundingBox(), s = e.getLeft(), i = e.getRight(), n = e.getTop(), r = e.getBottom(), h = this.GetTotalZElevation(), a = h + this.GetDepth();\n      return t.ContainsAABB(s, n, h, i, r, a);\n    }\n    IsInViewport2() {\n      const t = this.GetLayer();\n      if (t.Has3DCamera()) return this.IsInViewport3D(t._GetViewFrustum());\n      {\n        const e = t.GetLayout();\n        return this.IsInViewport(t.GetViewport(), e.HasVanishingPointOutsideViewport(), e.IsOrthographicProjection());\n      }\n    }\n    _SetDrawBackFaceOnly(t) {\n      this._SetFlag(FLAG_DRAW_BACK_FACE_ONLY, t);\n    }\n    _SetDrawNonBackFacesOnly(t) {\n      this._SetFlag(FLAG_DRAW_NON_BACK_FACES_ONLY, t);\n    }\n    IsDrawBackFaceOnly() {\n      return 0 != (this._flags & FLAG_DRAW_BACK_FACE_ONLY);\n    }\n    IsDrawNonBackFacesOnly() {\n      return 0 != (this._flags & FLAG_DRAW_NON_BACK_FACES_ONLY);\n    }\n    SetSourceCollisionPoly(t) {\n      this._sourceCollisionPoly = t, this._DiscardTransformedCollisionPoly(), this.HasMesh() && (this._meshInfo.meshPoly = null);\n    }\n    GetSourceCollisionPoly() {\n      return this._sourceCollisionPoly;\n    }\n    HasOwnCollisionPoly() {\n      return null !== this._sourceCollisionPoly || this.HasMesh();\n    }\n    GetTransformedCollisionPoly() {\n      return this._GetCustomTransformedCollisionPolyPrecalc(this.GetWidth(), this.GetHeight(), this.GetAngle(), this.GetSinAngle(), this.GetCosAngle());\n    }\n    GetCustomTransformedCollisionPoly(t, e, s) {\n      let i = 0, n = 1;\n      return 0 !== s && (i = Math.sin(s), n = Math.cos(s)), this._GetCustomTransformedCollisionPolyPrecalc(t, e, s, i, n);\n    }\n    _GetCustomTransformedCollisionPolyPrecalc(e, s, t, i, n) {\n      let r = this._transformedPolyInfo;\n      null === r && (r = { poly: C32.New(C32.CollisionPoly), width: NaN, height: NaN, angle: NaN }, this._transformedPolyInfo = r);\n      const h = r.poly;\n      if (r.width !== e || r.height !== s || r.angle !== t) {\n        const a = this._sourceCollisionPoly;\n        if (this.HasMesh()) {\n          const o = this.GetOriginX(), l = this.GetOriginY(), _ = this.GetSourceMesh();\n          let t2 = this._meshInfo.meshPoly;\n          t2 || (a ? (tempCollisionPoly.copy(a), tempCollisionPoly.offset(o, l)) : tempCollisionPoly.setDefaultPoints(), t2 = _.InsertPolyMeshVertices(tempCollisionPoly), this._meshInfo.meshPoly = t2), _.TransformCollisionPoly(t2, h), h.offset(-o, -l), h.transformPrecalc(e, s, i, n);\n        } else a ? (h.copy(a), h.transformPrecalc(e, s, i, n)) : h.setFromQuad(this.GetBoundingQuad(), -this.GetX(), -this.GetY());\n        r.width = e, r.height = s, r.angle = t;\n      }\n      return h;\n    }\n    _DiscardTransformedCollisionPoly() {\n      this.SetPhysicsBodyChanged(true);\n      const t = this._transformedPolyInfo;\n      null !== t && (t.width = NaN);\n    }\n    CreateMesh(t, e) {\n      if (t = Math.floor(t), e = Math.floor(e), !this.GetInstance().GetPlugin().SupportsMesh()) throw new Error(\"object does not support mesh\");\n      this.ReleaseMesh(), this._meshInfo = { sourceMesh: C32.New(C32.Gfx.Mesh, t, e), transformedMesh: C32.New(C32.Gfx.Mesh, t, e), meshPoly: null };\n    }\n    HasMesh() {\n      return null !== this._meshInfo;\n    }\n    GetSourceMesh() {\n      if (this.HasMesh()) return this._meshInfo.sourceMesh;\n      throw new Error(\"no mesh\");\n    }\n    GetTransformedMesh() {\n      if (this.HasMesh()) return this._meshInfo.transformedMesh;\n      throw new Error(\"no mesh\");\n    }\n    SetMeshChanged(t) {\n      this._SetFlag(FLAG_MESH_CHANGED, t);\n    }\n    IsMeshChanged() {\n      return 0 != (this._flags & FLAG_MESH_CHANGED);\n    }\n    SetPhysicsBodyChanged(t) {\n      this._SetFlag(FLAG_PHYSICS_BODY_CHANGED, t);\n    }\n    IsPhysicsBodyChanged() {\n      return 0 != (this._flags & FLAG_PHYSICS_BODY_CHANGED);\n    }\n    _ExpandBboxForMesh(t) {\n      const e = this._meshInfo.sourceMesh, s = Math.min(e.GetMinX(), 0), i = Math.min(e.GetMinY(), 0), n = Math.max(e.GetMaxX(), 1), r = Math.max(e.GetMaxY(), 1), h = t.width(), a = t.height();\n      t.offsetLeft(s * h), t.offsetTop(i * a), t.offsetRight((n - 1) * h), t.offsetBottom((r - 1) * a), this._depth = e.GetMaxZ();\n    }\n    ReleaseMesh() {\n      this._meshInfo && (this._meshInfo.sourceMesh.Release(), this._meshInfo.transformedMesh.Release(), this._meshInfo = null, this._DiscardTransformedCollisionPoly());\n    }\n    SetMeshPoint(t, e, s) {\n      t = Math.floor(t), e = Math.floor(e);\n      const i = s.mode || \"absolute\";\n      if (!VALID_SET_MESH_POINT_MODES.has(i)) throw new Error(\"invalid mode\");\n      const n = \"relative\" === i;\n      let r = s.x, h = s.y;\n      const a = s.zElevation;\n      let o = \"number\" == typeof s.u ? s.u : n ? 0 : -1, l = \"number\" == typeof s.v ? s.v : n ? 0 : -1;\n      if (!this.HasMesh()) return false;\n      const _ = this.GetSourceMesh(), G = _.GetMeshPointAt(t, e);\n      if (null === G) return false;\n      let c = false;\n      return \"number\" == typeof a && G.GetZElevation() !== a && (G.SetZElevation(a), c = true), n && (r += t / (_.GetHSize() - 1), h += e / (_.GetVSize() - 1)), o = -1 !== o || n ? (n && (o += t / (_.GetHSize() - 1)), C32.clamp(o, 0, 1)) : G.GetU(), l = -1 !== l || n ? (n && (l += e / (_.GetVSize() - 1)), C32.clamp(l, 0, 1)) : G.GetV(), G.GetX() === r && G.GetY() === h && G.GetU() === o && G.GetV() === l ? c : (G.SetX(r), G.SetY(h), G.SetU(o), G.SetV(l), this._DiscardTransformedCollisionPoly(), true);\n    }\n    HasTilemap() {\n      return this._inst.HasTilemap();\n    }\n    ContainsPoint(t, e) {\n      return !!this.GetBoundingBox().containsPoint(t, e) && !!this.GetBoundingQuad().containsPoint(t, e) && (this.HasTilemap() ? this._inst.GetSdkInstance().TestPointOverlapTile(t, e) : !this.HasOwnCollisionPoly() || this.GetTransformedCollisionPoly().containsPoint(t - this.GetX(), e - this.GetY()));\n    }\n    _IsCollisionCellChanged() {\n      return 0 != (this._flags & FLAG_COLLISION_CELL_CHANGED);\n    }\n    _UpdateCollisionCell() {\n      if (this._IsCollisionCellChanged() && this.IsCollisionEnabled() && 0 == (this._flags & FLAG_DESTROYED)) {\n        const t = this.GetBoundingBox(), e = this._objectClass._GetCollisionCellGrid(), s = this._collisionCells;\n        if (tempRect.set(e.XToCell(t.getLeft()), e.YToCell(t.getTop()), e.XToCell(t.getRight()), e.YToCell(t.getBottom())), !s.equals(tempRect)) {\n          const i = this._inst;\n          s === DEFAULT_COLLISION_CELLS ? (e.Update(i, null, tempRect), this._collisionCells = C32.New(C32.Rect, tempRect)) : (e.Update(i, s, tempRect), s.copy(tempRect)), this._flags &= ~FLAG_COLLISION_CELL_CHANGED;\n        }\n      }\n    }\n    _SetCollisionCellChanged() {\n      this._flags |= FLAG_COLLISION_CELL_CHANGED;\n    }\n    _RemoveFromCollisionCells() {\n      const t = this._collisionCells;\n      t !== DEFAULT_COLLISION_CELLS && (this._objectClass._GetCollisionCellGrid().Update(this._inst, t, null), this._collisionCells = DEFAULT_COLLISION_CELLS);\n    }\n    _UpdateRenderCell() {\n      const t = this.GetLayer();\n      if (t.UsesRenderCells() && 0 == (this._flags & FLAG_DESTROYED)) {\n        const e = t.GetRenderGrid(), s = this.GetBoundingBox(), i = this._renderCells;\n        if (tempRect.set(e.XToCell(s.getLeft()), e.YToCell(s.getTop()), e.XToCell(s.getRight()), e.YToCell(s.getBottom())), !i.equals(tempRect)) {\n          const n = this._inst;\n          i === DEFAULT_RENDER_CELLS ? (e.Update(n, null, tempRect), this._renderCells = C32.New(C32.Rect, tempRect)) : (e.Update(n, i, tempRect), i.copy(tempRect)), t.SetRenderListStale();\n        }\n      }\n    }\n    _RemoveFromRenderCells() {\n      const t = this._renderCells;\n      t !== DEFAULT_RENDER_CELLS && (this.GetLayer().GetRenderGrid().Update(this._inst, t, null), this._renderCells = DEFAULT_RENDER_CELLS);\n    }\n    GetRenderCellRange() {\n      return this._renderCells;\n    }\n    ZOrderMoveToTop() {\n      const t = this._inst, e = this._layer, s = e._GetInstances();\n      s.length && s.at(-1) === t || (e._RemoveInstance(t, false), e._AddInstance(t, false), this._runtime.UpdateRender());\n    }\n    ZOrderMoveToBottom() {\n      const t = this._inst, e = this._layer, s = e._GetInstances();\n      s.length && s[0] === t || (e._RemoveInstance(t, false), e._PrependInstance(t, false), this._runtime.UpdateRender());\n    }\n    ZOrderMoveToLayer(t) {\n      const e = this._inst, s = this._layer;\n      if (s.GetLayout() !== t.GetLayout()) throw new Error(\"layer from different layout\");\n      t !== s && (s._RemoveInstance(e, true), this._SetLayer(t), t._AddInstance(e, true), this._runtime.UpdateRender());\n    }\n    ZOrderMoveAdjacentToInstance(t, e) {\n      const s = this._inst;\n      let i = false;\n      const n = this._layer;\n      if (t.GetUID() !== s.GetUID()) {\n        const r = t.GetWorldInfo();\n        if (!r) throw new Error(\"expected world instance\");\n        const h = r.GetLayer(), a = (n.GetIndex() !== h.GetIndex() && (n._RemoveInstance(s, true), this._SetLayer(h), h._AddInstance(s, true), i = true), h.MoveInstanceAdjacent(s, t, !!e));\n        (i || a) && this._runtime.UpdateRender();\n      }\n    }\n    GetInstanceEffectList() {\n      return this._instanceEffectList;\n    }\n    _SetHasAnyActiveEffect(t) {\n      this._SetFlag(FLAG_HAS_ANY_ACTIVE_EFFECT, t);\n    }\n    HasAnyActiveEffect() {\n      return 0 != (this._flags & FLAG_HAS_ANY_ACTIVE_EFFECT);\n    }\n    _SaveToJson(t, e = null) {\n      const s = { \"x\": this.GetX(), \"y\": this.GetY(), \"w\": this.GetWidth(), \"h\": this.GetHeight(), \"l\": this.GetLayer().GetSID(), \"zi\": this.GetZIndex() }, i = (0 !== this.GetZElevation() && (s[\"ze\"] = this.GetZElevation()), 0 !== this.GetAngle() && (s[\"a\"] = this._GetAngleNoReflect()), this.HasDefaultColor() || (s[\"c\"] = this._color.toJSON()), 0.5 !== this.GetOriginX() && (s[\"oX\"] = this.GetOriginX()), 0.5 !== this.GetOriginY() && (s[\"oY\"] = this.GetOriginY()), 0 !== this.GetBlendMode() && (s[\"bm\"] = this.GetBlendMode()), this.IsVisible() || (s[\"v\"] = this.IsVisible()), this.IsCollisionEnabled() || (s[\"ce\"] = this.IsCollisionEnabled()), this.IsBboxChangeEventEnabled() && (s[\"be\"] = this.IsBboxChangeEventEnabled()), this._instanceEffectList && (s[\"fx\"] = this._instanceEffectList._SaveToJson()), 0 != (this._flags & FLAG_SOLID_FILTER_INCLUSIVE));\n      return i && (s[\"sfi\"] = i), this._solidFilterTags && (s[\"sft\"] = [...this._solidFilterTags].join(\" \")), this._sceneGraphInfo && \"visual-state\" !== t && (s[\"sgi\"] = this._sceneGraphInfo._SaveToJson(t, e), sceneGraphExportDataMap.has(this)) && (s[\"sgcd\"] = sceneGraphExportDataMap.get(this).childrenData, s[\"sgzid\"] = sceneGraphExportDataMap.get(this).zIndexData), this.HasMesh() && (s[\"mesh\"] = this.GetSourceMesh().SaveToJson()), s;\n    }\n    _SaveSceneGraphPropertiesToJson() {\n      return { \"x\": this._x, \"y\": this._y, \"z\": this._zElevation, \"w\": this._w, \"h\": this._h, \"a\": this._a, \"sgi\": this._GetSceneGraphInfo() ? this._GetSceneGraphInfo()._SaveToJsonProperties() : null };\n    }\n    _LoadSceneGraphPropertiesFromJson(t) {\n      t && (this._x = t[\"x\"], this._y = t[\"y\"], this._zElevation = t[\"z\"], this._w = t[\"w\"], this._h = t[\"h\"], this._a = t[\"a\"], t[\"sgi\"] && this._GetSceneGraphInfo() && this._GetSceneGraphInfo()._LoadFromJson(t[\"sgi\"]), this._MarkSinCosAngleChanged(), this.SetBboxChanged());\n    }\n    _SetupSceneGraphConnectionsOnChangeOfLayout() {\n      this._ReleaseTmpSceneGraphInfo(), this._ResetAllSceneGraphState(), this._CreateSceneGraphInfo(null), this._sceneGraphInfo && this._sceneGraphInfo._SetTmpSceneGraphChildren(this._tmpSceneGraphChildren, this._tmpSceneGraphChildrenIndexes);\n    }\n    _OnBeforeLoad(t) {\n      \"visual-state\" !== t && this._ResetAllSceneGraphState();\n    }\n    _OnAfterLoad(t, e = \"full\", s = null) {\n      t.hasOwnProperty(\"sgi\") && \"visual-state\" !== e && 0 == (this._flags & FLAG_DESTROYED) && this._sceneGraphInfo._OnAfterLoad(t[\"sgi\"], s);\n    }\n    _OnAfterLoad2(t, e = \"full\", s) {\n      t.hasOwnProperty(\"sgi\") && \"visual-state\" !== e && 0 == (this._flags & FLAG_DESTROYED) && (this._sceneGraphInfo._SetTmpSceneGraphChildren(null, null), this._ReleaseTmpSceneGraphInfo(), this.SetBboxChanged());\n    }\n    _LoadFromJson(t, e) {\n      if (enableUpdateRendererStateGroup = false, this.SetX(t[\"x\"]), this.SetY(t[\"y\"]), this.SetWidth(t[\"w\"]), this.SetHeight(t[\"h\"]), this._SetZIndex(t[\"zi\"]), this.SetZElevation(t.hasOwnProperty(\"ze\") ? t[\"ze\"] : 0), this.SetAngle(t.hasOwnProperty(\"a\") ? t[\"a\"] : 0), t.hasOwnProperty(\"c\") ? tempColor.setFromJSON(t[\"c\"]) : t.hasOwnProperty(\"o\") ? (tempColor.copyRgb(this._color), tempColor.a = t[\"o\"]) : tempColor.setRgba(1, 1, 1, 1), this._SetColor(tempColor), this.SetOriginX(t.hasOwnProperty(\"oX\") ? t[\"oX\"] : 0.5), this.SetOriginY(t.hasOwnProperty(\"oY\") ? t[\"oY\"] : 0.5), this.SetBlendMode(t.hasOwnProperty(\"bm\") ? t[\"bm\"] : 0), this.SetVisible(!t.hasOwnProperty(\"v\") || t[\"v\"]), this.SetCollisionEnabled(!t.hasOwnProperty(\"ce\") || t[\"ce\"]), this.SetBboxChangeEventEnabled(!!t.hasOwnProperty(\"be\") && t[\"be\"]), this.SetSolidCollisionFilter(!!t.hasOwnProperty(\"sfi\") && t[\"sfi\"], t.hasOwnProperty(\"sft\") ? t[\"sft\"] : \"\"), this._instanceEffectList && t.hasOwnProperty(\"fx\") && this._instanceEffectList._LoadFromJson(t[\"fx\"]), !t.hasOwnProperty(\"sgi\") && \"visual-state\" !== e && this._tmpSceneGraphChildren) for (const s of this._tmpSceneGraphChildren) s.IsDestroyed() || this._runtime.DestroyInstance(s);\n      if (t.hasOwnProperty(\"sgi\") && \"visual-state\" !== e) {\n        this._CreateSceneGraphInfo(null);\n        const i = this._sceneGraphInfo, n = t[\"sgi\"];\n        i._LoadFromJson(n), i._SetTmpSceneGraphChildren(this._tmpSceneGraphChildren, this._tmpSceneGraphChildrenIndexes), t[\"sgcd\"] && C32.IsFiniteNumber(t[\"sgzid\"]) && sceneGraphExportDataMap.set(this, { childrenData: t[\"sgcd\"], zIndexData: t[\"sgzid\"] });\n      }\n      if (t.hasOwnProperty(\"mesh\")) {\n        const r = t[\"mesh\"];\n        this.CreateMesh(r[\"cols\"], r[\"rows\"]), this.GetSourceMesh().LoadFromJson(r);\n      } else this.ReleaseMesh();\n      this.SetBboxChanged(), enableUpdateRendererStateGroup = true, this._UpdateRendererStateGroup(), \"visual-state\" !== e && this._runtime.AddInstanceNeedingAfterLoad(this.GetInstance(), t);\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.BehaviorType = class extends C32.DefendedBase {\n    constructor(e, t) {\n      super();\n      const s = e.GetRuntime(), i = s.GetObjectReference(t[1]), r = (s.GetAddonManager()._DelayCreateBehavior(i), this._runtime = s, this._objectClass = e, this._behavior = C32.AddonManager.GetBehaviorByConstructorFunction(i), this._sdkType = null, this._iBehaviorType = null, this._instSdkCtor = i.Instance, this._sid = t[2], this._name = t[0], this._jsPropName = this._runtime.GetJsPropName(t[3]), this._behavior.GetSdkVersion());\n      if (r < 2 && (this._sdkType = C32.New(i.Type, this), !(this._sdkType instanceof C32.SDKBehaviorTypeBase))) throw new Error(\"v1 sdk type must derive from SDKBehaviorBase\");\n      if (C32.AddonManager._PushInitObject(this, r), 2 <= r) {\n        const a = i.Type ?? globalThis.ISDKBehaviorTypeBase;\n        if (this._iBehaviorType = new a(), !(this._iBehaviorType instanceof globalThis.ISDKBehaviorTypeBase)) throw new Error(\"script interface class must derive from ISDKBehaviorTypeBase\");\n      } else this._iBehaviorType = new globalThis.IBehaviorType();\n      C32.AddonManager._PopInitObject(r), this.OnCreate();\n    }\n    static Create(e, t) {\n      return C32.New(C32.BehaviorType, e, t);\n    }\n    Release() {\n      this._runtime = null, this._behavior = null, this._sdkType && (this._sdkType.Release(), this._sdkType = null), this._instSdkCtor = null;\n    }\n    GetSdkType() {\n      return this._sdkType;\n    }\n    OnCreate() {\n      this._sdkType ? this._sdkType.OnCreate() : this._iBehaviorType && this._iBehaviorType._onCreate();\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetObjectClass() {\n      return this._objectClass;\n    }\n    GetBehavior() {\n      return this._behavior;\n    }\n    GetInstanceSdkCtor() {\n      return this._instSdkCtor;\n    }\n    GetName() {\n      return this._name;\n    }\n    GetSID() {\n      return this._sid;\n    }\n    GetIBehaviorType() {\n      return this._iBehaviorType;\n    }\n    GetJsPropName() {\n      return this._jsPropName;\n    }\n  };\n}\n{\n  const C32 = self.C3, IBehaviorInstance = self.IBehaviorInstance;\n  C32.BehaviorInstance = class extends C32.DefendedBase {\n    constructor(t) {\n      super(), this._runtime = t.runtime, this._behaviorType = t.behaviorType, this._behavior = this._behaviorType.GetBehavior(), this._inst = t.instance, this._index = t.index, this._sdkInst = null, this._iScriptInterface = null, this._behavior._AddInstance(this._inst);\n    }\n    Release() {\n      this._iScriptInterface && (this._iScriptInterface._release(), this._iScriptInterface = null), this._behavior._RemoveInstance(this._inst), this._sdkInst && (this._sdkInst.Release(), this._sdkInst = null), this._runtime = null, this._behaviorType = null, this._behavior = null, this._inst = null;\n    }\n    _CreateSdkInstance(t) {\n      if (this._sdkInst) throw new Error(\"already got sdk instance\");\n      const e = this.GetBehavior().GetSdkVersion();\n      if (e < 2) {\n        if (this._sdkInst = C32.New(this._behaviorType.GetInstanceSdkCtor(), this, t), !(this._sdkInst instanceof C32.SDKBehaviorInstanceBase)) throw new Error(\"v1 sdk type must derive from SDKBehaviorInstanceBase\");\n      } else {\n        const s = this.GetBehavior().GetScriptInterfaceClass();\n        this._InitScriptInterface(s.Instance, t);\n      }\n    }\n    GetSdkInstance() {\n      return this._sdkInst ?? this._iScriptInterface;\n    }\n    GetObjectInstance() {\n      return this._inst;\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetBehaviorType() {\n      return this._behaviorType;\n    }\n    GetBehavior() {\n      return this._behavior;\n    }\n    _GetIndex() {\n      return this._index;\n    }\n    PostCreate() {\n      this._sdkInst ? this._sdkInst.PostCreate() : this._iScriptInterface._postCreate();\n    }\n    OnSpriteFrameChanged(t, e) {\n      this._sdkInst && this._sdkInst.OnSpriteFrameChanged(t, e);\n    }\n    _GetDebuggerProperties() {\n      return this._sdkInst ? this._sdkInst.GetDebuggerProperties() : this._iScriptInterface._getDebuggerProperties();\n    }\n    SaveToJson(t = \"full\") {\n      return this._sdkInst ? this._sdkInst.SaveToJson(t) : this._iScriptInterface._saveToJson(t);\n    }\n    LoadFromJson(t, e = \"full\") {\n      if (this._sdkInst) return this._sdkInst.LoadFromJson(t, e);\n      this._iScriptInterface._loadFromJson(t, e);\n    }\n    static SortByTickSequence(t, e, s) {\n      const n = globalThis.ISDKBehaviorInstanceBase;\n      let i, r;\n      i = e instanceof n ? t._UnwrapScriptInterface(e) : e.GetBehaviorInstance(), r = s instanceof n ? t._UnwrapScriptInterface(s) : s.GetBehaviorInstance();\n      const a = i.GetObjectInstance(), h = r.GetObjectInstance(), c = a.GetObjectClass().GetIndex(), o = h.GetObjectClass().GetIndex();\n      if (c !== o) return c - o;\n      const I = a.GetPUID(), _ = h.GetPUID();\n      return I !== _ ? I - _ : i._GetIndex() - r._GetIndex();\n    }\n    _InitScriptInterface(t, e) {\n      const s = IBehaviorInstance, n = t ?? this._sdkInst.GetScriptInterfaceClass(), i = n || s, r = this.GetBehavior().GetSdkVersion();\n      if (C32.AddonManager._PushInitObject(this, r), C32.AddonManager._PushInitProperties(e), this._iScriptInterface = new i(), C32.AddonManager._PopInitProperties(), C32.AddonManager._PopInitObject(r), !n || this._iScriptInterface instanceof s) return this._iScriptInterface;\n      throw new TypeError(`script interface class '${n.name}' does not extend the right base class '${s.name}'`);\n    }\n    GetScriptInterface() {\n      return this._iScriptInterface || this._InitScriptInterface();\n    }\n    HasScriptInterface() {\n      return !!this._iScriptInterface;\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.EffectList = class extends C32.DefendedBase {\n    constructor(e, t) {\n      super(), this._owner = e, this._allEffectTypes = [], this._activeEffectTypes = [], this._effectTypesByName = /* @__PURE__ */ new Map(), this._effectParams = [], this._effectParamBuffers = [], this._allInstanceEffectLists = /* @__PURE__ */ new Set(), this._preservesOpaqueness = true;\n      for (const s of t) {\n        const f = C32.New(C32.EffectType, this, s, this._allEffectTypes.length);\n        this._allEffectTypes.push(f), this._effectTypesByName.set(f.GetName().toLowerCase(), f), 3 <= s.length && this._effectParams.push(this._LoadSingleEffectParameters(f, s[2]));\n      }\n      this.GetRuntime()._AddEffectList(this);\n    }\n    Release() {\n      this.GetRuntime()._RemoveEffectList(this);\n      for (const e of this._effectParamBuffers) e.Release();\n      C32.clearArray(this._effectParamBuffers), C32.clearArray(this._allEffectTypes), C32.clearArray(this._activeEffectTypes), this._effectTypesByName.clear(), C32.clearArray(this._effectParams), this._owner = null;\n    }\n    _AddInstanceEffectList(e) {\n      this._allInstanceEffectLists.add(e);\n    }\n    _RemoveInstanceEffectList(e) {\n      this._allInstanceEffectLists.delete(e);\n    }\n    _InitRenderer(e) {\n      e.IsWebGPU() && (this._effectParamBuffers = this._allEffectTypes.map((e2) => {\n        const t = e2.GetShaderProgram();\n        return 0 < t.GetCustomParametersByteSize() ? C32.New(C32.Gfx.WebGPUEffectCustomParamsBuffer, t) : null;\n      }), this._UpdateAllEffectParamBuffers());\n      for (const t of this._allInstanceEffectLists) t._InitRenderer(e);\n    }\n    PrependEffectTypes(e) {\n      if (e.length) {\n        this._allEffectTypes = e.concat(this._allEffectTypes);\n        for (const t of e) this._effectTypesByName.set(t.GetName().toLowerCase(), t);\n        for (let e2 = 0, t = this._allEffectTypes.length; e2 < t; ++e2) this._allEffectTypes[e2]._SetIndex(e2);\n      }\n    }\n    _LoadSingleEffectParameters(e, t) {\n      e.SetActive(t[0]);\n      const s = t.slice(1);\n      for (let e2 = 0, t2 = s.length; e2 < t2; ++e2) {\n        const f = s[e2];\n        if (Array.isArray(f)) {\n          const r = C32.New(C32.Color);\n          r.setFromJSON(f), s[e2] = r;\n        }\n      }\n      return s;\n    }\n    GetOwner() {\n      return this._owner;\n    }\n    GetRuntime() {\n      return this._owner.GetRuntime();\n    }\n    UpdateActiveEffects() {\n      C32.clearArray(this._activeEffectTypes);\n      let e = true;\n      for (const t of this._allEffectTypes) t.IsActive() && (this._activeEffectTypes.push(t), t.GetShaderProgram().PreservesOpaqueness() || (e = false));\n      this._preservesOpaqueness = e;\n    }\n    GetAllEffectTypes() {\n      return this._allEffectTypes;\n    }\n    HasAnyEffectType() {\n      return 0 < this._allEffectTypes.length;\n    }\n    GetEffectTypeByName(e) {\n      return this._effectTypesByName.get(e.toLowerCase()) || null;\n    }\n    GetEffectTypeByIndex(e) {\n      if ((e = Math.floor(+e)) < 0 || e >= this._allEffectTypes.length) throw new RangeError(\"invalid effect type index\");\n      return this._allEffectTypes[e];\n    }\n    IsEffectIndexActive(e) {\n      return this.GetEffectTypeByIndex(e).IsActive();\n    }\n    SetEffectIndexActive(e, t) {\n      this.GetEffectTypeByIndex(e).SetActive(t);\n    }\n    GetActiveEffectTypes() {\n      return this._activeEffectTypes;\n    }\n    HasAnyActiveEffect() {\n      return 0 < this._activeEffectTypes.length;\n    }\n    PreservesOpaqueness() {\n      return this._preservesOpaqueness;\n    }\n    GetEffectParametersForIndex(e) {\n      return this._effectParams[e];\n    }\n    _GetEffectChainShaderParametersForIndex(e) {\n      return (e < this._effectParamBuffers.length ? this._effectParamBuffers : this._effectParams)[e];\n    }\n    GetEffectParameter(e, t) {\n      if (e < 0 || e >= this._effectParams.length) return null;\n      const s = this._effectParams[e];\n      return t < 0 || t >= s.length ? null : s[t];\n    }\n    SetEffectParameter(e, t, s) {\n      if (e < 0 || e >= this._effectParams.length) return false;\n      const f = this._effectParams[e];\n      if (t < 0 || t >= f.length) return false;\n      const r = f[t];\n      if (r instanceof C32.Color) {\n        if (r.equalsIgnoringAlpha(s)) return false;\n        r.copyRgb(s);\n      } else {\n        if (r === s) return false;\n        f[t] = s;\n      }\n      return e < this._effectParamBuffers.length && this._effectParamBuffers[e].SetParameterValue(t, s), true;\n    }\n    _UpdateAllEffectParamBuffers() {\n      const s = this._effectParams, f = this._effectParamBuffers;\n      for (let e = 0, t = Math.min(s.length, f.length); e < t; ++e) {\n        const r = f[e], a = s[e];\n        for (let e2 = 0, t2 = a.length; e2 < t2; ++e2) r.SetParameterValue(e2, a[e2]);\n      }\n    }\n    static SaveFxParamToJson(e) {\n      return e && e instanceof C32.Color ? { \"t\": \"color\", \"v\": e.toJSON() } : e;\n    }\n    static LoadFxParamFromJson(e) {\n      if (null === e) return NaN;\n      if (\"object\" != typeof e) return e;\n      {\n        const t = e[\"t\"];\n        if (\"color\" !== t) throw new Error(\"invalid effect parameter type\");\n        {\n          const s = C32.New(C32.Color);\n          return s.setFromJSON(e[\"v\"]), s;\n        }\n      }\n    }\n    static SaveFxParamsToJson(e) {\n      return e.map(C32.EffectList.SaveFxParamToJson);\n    }\n    static LoadFxParamsFromJson(e) {\n      return e.map(C32.EffectList.LoadFxParamFromJson);\n    }\n    SaveToJson() {\n      return this._allEffectTypes.map((e) => ({ \"name\": e.GetName(), \"active\": e.IsActive(), \"params\": C32.EffectList.SaveFxParamsToJson(this._effectParams[e.GetIndex()]) }));\n    }\n    LoadFromJson(e) {\n      for (const t of e) {\n        const s = this.GetEffectTypeByName(t[\"name\"]);\n        s && (s.SetActive(t[\"active\"]), this._effectParams[s.GetIndex()] = C32.EffectList.LoadFxParamsFromJson(t[\"params\"]));\n      }\n      this.UpdateActiveEffects(), this._UpdateAllEffectParamBuffers();\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.EffectType = class extends C32.DefendedBase {\n    constructor(e, t, r) {\n      super(), this._effectList = e, this._id = t[0], this._name = t[1], this._index = r, this._shaderProgram = null, this._isActive = true;\n    }\n    Release() {\n      this._effectList = null, this._shaderProgram = null;\n    }\n    Clone(e) {\n      const t = C32.New(C32.EffectType, e, [this._id, this._name], -1);\n      return t._shaderProgram = this._shaderProgram, t._isActive = this._isActive, t;\n    }\n    _InitRenderer(e) {\n      const t = e.GetShaderProgramByName(this._id);\n      if (!t) throw new Error(\"failed to find shader program '\" + this._id + \"'\");\n      this._shaderProgram = t;\n    }\n    GetEffectList() {\n      return this._effectList;\n    }\n    GetName() {\n      return this._name;\n    }\n    _SetIndex(e) {\n      this._index = e;\n    }\n    GetIndex() {\n      return this._index;\n    }\n    GetOwner() {\n      return this._effectList.GetOwner();\n    }\n    GetRuntime() {\n      return this._effectList.GetRuntime();\n    }\n    SetActive(e) {\n      this._isActive = !!e;\n    }\n    IsActive() {\n      return this._isActive;\n    }\n    GetShaderProgram() {\n      return this._shaderProgram;\n    }\n    GetDefaultParameterValues() {\n      const r = [];\n      for (let e = 0, t = this._shaderProgram.GetParameterCount(); e < t; ++e) {\n        const s = this._shaderProgram.GetParameterType(e);\n        if (\"float\" === s || \"percent\" === s) r.push(0);\n        else {\n          if (\"color\" !== s) throw new TypeError(\"unknown effect parameter type\");\n          r.push(C32.New(C32.Color, 1, 1, 1, 1));\n        }\n      }\n      return r;\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.InstanceEffectList = class extends C32.DefendedBase {\n    constructor(e, t) {\n      super(), this._inst = e, this._wi = t, this._effectList = e.GetObjectClass().GetEffectList(), this._needsRebuildSteps = true, this._wasDefaultColor = true, this._was3D = false, this._wasRotatedOrNegativeSize = false, this._wasTexRotated = false, this._wasMustPreDraw = false, this._effectChain = C32.New(C32.Gfx.EffectChain, e.GetRuntime().GetCanvasManager().GetEffectChainManager(), { drawContent: (e2, t2) => {\n        const s = t2.GetContentObject(), f = s.GetWorldInfo();\n        e2.SetColor(f.GetPremultipliedColor()), e2.SetCurrentZ(f.GetTotalZElevation()), s.Draw(e2), e2.SetCurrentZ(0);\n      }, getSourceTextureInfo: (e2) => {\n        const t2 = e2.GetCurrentTexRect(), [s, f] = e2.GetCurrentSurfaceSize();\n        return { srcTexRect: t2, srcWidth: s, srcHeight: f };\n      }, getShaderParameters: (e2) => this._GetEffectChainShaderParametersForIndex(e2) }), this._activeEffectFlags = [], this._activeEffectTypes = [], this._preservesOpaqueness = true, this._effectParams = [], this._effectParamBuffers = [], this._InitRenderer(e.GetRuntime().GetRenderer());\n      for (let e2 = 0, t2 = this._effectList.GetAllEffectTypes().length; e2 < t2; ++e2) this._activeEffectFlags.push(true);\n      this.UpdateActiveEffects(), this._effectList._AddInstanceEffectList(this);\n    }\n    Release() {\n      this._effectList._RemoveInstanceEffectList(this);\n      for (const e of this._effectParamBuffers) e && e.Release();\n      C32.clearArray(this._effectParamBuffers), this._effectChain.Release(), this._effectChain = null, C32.clearArray(this._activeEffectFlags), C32.clearArray(this._activeEffectTypes), C32.clearArray(this._effectParams), this._inst = null, this._effectList = null;\n    }\n    _InitRenderer(e) {\n      e.IsWebGPU() && (this._effectParamBuffers = this._effectList.GetAllEffectTypes().map((e2) => {\n        const t = e2.GetShaderProgram();\n        return 0 < t.GetCustomParametersByteSize() ? C32.New(C32.Gfx.WebGPUEffectCustomParamsBuffer, t) : null;\n      }));\n    }\n    _LoadEffectParameters(e) {\n      let t = 0;\n      for (const s of e) this._effectParams.push(this._LoadSingleEffectParameters(t, s)), ++t;\n      this._UpdateAllEffectParamBuffers(), this.UpdateActiveEffects();\n    }\n    _LoadSingleEffectParameters(e, t) {\n      this._activeEffectFlags[e] = t[0];\n      const s = t.slice(1);\n      for (let e2 = 0, t2 = s.length; e2 < t2; ++e2) {\n        const f = s[e2];\n        if (Array.isArray(f)) {\n          const a = C32.New(C32.Color);\n          a.setFromJSON(f), s[e2] = a;\n        }\n      }\n      return s;\n    }\n    LoadDefaultEffectParameters() {\n      for (const e of this._effectList.GetAllEffectTypes()) this._effectParams.push(e.GetDefaultParameterValues());\n      this._UpdateAllEffectParamBuffers();\n    }\n    GetOwner() {\n      return this._owner;\n    }\n    GetEffectList() {\n      return this._effectList;\n    }\n    GetEffectChain() {\n      return this._MaybeRebuildEffectChainSteps(), this._effectChain;\n    }\n    GetRuntime() {\n      return this._inst.GetRuntime();\n    }\n    UpdateActiveEffects() {\n      C32.clearArray(this._activeEffectTypes);\n      const e = this._wi, s = this._effectList.GetAllEffectTypes(), f = this._activeEffectTypes, a = this._activeEffectFlags;\n      let r = true;\n      for (let e2 = 0, t = s.length; e2 < t; ++e2) if (a[e2]) {\n        const i = s[e2];\n        f.push(i), i.GetShaderProgram().PreservesOpaqueness() || (r = false);\n      }\n      this._preservesOpaqueness = r, e._SetHasAnyActiveEffect(!!f.length), this._needsRebuildSteps = true;\n    }\n    _MaybeRebuildEffectChainSteps() {\n      const e = this._inst, t = this._wi, s = t.HasDefaultColor(), f = e.GetPlugin().Is3D(), a = 0 !== t.GetAngle() || 0 !== t.GetLayer().GetAngle() || t.GetWidth() < 0 || t.GetHeight() < 0, r = e.IsCurrentTexRotated(), i = e.MustPreDraw();\n      (this._needsRebuildSteps || s !== this._wasDefaultColor || f !== this._was3D || a !== this._wasRotatedOrNegativeSize || r !== this._wasTexRotated || i !== this._wasMustPreDraw || this._effectChain.NeedsRebuild()) && (this._effectChain.BuildSteps(this._activeEffectTypes.map((e2) => e2.GetShaderProgram()), { indexMap: this._activeEffectTypes.map((e2) => e2.GetIndex()), forcePreDraw: !s || i, is3D: f, isSourceTextureRotated: r, isRotatedOrNegativeSizeInstance: a }), this._needsRebuildSteps = false, this._wasDefaultColor = s, this._was3D = f, this._wasRotatedOrNegativeSize = a, this._wasTexRotated = r, this._wasMustPreDraw = i);\n    }\n    GetActiveEffectTypes() {\n      return this._activeEffectTypes;\n    }\n    GetEffectParametersForIndex(e) {\n      return this._effectParams[e];\n    }\n    _GetEffectChainShaderParametersForIndex(e) {\n      return (e < this._effectParamBuffers.length ? this._effectParamBuffers : this._effectParams)[e];\n    }\n    GetEffectParameter(e, t) {\n      if (e < 0 || e >= this._effectParams.length) return null;\n      const s = this._effectParams[e];\n      return t < 0 || t >= s.length ? null : s[t];\n    }\n    SetEffectParameter(e, t, s) {\n      if (e < 0 || e >= this._effectParams.length) return false;\n      const f = this._effectParams[e];\n      if (t < 0 || t >= f.length) return false;\n      const a = f[t];\n      if (a instanceof C32.Color) {\n        if (a.equalsIgnoringAlpha(s)) return false;\n        a.copyRgb(s);\n      } else {\n        if (a === s) return false;\n        f[t] = s;\n      }\n      return e < this._effectParamBuffers.length && this._effectParamBuffers[e].SetParameterValue(t, s), true;\n    }\n    _UpdateAllEffectParamBuffers() {\n      const s = this._effectParams, f = this._effectParamBuffers;\n      for (let e = 0, t = f.length; e < t; ++e) {\n        const a = f[e], r = s[e];\n        for (let e2 = 0, t2 = r.length; e2 < t2; ++e2) a.SetParameterValue(e2, r[e2]);\n      }\n    }\n    PreservesOpaqueness() {\n      return this._preservesOpaqueness;\n    }\n    HasAnyActiveBackgroundBlendingEffect() {\n      return this._activeEffectTypes.some((e) => e.GetShaderProgram().BlendsBackground());\n    }\n    IsEffectIndexActive(e) {\n      return this._activeEffectFlags[e];\n    }\n    SetEffectIndexActive(e, t) {\n      this._activeEffectFlags[e] = !!t;\n    }\n    GetAllEffectTypes() {\n      return this._effectList.GetAllEffectTypes();\n    }\n    _SaveToJson() {\n      return this._effectList.GetAllEffectTypes().map((e) => ({ \"name\": e.GetName(), \"active\": this._activeEffectFlags[e.GetIndex()], \"params\": C32.EffectList.SaveFxParamsToJson(this._effectParams[e.GetIndex()]) }));\n    }\n    _LoadFromJson(e) {\n      for (const t of e) {\n        const s = this._effectList.GetEffectTypeByName(t[\"name\"]);\n        s && (this._activeEffectFlags[s.GetIndex()] = t[\"active\"], this._effectParams[s.GetIndex()] = C32.EffectList.LoadFxParamsFromJson(t[\"params\"]));\n      }\n      this.UpdateActiveEffects(), this._UpdateAllEffectParamBuffers();\n    }\n  };\n}\n{\n  const C32 = self.C3, tempCandidates = [], tileCollRectCandidates = [], tempJumpthruRet = [], tempPolyA = C32.New(C32.CollisionPoly), tempPolyB = C32.New(C32.CollisionPoly), tempQuad = C32.New(C32.Quad), tempRect = C32.New(C32.Rect), tempRect2 = C32.New(C32.Rect);\n  let tempPolyC = null, tempRect3 = null, tempQuadB = null;\n  C32.CollisionEngine = class extends C32.DefendedBase {\n    constructor(e) {\n      super(), this._runtime = e, this._collisionCellWidth = 0, this._collisionCellHeight = 0, this._registeredCollisions = [], this._collisionCheckCount = 0, this._collisionCheckSec = 0, this._polyCheckCount = 0, this._polyCheckSec = 0, this._iCollisionEngine = new self.ICollisionEngine(this);\n    }\n    Release() {\n      this._runtime = null;\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetICollisionEngine() {\n      return this._iCollisionEngine;\n    }\n    _Update1sStats() {\n      this._collisionCheckSec = this._collisionCheckCount, this._collisionCheckCount = 0, this._polyCheckSec = this._polyCheckCount, this._polyCheckCount = 0;\n    }\n    Get1secCollisionChecks() {\n      return this._collisionCheckSec;\n    }\n    Get1secPolyChecks() {\n      return this._polyCheckSec;\n    }\n    RegisterCollision(e, t) {\n      const s = e.GetWorldInfo(), l = t.GetWorldInfo();\n      s && l && s.IsCollisionEnabled() && l.IsCollisionEnabled() && this._registeredCollisions.push([e, t]);\n    }\n    AddRegisteredCollisionCandidates(t, s, l) {\n      for (const [n, o] of this._registeredCollisions) {\n        let e = null;\n        if (t === n) e = o;\n        else {\n          if (t !== o) continue;\n          e = n;\n        }\n        !e.BelongsToObjectClass(s) || l.includes(e) || l.push(e);\n      }\n    }\n    CheckRegisteredCollision(e, t) {\n      if (this._registeredCollisions.length) {\n        for (const [s, l] of this._registeredCollisions) if (e === s && t === l || e === l && t === s) return true;\n      }\n      return false;\n    }\n    ClearRegisteredCollisions() {\n      C32.clearArray(this._registeredCollisions);\n    }\n    TestOverlap(e, t) {\n      if (!e || !t || e === t) return false;\n      const s = e.GetWorldInfo(), l = t.GetWorldInfo();\n      if (!s.IsCollisionEnabled() || !l.IsCollisionEnabled()) return false;\n      this._collisionCheckCount++;\n      const n = s.GetLayer(), o = l.GetLayer(), i = n.IsTransformCompatibleWith(o);\n      return i ? this._TestOverlap_SameLayers(s, l) : this._TestOverlap_DifferentLayers(s, l);\n    }\n    _TestOverlap_SameLayers(e, t) {\n      if (!e.GetBoundingBox().intersectsRect(t.GetBoundingBox())) return false;\n      if (this._polyCheckCount++, !e.GetBoundingQuad().intersectsQuad(t.GetBoundingQuad())) return false;\n      if (e.HasTilemap() && t.HasTilemap()) return false;\n      if (e.HasTilemap()) return this.TestTilemapOverlap(e, t);\n      if (t.HasTilemap()) return this.TestTilemapOverlap(t, e);\n      if (!e.HasOwnCollisionPoly() && !t.HasOwnCollisionPoly()) return true;\n      const s = e.GetTransformedCollisionPoly(), l = t.GetTransformedCollisionPoly();\n      return s.intersectsPoly(l, t.GetX() - e.GetX(), t.GetY() - e.GetY());\n    }\n    _TestOverlap_DifferentLayers(s, l) {\n      const e = s.HasTilemap(), t = l.HasTilemap();\n      if (e && !t) return this.TestTilemapOverlapDifferentLayers(s, l);\n      if (t && !e) return this.TestTilemapOverlapDifferentLayers(l, s);\n      if (t || e) return false;\n      {\n        const n = s.GetLayer(), o = l.GetLayer(), i = (tempPolyA.copy(s.GetTransformedCollisionPoly()), tempPolyB.copy(l.GetTransformedCollisionPoly()), tempPolyA.pointsArr());\n        for (let e2 = 0, t2 = i.length; e2 < t2; e2 += 2) {\n          const a = e2 + 1, c = i[e2], C = i[a], [d, u] = n.LayerToCanvasCss(c + s.GetX(), C + s.GetY());\n          i[e2] = d, i[a] = u;\n        }\n        const r = tempPolyB.pointsArr();\n        for (let e2 = 0, t2 = r.length; e2 < t2; e2 += 2) {\n          const h = e2 + 1, p = r[e2], f = r[h], [G, m] = o.LayerToCanvasCss(p + l.GetX(), f + l.GetY());\n          r[e2] = G, r[h] = m;\n        }\n        return tempPolyA.setBboxChanged(), tempPolyB.setBboxChanged(), this._polyCheckCount++, tempPolyA.intersectsPoly(tempPolyB, 0, 0);\n      }\n    }\n    TestTilemapOverlapDifferentLayers(e, t) {\n      const s = e.GetLayer(), l = t.GetLayer(), n = (tempPolyC = tempPolyC || C32.New(C32.CollisionPoly), tempRect3 = tempRect3 || C32.New(C32.Rect), tempQuadB = tempQuadB || C32.New(C32.Quad), t.GetX()), o = t.GetY(), [i, r] = l.LayerToCanvasCss(n, o), [a, c] = s.CanvasCssToLayer(i, r), C = a - n, d = c - o;\n      if (tempRect3.copy(t.GetBoundingBox()), tempRect3.offset(C, d), !e.GetBoundingBox().intersectsRect(tempRect3)) return false;\n      if (tempQuadB.copy(t.GetBoundingQuad()), tempQuadB.offset(C, d), this._polyCheckCount++, !e.GetBoundingQuad().intersectsQuad(tempQuadB)) return false;\n      tempPolyC.copy(t.GetTransformedCollisionPoly());\n      const u = tempPolyC.pointsArr();\n      for (let e2 = 0, t2 = u.length; e2 < t2; e2 += 2) {\n        const h = e2 + 1;\n        u[e2] += C, u[h] += d;\n      }\n      return tempPolyC.setBboxChanged(), this.TestTilemapOverlap(e, t, a, c, tempPolyC, tempRect3, tempQuadB);\n    }\n    TestTilemapOverlap(e, s, t, l, n, o, i) {\n      const r = void 0 !== o ? o : s.GetBoundingBox(), a = e.GetX(), c = e.GetY(), C = e.GetInstance().GetSdkInstance(), d = void 0 !== t ? t : s.GetX(), u = void 0 !== l ? l : s.GetY(), h = s.HasOwnCollisionPoly(), p = void 0 !== i ? i : s.GetBoundingQuad(), f = tileCollRectCandidates;\n      C.GetCollisionRectCandidates(r, f);\n      for (let e2 = 0, t2 = f.length; e2 < t2; ++e2) {\n        const G = f[e2], m = G.GetRect();\n        if (this._collisionCheckCount++, r.intersectsRectOffset(m, a, c) && (tempQuad.setFromRect(m), tempQuad.offset(a, c), tempQuad.intersectsQuad(p))) if (h) {\n          const y = void 0 !== n ? n : s.GetTransformedCollisionPoly();\n          let e3 = d, t3 = u;\n          void 0 !== n && (e3 = s.GetX(), t3 = s.GetY());\n          const g = G.GetPoly();\n          if (g) {\n            if (this._polyCheckCount++, g.intersectsPoly(y, e3 - (a + m.getLeft()), t3 - (c + m.getTop()))) return C32.clearArray(f), true;\n          } else if (tempPolyA.setFromQuad(tempQuad, 0, 0), tempPolyA.intersectsPoly(y, e3, t3)) return C32.clearArray(f), true;\n        } else {\n          const T = G.GetPoly();\n          if (!T) return C32.clearArray(f), true;\n          if (tempPolyA.setFromQuad(p, 0, 0), T.intersectsPoly(tempPolyA, -(a + m.getLeft()), -(c + m.getTop()))) return C32.clearArray(f), true;\n        }\n      }\n      return C32.clearArray(f), false;\n    }\n    TestAndSelectCanvasPointOverlap(e, o, i) {\n      const r = e.GetCurrentSol(), t = this._runtime.GetCurrentEvent();\n      if (!t) throw new Error(\"cannot call outside event\");\n      const a = t.IsOrBlock(), s = /* @__PURE__ */ new Map(), c = (e2) => {\n        let t2 = s.get(e2);\n        return void 0 === t2 && (t2 = e2.IsSelfAndParentsInteractive(), s.set(e2, t2)), t2;\n      };\n      if (r.IsSelectAll()) {\n        i || (r._SetSelectAll(false), C32.clearArray(r._GetOwnInstances())), a && C32.clearArray(r._GetOwnElseInstances());\n        for (const l of e.GetInstances()) {\n          const n = l.GetWorldInfo(), C = n.GetLayer();\n          let e2 = false;\n          if (e2 = c(C) && n.IsInViewport2() ? o.some(([e3, t2]) => {\n            const [s2, l2] = C.CanvasCssToLayer(e3, t2, n.GetTotalZElevation());\n            return n.ContainsPoint(s2, l2);\n          }) : e2) {\n            if (i) return false;\n            r._PushInstance(l);\n          } else a && r._PushElseInstance(l);\n        }\n      } else {\n        let s2, l = false, n = (!a || t.IsFirstConditionOfType(this._runtime.GetCurrentCondition()) || this._runtime.IsCurrentConditionFirst() && !r._GetOwnElseInstances().length && r._GetOwnInstances().length ? s2 = r._GetOwnInstances() : (s2 = r._GetOwnElseInstances(), l = true), 0);\n        for (let t2 = 0, e2 = s2.length; t2 < e2; ++t2) {\n          const d = s2[t2], u = d.GetWorldInfo(), h = u.GetLayer();\n          let e3 = false;\n          if (e3 = c(h) && u.IsInViewport2() ? o.some(([e4, t3]) => {\n            const [s3, l2] = h.CanvasCssToLayer(e4, t3, u.GetTotalZElevation());\n            return u.ContainsPoint(s3, l2);\n          }) : e3) {\n            if (i) return false;\n            l ? r._PushInstance(d) : s2[n++] = d;\n          } else l ? s2[n++] = d : a && r._PushElseInstance(d);\n        }\n        i || (s2.length = n);\n      }\n      return e.ApplySolToContainer(), s.clear(), !!i || r.HasAnyInstances();\n    }\n    _ObjectClassCanUseCollisionCells(e, t) {\n      if (e) {\n        for (const s of t.layersHasInstancesOn()) if (!e.IsTransformCompatibleWith(s)) return false;\n      }\n      return true;\n    }\n    GetCollisionCandidates(e, t, s, l) {\n      if (t.IsFamily()) for (const n of t.GetFamilyMembers()) this._ObjectClassCanUseCollisionCells(e, n) ? (n._UpdateAllCollisionCells(), n._GetCollisionCellGrid().QueryRange(s, l)) : C32.appendArray(l, n.GetInstances());\n      else this._ObjectClassCanUseCollisionCells(e, t) ? (t._UpdateAllCollisionCells(), t._GetCollisionCellGrid().QueryRange(s, l)) : C32.appendArray(l, t.GetInstances());\n    }\n    GetObjectClassesCollisionCandidates(e, t, s, l) {\n      for (const n of t) this.GetCollisionCandidates(e, n, s, l);\n    }\n    GetSolidCollisionCandidates(e, t, s) {\n      const l = this._runtime.GetSolidBehavior();\n      l && this.GetObjectClassesCollisionCandidates(e, l.GetObjectClasses(), t, s);\n    }\n    GetJumpthruCollisionCandidates(e, t, s) {\n      const l = this._runtime.GetJumpthruBehavior();\n      l && this.GetObjectClassesCollisionCandidates(e, l.GetObjectClasses(), t, s);\n    }\n    IsSolidCollisionAllowed(e, t) {\n      return e._IsSolidEnabled() && (!t || t.GetWorldInfo().IsSolidCollisionAllowed(e.GetSavedDataMap().get(\"solidTags\")));\n    }\n    TestOverlapSolid(e) {\n      const t = e.GetWorldInfo();\n      this.GetSolidCollisionCandidates(t.GetLayer(), t.GetBoundingBox(), tempCandidates);\n      for (const s of tempCandidates) if (this.IsSolidCollisionAllowed(s, e) && this.TestOverlap(e, s)) return C32.clearArray(tempCandidates), s;\n      return C32.clearArray(tempCandidates), null;\n    }\n    TestRectOverlapSolid(e, t) {\n      this.GetSolidCollisionCandidates(null, e, tempCandidates);\n      for (const s of tempCandidates) if (this.IsSolidCollisionAllowed(s, t) && this.TestRectOverlap(e, s)) return C32.clearArray(tempCandidates), s;\n      return C32.clearArray(tempCandidates), null;\n    }\n    TestOverlapJumpthru(e, t) {\n      let s = null;\n      t && (s = tempJumpthruRet, C32.clearArray(s));\n      const l = e.GetWorldInfo();\n      this.GetJumpthruCollisionCandidates(l.GetLayer(), l.GetBoundingBox(), tempCandidates);\n      for (const n of tempCandidates) if (n._IsJumpthruEnabled() && this.TestOverlap(e, n)) {\n        if (!t) return C32.clearArray(tempCandidates), n;\n        s.push(n);\n      }\n      return C32.clearArray(tempCandidates), s;\n    }\n    PushOut(t, s, l, n, o) {\n      n = n || 50;\n      const i = t.GetWorldInfo(), r = i.GetX(), a = i.GetY();\n      for (let e = 0; e < n; ++e) if (i.SetXY(r + s * e, a + l * e), i.SetBboxChanged(), !this.TestOverlap(t, o)) return true;\n      return i.SetXY(r, a), i.SetBboxChanged(), false;\n    }\n    PushOutSolid(t, s, l, n, o, i) {\n      n = n || 50;\n      const r = t.GetWorldInfo(), a = r.GetX(), c = r.GetY();\n      let C = null, d = null;\n      for (let e = 0; e < n; ++e) if (r.SetXY(a + s * e, c + l * e), r.SetBboxChanged(), !this.TestOverlap(t, C)) {\n        if (C = this.TestOverlapSolid(t)) d = C;\n        else if (o && (C = i ? this.TestOverlap(t, i) ? i : null : this.TestOverlapJumpthru(t)) && (d = C), !C) return d && this.PushInFractional(t, s, l, d, 16, true), true;\n      }\n      return r.SetXY(a, c), r.SetBboxChanged(), false;\n    }\n    PushOutSolidAxis(s, l, n, e) {\n      e = e || 50;\n      const o = s.GetWorldInfo(), i = o.GetX(), r = o.GetY();\n      let a = null, c = null;\n      for (let t = 0; t < e; ++t) for (let e2 = 0; e2 < 2; ++e2) {\n        const C = 2 * e2 - 1;\n        if (o.SetXY(i + l * t * C, r + n * t * C), o.SetBboxChanged(), !this.TestOverlap(s, a)) {\n          if (!(a = this.TestOverlapSolid(s))) return c && this.PushInFractional(s, l * C, n * C, c, 16, true), true;\n          c = a;\n        }\n      }\n      return o.SetXY(i, r), o.SetBboxChanged(), false;\n    }\n    PushInFractional(e, t, s, l, n, o) {\n      let i = 2, r = false, a = false;\n      const c = e.GetWorldInfo();\n      let C = c.GetX(), d = c.GetY();\n      for (; i <= n; ) {\n        const u = 1 / i;\n        i *= 2, c.OffsetXY(t * u * (r ? 1 : -1), s * u * (r ? 1 : -1)), c.SetBboxChanged(), this.TestOverlap(e, l) || o && this.TestOverlapSolid(e) ? (r = true, a = true) : (r = false, a = false, C = c.GetX(), d = c.GetY());\n      }\n      a && (c.SetXY(C, d), c.SetBboxChanged());\n    }\n    PushOutSolidNearest(s, e = 100) {\n      let l = 0;\n      const n = s.GetWorldInfo(), o = n.GetX(), i = n.GetY();\n      let r = 0, a = this.TestOverlapSolid(s);\n      if (!a) return true;\n      for (; l <= e; ) {\n        let e2 = 0, t = 0;\n        switch (r) {\n          case 0:\n            e2 = 0, t = -1, l++;\n            break;\n          case 1:\n            e2 = 1, t = -1;\n            break;\n          case 2:\n            e2 = 1, t = 0;\n            break;\n          case 3:\n            e2 = 1, t = 1;\n            break;\n          case 4:\n            e2 = 0, t = 1;\n            break;\n          case 5:\n            e2 = -1, t = 1;\n            break;\n          case 6:\n            e2 = -1, t = 0;\n            break;\n          case 7:\n            e2 = -1, t = -1;\n        }\n        if (r = (r + 1) % 8, n.SetXY(Math.floor(o + e2 * l), Math.floor(i + t * l)), n.SetBboxChanged(), !this.TestOverlap(s, a) && !(a = this.TestOverlapSolid(s))) return true;\n      }\n      return n.SetXY(o, i), n.SetBboxChanged(), false;\n    }\n    CalculateBounceAngle(e, t, s, l) {\n      const n = e.GetWorldInfo(), o = n.GetX(), i = n.GetY(), r = Math.max(10, C32.distanceTo(t, s, o, i)), a = C32.angleTo(t, s, o, i), c = l || this.TestOverlapSolid(e);\n      if (!c) return C32.clampAngle(a + Math.PI);\n      let C = c, d = 0, u = 0;\n      const h = C32.toRadians(5);\n      let p;\n      for (p = 1; p < 36; ++p) {\n        const P = a - p * h;\n        if (n.SetXY(t + Math.cos(P) * r, s + Math.sin(P) * r), n.SetBboxChanged(), !this.TestOverlap(e, C) && !(C = l ? null : this.TestOverlapSolid(e))) {\n          d = P;\n          break;\n        }\n      }\n      for (36 === p && (d = C32.clampAngle(a + Math.PI)), C = c, p = 1; p < 36; ++p) {\n        const O = a + p * h;\n        if (n.SetXY(t + Math.cos(O) * r, s + Math.sin(O) * r), n.SetBboxChanged(), !this.TestOverlap(e, C) && !(C = l ? null : this.TestOverlapSolid(e))) {\n          u = O;\n          break;\n        }\n      }\n      if (36 === p && (u = C32.clampAngle(a + Math.PI)), n.SetXY(o, i), n.SetBboxChanged(), u === d) return u;\n      const f = C32.angleDiff(u, d) / 2;\n      let G;\n      G = C32.angleClockwise(u, d) ? C32.clampAngle(d + f + Math.PI) : C32.clampAngle(u + f);\n      const m = Math.cos(a), y = Math.sin(a), g = Math.cos(G), T = Math.sin(G), _ = m * g + y * T, I = m - 2 * _ * g, S = y - 2 * _ * T;\n      return C32.angleTo(0, 0, I, S);\n    }\n    TestSegmentOverlap(e, t, s, l, n) {\n      if (!n) return false;\n      const o = n.GetWorldInfo();\n      if (!o.IsCollisionEnabled()) return false;\n      if (this._collisionCheckCount++, tempRect.set(Math.min(e, s), Math.min(t, l), Math.max(e, s), Math.max(t, l)), !o.GetBoundingBox().intersectsRect(tempRect)) return false;\n      if (n.HasTilemap()) return this._TestSegmentOverlapTilemap(e, t, s, l, n, o);\n      if (this._polyCheckCount++, !o.GetBoundingQuad().intersectsSegment(e, t, s, l)) return false;\n      if (!o.HasOwnCollisionPoly()) return true;\n      const i = o.GetTransformedCollisionPoly();\n      return i.intersectsSegment(o.GetX(), o.GetY(), e, t, s, l);\n    }\n    _TestSegmentOverlapTilemap(s, l, n, o, e, t) {\n      const i = t.GetX(), r = t.GetY(), a = e.GetSdkInstance(), c = tileCollRectCandidates;\n      tempRect2.set(s, l, n, o), tempRect2.normalize(), a.GetCollisionRectCandidates(tempRect2, c);\n      for (let e2 = 0, t2 = c.length; e2 < t2; ++e2) {\n        const C = c[e2], d = C.GetRect();\n        if (this._collisionCheckCount++, tempRect.intersectsRectOffset(d, i, r) && (tempQuad.setFromRect(d), tempQuad.offset(i, r), tempQuad.intersectsSegment(s, l, n, o))) {\n          const u = C.GetPoly();\n          if (!u) return C32.clearArray(c), true;\n          if (this._polyCheckCount++, u.intersectsSegment(i + d.getLeft(), r + d.getTop(), s, l, n, o)) return C32.clearArray(c), true;\n        }\n      }\n      return C32.clearArray(c), false;\n    }\n    TestRectOverlap(e, t) {\n      if (!t) return false;\n      const s = t.GetWorldInfo();\n      if (!s.IsCollisionEnabled()) return false;\n      if (this._collisionCheckCount++, !s.GetBoundingBox().intersectsRect(e)) return false;\n      if (t.HasTilemap()) return this._TestRectOverlapTilemap(e, t, s);\n      if (this._polyCheckCount++, tempQuad.setFromRect(e), !s.GetBoundingQuad().intersectsQuad(tempQuad)) return false;\n      if (!s.HasOwnCollisionPoly()) return true;\n      const l = tempPolyA, n = (l.setFromRect(e, s.GetX(), s.GetY()), s.GetTransformedCollisionPoly());\n      return l.intersectsPoly(n, 0, 0);\n    }\n    _TestRectOverlapTilemap(s, e, t) {\n      const l = t.GetX(), n = t.GetY(), o = e.GetSdkInstance(), i = tileCollRectCandidates;\n      o.GetCollisionRectCandidates(s, i);\n      for (let e2 = 0, t2 = i.length; e2 < t2; ++e2) {\n        const r = i[e2], a = r.GetRect();\n        if (this._collisionCheckCount++, s.intersectsRectOffset(a, l, n)) {\n          const c = r.GetPoly();\n          if (!c) return C32.clearArray(i), true;\n          if (this._polyCheckCount++, tempPolyA.setFromRect(s, 0, 0), c.intersectsPoly(tempPolyA, -(l + a.getLeft()), -(n + a.getTop()))) return C32.clearArray(i), true;\n        }\n      }\n      return C32.clearArray(i), false;\n    }\n    TestRayIntersectsInstance(e, t) {\n      if (e) {\n        const s = e.GetWorldInfo();\n        s.IsCollisionEnabled() && (this._collisionCheckCount++, s.GetBoundingBox().intersectsRect(t.rect)) && (e.HasTilemap() ? this._TestRayIntersectsTilemap(e, s, t) : (this._polyCheckCount++, s.HasOwnCollisionPoly() ? t.TestInstancePoly(e, s.GetX(), s.GetY(), s.GetTransformedCollisionPoly()) : t.TestInstanceQuad(e, s.GetBoundingQuad())));\n      }\n    }\n    _TestRayIntersectsTilemap(s, l, n) {\n      const o = l.GetX(), i = l.GetY(), r = tileCollRectCandidates;\n      s.GetSdkInstance().GetCollisionRectCandidates(n.rect, r);\n      for (let e = 0, t = r.length; e < t; e++) {\n        const a = r[e], c = a.GetRect();\n        if (this._collisionCheckCount++, n.rect.intersectsRectOffset(c, o, i)) {\n          const C = a.GetPoly();\n          this._polyCheckCount++, C ? n.TestInstancePoly(s, o + c.getLeft(), i + c.getTop(), C) : n.TestInstanceRect(s, l.GetX(), l.GetY(), c);\n        }\n      }\n      C32.clearArray(r);\n    }\n    SetCollisionCellSize(e, t) {\n      if (e !== this._collisionCellWidth || t !== this._collisionCellHeight) {\n        this._collisionCellWidth = e, this._collisionCellHeight = t;\n        const s = this._runtime.GetAllObjectClasses();\n        for (const l of s) if (l.IsWorldType()) {\n          for (const n of l.instancesIncludingPendingCreate()) n.GetWorldInfo()._RemoveFromCollisionCells();\n          l._GetCollisionCellGrid().SetCellSize(e, t), l._SetAnyCollisionCellChanged();\n          for (const o of l.instancesIncludingPendingCreate()) {\n            const i = o.GetWorldInfo();\n            i._SetCollisionCellChanged(), i._UpdateCollisionCell();\n          }\n        }\n      }\n    }\n    GetCollisionCellSize() {\n      return [this._collisionCellWidth, this._collisionCellHeight];\n    }\n    _InitCollisionCellSize(e, t) {\n      this._collisionCellWidth = e, this._collisionCellHeight = t;\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.SparseGrid = class extends C32.DefendedBase {\n    constructor(t, e) {\n      super(), this._cellWidth = t, this._cellHeight = e, this._cells = C32.New(C32.PairMap);\n    }\n    Release() {\n      this._cells.Release(), this._cells = null;\n    }\n    SetCellSize(t, e) {\n      if (!this._cells.IsEmpty()) throw new Error(\"grid not empty\");\n      this._cellWidth = t, this._cellHeight = e;\n    }\n    GetCell(t, e, l) {\n      let i = this._cells.Get(t, e);\n      return i || (l ? (i = C32.New(C32.GridCell, this, t, e), this._cells.Set(t, e, i), i) : null);\n    }\n    XToCell(t) {\n      const e = Math.floor(t / this._cellWidth);\n      return isFinite(e) ? e : 0;\n    }\n    YToCell(t) {\n      const e = Math.floor(t / this._cellHeight);\n      return isFinite(e) ? e : 0;\n    }\n    Update(i, s, o) {\n      if (s) {\n        for (let l = s.getLeft(), t = s.getRight(); l <= t; ++l) for (let t2 = s.getTop(), e = s.getBottom(); t2 <= e; ++t2) if (!o || !o.containsPoint(l, t2)) {\n          const h = this.GetCell(l, t2, false);\n          h && (h.Remove(i), h.IsEmpty()) && this._cells.Delete(l, t2);\n        }\n      }\n      if (o) for (let l = o.getLeft(), t = o.getRight(); l <= t; ++l) for (let t2 = o.getTop(), e = o.getBottom(); t2 <= e; ++t2) s && s.containsPoint(l, t2) || this.GetCell(l, t2, true).Insert(i);\n    }\n    QueryRange(t, e) {\n      let l = this.XToCell(t.getLeft());\n      const i = this.YToCell(t.getTop()), s = this.XToCell(t.getRight()), o = this.YToCell(t.getBottom());\n      if (isFinite(s) && isFinite(o)) for (; l <= s; ++l) for (let t2 = i; t2 <= o; ++t2) {\n        const h = this.GetCell(l, t2, false);\n        h && h.Dump(e);\n      }\n    }\n  };\n}\n{\n  const C32 = self.C3;\n  C32.GridCell = class extends C32.DefendedBase {\n    constructor(s, e, t) {\n      super(), this._grid = s, this._x = e, this._y = t, this._instances = C32.New(C32.ArraySet);\n    }\n    Release() {\n      this._instances.Release(), this._instances = null, this._grid = null;\n    }\n    IsEmpty() {\n      return this._instances.IsEmpty();\n    }\n    Insert(s) {\n      this._instances.Add(s);\n    }\n    Remove(s) {\n      this._instances.Delete(s);\n    }\n    Dump(s) {\n      C32.appendArray(s, this._instances.GetArray());\n    }\n  };\n}\n{\n  const C32 = self.C3, PADDING = 1e-6, NO_HIT = 2;\n  C32.Ray = class {\n    constructor() {\n      this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.dx = 0, this.dy = 0, this.rect = new C32.Rect(), this.hitFraction = NO_HIT, this.hitUid = null, this.hitNormal = 0, this.hitNormalDx = 0, this.hitNormalDy = 0, this.hitX = 0, this.hitY = 0, this.distance = 0, this.normalX = 1, this.normalY = 0, this.reflectionX = 1, this.reflectionY = 0;\n    }\n    DidCollide() {\n      return this.hitFraction < 1 + PADDING;\n    }\n    Reset() {\n      this.hitFraction = NO_HIT;\n    }\n    Set(t, i, s, h) {\n      return this.x1 = t, this.y1 = i, this.x2 = s, this.y2 = h, this.dx = s - t, this.dy = h - i, this.rect.set(t, i, s, h), this.rect.normalize(), this.hitFraction = NO_HIT, this.hitUid = null, this.hitNormal = 0, this.hitNormalDx = 0, this.hitNormalDy = 0, this.hitX = 0, this.hitY = 0, this.distance = 0, this.normalX = 1, this.normalY = 0, this.reflectionX = 1, this.reflectionY = 0, this;\n    }\n    Complete() {\n      if (false !== this.DidCollide()) {\n        const t = this.dx * this.hitFraction, i = this.dy * this.hitFraction, s = C32.hypot2DFast(t, i), h = t / s, e = i / s, n = (this.distance = s - PADDING, this.hitX = this.x1 + h * this.distance, this.hitY = this.y1 + e * this.distance, this.hitNormal = Math.atan2(this.hitNormalDy, this.hitNormalDx) + Math.PI / 2, this.normalX = Math.cos(this.hitNormal), this.normalY = Math.sin(this.hitNormal), h * this.normalX + e * this.normalY);\n        if (this.reflectionX = h - 2 * this.normalX * n, this.reflectionY = e - 2 * this.normalY * n, 0 < n) {\n          const a = Math.PI;\n          this.hitNormal = C32.clampAngle(this.hitNormal + a), this.normalX = -this.normalX, this.normalY = -this.normalY;\n        }\n      }\n    }\n    TestInstanceSegment(t, i, s, h, e) {\n      const n = C32.rayIntersect(this.x1, this.y1, this.x2, this.y2, i, s, h, e);\n      0 <= n && n < this.hitFraction && (this.hitFraction = n, this.hitUid = t.GetUID(), this.hitNormalDx = i - h, this.hitNormalDy = s - e);\n    }\n    TestInstanceRect(t, i, s, h) {\n      const e = i + h.getLeft(), n = i + h.getRight(), a = s + h.getTop(), o = s + h.getBottom();\n      this.TestInstanceSegment(t, e, a, n, a), this.TestInstanceSegment(t, n, a, n, o), this.TestInstanceSegment(t, n, o, e, o), this.TestInstanceSegment(t, e, o, e, a);\n    }\n    TestInstanceQuad(t, i) {\n      const s = i.getTlx(), h = i.getTly(), e = i.getTrx(), n = i.getTry(), a = i.getBrx(), o = i.getBry(), r = i.getBlx(), l = i.getBly();\n      this.TestInstanceSegment(t, s, h, e, n), this.TestInstanceSegment(t, e, n, a, o), this.TestInstanceSegment(t, a, o, r, l), this.TestInstanceSegment(t, r, l, s, h);\n    }\n    TestInstancePoly(s, h, e, t) {\n      const n = t.pointsArr();\n      for (let t2 = 0, i = n.length; t2 < i; t2 += 2) {\n        const a = (t2 + 2) % i, o = n[t2] + h, r = n[t2 + 1] + e, l = n[a] + h, c = n[1 + a] + e;\n        this.TestInstanceSegment(s, o, r, l, c);\n      }\n    }\n  };\n}\n{\n  const C32 = self.C3, VALID_FULLSCREEN_MODES = /* @__PURE__ */ new Set([\"off\", \"crop\", \"scale-inner\", \"scale-outer\", \"letterbox-scale\", \"letterbox-integer-scale\"]), VALID_FULLSCREEN_SCALING_QUALITIES = /* @__PURE__ */ new Set([\"high\", \"low\"]), glMatrix = self.glMatrix, mat4 = glMatrix.mat4, vec3 = glMatrix.vec3, tempProjection = mat4.create(), PERCENTTEXT_WIDTH = 300, PERCENTTEXT_HEIGHT = 200, PROGRESSBAR_WIDTH = 120, PROGRESSBAR_HEIGHT = 8, tempQuad = C32.New(C32.Quad), tempRect = C32.New(C32.Rect), SPLASH_MIN_DISPLAY_TIME = 3e3, SPLASH_AFTER_FADEOUT_WAIT_TIME = 200, SPLASH_FADE_DURATION = 300;\n  C32.CanvasManager = class extends C32.DefendedBase {\n    constructor(e) {\n      super(), this._runtime = e, this._canvasLayers = [], this._isWebGPUEnabled = false, this._webglRenderer = null, this._webgpuRenderer = null, this._iRenderer = null, this._gpuPreference = \"high-performance\", this._isLimitedToWebGL1 = false, this._multitexturingMode = \"auto\", this._windowInnerWidth = 0, this._windowInnerHeight = 0, this._cssDisplayMode = \"\", this._canvasCssWidth = 0, this._canvasCssHeight = 0, this._canvasDeviceWidth = 0, this._canvasDeviceHeight = 0, this._canvasCssOffsetX = 0, this._canvasCssOffsetY = 0, this._zAxisScale = \"normalized\", this._initFieldOfView = 0, this._zNear = 1, this._zFar = 1e4, this._enableMipmaps = true, this._textureAnisotropy = 0, this._drawWidth = 0, this._drawHeight = 0, this._fullscreenMode = \"letterbox-scale\", this._documentFullscreenMode = \"letterbox-scale\", this._deviceTransformOffX = 0, this._deviceTransformOffY = 0, this._defaultProjectionMatrix = mat4.create(), this._wantFullscreenScalingQuality = \"high\", this._fullscreenScalingQuality = this._wantFullscreenScalingQuality, this._isDocumentFullscreen = false, this._availableAdditionalRenderTargets = [], this._usedAdditionalRenderTargets = /* @__PURE__ */ new Set(), this._shaderData = self[\"C3_Shaders\"], this._effectChainManager = C32.New(C32.Gfx.EffectChainManager, { getDrawSize: () => [this.GetDrawWidth(), this.GetDrawHeight()], getRenderTarget: () => this.GetEffectCompositorRenderTarget(), releaseRenderTarget: (e2) => this.ReleaseEffectCompositorRenderTarget(e2), getTime: () => this.GetRuntime().GetGameTime(), redraw: () => this.GetRuntime().UpdateRender() }), this._gpuTimeStartFrame = 0, this._gpuTimeEndFrame = 0, this._gpuLastUtilisation = NaN, this._gpuFrameTimingsBuffer = null, this._layersGpuProfile = /* @__PURE__ */ new Map(), this._gpuCurUtilisation = NaN, this._webgpuFrameTimings = /* @__PURE__ */ new Map(), this._snapshotFormat = \"\", this._snapshotQuality = 1, this._snapshotArea = C32.New(C32.Rect), this._snapshotUrl = \"\", this._snapshotPromise = null, this._snapshotResolve = null, this._isPastingToDrawingCanvas = 0, this._loaderStartTime = 0, this._rafId = -1, this._loadingProgress = 0, this._loadingprogress_handler = (e2) => this._loadingProgress = e2.progress, this._percentText = null, this._splashTextures = { logo: null, powered: null, website: null }, this._splashFrameNumber = 0, this._splashFadeInFinishTime = 0, this._splashFadeOutStartTime = 0, this._splashState = \"fade-in\", this._splashDoneResolve = null, this._splashDonePromise = new Promise((e2) => this._splashDoneResolve = e2);\n    }\n    _SetGPUPowerPreference(e) {\n      this._gpuPreference = e;\n    }\n    _SetWebGPUEnabled(e) {\n      this._isWebGPUEnabled = !!e;\n    }\n    _SetZAxisScale(e) {\n      this._zAxisScale = e;\n    }\n    GetZAxisScale() {\n      return this._zAxisScale;\n    }\n    _SetInitFieldOfView(e) {\n      this._initFieldOfView = e;\n    }\n    _SetZDistances(e, t) {\n      this._zNear = e, this._zFar = t;\n    }\n    _SetLimitedToWebGL1(e) {\n      this._isLimitedToWebGL1 = !!e;\n    }\n    _SetMultitexturingMode(e) {\n      this._multitexturingMode = e;\n    }\n    async CreateCanvas(e) {\n      let t = e[\"canvas\"];\n      this._canvasLayers.push({ canvas: t, ctx: null }), this._runtime.AddDOMComponentMessageHandler(\"runtime\", \"window-resize\", (e2) => this._OnWindowResize(e2)), this._runtime.AddDOMComponentMessageHandler(\"runtime\", \"fullscreenchange\", (e2) => this._OnFullscreenChange(e2)), this._runtime.AddDOMComponentMessageHandler(\"runtime\", \"fullscreenerror\", (e2) => this._OnFullscreenError(e2)), t.addEventListener(\"webglcontextlost\", (e2) => this._OnWebGLContextLost(e2)), t.addEventListener(\"webglcontextrestored\", (e2) => this._OnWebGLContextRestored(e2)), this._isDocumentFullscreen = !!e[\"isFullscreen\"], this._cssDisplayMode = e[\"cssDisplayMode\"];\n      const s = navigator[\"gpu\"] && this._isWebGPUEnabled;\n      let i = false;\n      if (s) try {\n        await this._InitWebGPUContext(true);\n      } catch (e2) {\n        this._MaybeLogRendererError(\"WebGPU\", e2), this._webgpuRenderer = null;\n      }\n      if (!this.GetRenderer()) try {\n        await this._InitWebGLContext(true);\n      } catch (e2) {\n        this._MaybeLogRendererError(\"WebGL\", e2), this._webglRenderer = null;\n      }\n      if (this.GetRenderer() || (i = true), !this.GetRenderer() && s) try {\n        await this._InitWebGPUContext(false);\n      } catch (e2) {\n        this._MaybeLogRendererError(\"WebGPU\", e2), this._webgpuRenderer = null;\n      }\n      if (!this.GetRenderer()) try {\n        await this._InitWebGLContext(false);\n      } catch (e2) {\n        this._MaybeLogRendererError(\"WebGL\", e2), this._webglRenderer = null;\n      }\n      const a = this.GetRenderer();\n      if (!a) throw new Error(\"failed to acquire a renderer - check WebGL or WebGPU is supported\");\n      a.SetHasMajorPerformanceCaveat(i), this._webgpuRenderer && (this._webgpuRenderer.ondevicelost = () => this._OnWebGPUDeviceLost(), this._webgpuRenderer.ondevicerestored = () => this._OnWebGPUDeviceRestored()), \"normalized\" === this._zAxisScale ? a.SetZAxisScaleNormalized() : (a.SetZAxisScaleRegular(), a.SetFovY(this._initFieldOfView)), this.SetSize(e[\"windowInnerWidth\"], e[\"windowInnerHeight\"], true), await this._InitRenderer();\n    }\n    _MaybeLogRendererError(e, t) {\n      t && \"string\" == typeof t.message && t.message.startsWith(\"renderer-unavailable\") || console.error(`Error creating ${e} renderer: `, t);\n    }\n    async _InitWebGPUContext(e) {\n      const t = { nearZ: this._zNear, farZ: this._zFar };\n      let s = true;\n      \"no\" === this._multitexturingMode ? s = false : \"auto\" === this._multitexturingMode && (s = C32.Platform.IsDesktop);\n      const i = { powerPreference: this._gpuPreference, depth: this._runtime.Uses3DFeatures(), failIfMajorPerformanceCaveat: e, usesBackgroundBlending: this._runtime.UsesAnyBackgroundBlending(), canSampleBackbuffer: this._runtime.UsesAnyCrossSampling(), canSampleDepth: this._runtime.UsesAnyDepthSampling(), isMultiTexturingAllowed: s };\n      this._webgpuRenderer = C32.New(C32.Gfx.WebGPURenderer, t), await this._webgpuRenderer.Create(this._canvasLayers[0].canvas, i);\n    }\n    async _InitWebGLContext(e) {\n      const t = { alpha: true, powerPreference: this._gpuPreference, enableGpuProfiling: \"xbox-uwp-webview2\" !== this._runtime.GetExportType(), depth: this._runtime.Uses3DFeatures(), canSampleDepth: this._runtime.UsesAnyDepthSampling(), failIfMajorPerformanceCaveat: e, nearZ: this._zNear, farZ: this._zFar };\n      this._isLimitedToWebGL1 && (t.maxWebGLVersion = 1), this._webglRenderer = C32.New(C32.Gfx.WebGLRenderer, this._canvasLayers[0].canvas, t), await this._webglRenderer.InitState();\n    }\n    async _InitWebGPU() {\n      if (this._shaderData) {\n        const e = [];\n        for (const [t, s] of Object.entries(this._shaderData)) {\n          s.src = s.wgsl;\n          const i = C32.Gfx.WebGPUShaderProgram.GetDefaultVertexShaderSource();\n          e.push(this._webgpuRenderer.CreateShaderProgram(Object.assign({ vertexSrc: i, name: t }, s)));\n        }\n        await Promise.all(e);\n      }\n    }\n    async _InitWebGL() {\n      if (this._shaderData) {\n        const t = [];\n        for (const [s, i] of Object.entries(this._shaderData)) {\n          let e;\n          if (i.glslWebGL2 && 2 <= this._webglRenderer.GetWebGLVersionNumber()) i.src = i.glslWebGL2, e = C32.Gfx.WebGLShaderProgram.GetDefaultVertexShaderSource_WebGL2();\n          else {\n            if (!i.glsl) throw new Error(`shader '${s}' does not support WebGL 1`);\n            i.src = i.glsl, e = C32.Gfx.WebGLShaderProgram.GetDefaultVertexShaderSource();\n          }\n          t.push(this._webglRenderer.CreateShaderProgram(Object.assign({ vertexSrc: e, name: s }, i)));\n        }\n        await Promise.all(t), this._webglRenderer.ResetLastProgram(), this._webglRenderer.SetTextureFillMode();\n      }\n      this._webglRenderer.SupportsGPUProfiling() && (this._gpuFrameTimingsBuffer = C32.New(C32.Gfx.WebGLQueryResultBuffer, this._webglRenderer));\n    }\n    async _InitRenderer() {\n      this._webgpuRenderer ? await this._InitWebGPU() : this._webglRenderer && await this._InitWebGL();\n      const e = this.GetRenderer();\n      e.SetMipmapsEnabled(this._enableMipmaps), e.SupportsGPUProfiling() && (this._gpuLastUtilisation = 0);\n      for (const t of this._runtime._GetAllEffectLists()) {\n        for (const s of t.GetAllEffectTypes()) s._InitRenderer(e);\n        t._InitRenderer(e), t.UpdateActiveEffects();\n      }\n      this._iRenderer = new self.IRenderer(this._runtime, e);\n    }\n    Release() {\n      this._runtime = null, this._webglRenderer = null, this._canvasLayers.length = 0;\n    }\n    IsInWorker() {\n      return this._runtime.IsInWorker();\n    }\n    _OnWindowResize(e) {\n      const t = this._runtime;\n      if (!t.IsExportToVideo()) {\n        const s = e[\"devicePixelRatio\"], i = (this.IsInWorker() && (self.devicePixelRatio = s), t._SetDevicePixelRatio(s), this._isDocumentFullscreen = !!e[\"isFullscreen\"], this._cssDisplayMode = e[\"cssDisplayMode\"], this.SetSize(e[\"innerWidth\"], e[\"innerHeight\"]), t.UpdateRender(), new C32.Event(\"window-resize\")), a = (i.data = e, t.Dispatcher().dispatchEventAndWaitAsyncSequential(i), new C32.Event(\"resize\"));\n        a.cssWidth = this.GetCssWidth(), a.cssHeight = this.GetCssHeight(), a.deviceWidth = this.GetDeviceWidth(), a.deviceHeight = this.GetDeviceHeight(), t.DispatchUserScriptEvent(a), t.IsDebug() && (t.HitBreakpoint() || self.C3Debugger.IsDebuggerPaused()) && t.Render();\n      }\n    }\n    _OnFullscreenChange(e) {\n      this._isDocumentFullscreen = !!e[\"isFullscreen\"], this.SetSize(e[\"innerWidth\"], e[\"innerHeight\"], true), this._runtime.UpdateRender();\n    }\n    _OnFullscreenError(e) {\n      this._isDocumentFullscreen = !!e[\"isFullscreen\"], this.SetSize(e[\"innerWidth\"], e[\"innerHeight\"], true), this._runtime.UpdateRender();\n    }\n    SetSize(e, t, s = false) {\n      if (e = Math.floor(e), t = Math.floor(t), e <= 0 || t <= 0) throw new Error(\"invalid size\");\n      if (this._windowInnerWidth !== e || this._windowInnerHeight !== t || s) {\n        this._windowInnerWidth = e, this._windowInnerHeight = t;\n        const i = this.GetCurrentFullscreenMode();\n        \"letterbox-scale\" === i ? this._CalculateLetterboxScale(e, t) : \"letterbox-integer-scale\" === i ? this._CalculateLetterboxIntegerScale(e, t) : \"off\" === i ? this._CalculateFixedSizeCanvas(e, t) : this._CalculateFullsizeCanvas(e, t), this._UpdateFullscreenScalingQuality(i);\n        for (const { canvas: n } of this._canvasLayers) n.width = this._canvasDeviceWidth, n.height = this._canvasDeviceHeight;\n        this._runtime.PostComponentMessageToDOM(\"canvas\", \"update-size\", { \"marginLeft\": this._canvasCssOffsetX, \"marginTop\": this._canvasCssOffsetY, \"styleWidth\": this._canvasCssWidth, \"styleHeight\": this._canvasCssHeight, \"displayScale\": this.GetDisplayScale() });\n        const a = this.GetRenderer();\n        a.SetSize(this._canvasDeviceWidth, this._canvasDeviceHeight, true);\n        for (const h of this._availableAdditionalRenderTargets) a.DeleteRenderTarget(h);\n        C32.clearArray(this._availableAdditionalRenderTargets), this.UpdateDefaultProjectionMatrix();\n        const r = this._runtime.GetLayoutManager();\n        r.SetAllLayerProjectionChanged(), r.SetAllLayerMVChanged();\n      }\n    }\n    UpdateDefaultProjectionMatrix() {\n      this.GetRenderer().CalculatePerspectiveMatrix(this._defaultProjectionMatrix, this.GetDrawWidth() / this.GetDrawHeight());\n    }\n    GetDefaultProjectionMatrix() {\n      return this._defaultProjectionMatrix;\n    }\n    _CalculateLetterboxScale(e, t) {\n      const s = this._runtime.GetDevicePixelRatio(), i = this._runtime.GetOriginalViewportWidth(), a = this._runtime.GetOriginalViewportHeight(), r = i / a, n = e / t;\n      if (r < n) {\n        const h = t * r;\n        this._canvasCssWidth = Math.round(h), this._canvasCssHeight = t, this._canvasCssOffsetX = Math.floor((e - this._canvasCssWidth) / 2), this._canvasCssOffsetY = 0;\n      } else {\n        const o = e / r;\n        this._canvasCssWidth = e, this._canvasCssHeight = Math.round(o), this._canvasCssOffsetX = 0, this._canvasCssOffsetY = Math.floor((t - this._canvasCssHeight) / 2);\n      }\n      this._canvasDeviceWidth = Math.round(this._canvasCssWidth * s), this._canvasDeviceHeight = Math.round(this._canvasCssHeight * s), this._runtime.SetViewportSize(i, a);\n    }\n    _CalculateLetterboxIntegerScale(e, t) {\n      const s = this._runtime.GetDevicePixelRatio(), i = (1 !== s && (e += 1, t += 1), this._runtime.GetOriginalViewportWidth()), a = this._runtime.GetOriginalViewportHeight(), r = i / a, n = e / t;\n      let h;\n      if (r < n) {\n        const o = t * r;\n        h = o * s / i;\n      } else {\n        const l = e / r;\n        h = l * s / a;\n      }\n      1 < h ? h = Math.floor(h) : h < 1 && (h = 1 / Math.ceil(1 / h)), this._canvasDeviceWidth = Math.round(i * h), this._canvasDeviceHeight = Math.round(a * h), this._canvasCssWidth = this._canvasDeviceWidth / s, this._canvasCssHeight = this._canvasDeviceHeight / s, this._canvasCssOffsetX = Math.max(Math.floor((e - this._canvasCssWidth) / 2), 0), this._canvasCssOffsetY = Math.max(Math.floor((t - this._canvasCssHeight) / 2), 0), this._runtime.SetViewportSize(i, a);\n    }\n    _CalculateFullsizeCanvas(e, t) {\n      const s = this._runtime.GetDevicePixelRatio(), i = (this._canvasCssWidth = e, this._canvasCssHeight = t, this._canvasDeviceWidth = Math.round(this._canvasCssWidth * s), this._canvasDeviceHeight = Math.round(this._canvasCssHeight * s), this._canvasCssOffsetX = 0, this._canvasCssOffsetY = 0, this.GetDisplayScale());\n      this._runtime.SetViewportSize(this._canvasCssWidth / i, this._canvasCssHeight / i);\n    }\n    _CalculateFixedSizeCanvas(e, t) {\n      const s = this._runtime.GetDevicePixelRatio();\n      this._canvasCssWidth = this._runtime.GetViewportWidth(), this._canvasCssHeight = this._runtime.GetViewportHeight(), this._canvasDeviceWidth = Math.round(this._canvasCssWidth * s), this._canvasDeviceHeight = Math.round(this._canvasCssHeight * s), this.IsDocumentFullscreen() ? (this._canvasCssOffsetX = Math.floor((e - this._canvasCssWidth) / 2), this._canvasCssOffsetY = Math.floor((t - this._canvasCssHeight) / 2)) : (this._canvasCssOffsetX = 0, this._canvasCssOffsetY = 0), this._runtime.SetViewportSize(this._runtime.GetViewportWidth(), this._runtime.GetViewportHeight());\n    }\n    _UpdateFullscreenScalingQuality(s) {\n      if (\"high\" === this._wantFullscreenScalingQuality) this._drawWidth = this._canvasDeviceWidth, this._drawHeight = this._canvasDeviceHeight, this._fullscreenScalingQuality = \"high\";\n      else {\n        let e, t;\n        if (t = \"off\" === this.GetCurrentFullscreenMode() ? (e = this._runtime.GetViewportWidth(), this._runtime.GetViewportHeight()) : (e = this._runtime.GetOriginalViewportWidth(), this._runtime.GetOriginalViewportHeight()), this._canvasDeviceWidth < e || this._canvasDeviceHeight < t) this._drawWidth = this._canvasDeviceWidth, this._drawHeight = this._canvasDeviceHeight, this._fullscreenScalingQuality = \"high\";\n        else if (this._drawWidth = e, this._drawHeight = t, this._fullscreenScalingQuality = \"low\", \"scale-inner\" === s) {\n          const i = e / t, a = this._windowInnerWidth / this._windowInnerHeight;\n          a < i ? this._drawWidth = this._drawHeight * a : i < a && (this._drawHeight = this._drawWidth / a);\n        } else if (\"scale-outer\" === s) {\n          const r = e / t, n = this._windowInnerWidth / this._windowInnerHeight;\n          r < n ? this._drawWidth = this._drawHeight * n : n < r && (this._drawHeight = this._drawWidth / n);\n        }\n      }\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetMainCanvas() {\n      return this._canvasLayers[0].canvas;\n    }\n    GetEffectChainManager() {\n      return this._effectChainManager;\n    }\n    IsDocumentFullscreen() {\n      return this._isDocumentFullscreen;\n    }\n    GetCssDisplayMode() {\n      return this._cssDisplayMode;\n    }\n    SetFullscreenMode(e) {\n      if (!VALID_FULLSCREEN_MODES.has(e)) throw new Error(\"invalid fullscreen mode\");\n      this._fullscreenMode = e;\n      const t = this._runtime.GetLayoutManager();\n      t.SetAllLayerProjectionChanged(), t.SetAllLayerMVChanged();\n    }\n    GetFullscreenMode() {\n      return this._fullscreenMode;\n    }\n    SetDocumentFullscreenMode(e) {\n      if (!VALID_FULLSCREEN_MODES.has(e)) throw new Error(\"invalid fullscreen mode\");\n      this._documentFullscreenMode = e;\n      const t = this._runtime.GetLayoutManager();\n      t.SetAllLayerProjectionChanged(), t.SetAllLayerMVChanged();\n    }\n    GetDocumentFullscreenMode() {\n      return this._documentFullscreenMode;\n    }\n    GetCurrentFullscreenMode() {\n      return this.IsDocumentFullscreen() ? this.GetDocumentFullscreenMode() : this.GetFullscreenMode();\n    }\n    SetFullscreenScalingQuality(e) {\n      if (!VALID_FULLSCREEN_SCALING_QUALITIES.has(e)) throw new Error(\"invalid fullscreen scaling quality\");\n      this._wantFullscreenScalingQuality = e, this._runtime.GetLayoutManager().SetAllLayerProjectionChanged();\n    }\n    GetSetFullscreenScalingQuality() {\n      return this._wantFullscreenScalingQuality;\n    }\n    GetCurrentFullscreenScalingQuality() {\n      return this._fullscreenScalingQuality;\n    }\n    static _FullscreenModeNumberToString(e) {\n      switch (e) {\n        case 0:\n          return \"off\";\n        case 1:\n          return \"crop\";\n        case 2:\n          return \"scale-inner\";\n        case 3:\n          return \"scale-outer\";\n        case 4:\n          return \"letterbox-scale\";\n        case 5:\n          return \"letterbox-integer-scale\";\n        default:\n          throw new Error(\"invalid fullscreen mode\");\n      }\n    }\n    GetLastWidth() {\n      return this._windowInnerWidth;\n    }\n    GetLastHeight() {\n      return this._windowInnerHeight;\n    }\n    GetDrawWidth() {\n      return this._drawWidth;\n    }\n    GetDrawHeight() {\n      return this._drawHeight;\n    }\n    SetMipmapsEnabled(e) {\n      this._enableMipmaps = !!e;\n    }\n    _SetTextureAnisotropy(e) {\n      this._textureAnisotropy = e;\n    }\n    GetTextureAnisotropy() {\n      return this._textureAnisotropy;\n    }\n    IsRendererContextLost() {\n      return this.GetRenderer().IsContextLost();\n    }\n    _OnWebGLContextLost(e) {\n      console.log(\"[Construct] WebGL context lost\"), e.preventDefault(), this._availableAdditionalRenderTargets = [], this._usedAdditionalRenderTargets.clear(), this._effectChainManager.OnContextLost(), this._webglRenderer.OnContextLost(), this._runtime._OnRendererContextLost();\n    }\n    _OnWebGPUDeviceLost() {\n      console.log(\"[Construct] WebGPU device lost\"), this._availableAdditionalRenderTargets = [], this._usedAdditionalRenderTargets.clear(), this._effectChainManager.OnContextLost(), this._runtime._OnRendererContextLost();\n    }\n    async _OnWebGLContextRestored(e) {\n      await this._webglRenderer.OnContextRestored(), await this._InitRenderer(), await this._runtime._OnRendererContextRestored(), console.log(\"[Construct] WebGL context restored\");\n    }\n    async _OnWebGPUDeviceRestored() {\n      await this._InitRenderer(), await this._runtime._OnRendererContextRestored(), console.log(\"[Construct] WebGPU device restored\");\n    }\n    GetWebGLRenderer() {\n      return this._webglRenderer;\n    }\n    GetWebGPURenderer() {\n      return this._webgpuRenderer;\n    }\n    GetRenderer() {\n      return this._webgpuRenderer || this._webglRenderer;\n    }\n    GetIRenderer() {\n      return this._iRenderer;\n    }\n    GetRendererString() {\n      let e = \"\";\n      return e = this._runtime.GetWebGPURenderer() ? \"webgpu\" : \"webgl\" + this._runtime.GetWebGLRenderer().GetWebGLVersionNumber(), this._runtime.GetRenderer().HasMajorPerformanceCaveat() && (e += \"-software\"), e;\n    }\n    GetRendererDetailString() {\n      return this._runtime.GetWebGPURenderer() ? this._runtime.GetWebGPURenderer().GetAdapterInfoString() : this._runtime.GetWebGLRenderer().GetUnmaskedRenderer();\n    }\n    GetRenderScale() {\n      return \"low\" === this._fullscreenScalingQuality ? 1 / this._runtime.GetDevicePixelRatio() : this.GetDisplayScale();\n    }\n    GetDisplayScale() {\n      const e = this.GetCurrentFullscreenMode();\n      if (\"off\" === e || \"crop\" === e) return 1;\n      const t = this._runtime.GetOriginalViewportWidth(), s = this._runtime.GetOriginalViewportHeight(), i = t / s, a = this._canvasDeviceWidth / this._canvasDeviceHeight;\n      return \"scale-inner\" !== e && i < a || \"scale-inner\" === e && a < i ? this._canvasCssHeight / s : this._canvasCssWidth / t;\n    }\n    GetEffectLayerScaleParam() {\n      return \"low\" === this.GetCurrentFullscreenScalingQuality() ? 1 : this.GetDisplayScale();\n    }\n    GetEffectDevicePixelRatioParam() {\n      return \"low\" === this.GetCurrentFullscreenScalingQuality() ? 1 : this._runtime.GetDevicePixelRatio();\n    }\n    SetDeviceTransformOffset(e, t) {\n      this._deviceTransformOffX = e, this._deviceTransformOffY = t;\n    }\n    SetDeviceTransform(t, s, i, e = true) {\n      s = s || this._drawWidth, i = i || this._drawHeight;\n      const a = s / 2 + this._deviceTransformOffX, r = i / 2 + this._deviceTransformOffY;\n      if (e) {\n        let e2 = this.GetDefaultProjectionMatrix();\n        s === this._drawWidth && i === this._drawHeight || (t.CalculatePerspectiveMatrix(tempProjection, s / i), e2 = tempProjection), t.SetProjectionMatrix(e2);\n      }\n      const n = t.CalculateLookAtModelView2(a, r, t.GetDefaultCameraZ(i), a, r, 0, i);\n      t.SetModelViewMatrix(n);\n    }\n    SetCssTransform(e, t = true) {\n      const s = this.GetCssWidth(), i = this.GetCssHeight(), a = s / 2, r = i / 2, n = (t && e.SetProjectionMatrix(this.GetDefaultProjectionMatrix()), e.CalculateLookAtModelView2(a, r, e.GetDefaultCameraZ(i), a, r, 0, i));\n      e.SetModelViewMatrix(n);\n    }\n    GetDeviceWidth() {\n      return this._canvasDeviceWidth;\n    }\n    GetDeviceHeight() {\n      return this._canvasDeviceHeight;\n    }\n    GetCssWidth() {\n      return this._canvasCssWidth;\n    }\n    GetCssHeight() {\n      return this._canvasCssHeight;\n    }\n    GetCanvasClientX() {\n      return this._canvasCssOffsetX;\n    }\n    GetCanvasClientY() {\n      return this._canvasCssOffsetY;\n    }\n    GetHTMLLayerCount() {\n      return this._canvasLayers.length;\n    }\n    _CanUseImageBitmapRenderingContext() {\n      return \"undefined\" != typeof OffscreenCanvas && this.GetMainCanvas() instanceof OffscreenCanvas && (\"Chromium\" !== C32.Platform.BrowserEngine || 124 <= C32.Platform.BrowserVersionNumber);\n    }\n    async SetHTMLLayerCount(t, s = false) {\n      if (t < 1) throw new Error(\"invalid HTML layer count\");\n      if (this._canvasLayers.length !== t) {\n        const i = this._runtime.GetLayoutManager().GetMainRunningLayout(), a = { \"count\": t, \"layersDomState\": i._GetRootLayers().filter((e2) => e2.IsHTMLElementsLayer()).map((e2) => e2._GetHTMLLayerDOMState()), \"immediate\": s, \"marginLeft\": this._canvasCssOffsetX, \"marginTop\": this._canvasCssOffsetY, \"styleWidth\": this._canvasCssWidth, \"styleHeight\": this._canvasCssHeight };\n        let e;\n        if (e = this.IsInWorker() ? await this._runtime.PostComponentMessageToDOMAsync(\"canvas\", \"set-html-layer-count\", a) : self[\"c3_runtimeInterface\"][\"_OnSetHTMLLayerCount\"](a), t < this._canvasLayers.length) this._canvasLayers.length = t;\n        else for (const r of e[\"addedCanvases\"]) {\n          r.width = this._canvasDeviceWidth, r.height = this._canvasDeviceHeight;\n          const n = this._CanUseImageBitmapRenderingContext() ? \"bitmaprenderer\" : \"2d\", h = r.getContext(n);\n          if (!h) throw new Error(`failed to acquire '${n}' canvas context`);\n          this._canvasLayers.push({ canvas: r, ctx: h });\n        }\n        this._runtime.UpdateRender();\n      }\n    }\n    BlitMainCanvasToHTMLLayerCanvas(e) {\n      if (!(e >= this._canvasLayers.length)) {\n        const t = this.GetMainCanvas(), s = this._canvasLayers[e].ctx;\n        this._CanUseImageBitmapRenderingContext() ? s[\"transferFromImageBitmap\"](t[\"transferToImageBitmap\"]()) : (s.globalCompositeOperation = \"copy\", s.drawImage(t, 0, 0));\n      }\n    }\n    GetAdditionalRenderTarget(t) {\n      t.depth = this._runtime.Uses3DFeatures();\n      const e = this._availableAdditionalRenderTargets, s = e.findIndex((e2) => e2.IsCompatibleWithOptions(t));\n      let i;\n      return -1 !== s ? (i = e[s], e.splice(s, 1)) : i = this.GetRenderer().CreateRenderTarget(t), this._usedAdditionalRenderTargets.add(i), i;\n    }\n    ReleaseAdditionalRenderTarget(e) {\n      if (!this._usedAdditionalRenderTargets.has(e)) throw new Error(\"render target not in use\");\n      this._usedAdditionalRenderTargets.delete(e), this._availableAdditionalRenderTargets.push(e);\n    }\n    GetEffectCompositorRenderTarget() {\n      const e = { sampling: this._runtime.GetSampling() };\n      return \"low\" === this.GetCurrentFullscreenScalingQuality() && (e.width = this.GetDrawWidth(), e.height = this.GetDrawHeight()), this.GetAdditionalRenderTarget(e);\n    }\n    ReleaseEffectCompositorRenderTarget(e) {\n      this.ReleaseAdditionalRenderTarget(e);\n    }\n    *activeLayersGpuProfiles() {\n      for (const e of this._runtime.GetLayoutManager().runningLayouts()) for (const t of e.GetLayers()) {\n        const s = this._layersGpuProfile.get(t);\n        s && (yield s);\n      }\n    }\n    GetLayerTimingsBuffer(e) {\n      if (!this.GetRenderer().SupportsGPUProfiling()) return null;\n      let t = this._layersGpuProfile.get(e);\n      return t || (t = { layer: e, name: e.GetName(), timingsBuffer: C32.New(C32.Gfx.WebGLQueryResultBuffer, this._webglRenderer), curUtilisation: 0, lastTotalUtilisation: 0, lastSelfUtilisation: 0 }, this._layersGpuProfile.set(e, t)), t.timingsBuffer;\n    }\n    _Update1sFrameRange() {\n      const e = this.GetRenderer();\n      if (e.SupportsGPUProfiling() && 0 === this._gpuTimeEndFrame) {\n        this._gpuTimeEndFrame = e.GetFrameNumber(), this._gpuCurUtilisation = NaN;\n        for (const t of this.activeLayersGpuProfiles()) t.curUtilisation = NaN;\n      }\n    }\n    _UpdateTick() {\n      this._webglRenderer && this._webglRenderer.SupportsGPUProfiling() && this._UpdateTick_WebGL(), this._webgpuRenderer && this._webgpuRenderer.SupportsGPUProfiling() && this._UpdateTick_WebGPU();\n    }\n    _UpdateTick_WebGL() {\n      if (isNaN(this._gpuCurUtilisation) && (this._gpuCurUtilisation = this._gpuFrameTimingsBuffer.GetFrameRangeResultSum(this._gpuTimeStartFrame, this._gpuTimeEndFrame), !isNaN(this._gpuCurUtilisation))) {\n        if (this._runtime.IsDebug()) {\n          for (const e of this.activeLayersGpuProfiles()) if (e.curUtilisation = e.timingsBuffer.GetFrameRangeResultSum(this._gpuTimeStartFrame, this._gpuTimeEndFrame), isNaN(e.curUtilisation)) return;\n        }\n        if (this._gpuFrameTimingsBuffer.DeleteAllBeforeFrameNumber(this._gpuTimeEndFrame), this._gpuLastUtilisation = Math.min(this._gpuCurUtilisation, 1), this._runtime.IsDebug()) {\n          const s = /* @__PURE__ */ new Map();\n          for (const a of this.activeLayersGpuProfiles()) a.timingsBuffer.DeleteAllBeforeFrameNumber(this._gpuTimeEndFrame), a.lastTotalUtilisation = Math.min(a.curUtilisation, 1), s.set(a.layer, a.lastTotalUtilisation);\n          for (const r of this.activeLayersGpuProfiles()) {\n            const n = r.layer, h = s.get(n) || 0, o = h - n.GetSubLayers().reduce((e, t2) => e + (s.get(t2) || 0), 0);\n            r.lastSelfUtilisation = C32.clamp(o, 0, 1);\n          }\n          const t = this._runtime.GetMainRunningLayout(), i = this._gpuLastUtilisation - t._GetRootLayers().reduce((e, t2) => e + (s.get(t2) || 0), 0);\n          self.C3Debugger.UpdateGPUProfile(C32.clamp(i, 0, 1), this._gpuLastUtilisation, [...this.activeLayersGpuProfiles()]);\n        }\n        this._gpuTimeStartFrame = this._gpuTimeEndFrame, this._gpuTimeEndFrame = 0;\n      }\n    }\n    GetGPUFrameTimingsBuffer() {\n      return this._gpuFrameTimingsBuffer;\n    }\n    _UpdateTick_WebGPU() {\n      if (0 !== this._gpuTimeEndFrame) {\n        for (let e2 = this._gpuTimeStartFrame; e2 < this._gpuTimeEndFrame; ++e2) {\n          const s = this._webgpuFrameTimings.get(e2);\n          if (s && !s.HasResult()) return;\n        }\n        const e = this._runtime.GetMainRunningLayout(), a = C32.MakeFilledArray(e.GetLayerCount() + 1, 0);\n        let t = 0;\n        for (let e2 = this._gpuTimeStartFrame; e2 < this._gpuTimeEndFrame; ++e2) {\n          const r = this._webgpuFrameTimings.get(e2);\n          if (r) {\n            const n = r.GetResult();\n            let s = BigInt(0), i = BigInt(0);\n            const h = BigInt(0);\n            for (let e3 = 0, t2 = Math.min(a.length, n.length / 2); e3 < t2; ++e3) {\n              const c = n[2 * e3], _ = n[2 * e3 + 1], d = (c !== h && (s === h || c < s) && (s = c), _ > i && (i = _), _ - c), u = Number(d) / 1e9;\n              a[e3] += u;\n            }\n            const o = i - s, l = Number(o) / 1e9;\n            t += l;\n          }\n        }\n        if (this._gpuLastUtilisation = C32.clamp(t, 0, 1), this._runtime.IsDebug()) {\n          const i = e.GetLayers(), g = /* @__PURE__ */ new Map();\n          for (let e2 = 0, t2 = Math.min(i.length, a.length - 1); e2 < t2; ++e2) {\n            const S = a[e2 + 1];\n            g.set(i[e2], S);\n          }\n          const m = [], p = /* @__PURE__ */ new Map();\n          for (const [C, R] of g) {\n            const w = [...C.selfAndAllSubLayers()].reduce((e2, t2) => e2 + (g.get(t2) || 0), 0);\n            p.set(C, w), m.push({ name: C.GetName(), lastSelfUtilisation: C32.clamp(R, 0, 1), lastTotalUtilisation: C32.clamp(w, 0, 1) });\n          }\n          const f = this._gpuLastUtilisation - e._GetRootLayers().reduce((e2, t2) => e2 + (p.get(t2) || 0), 0);\n          self.C3Debugger.UpdateGPUProfile(C32.clamp(f, 0, 1), this._gpuLastUtilisation, m);\n        }\n        for (let e2 = this._gpuTimeStartFrame; e2 < this._gpuTimeEndFrame; ++e2) this._webgpuFrameTimings.delete(e2);\n        this._gpuTimeStartFrame = this._gpuTimeEndFrame, this._gpuTimeEndFrame = 0;\n      }\n    }\n    _AddWebGPUFrameTiming(e) {\n      this._webgpuFrameTimings.set(this._webgpuRenderer.GetFrameNumber(), e);\n    }\n    GetGPUUtilisation() {\n      return this._gpuLastUtilisation;\n    }\n    SnapshotCanvas(e, t, s, i, a, r) {\n      return this._snapshotFormat = e, this._snapshotQuality = t, this._snapshotArea.setWH(s, i, a, r), this._snapshotPromise || (this._snapshotPromise = new Promise((e2) => {\n        this._snapshotResolve = e2;\n      })), this._snapshotPromise;\n    }\n    _MaybeTakeSnapshot() {\n      if (this._snapshotFormat) {\n        let e = this.GetMainCanvas();\n        const i = this._snapshotArea, a = C32.clamp(Math.floor(i.getLeft()), 0, e.width), r = C32.clamp(Math.floor(i.getTop()), 0, e.height);\n        let t = i.width(), s = (t = 0 === t ? e.width - a : C32.clamp(Math.floor(t), 0, e.width - a), i.height());\n        if (s = 0 === s ? e.height - r : C32.clamp(Math.floor(s), 0, e.height - r), (0 !== a || 0 !== r || t !== e.width || s !== e.height) && 0 < t && 0 < s) {\n          const n = C32.CreateCanvas(t, s), h = n.getContext(\"2d\");\n          h.drawImage(e, a, r, t, s, 0, 0, t, s), e = n;\n        }\n        C32.CanvasToBlob(e, this._snapshotFormat, this._snapshotQuality).then((e2) => {\n          this._snapshotUrl && URL.revokeObjectURL(this._snapshotUrl), this._snapshotUrl = URL.createObjectURL(e2), this._snapshotPromise = null, this._snapshotResolve(this._snapshotUrl);\n        }), this._snapshotFormat = \"\", this._snapshotQuality = 1;\n      }\n    }\n    GetCanvasSnapshotUrl() {\n      return this._snapshotUrl;\n    }\n    SetIsPastingToDrawingCanvas(e) {\n      e ? this._isPastingToDrawingCanvas++ : this._isPastingToDrawingCanvas--;\n    }\n    IsPastingToDrawingCanvas() {\n      return 0 < this._isPastingToDrawingCanvas;\n    }\n    InitLoadingScreen(e) {\n      const t = this.GetRenderer();\n      if (2 === e) this._percentText = C32.New(C32.Gfx.RendererText, this.GetRenderer()), this._percentText.SetFontName(\"Arial\"), this._percentText.SetFontSize(16), this._percentText.SetHorizontalAlignment(\"center\"), this._percentText.SetVerticalAlignment(\"center\"), this._percentText.SetSize(PERCENTTEXT_WIDTH, PERCENTTEXT_HEIGHT);\n      else if (0 === e) {\n        const s = this._runtime.GetLoadingLogoAsset();\n        s && s.LoadStaticTexture(t).catch((e2) => console.warn(\"[C3 runtime] Failed to create texture for loading logo: \", e2));\n      } else 4 === e && (this._LoadSvgSplashImage(\"splash-images/splash-logo.svg\").then((e2) => {\n        \"done\" === this._splashState ? t.DeleteTexture(e2) : this._splashTextures.logo = e2;\n      }).catch((e2) => console.warn(\"Failed to load splash image: \", e2)), this._LoadBitmapSplashImage(\"splash-images/splash-poweredby-512.png\").then((e2) => {\n        \"done\" === this._splashState ? t.DeleteTexture(e2) : this._splashTextures.powered = e2;\n      }).catch((e2) => console.warn(\"Failed to load splash image: \", e2)), this._LoadBitmapSplashImage(\"splash-images/splash-website-512.png\").then((e2) => {\n        \"done\" === this._splashState ? t.DeleteTexture(e2) : this._splashTextures.website = e2;\n      }).catch((e2) => console.warn(\"Failed to load splash image: \", e2)));\n    }\n    async _LoadSvgSplashImage(e) {\n      e = new URL(e, this._runtime.GetRuntimeBaseURL()).toString();\n      const t = await C32.FetchBlob(e), s = await this._runtime.RasterSvgImage(t, 2048, 2048);\n      return this.GetRenderer().CreateStaticTextureAsync(s, { mipMapQuality: \"high\" });\n    }\n    async _LoadBitmapSplashImage(e) {\n      e = new URL(e, this._runtime.GetRuntimeBaseURL()).toString();\n      const t = await C32.FetchBlob(e);\n      return this.GetRenderer().CreateStaticTextureAsync(t, { mipMapQuality: \"high\" });\n    }\n    HideCordovaSplashScreen() {\n      this._runtime.PostComponentMessageToDOM(\"runtime\", \"hide-cordova-splash\");\n    }\n    StartLoadingScreen() {\n      this._loaderStartTime = Date.now(), this._runtime.Dispatcher().addEventListener(\"loadingprogress\", this._loadingprogress_handler), this._rafId = requestAnimationFrame(() => this._DrawLoadingScreen());\n      const e = this._runtime.GetLoaderStyle();\n      3 !== e && this.HideCordovaSplashScreen();\n    }\n    async EndLoadingScreen() {\n      const e = this.GetRenderer(), t = (this._loadingProgress = 1, this._runtime.GetLoaderStyle());\n      4 === t && await this._splashDonePromise, this._splashDoneResolve = null, this._splashDonePromise = null, -1 !== this._rafId && (cancelAnimationFrame(this._rafId), this._rafId = -1), this._runtime.Dispatcher().removeEventListener(\"loadingprogress\", this._loadingprogress_handler), this._loadingprogress_handler = null, this._percentText && (this._percentText.Release(), this._percentText = null), this._runtime.ReleaseLoadingLogoAsset(), e.Start(), this._splashTextures.logo && (e.DeleteTexture(this._splashTextures.logo), this._splashTextures.logo = null), this._splashTextures.powered && (e.DeleteTexture(this._splashTextures.powered), this._splashTextures.powered = null), this._splashTextures.website && (e.DeleteTexture(this._splashTextures.website), this._splashTextures.website = null), e.ClearRgba(0, 0, 0, 0), e.Finish(), this._splashState = \"done\", this._gpuTimeStartFrame = e.GetFrameNumber(), 3 === t && this.HideCordovaSplashScreen();\n    }\n    _DrawLoadingScreen() {\n      if (-1 !== this._rafId) {\n        const e = this.GetRenderer(), t = (e.Start(), this._rafId = -1, this._runtime.GetAssetManager().HasHadErrorLoading()), s = this._runtime.GetLoaderStyle();\n        if (3 !== s && (this.SetCssTransform(e), e.ClearRgba(0, 0, 0, 0), e.ResetColor(), e.SetTextureFillMode(), e.SetTexture(null)), 0 === s) this._DrawProgressBarAndLogoLoadingScreen(t);\n        else if (1 === s) this._DrawProgressBarLoadingScreen(t, PROGRESSBAR_WIDTH, 0);\n        else if (2 === s) this._DrawPercentTextLoadingScreen(t);\n        else if (3 === s) C32.noop();\n        else {\n          if (4 !== s) throw new Error(\"invalid loader style\");\n          this._DrawSplashLoadingScreen(t);\n        }\n        e.Finish(), this._rafId = requestAnimationFrame(() => this._DrawLoadingScreen());\n      }\n    }\n    _DrawPercentTextLoadingScreen(e) {\n      e ? this._percentText.SetColorRgb(1, 0, 0) : this._percentText.SetColorRgb(0.6, 0.6, 0.6), this._percentText.SetText(Math.round(100 * this._loadingProgress) + \"%\");\n      const t = this._canvasCssWidth / 2, s = this._canvasCssHeight / 2, i = PERCENTTEXT_WIDTH / 2, a = PERCENTTEXT_HEIGHT / 2, r = (tempQuad.setRect(t - i, s - a, t + i, s + a), this.GetRenderer());\n      r.SetTexture(this._percentText.GetTexture()), r.Quad3(tempQuad, this._percentText.GetTexRect());\n    }\n    _DrawProgressBarLoadingScreen(e, t, s) {\n      const i = this.GetRenderer(), a = PROGRESSBAR_HEIGHT, r = (i.SetColorFillMode(), e ? i.SetColorRgba(1, 0, 0, 1) : i.SetColorRgba(0.118, 0.565, 1, 1), this._canvasCssWidth / 2), n = this._canvasCssHeight / 2, h = t / 2, o = a / 2;\n      tempRect.setWH(r - h, n - o + s, Math.floor(t * this._loadingProgress), a), i.Rect(tempRect), tempRect.setWH(r - h, n - o + s, t, a), tempRect.offset(-0.5, -0.5), tempRect.inflate(0.5, 0.5), i.SetColorRgba(0, 0, 0, 1), i.LineRect2(tempRect), tempRect.inflate(1, 1), i.SetColorRgba(1, 1, 1, 1), i.LineRect2(tempRect);\n    }\n    _DrawProgressBarAndLogoLoadingScreen(e) {\n      const t = this.GetRenderer(), s = this._runtime.GetLoadingLogoAsset();\n      if (s) {\n        const i = s.GetTexture();\n        if (i) {\n          const a = i.GetWidth(), r = i.GetHeight(), n = this._canvasCssWidth / 2, h = this._canvasCssHeight / 2, o = a / 2, l = r / 2;\n          tempQuad.setRect(n - o, h - l, n + o, h + l), t.SetTexture(i), t.Quad(tempQuad), this._DrawProgressBarLoadingScreen(e, a, 16 + l);\n        } else this._DrawProgressBarLoadingScreen(e, PROGRESSBAR_WIDTH, 0);\n      } else this._DrawProgressBarLoadingScreen(e, PROGRESSBAR_WIDTH, 0);\n    }\n    _DrawSplashLoadingScreen(e) {\n      const t = this.GetRenderer(), s = this._splashTextures.logo, i = this._splashTextures.powered, a = this._splashTextures.website, r = Date.now(), n = (0 === this._splashFrameNumber && (this._loaderStartTime = r), this._runtime.IsPreview() || this._runtime.IsFBInstantAvailable() && !this._runtime.IsCordova()), h = n ? 0 : SPLASH_AFTER_FADEOUT_WAIT_TIME, o = n ? 0 : SPLASH_MIN_DISPLAY_TIME;\n      let l = 1;\n      \"fade-in\" === this._splashState ? l = Math.min((r - this._loaderStartTime) / SPLASH_FADE_DURATION, 1) : \"fade-out\" === this._splashState && (l = Math.max(1 - (r - this._splashFadeOutStartTime) / SPLASH_FADE_DURATION, 0)), t.SetColorFillMode(), t.SetColorRgba(0.231 * l, 0.251 * l, 0.271 * l, l), tempRect.set(0, 0, this._canvasCssWidth, this._canvasCssHeight), t.Rect(tempRect);\n      const c = Math.ceil(this._canvasCssWidth), _ = Math.ceil(this._canvasCssHeight);\n      let d, u;\n      256 < this._canvasCssHeight ? (t.SetColorRgba(0.302 * l, 0.334 * l, 0.365 * l, l), d = c, u = Math.max(5e-3 * _, 2), tempRect.setWH(0, 0.8 * _ - u / 2, d, u), t.Rect(tempRect), e ? t.SetColorRgba(l, 0, 0, l) : t.SetColorRgba(0.161 * l, 0.953 * l, 0.816 * l, l), d = c * this._loadingProgress, tempRect.setWH(0.5 * c - d / 2, 0.8 * _ - u / 2, d, u), t.Rect(tempRect), t.SetColorRgba(l, l, l, l), t.SetTextureFillMode(), i && (d = 1.5 * C32.clamp(0.22 * _, 105, 0.6 * c), u = d / 8, tempRect.setWH(0.5 * c - d / 2, 0.2 * _ - u / 2, d, u), t.SetTexture(i), t.Rect(tempRect)), s && (d = Math.min(0.395 * _, 0.95 * c), u = d, tempRect.setWH(0.5 * c - d / 2, 0.485 * _ - u / 2, d, u), t.SetTexture(s), t.Rect(tempRect)), a && (d = 1.5 * C32.clamp(0.22 * _, 105, 0.6 * c), u = d / 8, tempRect.setWH(0.5 * c - d / 2, 0.868 * _ - u / 2, d, u), t.SetTexture(a), t.Rect(tempRect))) : (t.SetColorRgba(0.302 * l, 0.334 * l, 0.365 * l, l), d = c, u = Math.max(5e-3 * _, 2), tempRect.setWH(0, 0.85 * _ - u / 2, d, u), t.Rect(tempRect), e ? t.SetColorRgba(l, 0, 0, l) : t.SetColorRgba(0.161 * l, 0.953 * l, 0.816 * l, l), d = c * this._loadingProgress, tempRect.setWH(0.5 * c - d / 2, 0.85 * _ - u / 2, d, u), t.Rect(tempRect), t.SetColorRgba(l, l, l, l), t.SetTextureFillMode(), s && (d = 0.55 * _, u = d, tempRect.setWH(0.5 * c - d / 2, 0.45 * _ - u / 2, d, u), t.SetTexture(s), t.Rect(tempRect))), this._splashFrameNumber++, \"fade-in\" === this._splashState && r - this._loaderStartTime >= SPLASH_FADE_DURATION && 2 <= this._splashFrameNumber && (this._splashState = \"wait\", this._splashFadeInFinishTime = r), \"wait\" === this._splashState && r - this._splashFadeInFinishTime >= o && 1 <= this._loadingProgress && (this._splashState = \"fade-out\", this._splashFadeOutStartTime = r), (\"fade-out\" === this._splashState && r - this._splashFadeOutStartTime >= SPLASH_FADE_DURATION + h || n && 1 <= this._loadingProgress && r - this._loaderStartTime < 500) && this._splashDoneResolve();\n    }\n  };\n}\n{\n  const C32 = self.C3, C3Debugger = self.C3Debugger, assert = self.assert, ISDKBehaviorInstanceBase = self.ISDKBehaviorInstanceBase, DEFAULT_RUNTIME_OPTS = { \"messagePort\": null, \"runtimeBaseUrl\": \"\", \"headless\": false, \"hasDom\": true, \"isInWorker\": false, \"useAudio\": true, \"exportType\": \"\" };\n  let ife = true;\n  C32.Runtime = class extends C32.DefendedBase {\n    constructor(e) {\n      e = Object.assign({}, DEFAULT_RUNTIME_OPTS, e), super(), this._messagePort = e[\"messagePort\"], this._runtimeBaseUrl = e[\"runtimeBaseUrl\"], this._previewUrl = e[\"previewUrl\"], this._isHeadless = !!e[\"headless\"], this._hasDom = !!e[\"hasDom\"], this._isInWorker = !!e[\"isInWorker\"], ife = e[\"ife\"], this._useAudio = !!e[\"useAudio\"], this._exportType = e[\"exportType\"], this._isNWjs = e[\"isNWjs\"], this._isiOSCordova = !!e[\"isiOSCordova\"], this._isiOSWebView = !!e[\"isiOSWebView\"], this._isWindowsWebView2 = !!e[\"isWindowsWebView2\"], this._isAnyWebView2Wrapper = !!e[\"isAnyWebView2Wrapper\"], this._isFBInstantAvailable = !!e[\"isFBInstantAvailable\"], this._isDebug = !(\"preview\" !== this._exportType || !e[\"isDebug\"]), this._breakpointsEnabled = this._isDebug, this._isDebugging = this._isDebug, this._debuggingDisabled = 0, this._additionalLoadPromises = [], this._additionalCreatePromises = [], this._isUsingCreatePromises = false, this._projectName = \"\", this._projectVersion = \"\", this._projectUniqueId = \"\", this._appId = \"\", this._exportTimestamp = 0, this._originalViewportWidth = 0, this._originalViewportHeight = 0, this._devicePixelRatio = self.devicePixelRatio, this._parallaxXorigin = 0, this._parallaxYorigin = 0, this._viewportWidth = 0, this._viewportHeight = 0, this._loaderStyle = 0, this._usesLoaderLayout = false, this._isLoading = true, this._usesAnyBackgroundBlending = false, this._usesAnyCrossSampling = false, this._usesAnyDepthSampling = false, this._loadingLogoAsset = null, this._assetManager = C32.New(C32.AssetManager, this, e), this._layoutManager = C32.New(C32.LayoutManager, this), this._eventSheetManager = C32.New(C32.EventSheetManager, this), this._addonManager = C32.New(C32.AddonManager, this, e[\"wrapperComponentIds\"]), this._collisionEngine = C32.New(C32.CollisionEngine, this), this._timelineManager = C32.New(C32.TimelineManager, this), this._transitionManager = C32.New(C32.TransitionManager, this), this._templateManager = C32.New(C32.TemplateManager, this), this._flowchartManager = C32.New(C32.FlowchartManager, this), this._textIconManager = C32.New(C32.TextIconManager, { getIconSetMeta: (e2) => this._GetTextIconSetMeta(e2), getIconSetContent: (e2) => this._GetTextIconSetContent(e2) }), this._iconChangeHandlers = /* @__PURE__ */ new Map(), this._allObjectClasses = [], this._objectClassesByName = /* @__PURE__ */ new Map(), this._objectClassesBySid = /* @__PURE__ */ new Map(), this._familyCount = 0, this._allContainers = [], this._allEffectLists = /* @__PURE__ */ new Set(), this._currentLayoutStack = [], this._instancesPendingCreate = [], this._instancesPendingDestroy = /* @__PURE__ */ new Map(), this._hasPendingInstances = false, this._isFlushingPendingInstances = false, this._objectCount = 0, this._nextUid = 0, this._instancesByUid = /* @__PURE__ */ new Map(), this._instancesPendingRelease = /* @__PURE__ */ new Set(), this._instancesPendingReleaseAffectedObjectClasses = /* @__PURE__ */ new Set(), this._objectReferenceTable = [], this._jsPropNameTable = [], this._canvasManager = null, this._uses3dFeatures = false, this._framerateMode = \"vsync\", this._sampling = \"trilinear\", this._isPixelRoundingEnabled = false, this._needRender = true, this._pauseOnBlur = false, this._isPausedOnBlur = false, this._exportToVideo = null, this._tickCallbacks = { normal: (e2) => {\n        this._rafId = -1, this._ruafId = -1, this.Tick(e2);\n      }, tickOnly: (e2) => {\n        this._ruafId = -1, this.Tick(e2, false, \"skip-render\");\n      }, renderOnly: () => {\n        this._rafId = -1, this.Render();\n      } }, this._rafId = -1, this._ruafId = -1, this._tickCount = 0, this._tickCountNoSave = 0, this._hasStarted = false, this._isInTick = false, this._hasStartedTicking = false, this._isLayoutFirstTick = true, this._isAutoSuspendEnabled = true, this._isPageVisibilitySuspended = false, this._suspendCount = 0, this._scheduleTriggersThrottle = new C32.PromiseThrottle(1), this._randomNumberCallback = () => Math.random(), this._startTime = 0, this._lastTickTime = 0, this._dtRaw = 0, this._dt1 = 0, this._dt = 0, this._timeScale = 1, this._maxDt = 1 / 30, this._minDt = 0, this._gameTime = C32.New(C32.KahanSum), this._gameTimeRaw = C32.New(C32.KahanSum), this._wallTime = C32.New(C32.KahanSum), this._instanceTimes = /* @__PURE__ */ new Map(), this._fpsFrameCount = -1, this._fpsLastTime = 0, this._fps = 0, this._tpsTickCount = -1, this._tps = 0, this._mainThreadTimeCounter = 0, this._mainThreadTime = 0, this._isLoadingState = false, this._saveToSlotName = \"\", this._saveToJsonString = false, this._loadFromSlotName = \"\", this._loadFromJson = null, this._lastSaveJson = \"\", this._projectStorage = null, this._savegamesStorage = null, this._dispatcher = C32.New(C32.Event.Dispatcher), this._domEventHandlers = /* @__PURE__ */ new Map(), this._pendingResponsePromises = /* @__PURE__ */ new Map(), this._nextDomResponseId = 0, this._didRequestDeviceOrientationEvent = false, this._didRequestDeviceMotionEvent = false, this._isReadyToHandleEvents = false, this._waitingToHandleEvents = [], this._eventObjects = { \"pretick\": C32.New(C32.Event, \"pretick\", false), \"tick\": C32.New(C32.Event, \"tick\", false), \"tick2\": C32.New(C32.Event, \"tick2\", false), \"instancecreate\": C32.New(C32.Event, \"instancecreate\", false), \"instancedestroy\": C32.New(C32.Event, \"instancedestroy\", false), \"beforelayoutchange\": C32.New(C32.Event, \"beforelayoutchange\", false), \"layoutchange\": C32.New(C32.Event, \"layoutchange\", false) }, this._eventObjects[\"instancecreate\"].instance = null, this._eventObjects[\"instancedestroy\"].instance = null, this._userScriptDispatcher = C32.New(C32.Event.Dispatcher), this._userScriptEventObjects = null;\n      const t = (e2, t2) => C32.BehaviorInstance.SortByTickSequence(this, e2, t2);\n      this._behInstsToTick = C32.New(C32.RedBlackSet, t), this._behInstsToPostTick = C32.New(C32.RedBlackSet, t), this._behInstsToTick2 = C32.New(C32.RedBlackSet, t), this._jobScheduler = C32.New(C32.JobSchedulerRuntime, this, e[\"jobScheduler\"]), e[\"canvas\"] && (this._canvasManager = C32.New(C32.CanvasManager, this)), this._messagePort.onmessage = (e2) => this[\"_OnMessageFromDOM\"](e2.data), this.AddDOMComponentMessageHandler(\"runtime\", \"visibilitychange\", (e2) => this._OnVisibilityChange(e2)), this.AddDOMComponentMessageHandler(\"runtime\", \"wrapper-extension-message\", (e2) => this._OnWrapperExtensionMessage(e2)), this.AddDOMComponentMessageHandler(\"runtime\", \"get-remote-preview-status-info\", () => this._GetRemotePreviewStatusInfo()), this.AddDOMComponentMessageHandler(\"runtime\", \"js-invoke-function\", (e2) => this._InvokeFunctionFromJS(e2)), this.AddDOMComponentMessageHandler(\"runtime\", \"go-to-last-error-script\", self[\"goToLastErrorScript\"]), this.AddDOMComponentMessageHandler(\"runtime\", \"offline-audio-render-completed\", (e2) => this._OnOfflineAudioRenderCompleted(e2)), this._dispatcher.addEventListener(\"window-blur\", (e2) => this._OnWindowBlur(e2)), this._dispatcher.addEventListener(\"window-focus\", () => this._OnWindowFocus()), this._timelineManager.AddRuntimeListeners(), this._templateManager.AddRuntimeListeners(), this._iRuntime = null, this._interfaceMap = /* @__PURE__ */ new WeakMap(), this._commonScriptInterfaces = { keyboard: null, mouse: null, touch: null, timelineController: null }, this._instancesNeedingAfterLoadMap = /* @__PURE__ */ new WeakMap(), this._instancesNeedingAfterLoadArray = [];\n    }\n    static Create(e) {\n      return C32.New(C32.Runtime, e);\n    }\n    Release() {\n      C32.clearArray(this._allObjectClasses), this._objectClassesByName.clear(), this._objectClassesBySid.clear(), this._layoutManager.Release(), this._layoutManager = null, this._eventSheetManager.Release(), this._eventSheetManager = null, this._addonManager.Release(), this._addonManager = null, this._assetManager.Release(), this._assetManager = null, this._collisionEngine.Release(), this._collisionEngine = null, this._timelineManager.Release(), this._timelineManager = null, this._transitionManager.Release(), this._transitionManager = null, this._templateManager.Release(), this._templateManager = null, this._flowchartManager.Release(), this._flowchartManager = null, this._textIconManager.Release(), this._textIconManager = null, this._canvasManager && (this._canvasManager.Release(), this._canvasManager = null), this._dispatcher.Release(), this._dispatcher = null, this._tickEvent = null;\n    }\n    [\"_OnMessageFromDOM\"](e) {\n      const t = e[\"type\"];\n      if (\"event\" === t) this._OnEventFromDOM(e);\n      else {\n        if (\"result\" !== t) throw new Error(`unknown message '${t}'`);\n        this._OnResultFromDOM(e);\n      }\n    }\n    _OnEventFromDOM(e) {\n      if (this._isReadyToHandleEvents) {\n        const t = e[\"component\"], s = e[\"handler\"], i = e[\"data\"], n = e[\"dispatchOpts\"], a = !(!n || !n[\"dispatchRuntimeEvent\"]), r = !(!n || !n[\"dispatchUserScriptEvent\"]), o = e[\"responseId\"];\n        if (\"runtime\" === t) {\n          if (a) {\n            const l = new C32.Event(s);\n            l.data = i, this._dispatcher.dispatchEventAndWaitAsyncSequential(l);\n          }\n          if (r) {\n            const c = new C32.Event(s, true);\n            for (const [d, _] of Object.entries(i)) c[d] = _;\n            this.DispatchUserScriptEvent(c);\n          }\n        }\n        const h = this._domEventHandlers.get(t);\n        if (h) {\n          const g = h.get(s);\n          if (g) {\n            let e2 = null;\n            try {\n              e2 = g(i);\n            } catch (e3) {\n              return console.error(`Exception in '${t}' handler '${s}':`, e3), void (null !== o && this._PostResultToDOM(o, false, \"\" + e3));\n            }\n            null !== o && (e2 && e2.then ? e2.then((e3) => this._PostResultToDOM(o, true, e3)).catch((e3) => {\n              console.error(`Rejection from '${t}' handler '${s}':`, e3), this._PostResultToDOM(o, false, \"\" + e3);\n            }) : this._PostResultToDOM(o, true, e2));\n          } else a || r || console.warn(`[Runtime] No DOM handler '${s}' for component '${t}'`);\n        } else a || r || console.warn(`[Runtime] No DOM event handlers for component '${t}'`);\n      } else this._waitingToHandleEvents.push(e);\n    }\n    _PostResultToDOM(e, t, s) {\n      this._messagePort.postMessage({ \"type\": \"result\", \"responseId\": e, \"isOk\": t, \"result\": s });\n    }\n    _OnResultFromDOM(e) {\n      const t = e[\"responseId\"], s = e[\"isOk\"], i = e[\"result\"], n = this._pendingResponsePromises.get(t);\n      s ? n.resolve(i) : n.reject(i), this._pendingResponsePromises.delete(t);\n    }\n    AddDOMComponentMessageHandler(e, t, s) {\n      let i = this._domEventHandlers.get(e);\n      if (i || (i = /* @__PURE__ */ new Map(), this._domEventHandlers.set(e, i)), i.has(t)) throw new Error(`[Runtime] Component '${e}' already has handler '${t}'`);\n      i.set(t, s);\n    }\n    PostComponentMessageToDOM(e, t, s, i) {\n      this._messagePort.postMessage({ \"type\": \"event\", \"component\": e, \"handler\": t, \"data\": s, \"responseId\": null }, i);\n    }\n    PostComponentMessageToDOMAsync(e, t, s, i) {\n      const n = this._nextDomResponseId++, a = new Promise((e2, t2) => {\n        this._pendingResponsePromises.set(n, { resolve: e2, reject: t2 });\n      });\n      return this._messagePort.postMessage({ \"type\": \"event\", \"component\": e, \"handler\": t, \"data\": s, \"responseId\": n }, i), a;\n    }\n    SendWrapperExtensionMessage(e, t, s, i = -1) {\n      this.PostComponentMessageToDOM(\"runtime\", \"send-wrapper-extension-message\", { \"componentId\": e, \"messageId\": t, \"params\": s, \"asyncId\": i });\n    }\n    SendWrapperExtensionMessageAsync(e, t, s) {\n      const i = this._nextDomResponseId++, n = new Promise((e2, t2) => {\n        this._pendingResponsePromises.set(i, { resolve: e2, reject: t2 });\n      });\n      return this.SendWrapperExtensionMessage(e, t, s, i), n;\n    }\n    _OnWrapperExtensionMessage(e) {\n      if (-1 !== e[\"asyncId\"]) {\n        const t = e[\"asyncId\"], s = this._pendingResponsePromises.get(t);\n        s.resolve(e[\"params\"]), this._pendingResponsePromises.delete(t);\n      } else this._OnEventFromDOM({ \"component\": \"wrapper-extension:\" + e[\"componentId\"], \"handler\": e[\"messageId\"], \"data\": e[\"params\"], \"responseId\": null });\n    }\n    AddWrapperExtensionMessageHandler(e, t, s) {\n      this.AddDOMComponentMessageHandler(\"wrapper-extension:\" + e, t, s);\n    }\n    HasWrapperComponentId(e) {\n      return this._addonManager.HasWrapperComponentId(e);\n    }\n    PostToDebugger(e) {\n      if (!this.IsDebug()) throw new Error(\"not in debug mode\");\n      this.PostComponentMessageToDOM(\"runtime\", \"post-to-debugger\", e);\n    }\n    async Init(e) {\n      C32.CommonACES_SetRuntime(this), this.IsDebug() ? await C3Debugger.Init(this) : self.C3Debugger && self.C3Debugger.InitPreview(this);\n      const t = await this._assetManager.FetchJson(\"data.json\");\n      if (await this._LoadDataJson(t), await this._InitialiseCanvas(e), this.IsPreview() || console.info(\"%cMade with Construct, the game and animation creation tool. Visit: https://www.construct.net\", \"font-weight: bold\"), this.GetWebGLRenderer()) {\n        const s = this.GetWebGLRenderer();\n        console.info(`[C3 runtime] Hosted in ${this.IsInWorker() ? \"worker\" : \"DOM\"}, rendering with WebGL ${s.GetWebGLVersionNumber()} [${s.GetUnmaskedRenderer()}]`);\n      } else this.GetWebGPURenderer() && console.info(`[C3 runtime] Hosted in ${this.IsInWorker() ? \"worker\" : \"DOM\"}, rendering with WebGPU [${this.GetWebGPURenderer().GetAdapterInfoString()}]`);\n      this.GetRenderer().HasMajorPerformanceCaveat() && console.warn(\"[C3 runtime] The renderer indicates a major performance caveat. Software rendering may be in use. This can result in significantly degraded performance.\"), this._isReadyToHandleEvents = true;\n      for (const i of this._waitingToHandleEvents) this._OnEventFromDOM(i);\n      C32.clearArray(this._waitingToHandleEvents), this._canvasManager && this._canvasManager.StartLoadingScreen();\n      for (const n of e[\"runOnStartupFunctions\"]) this._additionalLoadPromises.push(this._RunOnStartupFunction(n));\n      if (await Promise.all([this._assetManager.WaitForAllToLoad(), ...this._additionalLoadPromises]), C32.clearArray(this._additionalLoadPromises), !this._assetManager.HasHadErrorLoading()) return this._canvasManager && await this._canvasManager.EndLoadingScreen(), await this._dispatcher.dispatchEventAndWaitAsync(new C32.Event(\"beforeruntimestart\")), await this.Start(), this._messagePort.postMessage({ \"type\": \"runtime-ready\" }), this;\n      this._canvasManager && this._canvasManager.HideCordovaSplashScreen();\n    }\n    async _RunOnStartupFunction(e) {\n      try {\n        await e(this._iRuntime);\n      } catch (e2) {\n        console.error(\"[C3 runtime] Error in runOnStartup function: \", e2);\n      }\n    }\n    async _LoadDataJson(e) {\n      const t = e[\"project\"], s = (this._projectName = t[0], this._projectVersion = t[16], this._projectUniqueId = t[31], this._appId = t[38], this._exportTimestamp = t[36], t[39] || \"loading-logo.png\"), i = (this._isPixelRoundingEnabled = !!t[9], this._originalViewportWidth = this._viewportWidth = t[10], this._originalViewportHeight = this._viewportHeight = t[11], this._collisionEngine._InitCollisionCellSize(this._originalViewportWidth, this._originalViewportHeight), this._parallaxXorigin = this._originalViewportWidth / 2, this._parallaxYorigin = this._originalViewportHeight / 2, this._framerateMode = t[37], this._uses3dFeatures = !!t[40], this._sampling = t[14], this._usesAnyBackgroundBlending = t[15], this._usesAnyCrossSampling = t[42], this._usesAnyDepthSampling = t[17], this._usesLoaderLayout = !!t[18], this._loaderStyle = t[19], this._nextUid = t[21], this._pauseOnBlur = t[22], this._assetManager);\n      if (i._SetFileStructure(t[45]), i._SetAudioFiles(t[7], t[25]), i._SetMediaSubfolder(t[8]), i._SetFontsSubfolder(t[32]), i._SetIconsSubfolder(t[28]), i._SetWebFonts(t[29]), 0 === this._loaderStyle) {\n        let e2 = \"\";\n        (e2 = \"flat\" === i.GetFileStructure() ? i.GetIconsSubfolder() + s : s) && (this._loadingLogoAsset = i.LoadImage({ url: e2 }));\n      }\n      this._canvasManager && (this._canvasManager.SetFullscreenMode(C32.CanvasManager._FullscreenModeNumberToString(t[12])), this._canvasManager.SetFullscreenScalingQuality(t[23] ? \"high\" : \"low\"), this._canvasManager.SetMipmapsEnabled(0 !== t[24]), this._canvasManager._SetGPUPowerPreference(t[34]), this._canvasManager._SetTextureAnisotropy(t[41]), this._canvasManager._SetWebGPUEnabled(t[13]), this._canvasManager._SetZAxisScale(t[30]), this._canvasManager._SetZDistances(t[46], t[47]), this._canvasManager._SetInitFieldOfView(t[26]), this._canvasManager._SetLimitedToWebGL1(t[48]), this._canvasManager._SetMultitexturingMode(t[50]));\n      const n = t[43], a = (n && await this._LoadExportToVideoData(n), this._InitScriptInterfaces(), this._addonManager.CreateSystemPlugin(), this._objectReferenceTable = self.C3_GetObjectRefTable(), t[2]);\n      for (const l of a[1]) this._addonManager.CreateBehavior(l);\n      for (const c of a[0]) this._addonManager.CreatePlugin(c);\n      this._objectReferenceTable = self.C3_GetObjectRefTable(), this._LoadJsPropNameTable(), this._addonManager._InitAddonScriptInterfaces();\n      for (const d of t[3]) {\n        const _ = C32.ObjectClass.Create(this, this._allObjectClasses.length, d);\n        this._allObjectClasses.push(_), this._objectClassesByName.set(_.GetName().toLowerCase(), _), this._objectClassesBySid.set(_.GetSID(), _);\n      }\n      for (const g of t[4]) {\n        const u = this._allObjectClasses[g[0]];\n        u._LoadFamily(g);\n      }\n      for (const m of t[27]) {\n        const p = m.map((e2) => this._allObjectClasses[e2]);\n        this._allContainers.push(C32.New(C32.Container, this, p));\n      }\n      this._InitObjectsScriptInterface();\n      for (const f of this._allObjectClasses) f._OnAfterCreate();\n      for (const C of t[5]) this._layoutManager.Create(C);\n      const r = t[1];\n      if (r) {\n        const S = this._layoutManager.GetLayoutByName(r);\n        S && this._layoutManager.SetFirstLayout(S);\n      }\n      for (const I of t[35]) this._transitionManager.Create(I);\n      for (const v of t[33]) this._timelineManager.Create(v);\n      for (const T of t[44]) this._templateManager.Create(T);\n      this._templateManager.HasTemplates() || (this._templateManager.Release(), this._templateManager = null);\n      for (const b of t[49]) this._flowchartManager.Create(b);\n      this._flowchartManager.HasFlowcharts() || (this._flowchartManager.Release(), this._flowchartManager = null);\n      for (const M of t[6]) this._eventSheetManager.Create(M);\n      this._eventSheetManager._PostInit(), this._InitGlobalVariableScriptInterface(), C32.clearArray(this._objectReferenceTable), this.FlushPendingInstances();\n      let o = \"any\";\n      const h = t[20];\n      1 === h ? o = \"portrait\" : 2 === h && (o = \"landscape\"), this.PostComponentMessageToDOM(\"runtime\", \"set-target-orientation\", { \"targetOrientation\": o });\n    }\n    async _LoadExportToVideoData(e) {\n      const t = e[\"format\"];\n      \"image-sequence\" === t ? this._exportToVideo = new self.C3ExportToImageSequence(this, e) : \"image-sequence-gif\" === t ? this._exportToVideo = new self.C3ExportToGIF(this, e) : \"webm\" === t ? this._exportToVideo = new self.C3ExportToWebMVideo(this, e) : \"mp4\" === t && (this._exportToVideo = new self.C3ExportToMP4Video(this, e)), this._framerateMode = \"unlimited-frame\", this._canvasManager.SetFullscreenMode(\"off\"), this._devicePixelRatio = 1, self.devicePixelRatio = 1, await this.PostComponentMessageToDOMAsync(\"runtime\", \"set-exporting-to-video\", { \"message\": this._exportToVideo.GetExportingMessageForPercent(0), \"duration\": this._exportToVideo.GetDuration() });\n    }\n    GetLoaderStyle() {\n      return this._loaderStyle;\n    }\n    IsExportToVideo() {\n      return null !== this._exportToVideo;\n    }\n    GetExportVideoDuration() {\n      return this._exportToVideo.GetDuration();\n    }\n    GetExportVideoFramerate() {\n      return this._exportToVideo.GetFramerate();\n    }\n    _InitExportToVideo() {\n      return this._exportToVideo.Init({ width: this._canvasManager.GetDeviceWidth(), height: this._canvasManager.GetDeviceHeight() });\n    }\n    _ExportToVideoAddFrame() {\n      const e = this._tickCount / this.GetExportVideoFramerate();\n      return this._exportToVideo.AddFrame(this._canvasManager.GetMainCanvas(), e);\n    }\n    _ExportToVideoAddKeyframe() {\n      this._exportToVideo && this._exportToVideo.AddKeyframe();\n    }\n    _OnOfflineAudioRenderCompleted(e) {\n      this._exportToVideo.OnOfflineAudioRenderCompleted(e);\n    }\n    _ExportToVideoFinish() {\n      return this._exportToVideo.Finish();\n    }\n    IsFBInstantAvailable() {\n      return this._isFBInstantAvailable;\n    }\n    IsLoading() {\n      return this._isLoading;\n    }\n    AddLoadPromise(e) {\n      this._additionalLoadPromises.push(e);\n    }\n    SetUsingCreatePromises(e) {\n      this._isUsingCreatePromises = !!e;\n    }\n    AddCreatePromise(e) {\n      this._isUsingCreatePromises && this._additionalCreatePromises.push(e);\n    }\n    GetCreatePromises() {\n      return this._additionalCreatePromises;\n    }\n    _GetNextFamilyIndex() {\n      return this._familyCount++;\n    }\n    GetFamilyCount() {\n      return this._familyCount;\n    }\n    _AddEffectList(e) {\n      this._allEffectLists.add(e);\n    }\n    _RemoveEffectList(e) {\n      this._allEffectLists.delete(e);\n    }\n    _GetAllEffectLists() {\n      return this._allEffectLists;\n    }\n    async _InitialiseCanvas(e) {\n      this._canvasManager && (await this._canvasManager.CreateCanvas(e), this._canvasManager.InitLoadingScreen(this._loaderStyle));\n    }\n    async Start() {\n      this._hasStarted = true, this._startTime = Date.now();\n      let t = null;\n      const e = new Promise((e2) => t = e2);\n      if (this._usesLoaderLayout) {\n        for (const n of this._allObjectClasses) n.IsFamily() || n.IsOnLoaderLayout() || !n.IsWorldType() || n.OnCreate();\n        (async () => {\n          await this._assetManager.WaitForAllToLoad(), await e, this._isLoading = false, this._OnLoadFinished();\n        })();\n      } else this._isLoading = false;\n      this._assetManager.SetInitialLoadFinished(), this.IsDebug() && C3Debugger.RuntimeInit(ife);\n      for (const a of this._layoutManager.GetAllLayouts()) a._CreateGlobalNonWorlds();\n      this.IsExportToVideo() && await this._InitExportToVideo();\n      const s = this._layoutManager.GetFirstLayout(), i = (await s._Load(null, this.GetRenderer()), await s._StartRunning(true), this._fpsLastTime = performance.now(), t(), this._usesLoaderLayout || this._OnLoadFinished(), await this.PostComponentMessageToDOMAsync(\"runtime\", \"before-start-ticking\"));\n      i[\"isSuspended\"] && !this.IsExportToVideo() ? (this._suspendCount++, this._isPageVisibilitySuspended = true) : this.Tick();\n    }\n    _OnLoadFinished() {\n      this.Trigger(C32.Plugins.System.Cnds.OnLoadFinished, null, null), this.PostComponentMessageToDOM(\"runtime\", \"register-sw\");\n    }\n    GetObjectReference(e) {\n      e = Math.floor(e);\n      const t = this._objectReferenceTable;\n      if (e < 0 || e >= t.length) throw new Error(\"invalid object reference\");\n      return t[e];\n    }\n    _LoadJsPropNameTable() {\n      for (const e of self.C3_JsPropNameTable) {\n        const t = C32.first(Object.keys(e));\n        this._jsPropNameTable.push(t);\n      }\n    }\n    GetJsPropName(e) {\n      e = Math.floor(e);\n      const t = this._jsPropNameTable;\n      if (e < 0 || e >= t.length) throw new Error(\"invalid prop reference\");\n      return t[e];\n    }\n    HasDOM() {\n      return this._hasDom;\n    }\n    IsHeadless() {\n      return this._isHeadless;\n    }\n    IsInWorker() {\n      return this._isInWorker;\n    }\n    GetRuntimeBaseURL() {\n      return this._runtimeBaseUrl;\n    }\n    GetPreviewURL() {\n      return this._previewUrl;\n    }\n    GetEventSheetManager() {\n      return this._eventSheetManager;\n    }\n    GetEventStack() {\n      return this._eventSheetManager.GetEventStack();\n    }\n    GetCurrentEventStackFrame() {\n      return this._eventSheetManager.GetCurrentEventStackFrame();\n    }\n    GetCurrentEvent() {\n      return this._eventSheetManager.GetCurrentEvent();\n    }\n    GetCurrentCondition() {\n      return this._eventSheetManager.GetCurrentCondition();\n    }\n    IsCurrentConditionFirst() {\n      return 0 === this.GetCurrentEventStackFrame().GetConditionIndex();\n    }\n    GetCurrentAction() {\n      return this._eventSheetManager.GetCurrentAction();\n    }\n    GetAddonManager() {\n      return this._addonManager;\n    }\n    GetSystemPlugin() {\n      return this._addonManager.GetSystemPlugin();\n    }\n    GetObjectClassByIndex(e) {\n      if ((e = Math.floor(e)) < 0 || e >= this._allObjectClasses.length) throw new RangeError(\"invalid index\");\n      return this._allObjectClasses[e];\n    }\n    GetObjectClassByName(e) {\n      return this._objectClassesByName.get(e.toLowerCase()) || null;\n    }\n    GetObjectClassBySID(e) {\n      return this._objectClassesBySid.get(e) || null;\n    }\n    GetSingleGlobalObjectClassByCtor(e) {\n      const t = C32.AddonManager.GetPluginByConstructorFunction(e);\n      return t ? t.GetSingleGlobalObjectClass() : null;\n    }\n    GetAllObjectClasses() {\n      return this._allObjectClasses;\n    }\n    *allInstances() {\n      for (const e of this._allObjectClasses) e.IsFamily() || (yield* e.instances());\n    }\n    Dispatcher() {\n      return this._dispatcher;\n    }\n    UserScriptDispatcher() {\n      return this._userScriptDispatcher;\n    }\n    DispatchUserScriptEvent(e) {\n      e.runtime = this.GetIRuntime();\n      const t = this.IsDebug() && !this._eventSheetManager.IsInEventEngine();\n      t && C3Debugger.StartMeasuringScriptTime(), this._userScriptDispatcher.dispatchEvent(e), t && C3Debugger.AddScriptTime();\n    }\n    DispatchUserScriptEventAsyncWait(e) {\n      return e.runtime = this.GetIRuntime(), this._userScriptDispatcher.dispatchEventAndWaitAsync(e);\n    }\n    GetOriginalViewportWidth() {\n      return this._originalViewportWidth;\n    }\n    GetOriginalViewportHeight() {\n      return this._originalViewportHeight;\n    }\n    SetOriginalViewportSize(e, t) {\n      if (this._originalViewportWidth !== e || this._originalViewportHeight !== t) {\n        this._originalViewportWidth = e, this._originalViewportHeight = t;\n        const s = this.GetLayoutManager();\n        s.SetAllLayerProjectionChanged(), s.SetAllLayerMVChanged();\n      }\n    }\n    GetViewportWidth() {\n      return this._viewportWidth;\n    }\n    GetViewportHeight() {\n      return this._viewportHeight;\n    }\n    SetViewportSize(e, t) {\n      if (this._viewportWidth !== e || this._viewportHeight !== t) {\n        this._viewportWidth = e, this._viewportHeight = t;\n        const s = this.GetLayoutManager();\n        s.SetAllLayerProjectionChanged(), s.SetAllLayerMVChanged();\n      }\n    }\n    _SetDevicePixelRatio(e) {\n      this.IsExportToVideo() || (this._devicePixelRatio = e);\n    }\n    GetDevicePixelRatio() {\n      return this._devicePixelRatio;\n    }\n    GetParallaxXOrigin() {\n      return this._parallaxXorigin;\n    }\n    GetParallaxYOrigin() {\n      return this._parallaxYorigin;\n    }\n    GetCanvasManager() {\n      return this._canvasManager;\n    }\n    GetDrawWidth() {\n      return this._canvasManager ? this._canvasManager.GetDrawWidth() : this._viewportWidth;\n    }\n    GetDrawHeight() {\n      return this._canvasManager ? this._canvasManager.GetDrawHeight() : this._viewportHeight;\n    }\n    GetRenderScale() {\n      return this._canvasManager ? this._canvasManager.GetRenderScale() : 1;\n    }\n    GetDisplayScale() {\n      return this._canvasManager ? this._canvasManager.GetDisplayScale() : 1;\n    }\n    GetEffectLayerScaleParam() {\n      return this._canvasManager ? this._canvasManager.GetEffectLayerScaleParam() : 1;\n    }\n    GetEffectDevicePixelRatioParam() {\n      return this._canvasManager ? this._canvasManager.GetEffectDevicePixelRatioParam() : 1;\n    }\n    GetCanvasClientX() {\n      return this._canvasManager ? this._canvasManager.GetCanvasClientX() : 0;\n    }\n    GetCanvasClientY() {\n      return this._canvasManager ? this._canvasManager.GetCanvasClientY() : 0;\n    }\n    GetCanvasCssWidth() {\n      return this._canvasManager ? this._canvasManager.GetCssWidth() : 0;\n    }\n    GetCanvasCssHeight() {\n      return this._canvasManager ? this._canvasManager.GetCssHeight() : 0;\n    }\n    GetFullscreenMode() {\n      return this._canvasManager ? this._canvasManager.GetFullscreenMode() : \"off\";\n    }\n    GetAdditionalRenderTarget(e) {\n      return this._canvasManager ? this._canvasManager.GetAdditionalRenderTarget(e) : null;\n    }\n    ReleaseAdditionalRenderTarget(e) {\n      this._canvasManager && this._canvasManager.ReleaseAdditionalRenderTarget(e);\n    }\n    UsesAnyBackgroundBlending() {\n      return this._usesAnyBackgroundBlending;\n    }\n    UsesAnyCrossSampling() {\n      return this._usesAnyCrossSampling;\n    }\n    UsesAnyDepthSampling() {\n      return this._usesAnyDepthSampling;\n    }\n    GetGPUUtilisation() {\n      return this._canvasManager ? this._canvasManager.GetGPUUtilisation() : NaN;\n    }\n    IsLinearSampling() {\n      return \"nearest\" !== this.GetSampling();\n    }\n    GetFramerateMode() {\n      return this._framerateMode;\n    }\n    _SetFramerateMode(e) {\n      this._framerateMode !== e && (this._framerateMode = e, -1 !== this._rafId || -1 !== this._ruafId) && (this._CancelAnimationFrame(), this._RequestAnimationFrame());\n    }\n    GetSampling() {\n      return this._sampling;\n    }\n    UsesLoaderLayout() {\n      return this._usesLoaderLayout;\n    }\n    GetLoadingLogoAsset() {\n      return this._loadingLogoAsset;\n    }\n    ReleaseLoadingLogoAsset() {\n      this._loadingLogoAsset && (this._loadingLogoAsset.ReleaseTexture(), this._loadingLogoAsset.Release(), this._loadingLogoAsset = null);\n    }\n    GetLayoutManager() {\n      return this._layoutManager;\n    }\n    GetMainRunningLayout() {\n      return this._layoutManager.GetMainRunningLayout();\n    }\n    GetTimelineManager() {\n      return this._timelineManager;\n    }\n    GetTransitionManager() {\n      return this._transitionManager;\n    }\n    GetTemplateManager() {\n      return this._templateManager;\n    }\n    GetFlowchartManager() {\n      return this._flowchartManager;\n    }\n    GetAssetManager() {\n      return this._assetManager;\n    }\n    LoadImage(e) {\n      return this._assetManager.LoadImage(e);\n    }\n    CreateInstance(e, t, s, i, n, a) {\n      if (a && this._templateManager) {\n        if (e instanceof C32.ObjectClass && e.IsFamily()) {\n          const o = e.GetFamilyMembers(), h = Math.floor(this.Random() * o.length);\n          return this.CreateInstance(o[h], t, s, i, n, a);\n        }\n        const r = this._templateManager.GetTemplateData(e, a);\n        if (r) {\n          const l = this.CreateInstanceFromData(r, t, false, s, i, false, n, void 0, n);\n          return this._templateManager.MapInstanceToTemplateName(l, a), l;\n        }\n      }\n      return this.CreateInstanceFromData(e, t, false, s, i, false, n, void 0, n);\n    }\n    CreateInstanceFromData(e, t, s, i, n, a, r, o, h) {\n      let l = null, c = null;\n      if (e instanceof C32.ObjectClass) {\n        if ((c = e).IsFamily()) {\n          const I = c.GetFamilyMembers(), v = Math.floor(this.Random() * I.length);\n          c = I[v];\n        }\n        l = c.GetDefaultInstanceData();\n      } else l = e, c = this.GetObjectClassByIndex(l[1]);\n      const d = c.GetPlugin().IsWorldType();\n      if (this._isLoading && d && !c.IsOnLoaderLayout()) return null;\n      const _ = t;\n      d || (t = null);\n      let g;\n      g = s && !a && l && !this._instancesByUid.has(l[2]) ? l[2] : this._nextUid++;\n      const u = l ? l[0] : null, m = C32.New(C32.Instance, { runtime: this, objectType: c, layer: t, worldData: u, instVarData: l ? l[3] : null, uid: g, tags: l ? l[6] : null });\n      this._instancesByUid.set(g, m);\n      let p = null, f = (d && (p = m.GetWorldInfo(), void 0 !== i && void 0 !== n && (p.SetX(i), p.SetY(n)), c._SetAnyCollisionCellChanged(true)), t && (h || t._AddInstance(m, true), t.GetLayout().MaybeLoadTexturesFor(c)), this._objectCount++, true);\n      if (o) {\n        const T = o.GetObjectClass();\n        if (T.IsInContainer() && c.IsInContainer()) {\n          const b = c.GetContainer(), M = T.GetContainer();\n          b === M && (f = false);\n        }\n      }\n      if (c.IsInContainer() && !s && !a && f) {\n        const y = /* @__PURE__ */ new Set();\n        for (const G of c.GetContainer().objectTypes()) if (G !== c) {\n          const w = this._MaybeGetChildInstanceForObjectTypeData(G, p, y);\n          if (w) {\n            const D = this.CreateInstanceFromData(w, _, false, p ? p.GetX() : i, p ? p.GetY() : n, true, false, void 0, h);\n            m._AddSibling(D);\n          } else {\n            const B = this.CreateInstanceFromData(G, _, false, p ? p.GetX() : i, p ? p.GetY() : n, true, false, void 0, h);\n            m._AddSibling(B);\n          }\n        }\n        for (const P of m.siblings()) {\n          P._AddSibling(m);\n          for (const R of m.siblings()) P !== R && P._AddSibling(R);\n        }\n      }\n      if (d && !s && r && this._CreateChildInstancesFromData(m, u, p, t, i, n, h), c.IsInContainer() && !s && !a && r) for (const L of m.siblings()) {\n        const E = L.GetWorldInfo();\n        if (E) {\n          const j = L.GetPlugin(), k = L.GetObjectClass().GetDefaultInstanceData()[0];\n          j.IsWorldType() ? this._CreateChildInstancesFromData(L, k, E, t, E.GetX(), E.GetY(), h) : this._CreateChildInstancesFromData(L, k, E, t, void 0, void 0, h);\n        }\n      }\n      if (!a && r) {\n        void 0 === i && (i = u[0]), void 0 === n && (n = u[1]);\n        const A = p.GetTopParent(), W = i - p.GetX() + A.GetX(), N = n - p.GetY() + A.GetY();\n        A.SetXY(W, N);\n      }\n      c._SetIIDsStale();\n      const F = l ? C32.cloneArray(l[5]) : null, x = l ? l[4].map((e2) => C32.cloneArray(e2)) : null, C = d && u && u[13];\n      if (C && m._SetHasTilemap(), m._CreateSdkInstance(F, x), C) {\n        const O = u[13];\n        m.GetSdkInstance().LoadTilemapData(O[2], O[0], O[1]);\n      }\n      this._instancesPendingCreate.push(m), this._hasPendingInstances = true, this.IsDebug() && C3Debugger.InstanceCreated(m);\n      const S = this._eventObjects[\"instancecreate\"];\n      return S.instance = m, this._dispatcher.dispatchEvent(S), m;\n    }\n    _GetInstanceData(e) {\n      const t = e[0], s = e[1], i = e[2], n = e[6];\n      if (n) return n;\n      const a = this._layoutManager.GetLayoutBySID(t), r = a.GetLayer(s);\n      return r.GetInitialInstanceData(i);\n    }\n    _MaybeGetChildInstanceForObjectTypeData(e, t, s) {\n      const i = t?.GetSceneGraphChildrenExportData() ?? [];\n      for (const n of i) {\n        const a = this._GetInstanceData(n), r = !!n[4], o = this.GetObjectClassByIndex(a[1]);\n        if (!s.has(a) && (e === o && r)) return s.add(a), a;\n      }\n    }\n    _CreateChildInstancesFromData(t, e, s, i, n, a, r) {\n      const o = s.GetSceneGraphZIndexExportData(), h = s.GetSceneGraphChildrenExportData();\n      if (t.GetWorldInfo().SetSceneGraphZIndex(o), h) {\n        void 0 === n && (n = e[0]), void 0 === a && (a = e[1]);\n        const l = /* @__PURE__ */ new Set(), c = e[0], d = e[1];\n        for (const _ of h) {\n          const g = _[0], u = _[1], m = _[2], p = _[3], f = !!_[4], C = _[5], S = _[6];\n          let e2;\n          if (S) e2 = S;\n          else {\n            const b = this._layoutManager.GetLayoutBySID(g), M = b.GetLayer(u);\n            e2 = M.GetInitialInstanceData(m);\n          }\n          const I = this.GetObjectClassByIndex(e2[1]), v = t.HasSibling(I), T = l.has(I);\n          if (v && !T && f) {\n            const y = t.GetSibling(I), G = (y.GetWorldInfo().Init(e2[0]), n + e2[0][0] - c), w = a + e2[0][1] - d;\n            y.GetWorldInfo().SetXY(G, w), y.GetWorldInfo().SetSceneGraphZIndex(C), t.AddChild(y, { transformX: !!(p >> 0 & 1), transformY: !!(p >> 1 & 1), transformWidth: !!(p >> 2 & 1), transformHeight: !!(p >> 3 & 1), transformAngle: !!(p >> 4 & 1), destroyWithParent: !!(p >> 5 & 1), transformZElevation: !!(p >> 6 & 1), transformOpacity: !!(p >> 7 & 1), transformVisibility: !!(p >> 8 & 1) }), l.add(I);\n          } else {\n            const D = n + e2[0][0] - c, P = a + e2[0][1] - d, R = this.CreateInstanceFromData(e2, i, false, D, P, false, true, t, r);\n            R.GetWorldInfo().SetSceneGraphZIndex(C), t.AddChild(R, { transformX: !!(p >> 0 & 1), transformY: !!(p >> 1 & 1), transformWidth: !!(p >> 2 & 1), transformHeight: !!(p >> 3 & 1), transformAngle: !!(p >> 4 & 1), destroyWithParent: !!(p >> 5 & 1), transformZElevation: !!(p >> 6 & 1), transformOpacity: !!(p >> 7 & 1), transformVisibility: !!(p >> 8 & 1) });\n          }\n        }\n      }\n    }\n    DestroyInstance(t) {\n      if (!this._instancesPendingRelease.has(t)) {\n        const s = t.GetObjectClass();\n        let e = this._instancesPendingDestroy.get(s);\n        if (e) {\n          if (e.has(t)) return;\n          e.add(t);\n        } else (e = /* @__PURE__ */ new Set()).add(t), this._instancesPendingDestroy.set(s, e);\n        if (this.IsDebug() && C3Debugger.InstanceDestroyed(t), t._MarkDestroyed(), this._hasPendingInstances = true, t.IsInContainer()) for (const e2 of t.siblings()) this.DestroyInstance(e2);\n        for (const i of t.children()) i.GetDestroyWithParent() && this.DestroyInstance(i);\n        if (!this._layoutManager.IsEndingLayout() && !this._isLoadingState) {\n          const n = this.GetEventSheetManager();\n          n.BlockFlushingInstances(true), t._TriggerOnDestroyed(), n.BlockFlushingInstances(false);\n        }\n        t._FireDestroyedScriptEvents(this._layoutManager.IsEndingLayout());\n      }\n    }\n    FlushPendingInstances() {\n      this._hasPendingInstances && (this._isFlushingPendingInstances = true, this._FlushInstancesPendingCreate(), this._FlushInstancesPendingDestroy(), this._isFlushingPendingInstances = false, this._hasPendingInstances = false, this.UpdateRender());\n    }\n    _FlushInstancesPendingCreate() {\n      for (const e of this._instancesPendingCreate) {\n        const t = e.GetObjectClass();\n        t._AddInstance(e);\n        for (const s of t.GetFamilies()) s._AddInstance(e), s._SetIIDsStale();\n      }\n      C32.clearArray(this._instancesPendingCreate);\n    }\n    _FlushInstancesPendingDestroy() {\n      this._dispatcher.SetDelayRemoveEventsEnabled(true);\n      for (const [e, t] of this._instancesPendingDestroy.entries()) this._FlushInstancesPendingDestroyForObjectClass(e, t), t.clear();\n      this._instancesPendingDestroy.clear(), this._dispatcher.SetDelayRemoveEventsEnabled(false);\n    }\n    _FlushInstancesPendingDestroyForObjectClass(e, t) {\n      for (const s of t) {\n        const i = this._eventObjects[\"instancedestroy\"], n = (i.instance = s, this._dispatcher.dispatchEvent(i), this._instancesByUid.delete(s.GetUID()), this._instanceTimes.delete(s), s.GetWorldInfo());\n        n && (n._RemoveFromCollisionCells(), n._RemoveFromRenderCells(), n._MarkDestroyed()), this._instancesPendingRelease.add(s), this._objectCount--;\n      }\n      C32.arrayRemoveAllInSet(e.GetInstances(), t), e._SetIIDsStale(), this._instancesPendingReleaseAffectedObjectClasses.add(e);\n      for (const a of e.GetFamilies()) C32.arrayRemoveAllInSet(a.GetInstances(), t), a._SetIIDsStale(), this._instancesPendingReleaseAffectedObjectClasses.add(a);\n      if (e.GetPlugin().IsWorldType()) {\n        const r = new Set([...t].map((e2) => e2.GetWorldInfo().GetLayer()));\n        for (const o of r) o._RemoveAllInstancesInSet(t);\n      }\n    }\n    _GetInstancesPendingCreate() {\n      return this._instancesPendingCreate;\n    }\n    *instancesPendingCreateForObjectClass(e) {\n      for (const t of this._GetInstancesPendingCreate()) e.IsFamily() ? t.GetObjectClass().BelongsToFamily(e) && (yield t) : t.GetObjectClass() === e && (yield t);\n    }\n    _GetNewUID() {\n      return this._nextUid++;\n    }\n    _MapInstanceByUID(e, t) {\n      this._instancesByUid.set(e, t);\n    }\n    _SetAutoSuspendEnabled(e) {\n      this._isAutoSuspendEnabled !== (e = !!e) && (this._isAutoSuspendEnabled = !!e, this._isAutoSuspendEnabled) && this._isPageVisibilitySuspended && (this.SetSuspended(false), this._isPageVisibilitySuspended = false);\n    }\n    _IsAutoSuspendEnabled() {\n      return this._isAutoSuspendEnabled;\n    }\n    _OnRendererContextLost() {\n      this._dispatcher.dispatchEvent(C32.New(C32.Event, \"renderercontextlost\")), this.SetSuspended(true);\n      for (const t of this._allObjectClasses) !t.IsFamily() && t.HasLoadedTextures() && t.ReleaseTextures();\n      const e = this.GetMainRunningLayout();\n      e && e._OnRendererContextLost(), C32.ImageInfo.OnRendererContextLost(), C32.ImageAsset.OnRendererContextLost();\n    }\n    async _OnRendererContextRestored() {\n      await this.GetMainRunningLayout()._Load(null, this.GetRenderer()), this._dispatcher.dispatchEvent(C32.New(C32.Event, \"renderercontextrestored\")), this.SetSuspended(false), this.UpdateRender();\n    }\n    _OnVisibilityChange(e) {\n      if (this._isAutoSuspendEnabled) {\n        const t = e[\"hidden\"];\n        this.SetSuspended(t), (this._isPageVisibilitySuspended = t) || this.UpdateRender();\n      }\n    }\n    _OnWindowBlur(e) {\n      !this.IsPreview() || !this._pauseOnBlur || C32.Platform.IsMobile || e.data[\"parentHasFocus\"] || (this.SetSuspended(true), this._isPausedOnBlur = true);\n    }\n    _OnWindowFocus() {\n      this._isPausedOnBlur && (this.SetSuspended(false), this._isPausedOnBlur = false);\n    }\n    _RequestAnimationFrame() {\n      const e = this._tickCallbacks;\n      \"vsync\" === this._framerateMode ? -1 === this._rafId && (this._rafId = self.requestAnimationFrame(e.normal)) : \"unlimited-tick\" === this._framerateMode ? (-1 === this._ruafId && (this._ruafId = C32.RequestUnlimitedAnimationFrame(e.tickOnly)), -1 === this._rafId && (this._rafId = self.requestAnimationFrame(e.renderOnly))) : -1 === this._ruafId && (this._ruafId = C32.RequestUnlimitedAnimationFrame(e.normal));\n    }\n    _CancelAnimationFrame() {\n      -1 !== this._rafId && (self.cancelAnimationFrame(this._rafId), this._rafId = -1), -1 !== this._ruafId && (C32.CancelUnlimitedAnimationFrame(this._ruafId), this._ruafId = -1);\n    }\n    IsSuspended() {\n      return 0 < this._suspendCount;\n    }\n    SetSuspended(e) {\n      if (!this.IsExportToVideo()) {\n        const t = this.IsSuspended(), s = (this._suspendCount += e ? 1 : -1, this._suspendCount < 0 && (this._suspendCount = 0), this.IsSuspended());\n        if (!t && s) console.log(\"[Construct] Suspending\"), this._CancelAnimationFrame(), this._dispatcher.dispatchEvent(C32.New(C32.Event, \"suspend\")), this.Trigger(C32.Plugins.System.Cnds.OnSuspend, null, null);\n        else if (t && !s) {\n          console.log(\"[Construct] Resuming\");\n          const i = performance.now();\n          this._lastTickTime = i, this._fpsLastTime = i, this._fpsFrameCount = 0, this._fps = 0, this._tpsTickCount = 0, this._tps = 0, this._mainThreadTime = 0, this._mainThreadTimeCounter = 0, this._dispatcher.dispatchEvent(C32.New(C32.Event, \"resume\")), this.Trigger(C32.Plugins.System.Cnds.OnResume, null, null), this.HitBreakpoint() || this.Tick(i);\n        }\n      }\n    }\n    _AddBehInstToTick(e) {\n      this._behInstsToTick.Add(e);\n    }\n    _AddBehInstToPostTick(e) {\n      this._behInstsToPostTick.Add(e);\n    }\n    _AddBehInstToTick2(e) {\n      this._behInstsToTick2.Add(e);\n    }\n    _RemoveBehInstToTick(e) {\n      this._behInstsToTick.Remove(e);\n    }\n    _RemoveBehInstToPostTick(e) {\n      this._behInstsToPostTick.Remove(e);\n    }\n    _RemoveBehInstToTick2(e) {\n      this._behInstsToTick2.Remove(e);\n    }\n    _CallBehaviorTickMethod(e, t) {\n      const s = t ? performance.now() : 0;\n      let i;\n      return e instanceof ISDKBehaviorInstanceBase ? (i = e._tick(), t && C3Debugger.AddIndividualBehaviorTickTime(e.behavior, performance.now() - s)) : (i = e.Tick(), t && C3Debugger.AddIndividualBehaviorTickTime(e.GetBehavior(), performance.now() - s)), i;\n    }\n    _BehaviorTick() {\n      const e = this.IsDebug();\n      this._behInstsToTick.SetQueueingEnabled(true);\n      for (const t of this._behInstsToTick) this._CallBehaviorTickMethod(t, e);\n      this._behInstsToTick.SetQueueingEnabled(false);\n    }\n    _CallBehaviorPostTickMethod(e, t) {\n      const s = t ? performance.now() : 0;\n      let i;\n      return e instanceof ISDKBehaviorInstanceBase ? (i = e._postTick(), t && C3Debugger.AddIndividualBehaviorTickTime(e.behavior, performance.now() - s)) : (i = e.PostTick(), t && C3Debugger.AddIndividualBehaviorTickTime(e.GetBehavior(), performance.now() - s)), i;\n    }\n    _BehaviorPostTick() {\n      const e = this.IsDebug();\n      this._behInstsToPostTick.SetQueueingEnabled(true);\n      for (const t of this._behInstsToPostTick) this._CallBehaviorPostTickMethod(t, e);\n      this._behInstsToPostTick.SetQueueingEnabled(false);\n    }\n    _CallBehaviorTick2Method(e, t) {\n      const s = t ? performance.now() : 0;\n      let i;\n      return e instanceof ISDKBehaviorInstanceBase ? (i = e._tick2(), t && C3Debugger.AddIndividualBehaviorTickTime(e.behavior, performance.now() - s)) : (i = e.Tick2(), t && C3Debugger.AddIndividualBehaviorTickTime(e.GetBehavior(), performance.now() - s)), i;\n    }\n    _BehaviorTick2() {\n      const e = this.IsDebug();\n      this._behInstsToTick2.SetQueueingEnabled(true);\n      for (const t of this._behInstsToTick2) this._CallBehaviorTick2Method(t, e);\n      this._behInstsToTick2.SetQueueingEnabled(false);\n    }\n    *_DebugBehaviorTick() {\n      const e = this.IsDebug();\n      this._behInstsToTick.SetQueueingEnabled(true);\n      for (const t of this._behInstsToTick) {\n        const s = this._CallBehaviorTickMethod(t, e);\n        C32.IsIterator(s) && (yield* s);\n      }\n      this._behInstsToTick.SetQueueingEnabled(false);\n    }\n    *_DebugBehaviorPostTick() {\n      const e = this.IsDebug();\n      this._behInstsToPostTick.SetQueueingEnabled(true);\n      for (const t of this._behInstsToPostTick) {\n        const s = this._CallBehaviorPostTickMethod(t, e);\n        C32.IsIterator(s) && (yield* s);\n      }\n      this._behInstsToPostTick.SetQueueingEnabled(false);\n    }\n    *_DebugBehaviorTick2() {\n      const e = this.IsDebug();\n      this._behInstsToTick2.SetQueueingEnabled(true);\n      for (const t of this._behInstsToTick2) {\n        const s = this._CallBehaviorTick2Method(t, e);\n        C32.IsIterator(s) && (yield* s);\n      }\n      this._behInstsToTick2.SetQueueingEnabled(false);\n    }\n    async Tick(t, e, s) {\n      this._hasStartedTicking = true;\n      const i = \"background-wake\" === s, n = \"background-wake\" !== s && \"skip-render\" !== s, a = this.GetLayoutManager(), r = this.GetCanvasManager();\n      if (this._hasStarted && (!this.IsSuspended() || e || i)) {\n        const o = performance.now(), h = (this._isInTick = true, this._MeasureDt(t || 0), this._tpsTickCount++, this._ReleasePendingInstances(), this.Step_BeforePreTick()), l = (this.IsDebugging() && await h, this._dispatcher.dispatchEventAndWait_AsyncOptional(this._eventObjects[\"pretick\"])), c = (l instanceof Promise && await l, this.DispatchUserScriptEvent(this._userScriptEventObjects[\"pretick\"]), this.Step_AfterPreTick()), d = (this.IsDebugging() && await c, this._NeedsHandleSaveOrLoad() && await this._HandleSaveOrLoad(), a.IsPendingChangeMainLayout() && await this._MaybeChangeLayout(), this.Step_RunEventsEtc()), _ = (this.IsDebugging() && await d, a.GetMainRunningLayout()), g = _._GetPendingSetHTMLLayerCount();\n        let e2 = false;\n        if (-1 !== g && (_._ResetPendingHTMLLayerCount(), r.GetHTMLLayerCount() !== g)) {\n          const u = this.GetCanvasManager().SetHTMLLayerCount(g);\n          this.IsInWorker() && (e2 = true, await u);\n        }\n        this.PostComponentMessageToDOM(\"canvas\", \"update-html-layer-dom-state\", { \"layersDomState\": _._GetRootLayers().filter((e3) => e3.IsHTMLElementsLayer()).map((e3) => e3._GetHTMLLayerDOMState()) }), n && this.Render(), e2 && this.PostComponentMessageToDOM(\"canvas\", \"cleanup-html-layers\"), this.IsExportToVideo() && (await this._ExportToVideoAddFrame(), this.GetGameTime() >= this.GetExportVideoDuration()) ? this._ExportToVideoFinish() : (this.IsSuspended() || i || this._RequestAnimationFrame(), this._tickCount++, this._tickCountNoSave++, this._isInTick = false, this._mainThreadTimeCounter += performance.now() - o);\n      }\n    }\n    async Step_BeforePreTick() {\n      const e = this._eventSheetManager, t = this.IsDebug();\n      this.FlushPendingInstances(), e.BlockFlushingInstances(true), this.PushCurrentLayout(this.GetMainRunningLayout()), t && C3Debugger.StartMeasuringTime(), this.IsDebugging() ? await e.DebugRunScheduledWaits() : e.RunScheduledWaits(), t && C3Debugger.AddEventsTime(), this.PopCurrentLayout(), e.BlockFlushingInstances(false), this.FlushPendingInstances(), e.BlockFlushingInstances(true);\n    }\n    async Step_AfterPreTick() {\n      const e = this._eventSheetManager, t = this.IsDebug(), s = this.IsDebugging(), i = this._dispatcher, n = this._eventObjects, a = this._userScriptEventObjects;\n      t && C3Debugger.StartMeasuringTime(), s ? await this.DebugIterateAndBreak(this._DebugBehaviorTick()) : this._BehaviorTick(), s ? await this.DebugIterateAndBreak(this._DebugBehaviorPostTick()) : this._BehaviorPostTick(), t && C3Debugger.AddBehaviorTotalTickTime(), t && C3Debugger.StartMeasuringTime(), s ? await this.DebugFireGeneratorEventAndBreak(n[\"tick\"]) : i.dispatchEvent(n[\"tick\"]), t && C3Debugger.AddPluginTotalTickTime(), e.BlockFlushingInstances(false), this.DispatchUserScriptEvent(a[\"tick\"]);\n    }\n    async Step_RunEventsEtc() {\n      const e = this._eventSheetManager, t = this._dispatcher, s = this._eventObjects, i = this._userScriptEventObjects, n = this.IsDebug(), a = this.IsDebugging();\n      n && C3Debugger.StartMeasuringTime(), a ? await e.DebugRunEvents(this._layoutManager) : e.RunEvents(this._layoutManager), n && C3Debugger.AddEventsTime(), this._collisionEngine.ClearRegisteredCollisions(), this._ReleasePendingInstances(), this._isLayoutFirstTick = false, e.BlockFlushingInstances(true), n && C3Debugger.StartMeasuringTime(), a ? await this.DebugIterateAndBreak(this._DebugBehaviorTick2()) : this._BehaviorTick2(), n && C3Debugger.AddBehaviorTotalTickTime(), n && C3Debugger.StartMeasuringTime(), a ? await this.DebugFireGeneratorEventAndBreak(s[\"tick2\"]) : t.dispatchEvent(s[\"tick2\"]), n && C3Debugger.AddPluginTotalTickTime(), e.BlockFlushingInstances(false), this.DispatchUserScriptEvent(i[\"tick2\"]), a && await e.RunQueuedDebugTriggersAsync();\n    }\n    _ReleasePendingInstances() {\n      if (0 !== this._instancesPendingRelease.size) {\n        const e = this._dispatcher;\n        e.SetDelayRemoveEventsEnabled(true);\n        for (const t of this._instancesPendingReleaseAffectedObjectClasses) t.GetSolStack().RemoveInstances(this._instancesPendingRelease);\n        this._instancesPendingReleaseAffectedObjectClasses.clear(), this._eventSheetManager._OnInstancesReleased(this._instancesPendingRelease);\n        for (const s of this._instancesPendingRelease) s.Release();\n        this._instancesPendingRelease.clear(), e.SetDelayRemoveEventsEnabled(false);\n      }\n    }\n    async _MaybeChangeLayout() {\n      const e = this.GetLayoutManager();\n      let t = 0;\n      for (; e.IsPendingChangeMainLayout() && t++ < 10; ) await this._DoChangeLayout(e.GetPendingChangeMainLayout());\n    }\n    _MeasureDt(e) {\n      let t = 0;\n      if (this.IsExportToVideo()) t = 1 / this.GetExportVideoFramerate(), this._dtRaw = t, this._dt1 = t;\n      else if (0 !== this._lastTickTime) {\n        const s = Math.max(e - this._lastTickTime, 0);\n        0.5 < (t = s / 1e3) && (t = 0), this._dtRaw = t, this._dt1 = C32.clamp(t, this._minDt, this._maxDt);\n      }\n      this._lastTickTime = e, this._dt = this._dt1 * this._timeScale, this._gameTime.Add(this._dt), this._gameTimeRaw.Add(t * this._timeScale), this._wallTime.Add(this._dt1);\n      for (const [i, n] of this._instanceTimes) n.Add(this._dt1 * i.GetTimeScale());\n      this._canvasManager && this._canvasManager._UpdateTick(), 1e3 <= e - this._fpsLastTime && (this._fpsLastTime += 1e3, 1e3 <= e - this._fpsLastTime && (this._fpsLastTime = e), this._fps = this._fpsFrameCount, this._fpsFrameCount = 0, this._tps = this._tpsTickCount, this._tpsTickCount = 0, this._mainThreadTime = Math.min(this._mainThreadTimeCounter / 1e3, 1), this._mainThreadTimeCounter = 0, this._canvasManager && this._canvasManager._Update1sFrameRange(), this._collisionEngine._Update1sStats(), this.IsDebug()) && C3Debugger.Update1sPerfStats();\n    }\n    _SetTrackingInstanceTime(e, t) {\n      if (t) {\n        if (!this._instanceTimes.has(e)) {\n          const s = C32.New(C32.KahanSum);\n          s.Copy(this._gameTime), this._instanceTimes.set(e, s);\n        }\n      } else this._instanceTimes.delete(e);\n    }\n    _GetInstanceGameTime(e) {\n      const t = this._instanceTimes.get(e);\n      return t ? t.Get() : this.GetGameTime();\n    }\n    async _DoChangeLayout(e) {\n      const t = this._dispatcher, s = this.GetLayoutManager(), i = s.GetMainRunningLayout();\n      await i._StopRunning(), i._Unload(e, this.GetRenderer()), i === e && this._eventSheetManager.ClearAllScheduledWaits(), this._collisionEngine.ClearRegisteredCollisions(), this._ReleasePendingInstances(), t.dispatchEvent(this._eventObjects[\"beforelayoutchange\"]), C32.Asyncify.SetHighThroughputMode(true), await e._Load(i, this.GetRenderer()), C32.Asyncify.SetHighThroughputMode(false), await e._StartRunning(false), t.dispatchEvent(this._eventObjects[\"layoutchange\"]), this.UpdateRender(), this._isLayoutFirstTick = true, this.FlushPendingInstances(), this._ExportToVideoAddKeyframe();\n    }\n    UpdateRender() {\n      this._needRender = true;\n    }\n    GetWebGLRenderer() {\n      return this._canvasManager ? this._canvasManager.GetWebGLRenderer() : null;\n    }\n    GetWebGPURenderer() {\n      return this._canvasManager ? this._canvasManager.GetWebGPURenderer() : null;\n    }\n    GetRenderer() {\n      return this._canvasManager ? this._canvasManager.GetRenderer() : null;\n    }\n    Render() {\n      const s = this._canvasManager;\n      if (s && !s.IsRendererContextLost()) {\n        const i = this.GetRenderer(), e = i.SupportsGPUProfiling(), n = e && i.IsWebGL(), a = e && i.IsWebGPU();\n        if (n && i.CheckForQueryResults(), this._needRender || this.IsExportToVideo()) {\n          const r = this._layoutManager.GetMainRunningLayout(), o = (this._fpsFrameCount++, i.Start(), this.IsDebug());\n          o && C3Debugger.StartMeasuringTime(), this._needRender = false;\n          let e2 = null, t = (n && (e2 = s.GetGPUFrameTimingsBuffer().AddTimeElapsedQuery(), i.StartQuery(e2)), null);\n          a && (t = i.StartFrameTiming(2 * (1 + r.GetLayerCount())), i.StartMeasuringRenderPassTime(0, 1)), this.Uses3DFeatures() && \"low\" === s.GetCurrentFullscreenScalingQuality() ? i.SetFixedSizeDepthBuffer(s.GetDrawWidth(), s.GetDrawHeight()) : i.SetAutoSizeDepthBuffer(), this._Render(this.GetRenderer(), r), e2 && i.EndQuery(e2), a && (i.StopMeasuringRenderPassTime(), this._canvasManager._AddWebGPUFrameTiming(t)), i.Finish(), o && (C3Debugger.AddDrawCallsTime(), C3Debugger.UpdateInspectHighlight()), s && s._MaybeTakeSnapshot();\n        } else i.IncrementFrameNumber();\n      }\n    }\n    _NeedsHTMLLayerCompositing(e) {\n      return \"low\" === this.GetCanvasManager().GetCurrentFullscreenScalingQuality() || e.IsWebGL() && (this.UsesAnyBackgroundBlending() || this.Uses3DFeatures());\n    }\n    _Render(t, s) {\n      t.SetTextureFillMode(), t.SetAlphaBlend(), t.SetColorRgba(1, 1, 1, 1), t.SetRenderTarget(null), t.SetTexture(null), t.SetDepthEnabled(this.Uses3DFeatures()), this._NeedsHTMLLayerCompositing(t) && s._MaybeStartDrawToOwnTexture(t);\n      const i = s.GetHTMLLayerCount();\n      for (let e = 1; e < i; ++e) s.DrawForHTMLLayerIndex(t, e), t.IsWebGPU() && t.Restart();\n      this._NeedsHTMLLayerCompositing(t) || s._MaybeStartDrawToOwnTexture(t), s.DrawMain(t);\n    }\n    Trigger(e, t, s) {\n      if (!this._hasStarted) return false;\n      const i = !this._isInTick && !this._eventSheetManager.IsInTrigger();\n      let n = 0;\n      i && (n = performance.now());\n      const a = this.IsDebug(), r = (a && this.SetDebuggingEnabled(false), this._eventSheetManager._Trigger(this._layoutManager, e, t, s));\n      if (i) {\n        const o = performance.now() - n;\n        this._mainThreadTimeCounter += o, a && C3Debugger.AddTriggersTime(o);\n      }\n      return a && this.SetDebuggingEnabled(true), r;\n    }\n    DebugTrigger(e, t, s) {\n      if (!this.IsDebugging()) return this.Trigger(e, t, s);\n      if (this.HitBreakpoint()) throw new Error(\"called DebugTrigger() while stopped on breakpoint\");\n      if (this._isInTick || this._eventSheetManager.IsInTrigger()) return this._eventSheetManager._DebugTrigger(this._layoutManager, e, t, s);\n      throw new Error(\"called DebugTrigger() outside of event code - use TriggerAsync() instead\");\n    }\n    async TriggerAsync(e, t, s) {\n      if (!this.IsDebugging()) return this.Trigger(e, t, s);\n      if (!this._hasStarted) return false;\n      if (this.HitBreakpoint()) return this._eventSheetManager.QueueDebugTrigger(e, t, s);\n      if (!this.GetMainRunningLayout()) return this._eventSheetManager.QueueTrigger(e, t, s);\n      const i = performance.now(), n = this._eventSheetManager._DebugTrigger(this._layoutManager, e, t, s);\n      let a = n.next();\n      for (; !a.done; ) await this.DebugBreak(a.value), a = n.next();\n      return this.IsSuspended() || this._eventSheetManager.IsInTrigger() || (await this._eventSheetManager.RunQueuedDebugTriggersAsync(), this._hasStartedTicking && !this._isInTick && this._RequestAnimationFrame()), this._mainThreadTimeCounter += performance.now() - i, a.value;\n    }\n    FastTrigger(e, t, s) {\n      const i = this.IsDebug(), n = (i && this.SetDebuggingEnabled(false), this._eventSheetManager._FastTrigger(this._layoutManager, e, t, s));\n      return i && this.SetDebuggingEnabled(true), n;\n    }\n    DebugFastTrigger(e, t, s) {\n      return this._eventSheetManager._DebugFastTrigger(this._layoutManager, e, t, s);\n    }\n    ScheduleTriggers(e) {\n      return this._scheduleTriggersThrottle.Add(e);\n    }\n    PushCurrentLayout(e) {\n      this._currentLayoutStack.push(e);\n    }\n    PopCurrentLayout() {\n      if (!this._currentLayoutStack.length) throw new Error(\"layout stack empty\");\n      this._currentLayoutStack.pop();\n    }\n    GetCurrentLayout() {\n      return this._currentLayoutStack.length ? this._currentLayoutStack.at(-1) : this.GetMainRunningLayout();\n    }\n    GetDt(e) {\n      return e && -1 !== e.GetTimeScale() ? this._dt1 * e.GetTimeScale() : this._dt;\n    }\n    _GetDtFast() {\n      return this._dt;\n    }\n    GetDt1() {\n      return this._dt1;\n    }\n    GetDtRaw() {\n      return this._dtRaw;\n    }\n    GetTimeScale() {\n      return this._timeScale;\n    }\n    SetTimeScale(e) {\n      (isNaN(e) || e < 0) && (e = 0), this._timeScale = e;\n    }\n    SetMinDt(e) {\n      this._minDt = Math.max(e, 0);\n    }\n    GetMinDt() {\n      return this._minDt;\n    }\n    SetMaxDt(e) {\n      this._maxDt = Math.max(e, 0);\n    }\n    GetMaxDt() {\n      return this._maxDt;\n    }\n    GetFramesPerSecond() {\n      return this._fps;\n    }\n    GetTicksPerSecond() {\n      return this._tps;\n    }\n    GetMainThreadTime() {\n      return this._mainThreadTime;\n    }\n    GetStartTime() {\n      return this._startTime;\n    }\n    GetGameTime() {\n      return this._gameTime.Get();\n    }\n    GetGameTimeRaw() {\n      return this._gameTimeRaw.Get();\n    }\n    GetWallTime() {\n      return this._wallTime.Get();\n    }\n    GetTickCount() {\n      return this._tickCount;\n    }\n    GetTickCountNoSave() {\n      return this._tickCountNoSave;\n    }\n    GetObjectCount() {\n      return this._objectCount;\n    }\n    GetProjectName() {\n      return this._projectName;\n    }\n    GetProjectVersion() {\n      return this._projectVersion;\n    }\n    GetProjectUniqueId() {\n      return this._projectUniqueId;\n    }\n    GetAppId() {\n      return this._appId;\n    }\n    GetExportTimestamp() {\n      return this._exportTimestamp;\n    }\n    GetInstanceByUID(e) {\n      if (this._isLoadingState) throw new Error(\"cannot call while loading state - wait until afterload event\");\n      return this._instancesByUid.get(e) || null;\n    }\n    _RefreshUidMap() {\n      this._instancesByUid.clear();\n      for (const e of this._allObjectClasses) if (!e.IsFamily()) for (const t of e.GetInstances()) this._instancesByUid.set(t.GetUID(), t);\n    }\n    IsPreview() {\n      return \"preview\" === this._exportType;\n    }\n    IsDebug() {\n      return this._isDebug;\n    }\n    GetExportType() {\n      return this._exportType;\n    }\n    IsNWjs() {\n      return \"nwjs\" === this.GetExportType() || this._isNWjs;\n    }\n    IsCordova() {\n      return \"cordova\" === this._exportType;\n    }\n    IsAndroidWebView() {\n      return \"Android\" === C32.Platform.OS && (\"cordova\" === this._exportType || \"playable-ad-single-file\" === this._exportType || \"playable-ad-zip\" === this._exportType || \"instant-games\" === this._exportType);\n    }\n    IsiOSCordova() {\n      return this._isiOSCordova;\n    }\n    IsiOSWebView() {\n      return this._isiOSWebView;\n    }\n    IsWindowsWebView2() {\n      return this._isWindowsWebView2;\n    }\n    IsAnyWebView2Wrapper() {\n      return this._isAnyWebView2Wrapper;\n    }\n    GetCollisionEngine() {\n      return this._collisionEngine;\n    }\n    GetSolidBehavior() {\n      return this._addonManager.GetSolidBehavior();\n    }\n    GetJumpthruBehavior() {\n      return this._addonManager.GetJumpthruBehavior();\n    }\n    Uses3DFeatures() {\n      return this._uses3dFeatures;\n    }\n    GetZScaleFactor() {\n      return this.GetRenderer().GetZAxisScaleFactor(this.GetViewportHeight());\n    }\n    GetDefaultCameraZ(e) {\n      return this.GetRenderer().GetDefaultCameraZ(e || this.GetViewportHeight());\n    }\n    IsLayoutFirstTick() {\n      return this._isLayoutFirstTick;\n    }\n    SetPixelRoundingEnabled(e) {\n      this._isPixelRoundingEnabled !== (e = !!e) && (this._isPixelRoundingEnabled = e, this.GetLayoutManager().SetAllLayerMVChanged(), this.UpdateRender());\n    }\n    IsPixelRoundingEnabled() {\n      return this._isPixelRoundingEnabled;\n    }\n    GetTextIconSet(e) {\n      if (!this._iconChangeHandlers.has(e)) {\n        const s = () => this.DeleteTextIconSet(e);\n        this._iconChangeHandlers.set(e, s), e.Dispatcher().addEventListener(\"animationframeimagechange\", s);\n      }\n      const t = this._textIconManager.GetIconSet(e);\n      return t.HasLoaded() || t.LoadContent().then(() => this.UpdateRender()), t;\n    }\n    DeleteTextIconSet(e) {\n      this._textIconManager.DeleteIconSet(e);\n    }\n    _GetTextIconSetMeta(e) {\n      const t = [];\n      for (const s of e.GetAnimations()) for (const i of s.GetFrames()) {\n        const n = i.GetImageInfo();\n        t.push({ source: i, width: n.GetWidth(), height: n.GetHeight(), tag: i.GetTag() });\n      }\n      return { icons: t };\n    }\n    async _GetTextIconSetContent(e) {\n      const t = C32.New(C32.PromiseThrottle), s = [], n = /* @__PURE__ */ new Map();\n      for (const r of e.GetAnimations()) for (const o of r.GetFrames()) {\n        const h = o.GetImageInfo().GetImageAsset();\n        n.has(h) || (n.set(h, null), s.push(t.Add(async () => {\n          const e2 = await h.LoadToDrawable();\n          n.set(h, e2);\n        })));\n      }\n      await Promise.all(s);\n      const i = [];\n      for (const l of e.GetAnimations()) for (const c of l.GetFrames()) i.push(t.Add(async () => {\n        const e2 = c.GetImageInfo(), t2 = n.get(e2.GetImageAsset()), s2 = await e2.ExtractImageToCanvas(t2), i2 = await createImageBitmap(s2);\n        return { drawable: i2 };\n      }));\n      const a = await Promise.all(i);\n      for (const d of n.values()) d instanceof ImageBitmap && d[\"close\"] && d[\"close\"]();\n      return { icons: a };\n    }\n    SaveToSlot(e) {\n      this._saveToSlotName = e, this._saveToJsonString = false;\n    }\n    SaveToJsonString() {\n      this._saveToSlotName = \"\", this._saveToJsonString = true;\n    }\n    LoadFromSlot(e) {\n      this._loadFromSlotName = e;\n    }\n    LoadFromJsonString(e) {\n      this._loadFromJson = e;\n    }\n    GetLastSaveJsonString() {\n      return this._lastSaveJson;\n    }\n    _NeedsHandleSaveOrLoad() {\n      return !!(this._saveToSlotName || this._saveToJsonString || this._loadFromSlotName || null !== this._loadFromJson);\n    }\n    async _HandleSaveOrLoad() {\n      if (this._saveToSlotName && (this.FlushPendingInstances(), await this._DoSaveToSlot(this._saveToSlotName), this._ClearSaveOrLoad()), this._loadFromSlotName && (await this._DoLoadFromSlot(this._loadFromSlotName), this._ClearSaveOrLoad(), this.IsDebug()) && C3Debugger.StepIfPausedInDebugger(), this._saveToJsonString) {\n        const e = await this._SaveToJsonString();\n        this._lastSaveJson = e, await this.TriggerAsync(C32.Plugins.System.Cnds.OnSaveComplete, null), this._lastSaveJson = \"\", this._ClearSaveOrLoad();\n      }\n      if (null !== this._loadFromJson) {\n        this.FlushPendingInstances();\n        try {\n          await this._DoLoadFromJsonString(this._loadFromJson), this._lastSaveJson = this._loadFromJson, await this.TriggerAsync(C32.Plugins.System.Cnds.OnLoadComplete, null), this._lastSaveJson = \"\";\n        } catch (e) {\n          console.error(\"[Construct] Failed to load state from JSON string: \", e), await this.TriggerAsync(C32.Plugins.System.Cnds.OnLoadFailed, null);\n        }\n        this._ClearSaveOrLoad();\n      }\n    }\n    _ClearSaveOrLoad() {\n      this._saveToSlotName = \"\", this._saveToJsonString = false, this._loadFromSlotName = \"\", this._loadFromJson = null;\n    }\n    _GetProjectStorage() {\n      return this._projectStorage || (this._projectStorage = localforage.createInstance({ name: \"c3-localstorage-\" + this.GetProjectUniqueId(), description: this.GetProjectName() })), this._projectStorage;\n    }\n    _GetSavegamesStorage() {\n      return this._savegamesStorage || (this._savegamesStorage = localforage.createInstance({ name: \"c3-savegames-\" + this.GetProjectUniqueId(), description: this.GetProjectName() })), this._savegamesStorage;\n    }\n    async _DoSaveToSlot(e) {\n      const t = await this._SaveToJsonString();\n      try {\n        await this._GetSavegamesStorage().setItem(e, t), console.log(\"[Construct] Saved state to storage (\" + t.length + \" chars)\"), this._lastSaveJson = t, await this.TriggerAsync(C32.Plugins.System.Cnds.OnSaveComplete, null), this._lastSaveJson = \"\";\n      } catch (e2) {\n        console.error(\"[Construct] Failed to save state to storage: \", e2), await this.TriggerAsync(C32.Plugins.System.Cnds.OnSaveFailed, null);\n      }\n    }\n    async _DoLoadFromSlot(e) {\n      try {\n        const t = await this._GetSavegamesStorage().getItem(e);\n        if (!t) throw new Error(\"empty slot\");\n        console.log(\"[Construct] Loaded state from storage (\" + t.length + \" chars)\"), await this._DoLoadFromJsonString(t), this._lastSaveJson = t, await this.TriggerAsync(C32.Plugins.System.Cnds.OnLoadComplete, null), this._lastSaveJson = \"\";\n      } catch (e2) {\n        console.error(\"[Construct] Failed to load state from storage: \", e2), await this.TriggerAsync(C32.Plugins.System.Cnds.OnLoadFailed, null);\n      }\n    }\n    async _SaveToJsonString() {\n      const e = { \"c3save\": true, \"version\": 1, \"rt\": { \"time\": this.GetGameTime(), \"timeRaw\": this.GetGameTimeRaw(), \"walltime\": this.GetWallTime(), \"timescale\": this.GetTimeScale(), \"tickcount\": this.GetTickCount(), \"next_uid\": this._nextUid, \"running_layout\": this.GetMainRunningLayout().GetSID(), \"start_time_offset\": Date.now() - this._startTime }, \"types\": {}, \"layouts\": {}, \"events\": this._eventSheetManager._SaveToJson(), \"timelines\": this._timelineManager._SaveToJson(), \"user_script_data\": null };\n      for (const s of this._allObjectClasses) s.IsFamily() || s.HasNoSaveBehavior() || (e[\"types\"][s.GetSID().toString()] = s._SaveToJson());\n      for (const i of this._layoutManager.GetAllLayouts()) e[\"layouts\"][i.GetSID().toString()] = i._SaveToJson();\n      const t = this._CreateUserScriptEvent(\"save\");\n      return t.saveData = null, await this.DispatchUserScriptEventAsyncWait(t), e[\"user_script_data\"] = t.saveData, JSON.stringify(e);\n    }\n    IsLoadingState() {\n      return this._isLoadingState;\n    }\n    async _DoLoadFromJsonString(e) {\n      const t = this.GetLayoutManager(), s = JSON.parse(e);\n      if (s[\"c2save\"]) throw new Error(\"C2 saves are incompatible with C3 runtime\");\n      if (!s[\"c3save\"]) throw new Error(\"not valid C3 save data\");\n      if (1 < s[\"version\"]) throw new Error(\"C3 save data from future version\");\n      this.ClearIntancesNeedingAfterLoad(), this._dispatcher.dispatchEvent(C32.New(C32.Event, \"beforeload\"));\n      for (const h of this.allInstances()) {\n        const l = h.GetObjectClass();\n        l.HasNoSaveBehavior() || h._OnBeforeLoad();\n      }\n      const i = s[\"rt\"], n = (this._gameTime.Set(i[\"time\"]), i.hasOwnProperty(\"timeRaw\") && this._gameTimeRaw.Set(i[\"timeRaw\"]), this._wallTime.Set(i[\"walltime\"]), this._timeScale = i[\"timescale\"], this._tickCount = i[\"tickcount\"], this._startTime = Date.now() - i[\"start_time_offset\"], i[\"running_layout\"]);\n      let a = !(this._isLoadingState = true);\n      if (n !== this.GetMainRunningLayout().GetSID()) {\n        const c = t.GetLayoutBySID(n);\n        if (!c) return;\n        await this._DoChangeLayout(c), a = true;\n      }\n      for (const [d, _] of Object.entries(s[\"layouts\"])) {\n        const g = parseInt(d, 10), u = t.GetLayoutBySID(g);\n        u && u._LoadFromJson(_);\n      }\n      const r = /* @__PURE__ */ new Set();\n      for (const [m, p] of Object.entries(s[\"types\"])) {\n        const f = parseInt(m, 10), C = this.GetObjectClassBySID(f);\n        !C || C.IsFamily() || C.HasNoSaveBehavior() || C._LoadFromJson(p, r);\n      }\n      for (const S of this._layoutManager.GetAllLayouts()) for (const I of S.allLayers()) I._LoadFromJsonAfterInstances();\n      if (this.FlushPendingInstances(), this._RefreshUidMap(), this._isLoadingState = false, a) {\n        for (const v of this.allInstances()) v.SetupInitialSceneGraphConnections();\n        for (const [T, b] of Object.entries(s[\"types\"])) {\n          const M = parseInt(T, 10), y = this.GetObjectClassBySID(M);\n          !y || y.IsFamily() || y.HasNoSaveBehavior() || y._SetupSceneGraphConnectionsOnChangeOfLayout(b);\n        }\n      }\n      this._nextUid = i[\"next_uid\"], this._eventSheetManager._LoadFromJson(s[\"events\"]);\n      for (const G of this._allObjectClasses) if (!G.IsFamily() && G.IsInContainer()) for (const w of G.GetInstances()) {\n        const D = w.GetIID();\n        for (const P of G.GetContainer().objectTypes()) if (P !== G) {\n          const R = P.GetInstances();\n          if (D < 0 || D >= R.length) throw new Error(\"missing sibling instance\");\n          w._AddSibling(R[D]);\n        }\n      }\n      this._timelineManager._LoadFromJson(s[\"timelines\"]), t.SetAllLayerProjectionChanged(), t.SetAllLayerMVChanged();\n      for (const L of r) L._OnCreatedForLoadingSavegame();\n      this.DoAfterLoad(), this._dispatcher.dispatchEvent(C32.New(C32.Event, \"afterload\")), this.DispatchUserScriptEvent(this._CreateUserScriptEvent(\"afterload\"));\n      for (const [E, k] of Object.entries(s[\"types\"])) {\n        const A = parseInt(E, 10), O = this.GetObjectClassBySID(A);\n        O && O._ClearLoadInstancesJson();\n      }\n      const o = this._CreateUserScriptEvent(\"load\");\n      o.saveData = s[\"user_script_data\"], await this.DispatchUserScriptEventAsyncWait(o), this.UpdateRender();\n    }\n    SortOnTmpHierarchyPosition(e, t) {\n      return e.GetWorldInfo().GetTmpHierarchyPosition() - t.GetWorldInfo().GetTmpHierarchyPosition();\n    }\n    AddInstanceNeedingAfterLoad(e, t) {\n      !e.GetWorldInfo() || this._instancesNeedingAfterLoadMap.has(e) || (this._instancesNeedingAfterLoadMap.set(e, t), this._instancesNeedingAfterLoadArray.push(e));\n    }\n    ClearIntancesNeedingAfterLoad() {\n      this._instancesNeedingAfterLoadMap = /* @__PURE__ */ new WeakMap(), C32.clearArray(this._instancesNeedingAfterLoadArray);\n    }\n    DoAfterLoad(e = \"full\", t = null) {\n      this._instancesNeedingAfterLoadArray.sort(this.SortOnTmpHierarchyPosition);\n      for (const s of this._instancesNeedingAfterLoadArray) s._OnAfterLoad(this._instancesNeedingAfterLoadMap.get(s), e, t);\n      for (const i of this._instancesNeedingAfterLoadArray) i._OnAfterLoad2(this._instancesNeedingAfterLoadMap.get(i), e, t);\n      this.ClearIntancesNeedingAfterLoad();\n    }\n    async AddJobWorkerScripts(e) {\n      const t = await Promise.all(e.map(async (e2) => {\n        const t2 = this.IsCordova() && this._assetManager.IsFileProtocol();\n        if (t2 || \"playable-ad-single-file\" === this.GetExportType()) {\n          const s = await this._assetManager.FetchBlob(e2);\n          return URL.createObjectURL(s);\n        }\n        return new URL(e2, location.href).toString();\n      }));\n      this._jobScheduler.ImportScriptsToJobWorkers(t);\n    }\n    AddJobWorkerBlob(e, t) {\n      this._jobScheduler.SendBlobToJobWorkers(e, t);\n    }\n    AddJobWorkerBuffer(e, t) {\n      this._jobScheduler.SendBufferToJobWorkers(e, t);\n    }\n    AddJob(e, t, s, i) {\n      return this._jobScheduler.AddJob(e, t, s, null, null, i);\n    }\n    BroadcastJob(e, t, s, i) {\n      return this._jobScheduler.BroadcastJob(e, t, s, i);\n    }\n    GetMaxNumJobWorkers() {\n      return this._jobScheduler.GetMaxNumWorkers();\n    }\n    InvokeDownload(e, t) {\n      this.PostComponentMessageToDOM(\"runtime\", \"invoke-download\", { \"url\": e, \"filename\": t });\n    }\n    async RasterSvgImage(e, t, s, i, n, a) {\n      if (i = i || t, n = n || s, this.IsInWorker()) {\n        const r = await this.PostComponentMessageToDOMAsync(\"runtime\", \"raster-svg-image\", { \"blob\": e, \"imageWidth\": t, \"imageHeight\": s, \"surfaceWidth\": i, \"surfaceHeight\": n, \"imageBitmapOpts\": a });\n        return r[\"imageBitmap\"];\n      }\n      {\n        const o = await self[\"C3_RasterSvgImageBlob\"](e, t, s, i, n);\n        return a ? self.createImageBitmap(o, a) : o;\n      }\n    }\n    async GetSvgImageSize(e) {\n      return this.IsInWorker() ? this.PostComponentMessageToDOMAsync(\"runtime\", \"get-svg-image-size\", { \"blob\": e }) : self[\"C3_GetSvgImageSize\"](e);\n    }\n    RequestDeviceOrientationEvent() {\n      this._didRequestDeviceOrientationEvent || (this._didRequestDeviceOrientationEvent = true, this.PostComponentMessageToDOM(\"runtime\", \"enable-device-orientation\"));\n    }\n    RequestDeviceMotionEvent() {\n      this._didRequestDeviceMotionEvent || (this._didRequestDeviceMotionEvent = true, this.PostComponentMessageToDOM(\"runtime\", \"enable-device-motion\"));\n    }\n    Random() {\n      return this._randomNumberCallback();\n    }\n    SetRandomNumberGeneratorCallback(e) {\n      this._randomNumberCallback = e;\n    }\n    _GetRemotePreviewStatusInfo() {\n      const e = this.GetRenderer();\n      return { \"fps\": this.GetFramesPerSecond(), \"tps\": this.GetTicksPerSecond(), \"cpu\": this.GetMainThreadTime(), \"gpu\": this.GetGPUUtilisation(), \"layout\": this.GetMainRunningLayout() ? this.GetMainRunningLayout().GetName() : \"\", \"renderer\": e.IsWebGL() ? e.GetUnmaskedRenderer() : e.GetAdapterInfoString() };\n    }\n    HitBreakpoint() {\n      return !!this.IsDebug() && C3Debugger.HitBreakpoint();\n    }\n    DebugBreak(e) {\n      return this.IsDebugging() ? C3Debugger.DebugBreak(e) : Promise.resolve();\n    }\n    DebugBreakNext() {\n      return !!this.IsDebugging() && C3Debugger.BreakNext();\n    }\n    SetDebugBreakpointsEnabled(e) {\n      this._breakpointsEnabled = !!e, this._UpdateDebuggingFlag();\n    }\n    AreDebugBreakpointsEnabled() {\n      return this._breakpointsEnabled;\n    }\n    IsDebugging() {\n      return this._isDebugging;\n    }\n    SetDebuggingEnabled(e) {\n      e ? this._debuggingDisabled-- : this._debuggingDisabled++, this._UpdateDebuggingFlag();\n    }\n    _UpdateDebuggingFlag() {\n      this._isDebugging = this.IsDebug() && this._breakpointsEnabled && 0 === this._debuggingDisabled;\n    }\n    IsCPUProfiling() {\n      return this.IsDebug() && C3Debugger.IsCPUProfiling();\n    }\n    IsGPUProfiling() {\n      return this.IsDebug() && this.GetRenderer().SupportsGPUProfiling() && C3Debugger.IsGPUProfiling();\n    }\n    async DebugIterateAndBreak(e) {\n      if (e) for (const t of e) await this.DebugBreak(t);\n    }\n    DebugFireGeneratorEventAndBreak(e) {\n      return this.DebugIterateAndBreak(this._dispatcher.dispatchGeneratorEvent(e));\n    }\n    _InvokeFunctionFromJS(e) {\n      return this._eventSheetManager._InvokeFunctionFromJS(e[\"name\"], e[\"params\"]);\n    }\n    _GetHTMLLayerWrapElement(e) {\n      if (this.IsInWorker()) throw new Error(\"not supported in worker mode\");\n      return self[\"c3_runtimeInterface\"][\"_GetHTMLWrapElement\"](e);\n    }\n    GetIRuntime() {\n      return this._iRuntime;\n    }\n    _CreateUserScriptEvent(e) {\n      const t = C32.New(C32.Event, e, false);\n      return t.runtime = this._iRuntime, t;\n    }\n    _InitScriptInterfaces() {\n      this._iRuntime = new self.IRuntime(this), this._userScriptEventObjects = { \"pretick\": this._CreateUserScriptEvent(\"pretick\"), \"tick\": this._CreateUserScriptEvent(\"tick\"), \"tick2\": this._CreateUserScriptEvent(\"tick2\") };\n    }\n    _InitObjectsScriptInterface() {\n      const e = {};\n      for (const t of this._allObjectClasses) e[t.GetJsPropName()] = { value: t.GetIObjectClass(), enumerable: true, writable: false };\n      this._iRuntime._InitObjects(e);\n    }\n    _InitGlobalVariableScriptInterface() {\n      const e = {};\n      for (const t of this.GetEventSheetManager().GetAllGlobalVariables()) e[t.GetJsPropName()] = t._GetScriptInterfaceDescriptor();\n      this._iRuntime._InitGlobalVars(e);\n    }\n    _GetCommonScriptInterfaces() {\n      return this._commonScriptInterfaces;\n    }\n    _MapScriptInterface(e, t) {\n      this._interfaceMap.set(e, t);\n    }\n    _UnwrapScriptInterface(e) {\n      return this._interfaceMap.get(e);\n    }\n    _UnwrapIObjectClass(e) {\n      if (!(e instanceof self.IObjectClass)) throw new TypeError(\"expected IObjectClass\");\n      const t = this._UnwrapScriptInterface(e);\n      if (t && t instanceof C32.ObjectClass) return t;\n      throw new Error(\"invalid IObjectClass\");\n    }\n    _UnwrapIInstance(e) {\n      if (!(e instanceof self.IInstance)) throw new TypeError(\"expected IInstance\");\n      const t = this._UnwrapScriptInterface(e);\n      if (t && t instanceof C32.Instance) return t;\n      throw new Error(\"invalid IInstance\");\n    }\n    _UnwrapIWorldInstance(e) {\n      if (!(e instanceof self.IWorldInstance)) throw new TypeError(\"expected IWorldInstance\");\n      const t = this._UnwrapScriptInterface(e);\n      if (t && t instanceof C32.Instance) return t;\n      throw new Error(\"invalid IInstance\");\n    }\n  }, self[\"C3_CreateRuntime\"] = C32.Runtime.Create, self[\"C3_InitRuntime\"] = (e, t) => e.Init(t);\n}\n{\n  const C32 = self.C3;\n  C32.JobSchedulerRuntime = class extends C32.DefendedBase {\n    constructor(r, e) {\n      super(), this._runtime = r, this._jobPromises = /* @__PURE__ */ new Map(), this._nextJobId = 0, this._inputPort = e[\"inputPort\"], e[\"outputPort\"].onmessage = (r2) => this._OnJobWorkerMessage(r2), this._maxNumWorkers = e[\"maxNumWorkers\"], this._jobWorkerCount = 1, this._isCreatingWorker = false, this._hadErrorCreatingWorker = false;\n    }\n    GetMaxNumWorkers() {\n      return this._maxNumWorkers;\n    }\n    ImportScriptsToJobWorkers(r) {\n      this._inputPort.postMessage({ \"type\": \"_import_scripts\", \"scripts\": r });\n    }\n    SendBlobToJobWorkers(r, e) {\n      this._inputPort.postMessage({ \"type\": \"_send_blob\", \"blob\": r, \"id\": e });\n    }\n    SendBufferToJobWorkers(r, e) {\n      this._inputPort.postMessage({ \"type\": \"_send_buffer\", \"buffer\": r, \"id\": e }, [r]);\n    }\n    AddJob(r, e, o, s, t, i) {\n      if (o = o || [], \"number\" == typeof i && (i = Math.floor(i)) <= 0) throw new Error(\"invalid maxWorkerNum\");\n      const n = this._nextJobId++, a = { \"type\": r, \"isBroadcast\": false, \"maxWorkerNum\": i, \"jobId\": n, \"params\": e, \"transferables\": o }, _ = new Promise((r2, e2) => {\n        this._jobPromises.set(n, { resolve: r2, progress: s, reject: e2, cancelled: false, maxWorkerNum: i });\n      });\n      return t && t.SetAction(() => this._CancelJob(n)), this._inputPort.postMessage(a, o), this._MaybeCreateExtraWorker(), _;\n    }\n    BroadcastJob(r, e, o, s) {\n      if (o = o || [], \"number\" == typeof s && (s = Math.floor(s)) <= 0) throw new Error(\"invalid maxWorkerNum\");\n      const t = this._nextJobId++, i = { \"type\": r, \"isBroadcast\": true, \"maxWorkerNum\": s, \"jobId\": t, \"params\": e, \"transferables\": o };\n      this._inputPort.postMessage(i, o);\n    }\n    _CancelJob(r) {\n      const e = this._jobPromises.get(r);\n      e && (e.cancelled = true, e.resolve = null, e.progress = null, e.reject = null, this._inputPort.postMessage({ \"type\": \"_cancel\", \"jobId\": r }));\n    }\n    _OnJobWorkerMessage(r) {\n      const e = r.data, o = e[\"type\"], s = e[\"jobId\"];\n      switch (o) {\n        case \"result\":\n          this._OnJobResult(s, e[\"result\"]);\n          break;\n        case \"progress\":\n          this._OnJobProgress(s, e[\"progress\"]);\n          break;\n        case \"error\":\n          this._OnJobError(s, e[\"error\"]);\n          break;\n        case \"ready\":\n          this._OnJobWorkerReady();\n          break;\n        default:\n          throw new Error(`unknown message from worker '${o}'`);\n      }\n    }\n    _OnJobResult(r, e) {\n      const o = this._jobPromises.get(r);\n      if (!o) throw new Error(\"invalid job ID\");\n      o.cancelled || o.resolve(e), this._jobPromises.delete(r);\n    }\n    _OnJobProgress(r, e) {\n      const o = this._jobPromises.get(r);\n      if (!o) throw new Error(\"invalid job ID\");\n      !o.cancelled && o.progress && o.progress(e);\n    }\n    _OnJobError(r, e) {\n      const o = this._jobPromises.get(r);\n      if (!o) throw new Error(\"invalid job ID\");\n      o.cancelled || o.reject(e), this._jobPromises.delete(r);\n    }\n    _OnJobWorkerReady() {\n      this._isCreatingWorker && (this._isCreatingWorker = false, this._jobWorkerCount++, this._jobWorkerCount < this._maxNumWorkers ? this._MaybeCreateExtraWorker() : this._inputPort.postMessage({ \"type\": \"_no_more_workers\" }));\n    }\n    _GetWorkerCountNeededForPendingJobs() {\n      let r = 0;\n      const e = [...this._jobPromises.values()].sort((r2, e2) => {\n        const o = r2.maxWorkerNum || 1 / 0, s = e2.maxWorkerNum || 1 / 0;\n        return o - s;\n      });\n      for (const o of e) {\n        const s = o.maxWorkerNum || 1 / 0;\n        r < s && r++;\n      }\n      return r;\n    }\n    async _MaybeCreateExtraWorker() {\n      if (!(this._jobWorkerCount >= this._maxNumWorkers || this._isCreatingWorker || this._hadErrorCreatingWorker || this._GetWorkerCountNeededForPendingJobs() <= this._jobWorkerCount)) try {\n        this._isCreatingWorker = true;\n        const r = await this._runtime.PostComponentMessageToDOMAsync(\"runtime\", \"create-job-worker\");\n        r[\"outputPort\"].onmessage = (r2) => this._OnJobWorkerMessage(r2);\n      } catch (r) {\n        this._hadErrorCreatingWorker = true, this._isCreatingWorker = false, console.error(`[Construct] Failed to create job worker; stopping creating any more (created ${this._jobWorkerCount} so far)`, r);\n      }\n    }\n  };\n}\n{\n  self[\"C3_Shaders\"] = {};\n}\n{\n  {\n    let ForEachOrdered_SortInstances = function(e, t) {\n      const r2 = e[1], n2 = t[1];\n      if (\"number\" == typeof r2 && \"number\" == typeof n2) return r2 - n2;\n      {\n        const a2 = \"\" + r2, i2 = \"\" + n2;\n        return a2 < i2 ? -1 : i2 < a2 ? 1 : 0;\n      }\n    };\n    ForEachOrdered_SortInstances2 = ForEachOrdered_SortInstances;\n    const a = self.C3;\n    let r = null, n = \"\", s = \"\", o = [], u = \"\", l = \"\", c = \"\";\n    const i = a.New(a.ArrayStack);\n    a.Plugins.System = class extends a.SDKPluginBase {\n      constructor(e) {\n        super(e), this._loopStack = this._runtime.GetEventSheetManager().GetLoopStack(), this._eventStack = this._runtime.GetEventSheetManager().GetEventStack(), this._imagesLoadingTotal = 0, this._imagesLoadingComplete = 0, this._functionMaps = /* @__PURE__ */ new Map();\n      }\n      Release() {\n        super.Release();\n      }\n      UpdateRender() {\n        this._runtime.UpdateRender();\n      }\n      Trigger(e) {\n        this._runtime.Trigger(e, null, null);\n      }\n      GetRegex(e, t) {\n        return r && e === n && t === s || (r = new RegExp(e, t), n = e, s = t), r.lastIndex = 0, r;\n      }\n      GetRegexMatches(e, t, r2) {\n        if (e !== u || t !== l || r2 !== c) {\n          const n2 = this.GetRegex(t, r2);\n          o = e.match(n2), u = e, l = t, c = r2;\n        }\n        return o;\n      }\n      async _LoadTexturesForObjectClasses(e, t) {\n        if (t.length) {\n          this._imagesLoadingTotal += t.length;\n          const r2 = [];\n          for (const n2 of t) r2.push(e.MaybeLoadTexturesFor(n2));\n          await a.PromiseAllWithProgress(r2, () => {\n            this._imagesLoadingComplete++;\n          }), this._imagesLoadingComplete++, this._imagesLoadingComplete === this._imagesLoadingTotal && (this._imagesLoadingComplete = 0, this._imagesLoadingTotal = 0, this._runtime.Trigger(a.Plugins.System.Cnds.OnImageLoadingComplete, null, null));\n        }\n      }\n      GetImageLoadingProgress() {\n        return 0 === this._imagesLoadingTotal ? 1 : this._imagesLoadingComplete / this._imagesLoadingTotal;\n      }\n      _UnloadTexturesForObjectClasses(e, t) {\n        for (const r2 of t) 0 === r2.GetInstanceCount() && e.MaybeUnloadTexturesFor(r2);\n      }\n      _GetForEachStack() {\n        return i;\n      }\n      _Repeat(t) {\n        const r2 = this._runtime.GetEventSheetManager(), e = r2.GetEventStack(), n2 = e.GetCurrentStackFrame(), a2 = n2.GetCurrentEvent(), i2 = a2.GetSolModifiers(), s2 = n2.IsSolModifierAfterCnds(), o2 = e.Push(a2), u2 = r2.GetLoopStack(), l2 = u2.Push();\n        if (l2.SetEnd(t), s2) for (let e2 = 0; e2 < t && !l2.IsStopped(); ++e2) r2.PushCopySol(i2), l2.SetIndex(e2), a2.Retrigger(n2, o2), r2.PopSol(i2);\n        else for (let e2 = 0; e2 < t && !l2.IsStopped(); ++e2) l2.SetIndex(e2), a2.Retrigger(n2, o2);\n        return e.Pop(), u2.Pop(), false;\n      }\n      *_DebugRepeat(t) {\n        const r2 = this._runtime.GetEventSheetManager(), e = r2.GetEventStack(), n2 = e.GetCurrentStackFrame(), a2 = n2.GetCurrentEvent(), i2 = a2.GetSolModifiers(), s2 = n2.IsSolModifierAfterCnds(), o2 = e.Push(a2), u2 = r2.GetLoopStack(), l2 = u2.Push();\n        if (l2.SetEnd(t), s2) for (let e2 = 0; e2 < t && !l2.IsStopped(); ++e2) r2.PushCopySol(i2), l2.SetIndex(e2), yield* a2.DebugRetrigger(n2, o2), r2.PopSol(i2);\n        else for (let e2 = 0; e2 < t && !l2.IsStopped(); ++e2) l2.SetIndex(e2), yield* a2.DebugRetrigger(n2, o2);\n        return e.Pop(), u2.Pop(), false;\n      }\n      _While() {\n        const t = this._runtime.GetEventSheetManager(), e = t.GetEventStack(), r2 = e.GetCurrentStackFrame(), n2 = r2.GetCurrentEvent(), a2 = n2.GetSolModifiers(), i2 = r2.IsSolModifierAfterCnds(), s2 = e.Push(n2), o2 = t.GetLoopStack(), u2 = o2.Push();\n        if (i2) for (let e2 = 0; !u2.IsStopped(); ++e2) t.PushCopySol(a2), u2.SetIndex(e2), n2.Retrigger(r2, s2) || u2.Stop(), t.PopSol(a2);\n        else for (let e2 = 0; !u2.IsStopped(); ++e2) u2.SetIndex(e2), n2.Retrigger(r2, s2) || u2.Stop();\n        return e.Pop(), o2.Pop(), false;\n      }\n      *_DebugWhile() {\n        const t = this._runtime.GetEventSheetManager(), e = t.GetEventStack(), r2 = e.GetCurrentStackFrame(), n2 = r2.GetCurrentEvent(), a2 = n2.GetSolModifiers(), i2 = r2.IsSolModifierAfterCnds(), s2 = e.Push(n2), o2 = t.GetLoopStack(), u2 = o2.Push();\n        if (i2) for (let e2 = 0; !u2.IsStopped(); ++e2) {\n          t.PushCopySol(a2), u2.SetIndex(e2);\n          const l2 = yield* n2.DebugRetrigger(r2, s2);\n          l2 || u2.Stop(), t.PopSol(a2);\n        }\n        else for (let e2 = 0; !u2.IsStopped(); ++e2) {\n          u2.SetIndex(e2);\n          const c2 = yield* n2.DebugRetrigger(r2, s2);\n          c2 || u2.Stop();\n        }\n        return e.Pop(), o2.Pop(), false;\n      }\n      _For(e, t, r2) {\n        const n2 = this._runtime.GetEventSheetManager(), a2 = n2.GetEventStack(), i2 = a2.GetCurrentStackFrame(), s2 = i2.GetCurrentEvent(), o2 = s2.GetSolModifiers(), u2 = i2.IsSolModifierAfterCnds(), l2 = a2.Push(s2), c2 = n2.GetLoopStack(), h = c2.Push();\n        if (h.SetName(e), h.SetEnd(r2), r2 < t) if (u2) for (let e2 = t; e2 >= r2 && !h.IsStopped(); --e2) n2.PushCopySol(o2), h.SetIndex(e2), s2.Retrigger(i2, l2), n2.PopSol(o2);\n        else for (let e2 = t; e2 >= r2 && !h.IsStopped(); --e2) h.SetIndex(e2), s2.Retrigger(i2, l2);\n        else if (u2) for (let e2 = t; e2 <= r2 && !h.IsStopped(); ++e2) n2.PushCopySol(o2), h.SetIndex(e2), s2.Retrigger(i2, l2), n2.PopSol(o2);\n        else for (let e2 = t; e2 <= r2 && !h.IsStopped(); ++e2) h.SetIndex(e2), s2.Retrigger(i2, l2);\n        return a2.Pop(), c2.Pop(), false;\n      }\n      *_DebugFor(e, t, r2) {\n        const n2 = this._runtime.GetEventSheetManager(), a2 = n2.GetEventStack(), i2 = a2.GetCurrentStackFrame(), s2 = i2.GetCurrentEvent(), o2 = s2.GetSolModifiers(), u2 = i2.IsSolModifierAfterCnds(), l2 = a2.Push(s2), c2 = n2.GetLoopStack(), h = c2.Push();\n        if (h.SetName(e), h.SetEnd(r2), r2 < t) if (u2) for (let e2 = t; e2 >= r2 && !h.IsStopped(); --e2) n2.PushCopySol(o2), h.SetIndex(e2), yield* s2.DebugRetrigger(i2, l2), n2.PopSol(o2);\n        else for (let e2 = t; e2 >= r2 && !h.IsStopped(); --e2) h.SetIndex(e2), yield* s2.DebugRetrigger(i2, l2);\n        else if (u2) for (let e2 = t; e2 <= r2 && !h.IsStopped(); ++e2) n2.PushCopySol(o2), h.SetIndex(e2), yield* s2.DebugRetrigger(i2, l2), n2.PopSol(o2);\n        else for (let e2 = t; e2 <= r2 && !h.IsStopped(); ++e2) h.SetIndex(e2), yield* s2.DebugRetrigger(i2, l2);\n        return a2.Pop(), c2.Pop(), false;\n      }\n      _ForEach(r2) {\n        const e = r2.GetCurrentSol(), t = e.GetInstances();\n        if (0 !== t.length) {\n          const n2 = this._runtime.GetEventSheetManager(), s2 = n2.GetEventStack(), o2 = s2.GetCurrentStackFrame(), u2 = o2.GetCurrentEvent(), l2 = u2.GetSolModifiers(), c2 = o2.IsSolModifierAfterCnds(), h = s2.Push(u2), g = n2.GetLoopStack(), S = g.Push(), d = r2.IsInContainer(), p = i.Push();\n          if (a.shallowAssignArray(p, t), S.SetEnd(p.length), c2) for (let e2 = 0, t2 = p.length; e2 < t2 && !S.IsStopped(); ++e2) {\n            n2.PushCopySol(l2);\n            const m = p[e2];\n            r2.GetCurrentSol().SetSinglePicked(m), d && m.SetSiblingsSinglePicked(), S.SetIndex(e2), u2.Retrigger(o2, h), n2.PopSol(l2);\n          }\n          else {\n            e._SetSelectAll(false);\n            const G = e._GetOwnInstances();\n            a.clearArray(G), G.push(null);\n            for (let e2 = 0, t2 = p.length; e2 < t2 && !S.IsStopped(); ++e2) {\n              const y = p[e2];\n              G[0] = y, d && y.SetSiblingsSinglePicked(), S.SetIndex(e2), u2.Retrigger(o2, h);\n            }\n          }\n          s2.Pop(), g.Pop(), a.clearArray(p), i.Pop();\n        }\n        return false;\n      }\n      *_DebugForEach(r2) {\n        const e = r2.GetCurrentSol(), t = e.GetInstances();\n        if (0 !== t.length) {\n          const n2 = this._runtime.GetEventSheetManager(), s2 = n2.GetEventStack(), o2 = s2.GetCurrentStackFrame(), u2 = o2.GetCurrentEvent(), l2 = u2.GetSolModifiers(), c2 = o2.IsSolModifierAfterCnds(), h = s2.Push(u2), g = n2.GetLoopStack(), S = g.Push(), d = r2.IsInContainer(), p = i.Push();\n          if (a.shallowAssignArray(p, t), S.SetEnd(p.length), c2) for (let e2 = 0, t2 = p.length; e2 < t2 && !S.IsStopped(); ++e2) {\n            n2.PushCopySol(l2);\n            const m = p[e2];\n            r2.GetCurrentSol().SetSinglePicked(m), d && m.SetSiblingsSinglePicked(), S.SetIndex(e2), yield* u2.DebugRetrigger(o2, h), n2.PopSol(l2);\n          }\n          else {\n            e._SetSelectAll(false);\n            const G = e._GetOwnInstances();\n            a.clearArray(G), G.push(null);\n            for (let e2 = 0, t2 = p.length; e2 < t2 && !S.IsStopped(); ++e2) {\n              const y = p[e2];\n              G[0] = y, d && y.SetSiblingsSinglePicked(), S.SetIndex(e2), yield* u2.DebugRetrigger(o2, h);\n            }\n          }\n          s2.Pop(), g.Pop(), a.clearArray(p), i.Pop();\n        }\n        return false;\n      }\n      _ForEachOrdered(r2, e) {\n        const t = r2.GetCurrentSol(), n2 = t.GetInstances();\n        if (0 !== n2.length) {\n          const s2 = this._runtime.GetEventSheetManager(), o2 = s2.GetEventStack(), u2 = s2.GetCurrentCondition(), l2 = o2.GetCurrentStackFrame(), c2 = l2.GetCurrentEvent(), h = c2.GetSolModifiers(), g = l2.IsSolModifierAfterCnds(), S = o2.Push(c2), d = s2.GetLoopStack(), p = d.Push(), m = r2.IsInContainer(), G = i.Push();\n          a.clearArray(G), p.SetEnd(n2.length);\n          for (let e2 = 0, t2 = n2.length; e2 < t2; ++e2) G.push([n2[e2], u2.ReevaluateParameter(1, e2)]);\n          if (G.sort(ForEachOrdered_SortInstances), 1 === e && G.reverse(), g) for (let e2 = 0, t2 = G.length; e2 < t2 && !p.IsStopped(); ++e2) {\n            s2.PushCopySol(h);\n            const y = G[e2][0];\n            r2.GetCurrentSol().SetSinglePicked(y), m && y.SetSiblingsSinglePicked(), p.SetIndex(e2), c2.Retrigger(l2, S), s2.PopSol(h);\n          }\n          else {\n            t._SetSelectAll(false);\n            const f = t._GetOwnInstances();\n            a.clearArray(f), f.push(null);\n            for (let e2 = 0, t2 = G.length; e2 < t2 && !p.IsStopped(); ++e2) {\n              const C = G[e2][0];\n              f[0] = C, m && C.SetSiblingsSinglePicked(), p.SetIndex(e2), c2.Retrigger(l2, S);\n            }\n          }\n          o2.Pop(), d.Pop(), a.clearArray(G), i.Pop();\n        }\n        return false;\n      }\n      *_DebugForEachOrdered(r2, e) {\n        const t = r2.GetCurrentSol(), n2 = t.GetInstances();\n        if (0 !== n2.length) {\n          const s2 = this._runtime.GetEventSheetManager(), o2 = s2.GetEventStack(), u2 = s2.GetCurrentCondition(), l2 = o2.GetCurrentStackFrame(), c2 = l2.GetCurrentEvent(), h = c2.GetSolModifiers(), g = l2.IsSolModifierAfterCnds(), S = o2.Push(c2), d = s2.GetLoopStack(), p = d.Push(), m = r2.IsInContainer(), G = i.Push();\n          a.clearArray(G), p.SetEnd(n2.length);\n          for (let e2 = 0, t2 = n2.length; e2 < t2; ++e2) G.push([n2[e2], u2.ReevaluateParameter(1, e2)]);\n          if (G.sort(ForEachOrdered_SortInstances), 1 === e && G.reverse(), g) for (let e2 = 0, t2 = G.length; e2 < t2 && !p.IsStopped(); ++e2) {\n            s2.PushCopySol(h);\n            const y = G[e2][0];\n            r2.GetCurrentSol().SetSinglePicked(y), m && y.SetSiblingsSinglePicked(), p.SetIndex(e2), yield* c2.DebugRetrigger(l2, S), s2.PopSol(h);\n          }\n          else {\n            t._SetSelectAll(false);\n            const f = t._GetOwnInstances();\n            a.clearArray(f), f.push(null);\n            for (let e2 = 0, t2 = G.length; e2 < t2 && !p.IsStopped(); ++e2) {\n              const C = G[e2][0];\n              f[0] = C, m && C.SetSiblingsSinglePicked(), p.SetIndex(e2), yield* c2.DebugRetrigger(l2, S);\n            }\n          }\n          o2.Pop(), d.Pop(), a.clearArray(G), i.Pop();\n        }\n        return false;\n      }\n      _GetFunctionMap(e, t) {\n        let r2 = this._functionMaps.get(e);\n        if (!r2) {\n          if (!t) return null;\n          r2 = { defaultFunc: null, strMap: /* @__PURE__ */ new Map() }, this._functionMaps.set(e, r2);\n        }\n        return r2;\n      }\n      _DoCallMappedFunction(e, t, r2, n2, a2) {\n        t.GetEventBlock().RunAsMappedFunctionCall(r2, t.IsCopyPicked()), n2 && e.PopSol(a2);\n      }\n      *_DebugDoCallMappedFunction(e, t, r2, n2, a2) {\n        yield* t.GetEventBlock().DebugRunAsMappedFunctionCall(r2, t.IsCopyPicked()), n2 && e.PopSol(a2);\n      }\n    };\n  }\n  {\n    const a1 = self.C3;\n    a1.Plugins.System.Type = class extends a1.DefendedBase {\n      constructor(e) {\n        super(), this._objectClass = e, this._runtime = e.GetRuntime(), this._plugin = e.GetPlugin();\n      }\n      OnCreate() {\n      }\n      Release() {\n        this._objectClass = null, this._runtime = null, this._plugin = null;\n      }\n    };\n  }\n  {\n    const d1 = self.C3;\n    d1.Plugins.System.Instance = class extends d1.DefendedBase {\n      constructor(e, t) {\n        super(), this._inst = e, this._objectClass = this._inst.GetObjectClass(), this._sdkType = this._objectClass.GetSdkType(), this._runtime = this._inst.GetRuntime();\n      }\n      Release() {\n        this._inst = null, this._objectClass = null, this._sdkType = null, this._runtime = null;\n      }\n    };\n  }\n  {\n    const h1 = self.C3, i1 = [];\n    h1.Plugins.System.Cnds = { EveryTick() {\n      return true;\n    }, OnLayoutStart() {\n      return true;\n    }, OnLayoutEnd() {\n      return true;\n    }, OnSuspend() {\n      return true;\n    }, OnResume() {\n      return true;\n    }, IsSuspended() {\n      return this._runtime.IsSuspended();\n    }, Else() {\n      const e = this._runtime.GetCurrentEventStackFrame();\n      return !e.GetElseBranchRan() && !e.GetLastEventTrue();\n    }, TriggerOnce() {\n      const e = this._runtime.GetCurrentCondition(), t = e.GetSavedDataMap();\n      let r = t.get(\"TriggerOnce_lastTick\");\n      void 0 === r && (r = -1, t.set(\"TriggerOnce_lastTick\", -1));\n      const n = this._runtime.GetTickCount();\n      return t.set(\"TriggerOnce_lastTick\", n), this._runtime.IsLayoutFirstTick() || r !== n - 1;\n    }, Every(e) {\n      const t = this._runtime.GetCurrentCondition(), r = t.GetSavedDataMap(), n = r.get(\"Every_lastTime\") || 0, a = this._runtime.GetGameTime(), i = (r.has(\"Every_seconds\") || r.set(\"Every_seconds\", e), r.get(\"Every_seconds\"));\n      return n + i <= a ? (r.set(\"Every_lastTime\", n + i), a >= r.get(\"Every_lastTime\") + 0.04 && r.set(\"Every_lastTime\", a), r.set(\"Every_seconds\", e), true) : (a < n - 0.1 && r.set(\"Every_lastTime\", a), false);\n    }, IsGroupActive(e) {\n      const t = this._runtime.GetEventSheetManager().GetEventGroupByName(e);\n      return t && t.IsGroupActive();\n    }, IsPreview() {\n      return this._runtime.IsPreview();\n    }, IsMobile() {\n      return h1.Platform.IsMobile;\n    }, OnLoadFinished() {\n      return true;\n    }, OnCanvasSnapshot() {\n      return true;\n    }, EffectsSupported() {\n      return true;\n    }, OnSaveComplete() {\n      return true;\n    }, OnSaveFailed() {\n      return true;\n    }, OnLoadComplete() {\n      return true;\n    }, OnLoadFailed() {\n      return true;\n    }, ObjectUIDExists(e) {\n      return !!this._runtime.GetInstanceByUID(e);\n    }, IsOnPlatform(e) {\n      switch (e) {\n        case 0:\n          return \"browser\" === h1.Platform.Context;\n        case 1:\n          return \"iOS\" === h1.Platform.OS;\n        case 2:\n          return \"Android\" === h1.Platform.OS;\n        case 8:\n          return \"cordova\" === h1.Platform.Context;\n        case 9:\n          return \"scirra-arcade\" === this._runtime.GetExportType();\n        case 10:\n          return \"nwjs\" === h1.Platform.Context;\n        case 13:\n          return \"windows-uwp\" === this._runtime.GetExportType();\n        default:\n          return false;\n      }\n    }, RegexTest(e, t, r) {\n      const n = this.GetRegex(t, r);\n      return n.test(e);\n    }, Compare(e, t, r) {\n      return h1.compare(e, t, r);\n    }, CompareBetween(e, t, r) {\n      return t <= e && e <= r;\n    }, CompareVar(e, t, r) {\n      return h1.compare(e.GetValue(), t, r);\n    }, CompareBoolVar(e) {\n      return !!e.GetValue();\n    }, CompareTime(e, t) {\n      const r = this._runtime.GetGameTime();\n      if (0 !== e) return h1.compare(r, e, t);\n      {\n        const n = this._runtime.GetCurrentCondition(), a = n.GetSavedDataMap();\n        return !a.get(\"CompareTime_executed\") && t <= r ? (a.set(\"CompareTime_executed\", true), true) : false;\n      }\n    }, IsNaN(e) {\n      return isNaN(e);\n    }, AngleWithin(e, t, r) {\n      return h1.angleDiff(h1.toRadians(e), h1.toRadians(r)) <= h1.toRadians(t);\n    }, IsClockwiseFrom(e, t) {\n      return h1.angleClockwise(h1.toRadians(e), h1.toRadians(t));\n    }, IsBetweenAngles(e, t, r) {\n      let n = h1.toRadians(e), a = h1.toRadians(t), i = h1.toRadians(r), s = !h1.angleClockwise(i, a);\n      return s ? !(!h1.angleClockwise(n, a) && h1.angleClockwise(n, i)) : h1.angleClockwise(n, a) && !h1.angleClockwise(n, i);\n    }, IsValueType(e, t) {\n      return \"number\" == typeof e ? 0 === t : 1 === t;\n    }, EvaluateExpression(e) {\n      return !!e;\n    }, OnSignal(e) {\n      return e.toLowerCase() === this._runtime.GetEventSheetManager().GetCurrentSignalTag();\n    }, PickByComparison(e, r, n, a) {\n      if (!e) return false;\n      const t = this._GetForEachStack(), i = t.Push(), s = e.GetCurrentSol(), o = (h1.shallowAssignArray(i, s.GetInstances()), s.IsSelectAll() && h1.clearArray(s._GetOwnElseInstances()), this._runtime.GetCurrentCondition());\n      let u = 0;\n      for (let e2 = 0, t2 = i.length; e2 < t2; ++e2) {\n        const c = i[e2];\n        i[u] = c, r = o.ReevaluateParameter(1, e2), a = o.ReevaluateParameter(3, e2), h1.compare(r, n, a) ? ++u : s._PushElseInstance(c);\n      }\n      h1.truncateArray(i, u), s.SetArrayPicked(i);\n      const l = !!i.length;\n      return h1.clearArray(i), t.Pop(), e.ApplySolToContainer(), l;\n    }, PickByEvaluate(e, t) {\n      if (!e) return false;\n      const r = this._GetForEachStack(), n = r.Push(), a = e.GetCurrentSol(), i = (h1.shallowAssignArray(n, a.GetInstances()), a.IsSelectAll() && h1.clearArray(a._GetOwnElseInstances()), this._runtime.GetCurrentCondition());\n      let s = 0;\n      for (let e2 = 0, t2 = n.length; e2 < t2; ++e2) {\n        const u = n[e2];\n        n[s] = u, i.ReevaluateParameter(1, e2) ? ++s : a._PushElseInstance(u);\n      }\n      h1.truncateArray(n, s), a.SetArrayPicked(n);\n      const o = !!n.length;\n      return h1.clearArray(n), r.Pop(), e.ApplySolToContainer(), o;\n    }, PickByHighestLowestValue(e, r, n) {\n      if (!e) return false;\n      const t = e.GetCurrentSol(), a = t.GetInstances();\n      if (0 === a.length) return false;\n      const i = this._runtime.GetCurrentCondition();\n      let s = null, o = 0;\n      for (let e2 = 0, t2 = a.length; e2 < t2; ++e2) {\n        const u = a[e2];\n        n = i.ReevaluateParameter(2, e2), (null === s || 0 === r && n < o || 1 === r && n > o) && (o = n, s = u);\n      }\n      return t.PickOne(s), e.ApplySolToContainer(), true;\n    }, PickNth(e, t) {\n      if (!e) return false;\n      const r = e.GetCurrentSol(), n = r.GetInstances();\n      if ((t = Math.floor(t)) >= n.length) return false;\n      const a = n[t];\n      return r.PickOne(a), e.ApplySolToContainer(), true;\n    }, PickRandom(e) {\n      if (!e) return false;\n      const t = e.GetCurrentSol(), r = t.GetInstances(), n = Math.floor(this._runtime.Random() * r.length);\n      if (n >= r.length) return false;\n      const a = r[n];\n      return t.PickOne(a), e.ApplySolToContainer(), true;\n    }, PickAll(e) {\n      if (!e) return false;\n      if (!e.GetInstanceCount()) return false;\n      const t = e.GetCurrentSol();\n      return t._SetSelectAll(true), e.ApplySolToContainer(), true;\n    }, PickOverlappingPoint(e, r, n) {\n      if (!e) return false;\n      const a = e.GetCurrentSol(), t = a.GetInstances(), i = this._runtime.GetCurrentEvent(), s = i.IsOrBlock(), o = this._runtime.GetCurrentCondition().IsInverted();\n      a.IsSelectAll() ? (h1.shallowAssignArray(i1, t), a.ClearArrays(), a._SetSelectAll(false)) : s ? (h1.shallowAssignArray(i1, a._GetOwnElseInstances()), h1.clearArray(a._GetOwnElseInstances())) : (h1.shallowAssignArray(i1, a._GetOwnInstances()), h1.clearArray(a._GetOwnInstances()));\n      for (let e2 = 0, t2 = i1.length; e2 < t2; ++e2) {\n        const u = i1[e2];\n        h1.xor(u.GetWorldInfo().ContainsPoint(r, n), o) ? a._PushInstance(u) : a._PushElseInstance(u);\n      }\n      return e.ApplySolToContainer(), h1.xor(!!a._GetOwnInstances().length, o);\n    }, PickLastCreated(t) {\n      if (!t) return false;\n      const r = t.IsFamily();\n      let n = null;\n      const a = this._runtime._GetInstancesPendingCreate();\n      for (let e2 = a.length - 1; 0 <= e2; --e2) {\n        const i = a[e2];\n        if (r) {\n          if (i.GetObjectClass().BelongsToFamily(t)) {\n            n = i;\n            break;\n          }\n        } else if (i.GetObjectClass() === t) {\n          n = i;\n          break;\n        }\n      }\n      if (!n) {\n        const s = t.GetInstances();\n        s.length && (n = s.at(-1));\n      }\n      if (!n) return false;\n      const e = t.GetCurrentSol();\n      return e.PickOne(n), t.ApplySolToContainer(), true;\n    }, Repeat(e) {\n      return this._runtime.IsDebugging() ? this._DebugRepeat(e) : this._Repeat(e);\n    }, While() {\n      return this._runtime.IsDebugging() ? this._DebugWhile() : this._While();\n    }, For(e, t, r) {\n      return this._runtime.IsDebugging() ? this._DebugFor(e, t, r) : this._For(e, t, r);\n    }, ForEach(e) {\n      return this._runtime.IsDebugging() ? this._DebugForEach(e) : this._ForEach(e);\n    }, ForEachOrdered(e, t, r) {\n      return this._runtime.IsDebugging() ? this._DebugForEachOrdered(e, r) : this._ForEachOrdered(e, r);\n    }, LayerVisible(e) {\n      return !!e && e.IsVisible();\n    }, LayerInteractive(e) {\n      return !!e && e.IsSelfAndParentsInteractive();\n    }, LayerIsHTML(e) {\n      return !!e && e.IsHTMLElementsLayer();\n    }, LayerEmpty(e) {\n      return !!e && !e.GetInstanceCount();\n    }, LayerCmpOpacity(e, t, r) {\n      return !!e && h1.compare(100 * e.GetOpacity(), t, r);\n    }, LayerNameExists(e) {\n      const t = this._runtime.GetMainRunningLayout();\n      return !!t && t.HasLayerByName(e);\n    }, OnImageLoadingComplete() {\n      return true;\n    }, IsLoadingImages() {\n      return 0 < this._imagesLoadingTotal;\n    }, TemplateExists(e, t) {\n      const r = this._runtime.GetTemplateManager();\n      return !!r && !!t && !!r.GetTemplateData(e, t);\n    } };\n  }\n  {\n    let SortZOrderList = function(e, t) {\n      const r = e[0], n = t[0], a = r - n;\n      if (0 != a) return a;\n      const i = e[1], s = t[1];\n      return i - s;\n    }, SortInstancesByValue = function(e, t) {\n      return e[1] - t[1];\n    };\n    SortZOrderList2 = SortZOrderList, SortInstancesByValue2 = SortInstancesByValue;\n    const M2 = self.C3;\n    const N2 = [], O2 = [], P2 = M2.New(M2.Rect), Q2 = M2.New(M2.Color), R2 = [];\n    M2.Plugins.System.Acts = { SetVar(e, t) {\n      e.SetValue(t);\n    }, AddVar(e, t) {\n      e.IsNumber() && \"number\" != typeof t && (t = parseFloat(t)), e.SetValue(e.GetValue() + t);\n    }, SubVar(e, t) {\n      e.IsNumber() && e.SetValue(e.GetValue() - t);\n    }, SetBoolVar(e, t) {\n      e.SetValue(!!t);\n    }, ToggleBoolVar(e) {\n      e.SetValue(!e.GetValue());\n    }, ResetEventVar(e) {\n      e.SetValue(e.GetInitialValue());\n    }, ResetGlobals(e) {\n      this._runtime.GetEventSheetManager().ResetAllGlobalsToInitialValue(e);\n    }, CreateObject(e, t, r, n, a, i) {\n      if (e && t) {\n        const s = this._runtime.CreateInstance(e, t, r, n, a, i);\n        if (s) {\n          a && t.SortAndAddInstancesByZIndex(s);\n          const o = this._runtime.GetEventSheetManager(), u = (o.BlockFlushingInstances(true), s._TriggerOnCreatedOnSelfAndRelated(), o.BlockFlushingInstances(false), /* @__PURE__ */ new Map());\n          s.CollectInstancesToPick(u, e, a);\n          for (const [l, c] of u) l.GetCurrentSol().SetSetPicked(c);\n        }\n      }\n    }, CreateObjectByName(e, t, r, n, a, i) {\n      if (e && t) {\n        const s = this._runtime.GetObjectClassByName(e);\n        s && M2.Plugins.System.Acts.CreateObject.call(this, s, t, r, n, a, i);\n      }\n    }, RecreateInitialObjects(n, a, i, s, o, e, u, l, c, h, g) {\n      if (n) {\n        const S = this._runtime.GetCurrentLayout();\n        let t = S;\n        if (e) {\n          const d = this._runtime.GetLayoutManager().GetLayoutByName(e);\n          if (!d) return;\n          t = d;\n        }\n        let r = null;\n        if (!(\"number\" != typeof u || 0 <= u) || (r = t.GetLayer(u))) {\n          let e2 = null;\n          if (!(\"number\" != typeof l || 0 <= l) || (e2 = S.GetLayer(l))) {\n            P2.set(a, i, s, o);\n            const p = t.RecreateInitialObjects(n, P2, r, e2, c, h, g);\n            n.GetCurrentSol().SetArrayPicked(p), n.ApplySolToContainer();\n          }\n        }\n      }\n    }, StopLoop() {\n      const e = this._loopStack;\n      e.IsInLoop() && e.GetCurrent().Stop();\n    }, SetGroupActive(e, t) {\n      const r = this._runtime.GetEventSheetManager().GetEventGroupByName(e);\n      r && (0 === t ? r.SetGroupActive(false) : 1 === t ? r.SetGroupActive(true) : r.SetGroupActive(!r.IsGroupActive()));\n    }, SetTimescale(e) {\n      this._runtime.SetTimeScale(e);\n    }, SetObjectTimescale(e, t) {\n      if (t < 0 && (t = 0), e) {\n        const r = e.GetCurrentSol(), n = r.GetInstances();\n        for (const a of n) a.SetTimeScale(t);\n      }\n    }, RestoreObjectTimescale(e) {\n      if (e) {\n        const t = e.GetCurrentSol(), r = t.GetInstances();\n        for (const n of r) n.RestoreTimeScale();\n      }\n    }, Wait(e, t) {\n      if (!(e < 0)) {\n        const r = this._runtime.GetEventSheetManager().AddScheduledWait();\n        return t ? r.InitTimer(e) : r.InitWallTimer(e), true;\n      }\n    }, WaitForSignal(e) {\n      return this._runtime.GetEventSheetManager().AddScheduledWait().InitSignal(e), true;\n    }, WaitForPreviousActions() {\n      const e = this._runtime.GetEventSheetManager();\n      return e.AddScheduledWait().InitPromise(e.GetPromiseForAllAsyncActions()), true;\n    }, Signal(e) {\n      this._runtime.GetEventSheetManager().Signal(e);\n    }, async SnapshotCanvas(e, t, r, n, a, i) {\n      const s = this._runtime.GetCanvasManager();\n      s && (this.UpdateRender(), await s.SnapshotCanvas(0 === e ? \"image/png\" : \"image/jpeg\", t / 100, r, n, a, i), await this._runtime.TriggerAsync(M2.Plugins.System.Cnds.OnCanvasSnapshot, null));\n    }, SetCanvasSize(e, t) {\n      if (!(e <= 0 || t <= 0)) {\n        this._runtime.SetViewportSize(e, t), this._runtime.GetCurrentLayout().BoundScrolling();\n        const r = this._runtime.GetCanvasManager();\n        r && (\"off\" !== r.GetCurrentFullscreenMode() && this._runtime.SetOriginalViewportSize(e, t), r.SetSize(r.GetLastWidth(), r.GetLastHeight(), true), this._runtime.UpdateRender());\n      }\n    }, SetFullscreenQuality(e) {\n      const t = this._runtime.GetCanvasManager();\n      t && \"off\" !== t.GetCurrentFullscreenMode() && (t.SetFullscreenScalingQuality(0 !== e ? \"high\" : \"low\"), t.SetSize(t.GetLastWidth(), t.GetLastHeight(), true));\n    }, SaveState(e) {\n      this._runtime.SaveToSlot(e);\n    }, SaveStateJSON() {\n      this._runtime.SaveToJsonString();\n    }, LoadState(e) {\n      this._runtime.LoadFromSlot(e);\n    }, LoadStateJSON(e) {\n      this._runtime.LoadFromJsonString(e);\n    }, SetHalfFramerateMode(e) {\n    }, ResetPersisted() {\n      for (const e of this._runtime.GetLayoutManager().GetAllLayouts()) e.ResetPersistData();\n    }, SetPixelRounding(e) {\n      this._runtime.SetPixelRoundingEnabled(0 !== e);\n    }, SetFramerateMinMax(e, t) {\n      this._runtime.SetMaxDt(1 / e), this._runtime.SetMinDt(1 / t);\n    }, SetDeltaTimeMinMax(e, t) {\n      this._runtime.SetMinDt(e), this._runtime.SetMaxDt(t);\n    }, SetFramerateMode(e) {\n      this._runtime._SetFramerateMode([\"vsync\", \"unlimited-tick\", \"unlimited-frame\"][e]);\n    }, SortZOrderByInstVar(e, r) {\n      if (e) {\n        const t = e.GetCurrentSol(), n = t.GetInstances(), a = N2, i = O2, s = this._runtime.GetCurrentLayout(), o = e.IsFamily(), u = e.GetFamilyIndex();\n        for (let e2 = 0, t2 = n.length; e2 < t2; ++e2) {\n          const l = n[e2], c = l.GetWorldInfo();\n          if (c) {\n            let e3;\n            e3 = o ? l.GetInstanceVariableValue(r + l.GetObjectClass().GetFamilyInstanceVariableOffset(u)) : l.GetInstanceVariableValue(r), a.push([c.GetLayer().GetIndex(), c.GetZIndex()]), i.push([l, e3]);\n          }\n        }\n        if (a.length) {\n          a.sort(SortZOrderList), i.sort(SortInstancesByValue);\n          let r2 = false;\n          for (let e2 = 0, t2 = a.length; e2 < t2; ++e2) {\n            const h = i[e2][0], g = s.GetLayerByIndex(a[e2][0]), S = a[e2][1], d = g._GetInstances();\n            d[S] !== h && ((d[S] = h).GetWorldInfo()._SetLayer(g, true), g.SetZIndicesChanged(h), r2 = true);\n          }\n          r2 && this._runtime.UpdateRender(), M2.clearArray(N2), M2.clearArray(O2);\n        }\n      }\n    }, SetCollisionCellSize(e, t) {\n      e = Math.floor(e), t = Math.floor(t), e <= 0 || t <= 0 || !Number.isFinite(e) || !Number.isFinite(t) || this._runtime.GetCollisionEngine().SetCollisionCellSize(e, t);\n    }, GoToLayout(e) {\n      if (!this._runtime.IsLoading()) {\n        const t = this._runtime.GetLayoutManager();\n        t.IsPendingChangeMainLayout() || t.ChangeMainLayout(e);\n      }\n    }, GoToLayoutByName(e) {\n      if (!this._runtime.IsLoading()) {\n        const t = this._runtime.GetLayoutManager();\n        if (!t.IsPendingChangeMainLayout()) {\n          const r = t.GetLayoutByName(e);\n          r && t.ChangeMainLayout(r);\n        }\n      }\n    }, NextPrevLayout(e) {\n      if (!this._runtime.IsLoading()) {\n        const t = this._runtime.GetLayoutManager();\n        if (!t.IsPendingChangeMainLayout()) {\n          const r = t.GetAllLayouts(), n = r.indexOf(t.GetMainRunningLayout());\n          if ((!e || 0 !== n) && (e || n !== r.length - 1)) {\n            const a = r[n + (e ? -1 : 1)];\n            t.ChangeMainLayout(a);\n          }\n        }\n      }\n    }, RestartLayout() {\n      if (!this._runtime.IsLoading()) {\n        const e = this._runtime.GetLayoutManager();\n        e.IsPendingChangeMainLayout() || (e.ChangeMainLayout(e.GetMainRunningLayout()), this._runtime.GetEventSheetManager().ResetAllGroupsInitialActivation());\n      }\n    }, SetLayerVisible(e, t) {\n      e && e.SetVisible(t);\n    }, SetLayerInteractive(e, t) {\n      e && e.SetInteractive(t);\n    }, SetLayerHTML(e, t) {\n      e && e.SetIsHTMLElementsLayer(t);\n    }, SetLayerOpacity(e, t) {\n      e && e.SetOpacity(t / 100);\n    }, SetLayerScale(e, t) {\n      e && e.SetOwnScale(t);\n    }, SetLayerScaleRate(e, t) {\n      e && e.SetScaleRate(t);\n    }, SetLayerAngle(e, t) {\n      e && e.SetAngle(M2.toRadians(+t));\n    }, SetLayerScroll(e, t, r) {\n      e && (e.SetOwnScrollPositionEnabled(true), e.SetScrollX(t), e.SetScrollY(r));\n    }, RestoreLayerScroll(e) {\n      e && e.SetOwnScrollPositionEnabled(false);\n    }, SetLayerParallax(e, t, r) {\n      e && e.SetParallax(t / 100, r / 100);\n    }, SetLayerZElevation(e, t) {\n      e && e.SetZElevation(+t);\n    }, SetLayerBackground(e, t) {\n      if (e) {\n        Q2.setFromRgbValue(t), Q2.clamp();\n        const r = e.GetBackgroundColor();\n        r.equalsIgnoringAlpha(Q2) || (r.copyRgb(Q2), this.UpdateRender());\n      }\n    }, SetLayerTransparent(e, t) {\n      e && e.SetTransparent(t);\n    }, SetLayerBlendMode(e, t) {\n      e && e.SetBlendMode(t);\n    }, SetLayerEffectEnabled(e, t, r) {\n      if (e) {\n        const n = e.GetEffectList(), a = n.GetEffectTypeByName(r);\n        if (a) {\n          const i = 1 === t;\n          a.IsActive() !== i && (a.SetActive(i), e.UpdateActiveEffects(), this._runtime.UpdateRender());\n        }\n      }\n    }, SetLayerEffectParam(e, t, r, n) {\n      if (e) {\n        const a = e.GetEffectList(), i = a.GetEffectTypeByName(t);\n        if (i) {\n          r = Math.floor(r);\n          const s = i.GetShaderProgram().GetParameterType(r);\n          if (s) {\n            \"color\" === s ? (Q2.setFromRgbValue(n), n = Q2) : \"percent\" === s && (n /= 100);\n            const o = a.SetEffectParameter(i.GetIndex(), r, n);\n            o && i.IsActive() && this._runtime.UpdateRender();\n          }\n        }\n      }\n    }, SetLayerForceOwnTexture(e, t) {\n      e && e.SetForceOwnTexture(t);\n    }, SetLayoutScale(e) {\n      this._runtime.GetCurrentLayout().SetScale(+e);\n    }, SetLayoutAngle(e) {\n      this._runtime.GetCurrentLayout().SetAngle(M2.toRadians(+e));\n    }, SetLayoutEffectEnabled(e, t) {\n      const r = this._runtime.GetCurrentLayout(), n = r.GetEffectList(), a = n.GetEffectTypeByName(t);\n      if (a) {\n        const i = 1 === e;\n        a.IsActive() !== i && (a.SetActive(i), r.UpdateActiveEffects(), this._runtime.UpdateRender());\n      }\n    }, SetLayoutEffectParam(e, t, r) {\n      const n = this._runtime.GetCurrentLayout(), a = n.GetEffectList(), i = a.GetEffectTypeByName(e);\n      if (i) {\n        t = Math.floor(t);\n        const s = i.GetShaderProgram().GetParameterType(t);\n        if (s) {\n          \"color\" === s ? (Q2.setFromRgbValue(r), r = Q2) : \"percent\" === s && (r /= 100);\n          const o = a.SetEffectParameter(i.GetIndex(), t, r);\n          o && i.IsActive() && this._runtime.UpdateRender();\n        }\n      }\n    }, SetLayoutVanishingPoint(e, t) {\n      const r = this._runtime.GetCurrentLayout();\n      r.SetVanishingPointXY(e / 100, t / 100);\n    }, SetLayoutProjection(e) {\n      const t = this._runtime.GetCurrentLayout();\n      0 === e ? t.SetPerspectiveProjection() : t.SetOrthographicProjection();\n    }, ScrollX(e) {\n      const t = this._runtime.GetCurrentLayout();\n      t.SetScrollX(e);\n    }, ScrollY(e) {\n      const t = this._runtime.GetCurrentLayout();\n      t.SetScrollY(e);\n    }, Scroll(e, t) {\n      const r = this._runtime.GetCurrentLayout();\n      r.SetScrollX(e), r.SetScrollY(t);\n    }, ScrollToObject(e) {\n      if (e) {\n        const t = e.GetFirstPicked();\n        if (t) {\n          const r = t.GetWorldInfo();\n          if (r) {\n            const n = this._runtime.GetCurrentLayout();\n            n.SetScrollX(r.GetX()), n.SetScrollY(r.GetY());\n          }\n        }\n      }\n    }, AddLayer(e, t, r) {\n      const n = this._runtime.GetCurrentLayout();\n      try {\n        n.AddLayer(e, t, r);\n      } catch (e2) {\n        console.warn(\"[Construct] Cannot add layer: \", e2);\n      }\n    }, MoveLayer(e, t, r) {\n      if (e) {\n        const n = this._runtime.GetCurrentLayout();\n        try {\n          n.MoveLayer(e, t, r);\n        } catch (e2) {\n          console.warn(\"[Construct] Cannot move layer: \", e2);\n        }\n      }\n    }, RemoveLayer(e) {\n      if (e) {\n        const t = this._runtime.GetCurrentLayout();\n        t.RemoveLayer(e);\n      }\n    }, RemoveAllDynamicLayers() {\n      this._runtime.GetCurrentLayout().RemoveAllDynamicLayers();\n    }, async LoadObjectTextures(e) {\n      const t = this._runtime.GetMainRunningLayout();\n      if (t && e && !this._runtime.IsLoading()) {\n        const r = e.IsFamily() ? e.GetFamilyMembers() : [e];\n        await this._LoadTexturesForObjectClasses(t, r);\n      }\n    }, async LoadObjectTexturesByName(e) {\n      await M2.Plugins.System.Acts.LoadObjectTextures.call(this, this._runtime.GetObjectClassByName(e));\n    }, UnloadObjectTextures(e) {\n      const t = this._runtime.GetMainRunningLayout();\n      if (t && e) {\n        const r = e.IsFamily() ? e.GetFamilyMembers() : [e];\n        this._UnloadTexturesForObjectClasses(t, r);\n      }\n    }, UnloadObjectTexturesByName(e) {\n      M2.Plugins.System.Acts.UnloadObjectTextures.call(this, this._runtime.GetObjectClassByName(e));\n    }, UnloadUnusedTextures() {\n      const e = this._runtime.GetMainRunningLayout();\n      if (e) {\n        const t = e._GetTextureLoadedObjectTypes();\n        this._UnloadTexturesForObjectClasses(e, t);\n      }\n    }, async LoadLayoutTextures(e) {\n      const t = this._runtime.GetMainRunningLayout();\n      e && t && !this._runtime.IsLoading() && await this._LoadTexturesForObjectClasses(t, e._GetInitialObjectClasses());\n    }, async LoadLayoutTexturesByName(e) {\n      const t = this._runtime.GetMainRunningLayout(), r = this._runtime.GetLayoutManager().GetLayoutByName(e);\n      r && t && !this._runtime.IsLoading() && await this._LoadTexturesForObjectClasses(t, r._GetInitialObjectClasses());\n    }, SetFunctionReturnValue(e) {\n      const t = this._eventStack.GetCurrentExpFuncStackFrame();\n      if (t) switch (t.GetFunctionReturnType()) {\n        case 1:\n          \"number\" == typeof e && t.SetFunctionReturnValue(e);\n          break;\n        case 2:\n          \"string\" == typeof e && t.SetFunctionReturnValue(e);\n          break;\n        case 3:\n          t.SetFunctionReturnValue(e);\n      }\n    }, MapFunction(e, t, r) {\n      const n = this._GetFunctionMap(e.toLowerCase(), true), a = n.strMap, i = t.toLowerCase(), s = (a.has(i) && console.warn(`[Construct] Function map '${e}' string '${t}' already in map; overwriting entry`), M2.first(a.values()) || n.defaultFunc);\n      if (s) {\n        const o = 0 !== s.GetReturnType(), u = 0 !== r.GetReturnType();\n        if (o != u) return void console.error(`[Construct] Function map '${e}' string '${t}' function return type not compatible with other functions in the map; entry ignored`);\n      }\n      a.set(i, r);\n    }, MapFunctionDefault(e, t) {\n      const r = this._GetFunctionMap(e.toLowerCase(), true), n = (r.defaultFunc && console.warn(`[Construct] Function map '${e}' already has a default; overwriting entry`), M2.first(r.strMap.values()) || r.defaultFunc);\n      if (n) {\n        const a = 0 !== n.GetReturnType(), i = 0 !== t.GetReturnType();\n        if (a != i) return void console.error(`[Construct] Function map '${e}' default: function return type not compatible with other functions in the map; entry ignored`);\n      }\n      r.defaultFunc = t;\n    }, CallMappedFunction(e, t, r) {\n      const n = this._runtime, a = n.IsDebugging() ? R2 : null, i = (r = Math.floor(r), this._GetFunctionMap(e.toLowerCase(), false));\n      if (!i) return console.warn(`[Construct] Call mapped function: map name '${e}' not found; call ignored`), a;\n      let s = i.strMap.get(t.toLowerCase());\n      if (!s) {\n        if (!i.defaultFunc) return console.warn(`[Construct] Call mapped function: no function associated with map '${e}' string '${t}'; call ignored (consider setting a default)`), a;\n        s = i.defaultFunc, r = 0;\n      }\n      if (!s.IsEnabled()) return a;\n      if (0 !== s.GetReturnType()) return console.warn(`[Construct] Call mapped function: map '${e}' string '${t}' has a return type so cannot be called`), a;\n      const o = n.GetEventSheetManager(), u = o.GetCurrentEvent(), l = u.GetSolModifiersIncludingParents(), c = 0 < l.length, h = (c && (s.IsCopyPicked() ? o.PushCopySol(l) : o.PushCleanSol(l)), []), g = o.FindFirstFunctionBlockParent(u);\n      if (g) {\n        const d = g.GetFunctionParameters();\n        for (let e2 = r, t2 = d.length; e2 < t2; ++e2) h.push(d[e2].GetValue());\n      }\n      const S = s.GetFunctionParameters();\n      for (let e2 = h.length, t2 = S.length; e2 < t2; ++e2) h.push(S[e2].GetInitialValue());\n      return n.IsDebugging() ? this._DebugDoCallMappedFunction(o, s, h, c, l) : this._DoCallMappedFunction(o, s, h, c, l);\n    } };\n  }\n  {\n    const Xf = self.C3;\n    Xf.Plugins.System.Exps = { int: function(e) {\n      return \"string\" == typeof e && (e = parseInt(e, 10), isNaN(e)) && (e = 0), Math.floor(e);\n    }, float: function(e) {\n      return e = \"string\" == typeof e && (e = parseFloat(e), isNaN(e)) ? 0 : e;\n    }, str(e) {\n      return e.toString();\n    }, len(e) {\n      return \"string\" == typeof e ? e.length : 0;\n    }, random(e, t) {\n      return void 0 === t ? this._runtime.Random() * e : this._runtime.Random() * (t - e) + e;\n    }, choose(...e) {\n      const t = Math.floor(this._runtime.Random() * e.length);\n      return e[t];\n    }, chooseindex(e, ...t) {\n      return \"number\" != typeof e && (e = 0), t[e = Xf.clamp(Math.floor(e), 0, t.length - 1)];\n    }, pi() {\n      return Math.PI;\n    }, infinity() {\n      return 1 / 0;\n    }, sqrt(e) {\n      return Math.sqrt(e);\n    }, abs(e) {\n      return Math.abs(e);\n    }, round(e) {\n      return Math.round(e);\n    }, roundtodp(e, t) {\n      t = Math.max(Math.floor(t), 0);\n      const r = Math.pow(10, t);\n      return Math.round((e + Number.EPSILON) * r) / r;\n    }, floor(e) {\n      return Math.floor(e);\n    }, ceil(e) {\n      return Math.ceil(e);\n    }, sign(e) {\n      return Math.sign(e);\n    }, sin(e) {\n      return Math.sin(Xf.toRadians(e));\n    }, cos(e) {\n      return Math.cos(Xf.toRadians(e));\n    }, tan(e) {\n      return Math.tan(Xf.toRadians(e));\n    }, asin(e) {\n      return Xf.toDegrees(Math.asin(e));\n    }, acos(e) {\n      return Xf.toDegrees(Math.acos(e));\n    }, atan(e) {\n      return Xf.toDegrees(Math.atan(e));\n    }, exp(e) {\n      return Math.exp(e);\n    }, ln(e) {\n      return Math.log(e);\n    }, log10(e) {\n      return Math.log10(e);\n    }, max(...r) {\n      let n = r[0];\n      \"number\" != typeof n && (n = 0);\n      for (let t = 1, e = r.length; t < e; ++t) {\n        let e2 = r[t];\n        \"number\" == typeof e2 && n < e2 && (n = e2);\n      }\n      return n;\n    }, min(...r) {\n      let n = r[0];\n      \"number\" != typeof n && (n = 0);\n      for (let t = 1, e = r.length; t < e; ++t) {\n        let e2 = r[t];\n        \"number\" == typeof e2 && n > e2 && (n = e2);\n      }\n      return n;\n    }, clamp(e, t, r) {\n      return Xf.clamp(e, t, r);\n    }, distance(e, t, r, n) {\n      return Xf.distanceTo(e, t, r, n);\n    }, angle(e, t, r, n) {\n      return Xf.toDegrees(Xf.angleTo(e, t, r, n));\n    }, lerp(e, t, r) {\n      return Xf.lerp(e, t, r);\n    }, unlerp(e, t, r) {\n      return Xf.unlerp(e, t, r);\n    }, qarp(e, t, r, n) {\n      return Xf.qarp(e, t, r, n);\n    }, cubic(e, t, r, n, a) {\n      return Xf.cubic(e, t, r, n, a);\n    }, cosp(e, t, r) {\n      return Xf.cosp(e, t, r);\n    }, anglediff(e, t) {\n      return Xf.toDegrees(Xf.angleDiff(Xf.toRadians(e), Xf.toRadians(t)));\n    }, anglelerp(e, t, r) {\n      return Xf.toDegrees(Xf.angleLerp(Xf.toRadians(e), Xf.toRadians(t), r));\n    }, anglerotate(e, t, r) {\n      return Xf.toDegrees(Xf.angleRotate(Xf.toRadians(e), Xf.toRadians(t), Xf.toRadians(r)));\n    }, setbit(e, t, r) {\n      return (e |= 0) & ~(1 << (t |= 0)) | (r = 0 !== r ? 1 : 0) << t;\n    }, togglebit(e, t) {\n      return (e |= 0) ^ 1 << (t |= 0);\n    }, getbit(e, t) {\n      return (e |= 0) & 1 << (t |= 0) ? 1 : 0;\n    }, newline() {\n      return \"\\n\";\n    }, uppercase(e) {\n      return \"string\" == typeof e ? e.toUpperCase() : \"\";\n    }, lowercase(e) {\n      return \"string\" == typeof e ? e.toLowerCase() : \"\";\n    }, left(e, t) {\n      return \"string\" == typeof e ? e.substr(0, t) : \"\";\n    }, mid(e, t, r) {\n      return \"string\" != typeof e ? \"\" : r < 0 ? e.substr(t) : e.substr(t, r);\n    }, right(e, t) {\n      return \"string\" == typeof e ? e.substr(Math.max(e.length - t, 0)) : \"\";\n    }, trim(e) {\n      return \"string\" == typeof e ? e.trim() : \"\";\n    }, tokenat(e, t, r) {\n      if (\"string\" != typeof e || \"string\" != typeof r) return \"\";\n      let n = e.split(r);\n      return (t = Math.floor(t)) < 0 || t >= n.length ? \"\" : n[t];\n    }, tokencount(e, t) {\n      return \"string\" == typeof e && \"string\" == typeof t && e.length ? e.split(t).length : 0;\n    }, find(e, t) {\n      return \"string\" == typeof e && \"string\" == typeof t ? e.search(new RegExp(Xf.EscapeRegex(t), \"i\")) : -1;\n    }, findcase(e, t) {\n      return \"string\" == typeof e && \"string\" == typeof t ? e.search(new RegExp(Xf.EscapeRegex(t), \"\")) : -1;\n    }, replace(e, t, r) {\n      return \"string\" == typeof e && \"string\" == typeof t && \"string\" == typeof r ? e.replace(new RegExp(Xf.EscapeRegex(t), \"gi\"), r) : \"string\" == typeof e ? e : \"\";\n    }, stringsub(e, ...r) {\n      let n = e;\n      for (let e2 = 0, t = r.length; e2 < t; ++e2) n = n.replaceAll(`{${e2}}`, r[e2].toString());\n      return n;\n    }, regexsearch(e, t, r) {\n      const n = this.GetRegex(t, r);\n      return e ? e.search(n) : -1;\n    }, regexreplace(e, t, r, n) {\n      const a = this.GetRegex(t, r);\n      return e ? e.replace(a, n) : \"\";\n    }, regexmatchcount(e, t, r) {\n      const n = this.GetRegexMatches(e.toString(), t, r);\n      return n ? n.length : 0;\n    }, regexmatchat(e, t, r, n) {\n      n = Math.floor(n);\n      const a = this.GetRegexMatches(e.toString(), t, r);\n      return !a || n < 0 || n >= a.length ? \"\" : a[n];\n    }, zeropad(e, t) {\n      let r = e < 0 ? \"-\" : \"\";\n      const n = t - (e = e < 0 ? -e : e).toString().length;\n      return (r += \"0\".repeat(Math.max(n, 0))) + e.toString();\n    }, urlencode(e) {\n      return encodeURIComponent(e);\n    }, urldecode(e) {\n      return decodeURIComponent(e);\n    }, dt() {\n      return this._runtime._GetDtFast();\n    }, wallclockdt() {\n      return this._runtime.GetDt1();\n    }, timescale() {\n      return this._runtime.GetTimeScale();\n    }, wallclocktime() {\n      return (Date.now() - this._runtime.GetStartTime()) / 1e3;\n    }, unixtime() {\n      return Date.now();\n    }, time() {\n      return this._runtime.GetGameTime();\n    }, tickcount() {\n      return this._runtime.GetTickCount();\n    }, objectcount() {\n      return this._runtime.GetObjectCount();\n    }, fps() {\n      return this._runtime.GetFramesPerSecond();\n    }, cpuutilisation() {\n      return this._runtime.GetMainThreadTime();\n    }, gpuutilisation() {\n      return this._runtime.GetGPUUtilisation();\n    }, windowwidth() {\n      return this._runtime.GetCanvasManager().GetDeviceWidth();\n    }, windowheight() {\n      return this._runtime.GetCanvasManager().GetDeviceHeight();\n    }, originalwindowwidth() {\n      return this._runtime.GetOriginalViewportWidth();\n    }, originalwindowheight() {\n      return this._runtime.GetOriginalViewportHeight();\n    }, originalviewportwidth() {\n      return this._runtime.GetOriginalViewportWidth();\n    }, originalviewportheight() {\n      return this._runtime.GetOriginalViewportHeight();\n    }, scrollx() {\n      return this._runtime.GetCurrentLayout().GetScrollX();\n    }, scrolly() {\n      return this._runtime.GetCurrentLayout().GetScrollY();\n    }, layoutname() {\n      return this._runtime.GetCurrentLayout().GetName();\n    }, layoutscale() {\n      return this._runtime.GetCurrentLayout().GetScale();\n    }, layoutangle() {\n      return Xf.toDegrees(this._runtime.GetCurrentLayout().GetAngle());\n    }, layoutwidth() {\n      return this._runtime.GetCurrentLayout().GetWidth();\n    }, layoutheight() {\n      return this._runtime.GetCurrentLayout().GetHeight();\n    }, vanishingpointx() {\n      return 100 * this._runtime.GetCurrentLayout().GetVanishingPointX();\n    }, vanishingpointy() {\n      return 100 * this._runtime.GetCurrentLayout().GetVanishingPointY();\n    }, viewportleft(e) {\n      const t = this._runtime.GetCurrentLayout().GetLayer(e);\n      return t ? t.GetViewport3D().getLeft() : 0;\n    }, viewporttop(e) {\n      const t = this._runtime.GetCurrentLayout().GetLayer(e);\n      return t ? t.GetViewport3D().getTop() : 0;\n    }, viewportright(e) {\n      const t = this._runtime.GetCurrentLayout().GetLayer(e);\n      return t ? t.GetViewport3D().getRight() : 0;\n    }, viewportbottom(e) {\n      const t = this._runtime.GetCurrentLayout().GetLayer(e);\n      return t ? t.GetViewport3D().getBottom() : 0;\n    }, viewportwidth(e) {\n      const t = this._runtime.GetCurrentLayout().GetLayer(e);\n      return t ? t.GetViewport3D().width() : 0;\n    }, viewportheight(e) {\n      const t = this._runtime.GetCurrentLayout().GetLayer(e);\n      return t ? t.GetViewport3D().height() : 0;\n    }, viewportmidx(e) {\n      const t = this._runtime.GetCurrentLayout().GetLayer(e);\n      if (t) {\n        const r = t.GetViewport3D();\n        return (r.getLeft() + r.getRight()) / 2;\n      }\n      return 0;\n    }, viewportmidy(e) {\n      const t = this._runtime.GetCurrentLayout().GetLayer(e);\n      if (t) {\n        const r = t.GetViewport3D();\n        return (r.getTop() + r.getBottom()) / 2;\n      }\n      return 0;\n    }, canvastolayerx(e, t, r) {\n      const n = this._runtime.GetCurrentLayout().GetLayer(e);\n      return n ? n.CanvasCssToLayer(t, r)[0] : 0;\n    }, canvastolayery(e, t, r) {\n      const n = this._runtime.GetCurrentLayout().GetLayer(e);\n      return n ? n.CanvasCssToLayer(t, r)[1] : 0;\n    }, layertocanvasx(e, t, r) {\n      const n = this._runtime.GetCurrentLayout().GetLayer(e);\n      return n ? n.LayerToCanvasCss(t, r)[0] : 0;\n    }, layertocanvasy(e, t, r) {\n      const n = this._runtime.GetCurrentLayout().GetLayer(e);\n      return n ? n.LayerToCanvasCss(t, r)[1] : 0;\n    }, layertolayerx(e, t, r, n) {\n      const a = this._runtime.GetCurrentLayout(), i = a.GetLayer(e), s = a.GetLayer(t);\n      if (!i || !s || i === s) return r;\n      const [o, u] = i.LayerToCanvasCss(r, n);\n      return s.CanvasCssToLayer(o, u)[0];\n    }, layertolayery(e, t, r, n) {\n      const a = this._runtime.GetCurrentLayout(), i = a.GetLayer(e), s = a.GetLayer(t);\n      if (!i || !s || i === s) return n;\n      const [o, u] = i.LayerToCanvasCss(r, n);\n      return s.CanvasCssToLayer(o, u)[1];\n    }, layerscale(e) {\n      const t = this._runtime.GetCurrentLayout().GetLayer(e);\n      return t ? t.GetOwnScale() : 0;\n    }, layerangle(e) {\n      const t = this._runtime.GetCurrentLayout().GetLayer(e);\n      return t ? Xf.toDegrees(t.GetOwnAngle()) : 0;\n    }, layeropacity(e) {\n      const t = this._runtime.GetCurrentLayout().GetLayer(e);\n      return t ? 100 * t.GetOpacity() : 0;\n    }, layerscalerate(e) {\n      const t = this._runtime.GetCurrentLayout().GetLayer(e);\n      return t ? t.GetScaleRate() : 0;\n    }, layerscrollx(e) {\n      const t = this._runtime.GetCurrentLayout().GetLayer(e);\n      return t ? t.GetScrollX() : 0;\n    }, layerscrolly(e) {\n      const t = this._runtime.GetCurrentLayout().GetLayer(e);\n      return t ? t.GetScrollY() : 0;\n    }, layerparallaxx(e) {\n      const t = this._runtime.GetCurrentLayout().GetLayer(e);\n      return t ? 100 * t.GetParallaxX() : 0;\n    }, layerparallaxy(e) {\n      const t = this._runtime.GetCurrentLayout().GetLayer(e);\n      return t ? 100 * t.GetParallaxY() : 0;\n    }, layerzelevation(e) {\n      const t = this._runtime.GetCurrentLayout().GetLayer(e);\n      return t ? t.GetZElevation() : 0;\n    }, layerindex(e) {\n      const t = this._runtime.GetCurrentLayout().GetLayer(e);\n      return t ? t.GetIndex() : -1;\n    }, canvassnapshot() {\n      const e = this._runtime.GetCanvasManager();\n      return e ? e.GetCanvasSnapshotUrl() : \"\";\n    }, loopindex(e) {\n      const t = this._loopStack;\n      if (!t.IsInLoop()) return 0;\n      if (e) {\n        const r = t.FindByName(e);\n        return r ? r.GetIndex() : 0;\n      }\n      return t.GetCurrent().GetIndex();\n    }, savestatejson() {\n      return this._runtime.GetLastSaveJsonString();\n    }, callmapped(e, t, ...r) {\n      const n = this._GetFunctionMap(e.toLowerCase(), false);\n      if (!n) return console.warn(`[Construct] Call mapped function: map name '${e}' not found; returning 0`), 0;\n      let a = n.strMap.get(t.toLowerCase());\n      if (!a) {\n        if (!n.defaultFunc) return console.warn(`[Construct] Call mapped function: no function associated with map '${e}' string '${t}'; returning 0 (consider setting a default)`), 0;\n        a = n.defaultFunc;\n      }\n      const i = a.GetReturnType(), s = a.GetDefaultReturnValue();\n      if (0 === i) return console.warn(`[Construct] Call mapped function: map '${e}' string '${t}' has no return type so cannot be called from an expression; returning 0`), 0;\n      if (!a.IsEnabled()) return s;\n      const o = this._runtime, u = o.GetEventSheetManager(), l = u.GetCurrentEvent(), c = l.GetSolModifiersIncludingParents(), h = 0 < c.length, g = (h && (a.IsCopyPicked() ? u.PushCopySol(c) : u.PushCleanSol(c)), a.GetFunctionParameters());\n      for (let e2 = r.length, t2 = g.length; e2 < t2; ++e2) r.push(g[e2].GetInitialValue());\n      const S = a.GetEventBlock(), d = S.RunAsExpressionFunctionCall(S.GetSolModifiersIncludingParents(), a.IsCopyPicked(), i, s, ...r);\n      return h && u.PopSol(c), d;\n    }, loadingprogress() {\n      return this._runtime.GetAssetManager().GetLoadProgress();\n    }, imageloadingprogress() {\n      return this.GetImageLoadingProgress();\n    }, renderer() {\n      return this._runtime.GetWebGPURenderer() ? \"webgpu\" : \"webgl\";\n    }, rendererdetail() {\n      return this._runtime.GetWebGPURenderer() ? this._runtime.GetWebGPURenderer().GetAdapterInfoString() : this._runtime.GetWebGLRenderer().GetUnmaskedRenderer();\n    }, imagememoryusage() {\n      let e = this._runtime.GetRenderer().GetEstimatedTextureMemoryUsage();\n      return Math.round(100 * e / 1048576) / 100;\n    }, rgb(e, t, r) {\n      return Xf.PackRGB(e, t, r);\n    }, rgbex(e, t, r) {\n      return Xf.PackRGBEx(e / 100, t / 100, r / 100);\n    }, rgba(e, t, r, n) {\n      return Xf.PackRGBAEx(e / 100, t / 100, r / 100, n / 100);\n    }, rgbex255(e, t, r) {\n      return Xf.PackRGBEx(e / 255, t / 255, r / 255);\n    }, rgba255(e, t, r, n) {\n      return Xf.PackRGBAEx(e / 255, t / 255, r / 255, n / 255);\n    }, projectname() {\n      return this._runtime.GetProjectName();\n    }, projectversion() {\n      return this._runtime.GetProjectVersion();\n    }, currenteventsheetname() {\n      return this._runtime.GetCurrentEvent().GetEventSheet().GetName();\n    }, currenteventnumber() {\n      return this._runtime.GetCurrentEvent().GetDisplayNumber();\n    } };\n  }\n}\nvar ForEachOrdered_SortInstances2;\nvar SortZOrderList2;\nvar SortInstancesByValue2;\n{\n  {\n    const a = self.C3;\n    a.Plugins.Text = class extends a.SDKPluginBase {\n      constructor(e) {\n        super(e);\n      }\n      Release() {\n        super.Release();\n      }\n    };\n  }\n  {\n    const d = self.C3;\n    d.Plugins.Text.Type = class extends d.SDKTypeBase {\n      constructor(e) {\n        super(e);\n      }\n      Release() {\n        super.Release();\n      }\n      OnCreate() {\n      }\n      LoadTextures(e) {\n      }\n      ReleaseTextures() {\n      }\n    };\n  }\n  {\n    const h = self.C3, i = self.C3X, j = [0, 0, 0], k = 0, l = 1, m = 2, n = 3, o = 4, p = 5, q = 6, r = 7, s = 8, t = 9, u = 10, v = 11, w = 12, x = 13, y = 14, z = 15, A = [\"left\", \"center\", \"right\"], B = [\"top\", \"center\", \"bottom\"], C = [\"ltr\", \"rtl\"], D = [\"word\", \"cjk\", \"character\"], E = new h.Rect(), F = new h.Quad(), G = new h.Color(), H = h.New(h.Vector2), I = /* @__PURE__ */ new Map([[\"b\", \"strong\"], [\"i\", \"em\"], [\"s\", \"s\"], [\"u\", \"u\"], [\"iconoffsety\", null]]), J = (h.Plugins.Text.Instance = class extends h.SDKWorldInstanceBase {\n      constructor(e, i2) {\n        if (super(e), this._text = \"\", this._enableBBcode = true, this._faceName = \"Arial\", this._ptSize = 12, this._lineHeightOffset = 0, this._isBold = false, this._isItalic = false, this._color = h.New(h.Color), this._horizontalAlign = 0, this._verticalAlign = 0, this._wrapMode = \"word\", this._textDirection = 0, this._resolutionMode = \"auto\", this._fixedScaleFactor = 1, this._iconObjectClass = null, this._htmlString = \"\", this._isHtmlStringUpToDate = false, this._readAloud = false, this._screenReaderText = null, this._typewriterStartTime = -1, this._typewriterEndTime = -1, this._typewriterLength = 0, this._rendererText = h.New(h.Gfx.RendererText, this._runtime.GetRenderer(), { timeout: 5 }), this._rendererText.ontextureupdate = () => this._runtime.UpdateRender(), this._animationframeimagechange_handler = () => this._OnIconObjectClassImageChanged(), this._pendingUpdateIconSet = false, i2) {\n          this._text = i2[k], this._enableBBcode = !!i2[l], this._faceName = i2[m], this._ptSize = i2[n], this._lineHeightOffset = i2[o], this._isBold = !!i2[p], this._isItalic = !!i2[q], this._horizontalAlign = i2[s], this._verticalAlign = i2[t], this._wrapMode = D[i2[u]], this._textDirection = i2[v], this._SetIconObjectClass(this._runtime.GetObjectClassBySID(i2[w]));\n          const a = i2[r];\n          this._color.setRgb(a[0], a[1], a[2]), this.GetWorldInfo().SetVisible(i2[x]), this._readAloud = !!i2[z];\n        }\n        this._UpdateTextSettings(), this._UpdateScreenReaderText();\n      }\n      Release() {\n        this._SetIconObjectClass(null), this._CancelTypewriter(), this._screenReaderText && (this._screenReaderText.Release(), this._screenReaderText = null), this._rendererText.Release(), this._rendererText = null, super.Release();\n      }\n      _UpdateTextSettings() {\n        const e = this._rendererText;\n        e.SetText(this._text), e.SetBBCodeEnabled(this._enableBBcode), this._rendererText.IsBBCodeEnabled() && this._iconObjectClass ? this._rendererText.SetIconSet(this.GetRuntime().GetTextIconSet(this._iconObjectClass)) : this._rendererText.SetIconSet(null), e.SetIconSmoothing(\"nearest\" !== this._runtime.GetSampling()), e.SetFontName(this._faceName), e.SetLineHeight(this._lineHeightOffset), e.SetBold(this._isBold), e.SetItalic(this._isItalic), e.SetColor(this._color), e.SetHorizontalAlignment(A[this._horizontalAlign]), e.SetVerticalAlignment(B[this._verticalAlign]), e.SetWordWrapMode(this._wrapMode), e.SetTextDirection(C[this._textDirection]);\n      }\n      _UpdateTextSize() {\n        const e = this.GetWorldInfo(), t2 = (this._rendererText.SetFontSize(this._ptSize), this._rendererText.SetFontSizeScale(e.GetSceneGraphScale()), e.GetLayer());\n        let i2;\n        \"auto\" === this._resolutionMode ? i2 = t2.GetResolutionScaleFactorToZ(e.GetTotalZElevation()) : \"fixed\" === this._resolutionMode && (i2 = this._fixedScaleFactor), e.HasMesh() && i2 !== this._rendererText.GetZoom() && e.SetMeshChanged(true), this._rendererText.SetSize(e.GetWidth(), e.GetHeight(), i2);\n      }\n      _SetIconObjectClass(e) {\n        e && (e.IsFamily() || e.GetPlugin().constructor !== h.Plugins.Sprite) || e !== this._iconObjectClass && (this._iconObjectClass && this._iconObjectClass.Dispatcher().removeEventListener(\"animationframeimagechange\", this._animationframeimagechange_handler), this._iconObjectClass = e, this._iconObjectClass && this._iconObjectClass.Dispatcher().addEventListener(\"animationframeimagechange\", this._animationframeimagechange_handler), this._UpdateTextSettings(), this._isHtmlStringUpToDate = false, this._runtime.UpdateRender());\n      }\n      _OnIconObjectClassImageChanged() {\n        this._runtime.DeleteTextIconSet(this._iconObjectClass), this._runtime.UpdateRender(), this._pendingUpdateIconSet = true;\n      }\n      _UpdateScreenReaderText() {\n        if (this._readAloud) {\n          let e = this._text;\n          this._enableBBcode && (e = h.BBString.StripAnyTags(e)), this._screenReaderText ? this._screenReaderText.SetText(e) : this._screenReaderText = h.New(h.ScreenReaderText, this._runtime, e);\n        } else this._screenReaderText && (this._screenReaderText.Release(), this._screenReaderText = null);\n      }\n      Draw(e) {\n        const t2 = this.GetWorldInfo(), i2 = (this._UpdateTextSize(), this._pendingUpdateIconSet && (this._pendingUpdateIconSet = false, this._rendererText.IsBBCodeEnabled()) && this._iconObjectClass && this._rendererText.SetIconSet(this.GetRuntime().GetTextIconSet(this._iconObjectClass)), this._rendererText.GetTexture());\n        if (i2) {\n          const s2 = t2.GetLayer();\n          if (0 === t2.GetAngle() && 0 === s2.GetAngle() && 0 === t2.GetTotalZElevation() && !t2.HasMesh() && s2.RendersIn2DMode()) {\n            const r2 = t2.GetBoundingQuad(), [n2, a] = s2.LayerToDrawSurface(r2.getTlx(), r2.getTly()), [o2, h2] = s2.LayerToDrawSurface(r2.getBrx(), r2.getBry()), _ = n2 - Math.round(n2), l2 = a - Math.round(a), [c, d] = (E.set(n2, a, o2, h2), E.offset(-_, -l2), F.setFromRect(E), e.GetRenderTargetSize(e.GetRenderTarget()));\n            this._runtime.GetCanvasManager().SetDeviceTransform(e, c, d), e.SetTexture(i2), e.Quad3(F, this._rendererText.GetTexRect()), s2._SetTransform(e);\n          } else e.SetTexture(i2), t2.HasMesh() ? this._DrawMesh(t2, e) : this._DrawStandard(t2, e);\n        }\n      }\n      _DrawStandard(e, t2) {\n        let i2 = e.GetBoundingQuad();\n        this._runtime.IsPixelRoundingEnabled() && (i2 = this._PixelRoundQuad(i2)), t2.Quad3(i2, this._rendererText.GetTexRect());\n      }\n      _DrawMesh(t2, e) {\n        const i2 = t2.GetTransformedMesh();\n        if (t2.IsMeshChanged()) {\n          t2.CalculateBbox(E, F, false);\n          let e2 = F;\n          this._runtime.IsPixelRoundingEnabled() && (e2 = this._PixelRoundQuad(e2)), i2.CalculateTransformedMesh(t2.GetSourceMesh(), e2, this._rendererText.GetTexRect()), t2.SetMeshChanged(false);\n        }\n        i2.Draw(e);\n      }\n      _PixelRoundQuad(e) {\n        const t2 = e.getTlx() - Math.round(e.getTlx()), i2 = e.getTly() - Math.round(e.getTly());\n        return 0 == t2 && 0 == i2 ? e : (F.copy(e), F.offset(-t2, -i2), F);\n      }\n      GetCurrentSurfaceSize() {\n        const e = this._rendererText.GetTexture();\n        return e ? [e.GetWidth(), e.GetHeight()] : [100, 100];\n      }\n      GetCurrentTexRect() {\n        return this._rendererText.GetTexRect();\n      }\n      IsCurrentTexRotated() {\n        return false;\n      }\n      SaveToJson() {\n        const e = { \"t\": this._text, \"c\": this._color.toJSON(), \"fn\": this._faceName, \"ps\": this._ptSize };\n        return this._enableBBcode && (e[\"bbc\"] = this._enableBBcode), 0 !== this._horizontalAlign && (e[\"ha\"] = this._horizontalAlign), 0 !== this._verticalAlign && (e[\"va\"] = this._verticalAlign), \"word\" !== this._wrapMode && (e[\"wr\"] = this._wrapMode), 0 !== this._lineHeightOffset && (e[\"lho\"] = this._lineHeightOffset), this._isBold && (e[\"b\"] = this._isBold), this._isItalic && (e[\"i\"] = this._isItalic), -1 !== this._typewriterEndTime && (e[\"tw\"] = { \"st\": this._typewriterStartTime, \"en\": this._typewriterEndTime, \"l\": this._typewriterLength }), this._iconObjectClass && (e[\"ioc\"] = this._iconObjectClass.GetSID()), \"fixed\" === this._resolutionMode && (e[\"fs\"] = this._fixedScaleFactor), e;\n      }\n      LoadFromJson(e) {\n        if (this._CancelTypewriter(), this._text = e[\"t\"], this._color.setFromJSON(e[\"c\"]), this._faceName = e[\"fn\"], this._ptSize = e[\"ps\"], this._enableBBcode = !!e.hasOwnProperty(\"bbc\") && e[\"bbc\"], this._horizontalAlign = e.hasOwnProperty(\"ha\") ? e[\"ha\"] : 0, this._verticalAlign = e.hasOwnProperty(\"va\") ? e[\"va\"] : 0, e.hasOwnProperty(\"wr\")) {\n          const t2 = e[\"wr\"];\n          this._wrapMode = \"boolean\" == typeof t2 ? t2 ? \"word\" : \"character\" : t2;\n        } else this._wrapMode = \"word\";\n        if (this._lineHeightOffset = e.hasOwnProperty(\"lho\") ? e[\"lho\"] : 0, this._isBold = !!e.hasOwnProperty(\"b\") && e[\"b\"], this._isItalic = !!e.hasOwnProperty(\"i\") && e[\"i\"], e.hasOwnProperty(\"tw\")) {\n          const i2 = e[\"tw\"];\n          this._typewriterStartTime = i2[\"st\"], this._typewriterEndTime = i2[\"en\"], this._typewriterLength = i2[\"l\"];\n        }\n        if (e.hasOwnProperty(\"ioc\")) {\n          const s2 = this.GetRuntime().GetObjectClassBySID(e[\"ioc\"]);\n          s2 && this._SetIconObjectClass(s2);\n        } else this._SetIconObjectClass(null);\n        e.hasOwnProperty(\"fs\") ? (this._resolutionMode = \"fixed\", this._fixedScaleFactor = e[\"fs\"]) : this._resolutionMode = \"auto\", this._UpdateTextSettings(), this._UpdateScreenReaderText(), this._isHtmlStringUpToDate = false, -1 !== this._typewriterEndTime && this._StartTicking();\n      }\n      GetPropertyValueByIndex(e) {\n        switch (e) {\n          case k:\n            return this.GetText();\n          case l:\n            return this._enableBBcode;\n          case m:\n            return this._GetFontFace();\n          case n:\n            return this._GetFontSize();\n          case o:\n            return this._GetLineHeight();\n          case p:\n            return this._IsBold();\n          case q:\n            return this._IsItalic();\n          case r:\n            return j[0] = this._color.getR(), j[1] = this._color.getG(), j[2] = this._color.getB(), j;\n          case s:\n            return this._GetHAlign();\n          case t:\n            return this._GetVAlign();\n          case u:\n            return this._GetWrapMode();\n          case z:\n            return this._IsReadAloud();\n        }\n      }\n      SetPropertyValueByIndex(e, i2) {\n        switch (e) {\n          case k:\n            this._SetText(i2);\n            break;\n          case l:\n            this._enableBBcode !== !!i2 && (this._enableBBcode = !!i2, this._UpdateTextSettings());\n            break;\n          case m:\n            this._SetFontFace(i2);\n            break;\n          case n:\n            this._SetFontSize(i2);\n            break;\n          case o:\n            this._SetLineHeight(i2);\n            break;\n          case p:\n            this._SetBold(i2);\n            break;\n          case q:\n            this._SetItalic(i2);\n            break;\n          case r:\n            const a = this._color, h2 = i2;\n            a.getR() === h2[0] && a.getG() === h2[1] && a.getB() === h2[2] || (this._color.setRgb(h2[0], h2[1], h2[2]), this._UpdateTextSettings());\n            break;\n          case s:\n            this._SetHAlign(i2);\n            break;\n          case t:\n            this._SetVAlign(i2);\n            break;\n          case u:\n            this._SetWrapMode(i2);\n        }\n      }\n      SetPropertyColorOffsetValueByIndex(e, t2, i2, s2) {\n        0 === t2 && 0 === i2 && 0 === s2 || e === r && (this._color.addRgb(t2, i2, s2), this._UpdateTextSettings());\n      }\n      _SetText(e) {\n        this._text !== e && (this._text = e, this._rendererText.SetText(e), this._UpdateScreenReaderText(), this._isHtmlStringUpToDate = false, this._runtime.UpdateRender());\n      }\n      GetText() {\n        return this._text;\n      }\n      _StartTypewriter(e, t2) {\n        this._UpdateTextSize(), this._SetText(e), this._typewriterStartTime = this._runtime.GetWallTime(), this._typewriterEndTime = this._typewriterStartTime + t2 / this.GetInstance().GetActiveTimeScale(), this._typewriterLength = this._rendererText.GetLengthInGraphemes(), this._rendererText.SetDrawMaxCharacterCount(0), this._StartTicking();\n      }\n      _CancelTypewriter() {\n        this._typewriterStartTime = -1, this._typewriterEndTime = -1, this._typewriterLength = 0, this._rendererText.SetDrawMaxCharacterCount(-1), this._StopTicking();\n      }\n      _FinishTypewriter() {\n        -1 !== this._typewriterEndTime && (this._CancelTypewriter(), this.Trigger(h.Plugins.Text.Cnds.OnTypewriterTextFinished), this._runtime.UpdateRender());\n      }\n      _SetFontFace(e) {\n        this._faceName !== e && (this._faceName = e, this._rendererText.SetFontName(e), this._runtime.UpdateRender());\n      }\n      _GetFontFace() {\n        return this._faceName;\n      }\n      _SetBold(e) {\n        this._isBold !== (e = !!e) && (this._isBold = e, this._rendererText.SetBold(e), this._runtime.UpdateRender());\n      }\n      _IsBold() {\n        return this._isBold;\n      }\n      _SetItalic(e) {\n        this._isItalic !== (e = !!e) && (this._isItalic = e, this._rendererText.SetItalic(e), this._runtime.UpdateRender());\n      }\n      _IsItalic() {\n        return this._isItalic;\n      }\n      _SetFontSize(e) {\n        this._ptSize !== e && (this._ptSize = e, this._runtime.UpdateRender());\n      }\n      _GetFontSize() {\n        return this._ptSize;\n      }\n      _SetFontColor(e) {\n        this._color.equalsIgnoringAlpha(e) || (this._color.copyRgb(e), this._rendererText.SetColor(this._color), this._runtime.UpdateRender());\n      }\n      _GetFontColor() {\n        return this._color;\n      }\n      _SetLineHeight(e) {\n        this._lineHeightOffset !== e && (this._lineHeightOffset = e, this._UpdateTextSettings(), this._runtime.UpdateRender());\n      }\n      _GetLineHeight() {\n        return this._lineHeightOffset;\n      }\n      _SetHAlign(e) {\n        this._horizontalAlign !== e && (this._horizontalAlign = e, this._UpdateTextSettings(), this._runtime.UpdateRender());\n      }\n      _GetHAlign() {\n        return this._horizontalAlign;\n      }\n      _SetVAlign(e) {\n        this._verticalAlign !== e && (this._verticalAlign = e, this._UpdateTextSettings(), this._runtime.UpdateRender());\n      }\n      _GetVAlign() {\n        return this._verticalAlign;\n      }\n      _SetWrapModeByIndex(e) {\n        this._SetWrapMode(D[e]);\n      }\n      _SetWrapMode(e) {\n        this._wrapMode !== e && (this._wrapMode = e, this._UpdateTextSettings(), this._runtime.UpdateRender());\n      }\n      _GetWrapMode() {\n        return this._wrapMode;\n      }\n      _SetTextDirection(e) {\n        this._textDirection !== e && (this._textDirection = e, this._UpdateTextSettings(), this._runtime.UpdateRender());\n      }\n      _GetTextDirection() {\n        return this._textDirection;\n      }\n      _SetReadAloud(e) {\n        this._readAloud = !!e, this._UpdateScreenReaderText();\n      }\n      _IsReadAloud() {\n        return this._readAloud;\n      }\n      _SetResolutionMode(e) {\n        this._resolutionMode !== e && (this._resolutionMode = e, this._runtime.UpdateRender());\n      }\n      _GetResolutionMode() {\n        return this._resolutionMode;\n      }\n      _SetFixedScaleFactor(e) {\n        this._fixedScaleFactor !== e && (this._fixedScaleFactor = e, \"fixed\" === this._resolutionMode) && this._runtime.UpdateRender();\n      }\n      _GetFixedScaleFactor() {\n        return this._fixedScaleFactor;\n      }\n      _GetTextWidth() {\n        return this._UpdateTextSize(), this._rendererText.GetTextWidth();\n      }\n      _GetTextHeight() {\n        return this._UpdateTextSize(), this._rendererText.GetTextHeight();\n      }\n      _GetTagAtPosition(e, t2) {\n        this._UpdateTextSize();\n        const i2 = this.GetWorldInfo(), s2 = (H.set(e - i2.GetX(), t2 - i2.GetY()), H.rotate(-i2.GetAngle()), H.offset(i2.GetWidth() * i2.GetOriginX(), i2.GetHeight() * i2.GetOriginY()), H.divide(i2.GetWidth(), i2.GetHeight()), H.scale(this._rendererText.GetWidth(), this._rendererText.GetHeight()), this._rendererText.HitTestFragment(H.getX(), H.getY()));\n        if (s2) {\n          const r2 = s2.GetStyleTag(\"tag\");\n          if (r2) return r2.param;\n        }\n        return \"\";\n      }\n      _HasTagAtPosition(e, t2, i2) {\n        const s2 = this._GetTagAtPosition(t2, i2);\n        return s2 && h.equalsNoCase(e, s2);\n      }\n      _GetTagPosition(e, t2) {\n        this._UpdateTextSize(), t2 = Math.floor(t2);\n        const i2 = this._rendererText.FindFragmentWithTag(e, t2);\n        if (!i2) return null;\n        const s2 = this.GetWorldInfo(), r2 = this._rendererText.GetDrawScale(), n2 = i2.GetPosX(), a = i2.GetPosY() - (i2.GetHeight() - i2.GetFontBoundingBoxDescent()) * r2, o2 = i2.GetWidth() * r2 / this._rendererText.GetWidth() * s2.GetWidth(), h2 = i2.GetHeight() * r2 / this._rendererText.GetHeight() * s2.GetHeight();\n        return H.set(n2, a), H.divide(this._rendererText.GetWidth(), this._rendererText.GetHeight()), H.scale(s2.GetWidth(), s2.GetHeight()), H.offset(-s2.GetWidth() * s2.GetOriginX(), -s2.GetHeight() * s2.GetOriginY()), H.rotate(s2.GetAngle()), H.offset(s2.GetX(), s2.GetY()), { x: H.getX(), y: H.getY(), width: o2, height: h2 };\n      }\n      _GetTagCount(e) {\n        return this._UpdateTextSize(), this._rendererText.CountFragmentsWithTag(e);\n      }\n      _GetHTMLCloseTag(e) {\n        let t2 = I.get(e);\n        return null === t2 ? \"\" : `</${(t2 = t2 || \"span\") || \"span\"}>`;\n      }\n      _GetHTMLOpenTag(e, t2) {\n        let i2 = I.get(e);\n        if (null === i2) return \"\";\n        switch (i2 = i2 || \"span\", e) {\n          case \"color\":\n            return `<${i2} style=\"color: ${t2}\">`;\n          case \"font\":\n            return `<${i2} style=\"font-family: '${t2}'\">`;\n          case \"opacity\":\n            return `<${i2} style=\"opacity: ${t2}%\">`;\n          case \"size\":\n            return `<${i2} style=\"font-size: ${t2}pt\">`;\n          case \"background\":\n            return `<${i2} style=\"background-color: ${t2}\">`;\n          case \"hide\":\n            return `<${i2} style=\"visibility: hidden\">`;\n          case \"class\":\n            return `<${i2} class=\"${t2}\">`;\n          case \"tag\":\n            return `<${i2} data-tag=\"${t2}\">`;\n          default:\n            return `<${i2}>`;\n        }\n      }\n      async _UpdateHTMLString() {\n        if (!this._isHtmlStringUpToDate) {\n          const e = new h.BBString(this._text, { noEscape: true }).toFragmentList(), t2 = /* @__PURE__ */ new Map();\n          let i2 = '<span class=\"c3-text\"';\n          const s2 = [], r2 = (s2.push(`font-family: '${this._GetFontFace()}';`), this._IsBold() && s2.push(\"font-weight: bold;\"), this._IsItalic() && s2.push(\"font-style: italic;\"), \"character\" === this._GetWrapMode() && s2.push(\"word-break: break-all;\"), i2 += ` style=\"${s2.join(\" \")}\">`, this._iconObjectClass ? this.GetRuntime().GetTextIconSet(this._iconObjectClass) : null);\n          if (this._iconObjectClass) {\n            const o2 = h.New(h.PromiseThrottle), _ = [], l2 = /* @__PURE__ */ new Map();\n            for (const d of e) if (d.IsIcon()) {\n              const g = d.GetTextIcon(r2);\n              if (g) {\n                const u2 = g.GetSource(), T = u2.GetImageInfo().GetImageAsset();\n                l2.has(T) || (l2.set(T, null), _.push(o2.Add(async () => {\n                  const e2 = await T.LoadToDrawable();\n                  l2.set(T, e2);\n                })));\n              }\n            }\n            await Promise.all(_);\n            const c = [];\n            for (const S of e) if (S.IsIcon()) {\n              const p2 = S.GetTextIcon(r2);\n              if (p2) {\n                const x2 = p2.GetSource(), G2 = x2.GetImageInfo().GetImageAsset();\n                c.push(o2.Add(async () => {\n                  const e2 = await x2.GetImageInfo().ExtractImageToBlobURL(l2.get(G2));\n                  t2.set(p2, e2);\n                }));\n              }\n            }\n            await Promise.all(c);\n            for (const m2 of l2.values()) m2 instanceof ImageBitmap && m2[\"close\"] && m2[\"close\"]();\n          }\n          const n2 = /* @__PURE__ */ new Map();\n          for (const f of e) {\n            const w2 = f.GetStyleMap();\n            let e2 = [...n2.keys()];\n            e2.reverse();\n            for (const I2 of e2) w2.has(I2) && w2.get(I2) === n2.get(I2) || (n2.delete(I2), i2 += this._GetHTMLCloseTag(I2));\n            for (const [R, y2] of w2) n2.has(R) || (n2.set(R, y2), i2 += this._GetHTMLOpenTag(R, y2));\n            if (f.IsText() && (i2 += h.ReplaceAll(h.EscapeHTML(f.GetCharacterArray().join(\"\")), \"\\n\", \"<br>\")), f.IsIcon() && r2) {\n              const b = f.GetTextIcon(r2);\n              if (b) {\n                const C2 = t2.get(b);\n                if (C2) {\n                  const s3 = [];\n                  let t3 = \"0.2em\";\n                  const F2 = w2.get(\"iconoffsety\");\n                  if (F2) {\n                    let e3 = F2.trim();\n                    t3 = e3.endsWith(\"%\") ? parseFloat(e3) / 100 + \"em\" : e3 + \"px\";\n                  }\n                  s3.push(\"top: \" + t3), \"nearest\" === this._runtime.GetSampling() && s3.push(\"image-rendering: pixelated\"), i2 += `<img class=\"c3-text-icon\" data-icon=\"${f.GetIconParameter()}\" width=\"${b.GetWidth()}\" height=\"${b.GetHeight()}\" style=\"${s3.join(\";\")}\" src=\"${C2}\">`;\n                }\n              }\n            }\n          }\n          const a = [...n2.keys()];\n          a.reverse();\n          for (const A2 of a) i2 += this._GetHTMLCloseTag(A2);\n          i2 += \"</span>\", this._htmlString = i2, this._isHtmlStringUpToDate = true;\n        }\n        return this._htmlString;\n      }\n      Tick() {\n        const t2 = this._runtime.GetWallTime();\n        if (t2 >= this._typewriterEndTime) this._CancelTypewriter(), this.Trigger(h.Plugins.Text.Cnds.OnTypewriterTextFinished), this._runtime.UpdateRender();\n        else {\n          let e = h.relerp(this._typewriterStartTime, this._typewriterEndTime, t2, 0, this._typewriterLength);\n          (e = Math.floor(e)) !== this._rendererText.GetDrawMaxCharacterCount() && (this._rendererText.SetDrawMaxCharacterCount(e), this._runtime.UpdateRender());\n        }\n      }\n      GetDebuggerProperties() {\n        const e = \"plugins.text\";\n        return [{ title: e + \".name\", properties: [{ name: e + \".properties.text.name\", value: this.GetText(), onedit: (e2) => this._SetText(e2) }, { name: e + \".properties.font.name\", value: this._GetFontFace(), onedit: (e2) => this._SetFontFace(e2) }, { name: e + \".properties.size.name\", value: this._GetFontSize(), onedit: (e2) => this._SetFontSize(e2) }, { name: e + \".properties.line-height.name\", value: this._GetLineHeight(), onedit: (e2) => this._SetLineHeight(e2) }, { name: e + \".properties.bold.name\", value: this._IsBold(), onedit: (e2) => this._SetBold(e2) }, { name: e + \".properties.italic.name\", value: this._IsItalic(), onedit: (e2) => this._SetItalic(e2) }] }];\n      }\n      GetScriptInterfaceClass() {\n        return self.ITextInstance;\n      }\n    }, /* @__PURE__ */ new WeakMap()), K = /* @__PURE__ */ new Map([[\"left\", 0], [\"center\", 1], [\"right\", 2]]), L = /* @__PURE__ */ new Map([[\"top\", 0], [\"center\", 1], [\"bottom\", 2]]), M = [\"ltr\", \"rtl\"], N = /* @__PURE__ */ new Set([\"auto\", \"fixed\"]);\n    self.ITextInstance = class extends self.IWorldInstance {\n      constructor() {\n        super(), J.set(this, self.IInstance._GetInitInst().GetSdkInstance());\n      }\n      get text() {\n        return J.get(this).GetText();\n      }\n      set text(e) {\n        i.RequireString(e);\n        const t2 = J.get(this);\n        t2._CancelTypewriter(), t2._SetText(e);\n      }\n      typewriterText(e, t2) {\n        i.RequireString(e), i.RequireFiniteNumber(t2);\n        const s2 = J.get(this);\n        s2._CancelTypewriter(), s2._StartTypewriter(e, t2);\n      }\n      typewriterFinish() {\n        J.get(this)._FinishTypewriter();\n      }\n      set fontFace(e) {\n        i.RequireString(e), J.get(this)._SetFontFace(e);\n      }\n      get fontFace() {\n        return J.get(this)._GetFontFace();\n      }\n      set isBold(e) {\n        J.get(this)._SetBold(e);\n      }\n      get isBold() {\n        return J.get(this)._IsBold();\n      }\n      set isItalic(e) {\n        J.get(this)._SetItalic(e);\n      }\n      get isItalic() {\n        return J.get(this)._IsItalic();\n      }\n      set sizePt(e) {\n        i.RequireFiniteNumber(e), J.get(this)._SetFontSize(e);\n      }\n      get sizePt() {\n        return J.get(this)._GetFontSize();\n      }\n      set fontColor(e) {\n        if (i.RequireArray(e), e.length < 3) throw new Error(\"expected 3 elements\");\n        G.setRgb(e[0], e[1], e[2]), J.get(this)._SetFontColor(G);\n      }\n      get fontColor() {\n        const e = J.get(this)._GetFontColor();\n        return [e.getR(), e.getG(), e.getB()];\n      }\n      set lineHeight(e) {\n        i.RequireFiniteNumber(e), J.get(this)._SetLineHeight(e);\n      }\n      get lineHeight() {\n        return J.get(this)._GetLineHeight();\n      }\n      set horizontalAlign(e) {\n        i.RequireString(e);\n        const t2 = K.get(e);\n        if (void 0 === t2) throw new Error(\"invalid mode\");\n        J.get(this)._SetHAlign(t2);\n      }\n      get horizontalAlign() {\n        return A[J.get(this)._GetHAlign()];\n      }\n      set verticalAlign(e) {\n        i.RequireString(e);\n        const t2 = L.get(e);\n        if (void 0 === t2) throw new Error(\"invalid mode\");\n        J.get(this)._SetVAlign(t2);\n      }\n      get verticalAlign() {\n        return B[J.get(this)._GetVAlign()];\n      }\n      set wordWrapMode(e) {\n        if (!D.includes(e)) throw new Error(\"invalid mode\");\n        J.get(this)._SetWrapMode(e);\n      }\n      get wordWrapMode() {\n        return J.get(this)._GetWrapMode();\n      }\n      set textDirection(e) {\n        i.RequireString(e);\n        const t2 = M.indexOf(e);\n        if (-1 === t2) throw new Error(\"invalid text direction\");\n        J.get(this)._SetTextDirection(t2);\n      }\n      get textDirection() {\n        return M[J.get(this)._GetTextDirection()];\n      }\n      set readAloud(e) {\n        J.get(this)._SetReadAloud(!!e);\n      }\n      get readAloud() {\n        return J.get(this)._IsReadAloud();\n      }\n      setFixedResolutionMode(e) {\n        i.RequireFiniteNumber(e);\n        const t2 = J.get(this);\n        t2._SetResolutionMode(\"fixed\"), t2._SetFixedScaleFactor(e);\n      }\n      setAutoResolutionMode() {\n        J.get(this)._SetResolutionMode(\"auto\");\n      }\n      get textWidth() {\n        return J.get(this)._GetTextWidth();\n      }\n      get textHeight() {\n        return J.get(this)._GetTextHeight();\n      }\n      getTextSize() {\n        const e = J.get(this);\n        return [e._GetTextWidth(), e._GetTextHeight()];\n      }\n      hasTagAtPosition(e, t2, s2) {\n        return i.RequireString(e), i.RequireFiniteNumber(t2), i.RequireFiniteNumber(s2), J.get(this)._HasTagAtPosition(e, t2, s2);\n      }\n      getTagAtPosition(e, t2) {\n        return i.RequireFiniteNumber(e), i.RequireFiniteNumber(t2), J.get(this)._GetTagAtPosition(e, t2);\n      }\n      getTagPositionAndSize(e, t2 = 0) {\n        return i.RequireString(e), i.RequireFiniteNumber(t2), J.get(this)._GetTagPosition(e, t2);\n      }\n      getTagCount(e) {\n        return i.RequireString(e), J.get(this)._GetTagCount(e);\n      }\n      changeIconSet(e) {\n        const t2 = J.get(this), i2 = t2.GetRuntime()._UnwrapIObjectClass(e);\n        t2._SetIconObjectClass(i2);\n      }\n      getAsHtmlString() {\n        return J.get(this)._UpdateHTMLString();\n      }\n    };\n  }\n  {\n    const Tb = self.C3;\n    Tb.Plugins.Text.Cnds = { CompareText(e, t) {\n      return t ? this._text === e : Tb.equalsNoCase(this._text, e);\n    }, IsRunningTypewriterText() {\n      return -1 !== this._typewriterEndTime;\n    }, OnTypewriterTextFinished() {\n      return true;\n    }, HasTagAtPosition(e, t, i) {\n      return this._HasTagAtPosition(e, t, i);\n    } };\n  }\n  {\n    const Zb = self.C3, $b = Zb.New(Zb.Color);\n    Zb.Plugins.Text.Acts = { SetText(e) {\n      this._CancelTypewriter(), \"number\" == typeof e && e < 1e9 && (e = Math.round(1e10 * e) / 1e10), this._SetText(e.toString());\n    }, AppendText(e) {\n      this._CancelTypewriter(), (e = (e = \"number\" == typeof e && e < 1e9 ? Math.round(1e10 * e) / 1e10 : e).toString()) && this._SetText(this._text + e);\n    }, TypewriterText(e, t) {\n      this._CancelTypewriter(), \"number\" == typeof e && e < 1e9 && (e = Math.round(1e10 * e) / 1e10), this._StartTypewriter(e.toString(), t);\n    }, SetFontFace(e, t) {\n      let i = false, s = false;\n      switch (t) {\n        case 1:\n          i = true;\n          break;\n        case 2:\n          s = true;\n          break;\n        case 3:\n          i = true, s = true;\n      }\n      e === this._faceName && i === this._isBold && s === this._isItalic || (this._SetFontFace(e), this._SetBold(i), this._SetItalic(s));\n    }, SetFontSize(e) {\n      this._SetFontSize(e);\n    }, SetFontColor(e) {\n      $b.setFromRgbValue(e), $b.clamp(), this._SetFontColor($b);\n    }, SetWebFont(e, t) {\n      console.warn(\"[Text] 'Set web font' action is deprecated and no longer has any effect\");\n    }, SetEffect(e) {\n      this.GetWorldInfo().SetBlendMode(e), this._runtime.UpdateRender();\n    }, TypewriterFinish() {\n      this._FinishTypewriter();\n    }, SetLineHeight(e) {\n      this._SetLineHeight(e);\n    }, SetHAlign(e) {\n      this._SetHAlign(e);\n    }, SetVAlign(e) {\n      this._SetVAlign(e);\n    }, SetWrapping(e) {\n      this._SetWrapModeByIndex(e);\n    }, SetTextDirection(e) {\n      this._SetTextDirection(e);\n    }, ChangeIconSet(e) {\n      this._SetIconObjectClass(e);\n    }, UpdateHTML() {\n      return this._UpdateHTMLString();\n    }, SetReadAloud(e) {\n      this._SetReadAloud(e);\n    }, SetResolutionMode(e, t) {\n      this._SetResolutionMode([\"auto\", \"fixed\"][e]), this._SetFixedScaleFactor(t);\n    } };\n  }\n  {\n    const v1 = self.C3;\n    v1.Plugins.Text.Exps = { Text() {\n      return this._text;\n    }, PlainText() {\n      return this._enableBBcode ? v1.BBString.StripAnyTags(this._text) : this._text;\n    }, FaceName() {\n      return this._faceName;\n    }, FaceSize() {\n      return this._ptSize;\n    }, TextWidth() {\n      return this._GetTextWidth();\n    }, TextHeight() {\n      return this._GetTextHeight();\n    }, LineHeight() {\n      return this._lineHeightOffset;\n    }, TagAtPosition(e, t) {\n      return this._GetTagAtPosition(e, t);\n    }, TagCount(e) {\n      return this._GetTagCount(e);\n    }, TagX(e, t) {\n      const i = this._GetTagPosition(e, t);\n      return i ? i.x : 0;\n    }, TagY(e, t) {\n      const i = this._GetTagPosition(e, t);\n      return i ? i.y : 0;\n    }, TagWidth(e, t) {\n      const i = this._GetTagPosition(e, t);\n      return i ? i.width : 0;\n    }, TagHeight(e, t) {\n      const i = this._GetTagPosition(e, t);\n      return i ? i.height : 0;\n    }, AsHTML() {\n      return this._htmlString;\n    } };\n  }\n}\n{\n  {\n    const a = self.C3;\n    a.Plugins.Sprite = class extends a.SDKPluginBase {\n      constructor(t) {\n        super(t);\n      }\n      Release() {\n        super.Release();\n      }\n    };\n  }\n  {\n    const d = self.C3, e = self.C3X, f = [], g = (d.Plugins.Sprite.Type = class extends d.SDKTypeBase {\n      constructor(t) {\n        super(t), this._animations = t.GetAnimations();\n      }\n      Release() {\n        d.clearArray(this._animations), super.Release();\n      }\n      OnCreate() {\n        for (const t of this._animations) t.LoadAllAssets(this._runtime);\n      }\n      LoadTextures(e2) {\n        const n = { sampling: this._runtime.GetSampling() };\n        return Promise.all(this._animations.map((t) => t.LoadAllTextures(e2, n)));\n      }\n      ReleaseTextures() {\n        for (const t of this._animations) t.ReleaseAllTextures();\n      }\n      OnDynamicTextureLoadComplete() {\n        this._UpdateAllCurrentTexture();\n      }\n      _UpdateAllCurrentTexture() {\n        for (const t of this._objectClass.instancesIncludingPendingCreate()) t.GetSdkInstance()._UpdateCurrentTexture();\n      }\n      FinishCondition(t) {\n        d.Plugins.Sprite.FinishCollisionCondition(this, t);\n      }\n      BeforeRunAction(t) {\n        f.push({ objectClass: null, createHierarchy: false, instances: [] });\n      }\n      _SpawnPickInstance(t, e2, n) {\n        const i = f.at(-1);\n        i.objectClass = t, i.createHierarchy = n, i.instances.push(e2);\n      }\n      AfterRunAction(t) {\n        const e2 = f.pop(), n = e2.objectClass, i = e2.createHierarchy;\n        if (n) {\n          const r = /* @__PURE__ */ new Map();\n          for (const a of e2.instances) a.CollectInstancesToPick(r, n, i);\n          for (const [s, o] of r) s.GetCurrentSol().SetSetPicked(o);\n        }\n      }\n      _AddAnimation(t) {\n        const e2 = this.GetObjectClass().AddAnimation(t), n = this.GetRuntime(), i = e2.GetFrameAt(0);\n        return i.GetImageInfo().LoadStaticTexture(n.GetRenderer(), { sampling: n.GetSampling() }).then(() => this._UpdateAllCurrentTexture()), e2;\n      }\n      _RemoveAnimation(t) {\n        for (const e2 of this._objectClass.instancesIncludingPendingCreate()) e2.GetSdkInstance()._OnAnimationRemoved(t);\n        this.GetObjectClass().RemoveAnimation(t);\n      }\n      _AddAnimationFrame(t, e2) {\n        const n = this._objectClass.GetAnimationByName(t);\n        if (!n) throw new Error(`cannot find animation name '${t}'`);\n        let i = n.FrameTagOrIndexToIndex(e2);\n        i < 0 && (i += n.GetFrameCount() + 1);\n        const r = d.AnimationFrameInfo.CreateDynamic(this.GetRuntime()), a = (n.InsertFrameAt(r, i), this.GetRuntime());\n        r.GetImageInfo().LoadStaticTexture(a.GetRenderer(), { sampling: a.GetSampling() }).then(() => this._UpdateAllCurrentTexture());\n        for (const s of this._objectClass.instancesIncludingPendingCreate()) s.GetSdkInstance()._OnAnimationFramesChanged();\n        return r;\n      }\n      _RemoveAnimationFrame(t, e2) {\n        const n = this._objectClass.GetAnimationByName(t);\n        if (!n) throw new Error(`cannot find animation name '${t}'`);\n        if (1 === n.GetFrameCount()) throw new Error(`cannot remove last frame from animation '${t}'`);\n        let i = n.FrameTagOrIndexToIndex(e2);\n        i < 0 && (i += n.GetFrameCount()), n.RemoveFrameAt(i);\n        for (const r of this._objectClass.instancesIncludingPendingCreate()) r.GetSdkInstance()._OnAnimationFramesChanged();\n      }\n      GetScriptInterfaceClass() {\n        return self.ISpriteObjectType;\n      }\n    }, /* @__PURE__ */ new WeakMap());\n    self.ISpriteObjectType = class extends self.IObjectClass {\n      constructor(t) {\n        super(t), g.set(this, t.GetSdkType());\n      }\n      getAnimation(t) {\n        e.RequireString(t);\n        const n = g.get(this).GetObjectClass().GetAnimationByName(t);\n        return n ? n.GetIAnimation() : null;\n      }\n      getAllAnimations() {\n        return g.get(this).GetObjectClass().GetAllAnimations().map((t) => t.GetIAnimation());\n      }\n      addAnimation(t) {\n        return e.RequireString(t), g.get(this)._AddAnimation(t).GetIAnimation();\n      }\n      removeAnimation(t) {\n        e.RequireString(t), g.get(this)._RemoveAnimation(t);\n      }\n      addAnimationFrame(t, n) {\n        if (e.RequireString(t), \"number\" != typeof n && \"string\" != typeof n) throw new TypeError(\"invalid insert location\");\n        return g.get(this)._AddAnimationFrame(t, n).GetIAnimationFrame();\n      }\n      removeAnimationFrame(t, n) {\n        if (e.RequireString(t), \"number\" != typeof n && \"string\" != typeof n) throw new TypeError(\"invalid insert location\");\n        g.get(this)._RemoveAnimationFrame(t, n);\n      }\n    };\n  }\n  {\n    const ea = self.C3, fa = self.C3X, ga = 0, ha = 1, ia = 2, ja = 3, ka = ea.New(ea.Rect), la = ea.New(ea.Quad), ma = ea.New(ea.Vector2), na = 1, oa = 2, pa = 4, qa = (ea.Plugins.Sprite.Instance = class extends ea.SDKWorldInstanceBase {\n      constructor(t, e) {\n        super(t);\n        let n = true, i = \"\", r = 0, a = true;\n        e && (n = !!e[ga], i = e[ha], r = e[ia], a = e[ja]), this._currentAnimation = this._objectClass.GetAnimationByName(i) || this._objectClass.GetAnimations()[0], this._currentFrameIndex = ea.clamp(r, 0, this._currentAnimation.GetFrameCount() - 1), this._currentAnimationFrame = this._currentAnimation.GetFrameAt(this._currentFrameIndex);\n        const s = this._currentAnimationFrame.GetImageInfo(), o = (this._currentTexture = s.GetTexture(), this._currentRcTex = s.GetTexRect(), this._currentQuadTex = s.GetTexQuad(), this.HandleRendererContextLoss(), t.SetFlag(oa, true), t.SetFlag(na, 0 <= this._currentAnimation.GetSpeed()), this._currentAnimationSpeed = Math.abs(this._currentAnimation.GetSpeed()), this._currentAnimationRepeatTo = this._currentAnimation.GetRepeatTo(), this._animationTimer = ea.New(ea.KahanSum), this._frameStartTime = 0, this._animationRepeats = 0, this._animTriggerName = \"\", this._changeAnimFrameIndex = -1, this._changeAnimationName = \"\", this._changeAnimationFrom = 0, this.GetWorldInfo());\n        this._bquadRef = o.GetBoundingQuad(), o.SetVisible(n), o.SetCollisionEnabled(a), o.SetOriginX(this._currentAnimationFrame.GetOriginX()), o.SetOriginY(this._currentAnimationFrame.GetOriginY()), o.SetSourceCollisionPoly(this._currentAnimationFrame.GetCollisionPoly()), o.SetBboxChanged(), 1 === this._objectClass.GetAnimationCount() && 1 === this._objectClass.GetAnimations()[0].GetFrameCount() || 0 === this._currentAnimationSpeed || this._StartTicking();\n      }\n      Release() {\n        this._currentAnimation = null, this._currentAnimationFrame = null, this._currentTexture = null, this._animationTimer = null, super.Release();\n      }\n      GetCurrentImageInfo() {\n        return this._currentAnimationFrame.GetImageInfo();\n      }\n      IsOriginalSizeKnown() {\n        return true;\n      }\n      OnRendererContextLost() {\n        this._currentTexture = null;\n      }\n      OnRendererContextRestored() {\n        this._UpdateCurrentTexture();\n      }\n      Draw(t) {\n        const e = this._currentTexture;\n        if (null !== e) {\n          t.SetTexture(e);\n          const n = this.GetWorldInfo();\n          n.HasMesh() ? this._DrawMesh(n, t) : this._DrawStandard(n, t);\n        }\n      }\n      _DrawStandard(t, e) {\n        let n = this._bquadRef;\n        this._runtime.IsPixelRoundingEnabled() && (n = t.PixelRoundQuad(n)), e.Quad4(n, this._currentQuadTex);\n      }\n      _DrawMesh(e, t) {\n        const n = e.GetTransformedMesh();\n        if (e.IsMeshChanged()) {\n          e.CalculateBbox(ka, la, false);\n          let t2 = la;\n          this._runtime.IsPixelRoundingEnabled() && (t2 = e.PixelRoundQuad(t2)), n.CalculateTransformedMesh(e.GetSourceMesh(), t2, this._currentQuadTex), e.SetMeshChanged(false);\n        }\n        n.Draw(t);\n      }\n      GetAnimationTime() {\n        return this._animationTimer.Get();\n      }\n      IsAnimationPlaying() {\n        return this._inst.GetFlag(oa);\n      }\n      SetAnimationPlaying(t) {\n        this._inst.SetFlag(oa, t);\n      }\n      IsPlayingForwards() {\n        return this._inst.GetFlag(na);\n      }\n      SetPlayingForwards(t) {\n        this._inst.SetFlag(na, t);\n      }\n      IsInAnimationTrigger() {\n        return this._inst.GetFlag(pa);\n      }\n      SetInAnimationTrigger(t) {\n        this._inst.SetFlag(pa, t);\n      }\n      Tick() {\n        this._changeAnimationName && this._DoChangeAnimation(), 0 <= this._changeAnimFrameIndex && this._DoChangeAnimFrame();\n        const t = this._currentAnimationSpeed;\n        if (this.IsAnimationPlaying() && 0 !== t) {\n          const e = this._runtime.GetDt(this._inst), n = (this._animationTimer.Add(e), this.GetAnimationTime()), i = this._currentAnimationFrame, r = i.GetDuration() / t;\n          if (!(n < this._frameStartTime + r)) {\n            const a = this._currentAnimation, s = this._currentAnimationRepeatTo, o = a.GetFrameCount(), m = a.GetRepeatCount(), h = a.IsLooping(), u = a.IsPingPong(), c = (this.IsPlayingForwards() ? this._currentFrameIndex++ : this._currentFrameIndex--, this._frameStartTime += r, this._currentFrameIndex >= o && (u ? (this.SetPlayingForwards(false), this._currentFrameIndex = o - 2) : !h && (this._animationRepeats++, this._animationRepeats >= m) ? this._FinishAnimation(false) : this._currentFrameIndex = s), this._currentFrameIndex < 0 && (u ? (this._currentFrameIndex = 1, this.SetPlayingForwards(true), h || (this._animationRepeats++, this._animationRepeats >= m && this._FinishAnimation(true))) : !h && (this._animationRepeats++, this._animationRepeats >= m) ? this._FinishAnimation(true) : this._currentFrameIndex = s), this._currentFrameIndex = ea.clamp(this._currentFrameIndex, 0, o - 1), a.GetFrameAt(this._currentFrameIndex));\n            n > this._frameStartTime + c.GetDuration() / t && (this._frameStartTime = n), this._OnFrameChanged(i, c);\n          }\n        } else this._StopTicking();\n      }\n      _FinishAnimation(t) {\n        this._currentFrameIndex = t ? 0 : this._currentAnimation.GetFrameCount() - 1, this.SetAnimationPlaying(false), this._animTriggerName = this._currentAnimation.GetName(), this.SetInAnimationTrigger(true), this.DispatchScriptEvent(\"animationend\", false, { animationName: this._animTriggerName }), this.Trigger(ea.Plugins.Sprite.Cnds.OnAnyAnimFinished), this.Trigger(ea.Plugins.Sprite.Cnds.OnAnimFinished), this.SetInAnimationTrigger(false), this._animationRepeats = 0;\n      }\n      _OnFrameChanged(n, i, t) {\n        if (n !== i) {\n          const e = this.GetWorldInfo(), r = n.GetImageInfo(), a = i.GetImageInfo(), s = r.GetWidth(), o = r.GetHeight(), m = a.GetWidth(), h = a.GetHeight(), u = (t && t.onFrameChange ? t.onFrameChange(e, s, o, m, h) : (s !== m && e.SetWidth(e.GetWidth() * (m / s)), o !== h && e.SetHeight(e.GetHeight() * (h / o))), e.SetOriginX(i.GetOriginX()), e.SetOriginY(i.GetOriginY()), e.SetSourceCollisionPoly(i.GetCollisionPoly()), e.SetBboxChanged(), this._currentAnimationFrame = i, this._currentTexture = a.GetTexture(), this._currentRcTex = a.GetTexRect(), this._currentQuadTex = a.GetTexQuad(), this.GetInstance().GetBehaviorInstances());\n          for (let t2 = 0, e2 = u.length; t2 < e2; ++t2) u[t2].OnSpriteFrameChanged(n, i);\n          this.DispatchScriptEvent(\"framechange\", false, { animationName: this._currentAnimation.GetName(), animationFrame: this._currentFrameIndex }), this.Trigger(ea.Plugins.Sprite.Cnds.OnFrameChanged), this._runtime.UpdateRender();\n        }\n      }\n      _StartAnim(t) {\n        this.SetAnimationPlaying(true), this._frameStartTime = this.GetAnimationTime(), 1 === t && 0 !== this._currentFrameIndex && (this._changeAnimFrameIndex = 0, this.IsInAnimationTrigger() || this._DoChangeAnimFrame()), this._StartTicking();\n      }\n      _SetAnim(t, e, n) {\n        this._changeAnimationName = t, this._changeAnimationFrom = e, this._StartTicking(), !n && this.IsInAnimationTrigger() || this._DoChangeAnimation();\n      }\n      _GetCurrentAnimation() {\n        return this._currentAnimation;\n      }\n      _GetCurrentAnimationName() {\n        return this._changeAnimationName || this._currentAnimation.GetName();\n      }\n      _OnAnimationRemoved(t) {\n        ea.equalsNoCase(t, this._GetCurrentAnimationName()) && this._SetAnim(this._objectClass.GetFirstAnimation().GetName(), 1, true);\n      }\n      _SetAnimFrame(t) {\n        if (\"string\" == typeof t) if (String(Number(t)) === t) t = Number(t);\n        else {\n          const e = this._objectClass.GetAnimationByName(this._GetCurrentAnimationName());\n          if (!e) return;\n          if (-1 === (t = e.GetFrameIndexByTag(t))) return;\n        }\n        isFinite(t) && (this._changeAnimFrameIndex = t, this.IsInAnimationTrigger() || this._DoChangeAnimFrame());\n      }\n      _OnAnimationFramesChanged() {\n        if (!this._changeAnimationName && -1 === this._changeAnimFrameIndex) {\n          const t = this._currentAnimationFrame, e = this._currentAnimation.GetFrameAt(ea.clamp(this._currentFrameIndex, 0, this._currentAnimation.GetFrameCount() - 1));\n          t !== e && this._OnFrameChanged(t, e), 1 < this._currentAnimation.GetFrameCount() && 0 < this._currentAnimationSpeed && this._StartTicking();\n        }\n      }\n      _GetAnimFrame() {\n        return this._currentFrameIndex;\n      }\n      _GetAnimFrameTag() {\n        return this._currentAnimationFrame.GetTag();\n      }\n      _SetAnimSpeed(t) {\n        this._currentAnimationSpeed = Math.abs(t), this.SetPlayingForwards(0 <= t), 0 < this._currentAnimationSpeed && this._StartTicking();\n      }\n      _GetAnimSpeed() {\n        return this.IsPlayingForwards() ? this._currentAnimationSpeed : -this._currentAnimationSpeed;\n      }\n      _SetAnimRepeatToFrame(t) {\n        \"string\" == typeof t && -1 === (t = this._currentAnimation.GetFrameIndexByTag(t)) || (t = ea.clamp(Math.floor(t), 0, this._currentAnimation.GetFrameCount() - 1), this._currentAnimationRepeatTo = t);\n      }\n      _GetAnimRepeatToFrame() {\n        return this._currentAnimationRepeatTo;\n      }\n      _DoChangeAnimation(t) {\n        const e = this._currentAnimationFrame, n = this._objectClass.GetAnimationByName(this._changeAnimationName);\n        if (this._changeAnimationName = \"\", n && (n !== this._currentAnimation || !this.IsAnimationPlaying())) {\n          this._currentAnimation = n, this.SetPlayingForwards(0 <= n.GetSpeed()), this._currentAnimationSpeed = Math.abs(n.GetSpeed()), this._currentAnimationRepeatTo = n.GetRepeatTo(), this._currentFrameIndex = ea.clamp(this._currentFrameIndex, 0, this._currentAnimation.GetFrameCount() - 1), 1 === this._changeAnimationFrom && (this._currentFrameIndex = 0), this.SetAnimationPlaying(true), this._frameStartTime = this.GetAnimationTime();\n          const i = this._currentAnimation.GetFrameAt(this._currentFrameIndex);\n          this._OnFrameChanged(e, i, t);\n        }\n      }\n      _DoChangeAnimFrame(t) {\n        const e = this._currentAnimationFrame, n = this._currentFrameIndex;\n        if (this._currentFrameIndex = ea.clamp(Math.floor(this._changeAnimFrameIndex), 0, this._currentAnimation.GetFrameCount() - 1), this._changeAnimFrameIndex = -1, t || n !== this._currentFrameIndex) {\n          const i = this._currentAnimation.GetFrameAt(this._currentFrameIndex);\n          this._OnFrameChanged(e, i), this._frameStartTime = this.GetAnimationTime();\n        }\n      }\n      _UpdateCurrentTexture() {\n        const t = this._currentAnimationFrame.GetImageInfo();\n        this._currentTexture = t.GetTexture(), this._currentRcTex = t.GetTexRect(), this._currentQuadTex = t.GetTexQuad(), this.GetWorldInfo().SetMeshChanged(true);\n      }\n      GetTexture() {\n        return this._currentTexture;\n      }\n      GetTexRect() {\n        return this._currentRcTex;\n      }\n      GetTexQuad() {\n        return this._currentQuadTex;\n      }\n      GetImagePointCount() {\n        return this._currentAnimationFrame.GetImagePointCount();\n      }\n      GetImagePoint(t) {\n        const e = this._currentAnimationFrame, n = this.GetWorldInfo();\n        let i = null;\n        if (\"string\" == typeof t) i = e.GetImagePointByName(t);\n        else {\n          if (\"number\" != typeof t) throw new TypeError(\"expected string or number\");\n          i = e.GetImagePointByIndex(t - 1);\n        }\n        let r = n.GetTotalZElevation();\n        if (!i) return [n.GetX(), n.GetY(), r];\n        if (ma.copy(i.GetVec2()), n.HasMesh()) {\n          const [a, s, o] = n.GetSourceMesh().TransformPoint(ma.getX(), ma.getY());\n          ma.set(a, s), r += o;\n        }\n        return ma.offset(-e.GetOriginX(), -e.GetOriginY()), ma.scale(n.GetWidth(), n.GetHeight()), ma.rotate(n.GetAngle()), ma.offset(n.GetX(), n.GetY()), [ma.getX(), ma.getY(), r];\n      }\n      GetCollisionPolyPointCount() {\n        return this.GetWorldInfo().GetTransformedCollisionPoly().pointCount();\n      }\n      GetCollisionPolyPoint(t) {\n        t = Math.floor(t);\n        const e = this.GetWorldInfo(), n = e.GetTransformedCollisionPoly(), i = n.pointCount();\n        if ((t = t === i ? 0 : t) < 0 || i <= t) return [0, 0];\n        const r = n.pointsArr();\n        return [r[2 * t + 0] + e.GetX(), r[2 * t + 1] + e.GetY()];\n      }\n      GetDebuggerProperties() {\n        const e = ea.Plugins.Sprite.Acts, t = \"plugins.sprite.debugger.animation-properties\";\n        return [{ title: t + \".title\", properties: [{ name: t + \".current-animation\", value: this._currentAnimation.GetName(), onedit: (t2) => this.CallAction(e.SetAnim, t2, 0) }, { name: t + \".current-frame\", value: this._currentFrameIndex, onedit: (t2) => this.CallAction(e.SetAnimFrame, t2) }, { name: t + \".is-playing\", value: this.IsAnimationPlaying(), onedit: (t2) => t2 ? this.CallAction(e.StartAnim, 0) : this.CallAction(e.StopAnim) }, { name: t + \".speed\", value: this._currentAnimationSpeed, onedit: (t2) => this.CallAction(e.SetAnimSpeed, t2) }, { name: t + \".repeats\", value: this._animationRepeats, onedit: (t2) => this._animationRepeats = t2 }] }];\n      }\n      SaveToJson() {\n        const t = { \"a\": this._currentAnimation.GetSID() }, e = (0 !== this._frameStartTime && (t[\"fs\"] = this._frameStartTime), this.GetAnimationTime()), n = (0 !== e && (t[\"at\"] = e), 0 !== this._currentFrameIndex && (t[\"f\"] = this._currentFrameIndex), 0 !== this._currentAnimationSpeed && (t[\"cas\"] = this._currentAnimationSpeed), 1 !== this._animationRepeats && (t[\"ar\"] = this._animationRepeats), 0 !== this._currentAnimationRepeatTo && (t[\"rt\"] = this._currentAnimationRepeatTo), this.IsAnimationPlaying() || (t[\"ap\"] = this.IsAnimationPlaying()), this.IsPlayingForwards() || (t[\"af\"] = this.IsPlayingForwards()), this.GetWorldInfo());\n        return n.IsCollisionEnabled() && (t[\"ce\"] = n.IsCollisionEnabled()), t;\n      }\n      LoadFromJson(t) {\n        const e = this.GetObjectClass().GetAnimationBySID(t[\"a\"]), n = (e && (this._currentAnimation = e), this._frameStartTime = t.hasOwnProperty(\"fs\") ? t[\"fs\"] : 0, this._animationTimer.Set(t.hasOwnProperty(\"at\") ? t[\"at\"] : 0), t.hasOwnProperty(\"f\") ? t[\"f\"] : 0), i = (this._currentFrameIndex = ea.clamp(n, 0, this._currentAnimation.GetFrameCount() - 1), this._currentAnimationSpeed = t.hasOwnProperty(\"cas\") ? t[\"cas\"] : 0, this._animationRepeats = t.hasOwnProperty(\"ar\") ? t[\"ar\"] : 1, t.hasOwnProperty(\"rt\") ? t[\"rt\"] : 0), r = (this._currentAnimationRepeatTo = ea.clamp(i, 0, this._currentAnimation.GetFrameCount() - 1), this.SetAnimationPlaying(!t.hasOwnProperty(\"ap\") || !!t[\"ap\"]), this.SetPlayingForwards(!t.hasOwnProperty(\"af\") || !!t[\"af\"]), this._currentAnimation.GetFrameAt(this._currentFrameIndex)), a = (this._currentAnimationFrame = r, this._UpdateCurrentTexture(), this.GetWorldInfo());\n        a.SetOriginX(r.GetOriginX()), a.SetOriginY(r.GetOriginY()), a.SetSourceCollisionPoly(r.GetCollisionPoly()), a.SetCollisionEnabled(!!t[\"ce\"]), this.IsAnimationPlaying() && this._StartTicking();\n      }\n      GetPropertyValueByIndex(t) {\n        const e = this.GetWorldInfo();\n        switch (t) {\n          case ja:\n            return e.IsCollisionEnabled();\n          case ia:\n            return ea.clamp(this._currentFrameIndex, 0, this._currentAnimation.GetFrameCount() - 1);\n          case ha:\n            return this._currentAnimation.GetName();\n        }\n      }\n      SetPropertyValueByIndex(t, e, n) {\n        const i = this.GetWorldInfo();\n        switch (t) {\n          case ja:\n            i.SetCollisionEnabled(!!e);\n            break;\n          case ia: {\n            this.SetAnimationPlaying(false);\n            const r = this._currentAnimation.GetFrameCount() - 1, a = e = ea.clamp(e, 0, r), s = this._currentAnimation.GetFrameAt(this._currentFrameIndex), o = this._currentAnimation.GetFrameAt(a);\n            this._OnFrameChanged(s, o, n), this._currentFrameIndex = ea.clamp(a, 0, r);\n            break;\n          }\n          case ha: {\n            this._changeAnimationName = e, this._DoChangeAnimation(n);\n            const m = this._currentAnimation.GetFrameCount();\n            1 < m && 0 < this._currentAnimation.GetSpeed() ? this._StartTicking() : this._StopTicking();\n            break;\n          }\n        }\n      }\n      GetScriptInterfaceClass() {\n        return self.ISpriteInstance;\n      }\n    }, /* @__PURE__ */ new WeakMap()), ra = /* @__PURE__ */ new Map([[\"current-frame\", 0], [\"beginning\", 1]]);\n    self.ISpriteInstance = class extends self.IWorldInstance {\n      constructor() {\n        super(), qa.set(this, self.IInstance._GetInitInst().GetSdkInstance());\n      }\n      getImagePointCount() {\n        return qa.get(this).GetImagePointCount();\n      }\n      getImagePointX(t) {\n        return this.getImagePoint(t)[0];\n      }\n      getImagePointY(t) {\n        return this.getImagePoint(t)[1];\n      }\n      getImagePointZ(t) {\n        return this.getImagePoint(t)[2];\n      }\n      getImagePoint(t) {\n        if (\"string\" != typeof t && \"number\" != typeof t) throw new TypeError(\"expected string or number\");\n        return qa.get(this).GetImagePoint(t);\n      }\n      getPolyPointCount() {\n        return qa.get(this).GetCollisionPolyPointCount();\n      }\n      getPolyPointX(t) {\n        return fa.RequireFiniteNumber(t), qa.get(this).GetCollisionPolyPoint(t)[0];\n      }\n      getPolyPointY(t) {\n        return fa.RequireFiniteNumber(t), qa.get(this).GetCollisionPolyPoint(t)[1];\n      }\n      getPolyPoint(t) {\n        return fa.RequireFiniteNumber(t), qa.get(this).GetCollisionPolyPoint(t);\n      }\n      stopAnimation() {\n        qa.get(this).SetAnimationPlaying(false);\n      }\n      startAnimation(t = \"current-frame\") {\n        fa.RequireString(t);\n        const e = ra.get(t);\n        if (void 0 === e) throw new Error(\"invalid mode\");\n        qa.get(this)._StartAnim(e);\n      }\n      setAnimation(t, e = \"beginning\") {\n        fa.RequireString(t), fa.RequireString(e);\n        const n = ra.get(e);\n        if (void 0 === n) throw new Error(\"invalid mode\");\n        const i = qa.get(this);\n        if (!i.GetObjectClass().GetAnimationByName(t)) throw new Error(`animation name \"${t}\" does not exist`);\n        i._SetAnim(t, n);\n      }\n      getAnimation(t) {\n        fa.RequireString(t);\n        const e = qa.get(this).GetObjectClass().GetAnimationByName(t);\n        return e ? e.GetIAnimation() : null;\n      }\n      get animation() {\n        return qa.get(this)._GetCurrentAnimation().GetIAnimation();\n      }\n      get animationName() {\n        return qa.get(this)._GetCurrentAnimationName();\n      }\n      set animationFrame(t) {\n        fa.RequireFiniteNumber(t), qa.get(this)._SetAnimFrame(t);\n      }\n      get animationFrame() {\n        return qa.get(this)._GetAnimFrame();\n      }\n      set animationFrameTag(t) {\n        fa.RequireString(t), qa.get(this)._SetAnimFrame(t);\n      }\n      get animationFrameTag() {\n        return qa.get(this)._GetAnimFrameTag();\n      }\n      set animationSpeed(t) {\n        fa.RequireFiniteNumber(t), qa.get(this)._SetAnimSpeed(t);\n      }\n      get animationSpeed() {\n        return qa.get(this)._GetAnimSpeed();\n      }\n      set animationRepeatToFrame(t) {\n        fa.RequireFiniteNumber(t), qa.get(this)._SetAnimRepeatToFrame(t);\n      }\n      get animationRepeatToFrame() {\n        return qa.get(this)._GetAnimRepeatToFrame();\n      }\n      get imageWidth() {\n        return qa.get(this).GetCurrentImageInfo().GetWidth();\n      }\n      get imageHeight() {\n        return qa.get(this).GetCurrentImageInfo().GetHeight();\n      }\n      getImageSize() {\n        const t = qa.get(this).GetCurrentImageInfo();\n        return [t.GetWidth(), t.GetHeight()];\n      }\n      async replaceCurrentAnimationFrame(t) {\n        fa.RequireInstanceOf(t, Blob);\n        const e = qa.get(this), n = e.GetRuntime(), i = e.GetCurrentImageInfo(), r = ea.New(ea.ImageInfo);\n        if (r.LoadDynamicBlobAsset(n, t), await r.LoadStaticTexture(n.GetRenderer(), { sampling: n.GetSampling() }), e.WasReleased()) r.Release();\n        else {\n          i.ReplaceWith(r);\n          const a = e.GetSdkType();\n          a._UpdateAllCurrentTexture(), a.GetObjectClass().Dispatcher().dispatchEvent(new ea.Event(\"animationframeimagechange\")), n.UpdateRender();\n        }\n      }\n      setSolidCollisionFilter(t, e) {\n        fa.RequireString(e), qa.get(this).GetWorldInfo().SetSolidCollisionFilter(!!t, e);\n      }\n    };\n  }\n  {\n    const Vb = self.C3;\n    Vb.Plugins.Sprite.Cnds = { IsAnimPlaying(t) {\n      return Vb.equalsNoCase(this._GetCurrentAnimationName(), t);\n    }, CompareFrame(t, e) {\n      return Vb.compare(this._currentFrameIndex, t, e);\n    }, CompareFrameTag(t, e) {\n      if (\"string\" != typeof e) return false;\n      const n = this._currentAnimationFrame.GetTag();\n      return Vb.compare(n.toLowerCase(), t, e.toLowerCase());\n    }, CompareAnimSpeed(t, e) {\n      return Vb.compare(this._GetAnimSpeed(), t, e);\n    }, OnAnimFinished(t) {\n      return Vb.equalsNoCase(this._animTriggerName, t);\n    }, OnAnyAnimFinished() {\n      return true;\n    }, OnFrameChanged() {\n      return true;\n    }, IsMirrored() {\n      return this.GetWorldInfo().GetWidth() < 0;\n    }, IsFlipped() {\n      return this.GetWorldInfo().GetHeight() < 0;\n    }, OnURLLoaded() {\n      return true;\n    }, OnURLFailed() {\n      return true;\n    }, IsCollisionEnabled() {\n      return this.GetWorldInfo().IsCollisionEnabled();\n    } };\n  }\n  {\n    const d1 = self.C3;\n    d1.Plugins.Sprite.Acts = { Spawn(t, e, n, i, r) {\n      if (t && e) {\n        const [a, s] = this.GetImagePoint(n), o = this._runtime.CreateInstance(t, e, a, s, i, r);\n        if (o) {\n          if (i && e.SortAndAddInstancesByZIndex(o), t.GetPlugin().IsRotatable()) {\n            const h = o.GetWorldInfo();\n            h.SetAngle(this.GetWorldInfo().GetAngle()), h.SetBboxChanged();\n          }\n          const m = this._runtime.GetEventSheetManager();\n          m.BlockFlushingInstances(true), o._TriggerOnCreatedOnSelfAndRelated(), m.BlockFlushingInstances(false), t !== this._runtime.GetCurrentAction().GetObjectClass() && this._sdkType._SpawnPickInstance(t, o, i);\n        }\n      }\n    }, StopAnim() {\n      this.SetAnimationPlaying(false);\n    }, StartAnim(t) {\n      this._StartAnim(t);\n    }, SetAnim(t, e) {\n      this._SetAnim(t, e);\n    }, SetAnimFrame(t) {\n      this._SetAnimFrame(t);\n    }, SetAnimSpeed(t) {\n      this._SetAnimSpeed(t);\n    }, SetAnimRepeatToFrame(t) {\n      this._SetAnimRepeatToFrame(t);\n    }, AddRemoveAnimation(e, t) {\n      try {\n        0 === e ? this.GetSdkType()._AddAnimation(t) : this.GetSdkType()._RemoveAnimation(t);\n      } catch (t2) {\n        console.error(`[Construct] Error ${0 === e ? \"adding\" : \"removing\"} animation: `, t2);\n      }\n    }, AddRemoveAnimationFrame(e, t, n) {\n      try {\n        0 === e ? this.GetSdkType()._AddAnimationFrame(t, n) : this.GetSdkType()._RemoveAnimationFrame(t, n);\n      } catch (t2) {\n        console.error(`[Construct] Error ${0 === e ? \"adding\" : \"removing\"} animation frame: `, t2);\n      }\n    }, SetMirrored(t) {\n      const e = this.GetWorldInfo(), n = e.GetWidth(), i = Math.abs(n) * (0 === t ? -1 : 1);\n      n !== i && (e.SetWidth(i), e.SetBboxChanged());\n    }, SetFlipped(t) {\n      const e = this.GetWorldInfo(), n = e.GetHeight(), i = Math.abs(n) * (0 === t ? -1 : 1);\n      n !== i && (e.SetHeight(i), e.SetBboxChanged());\n    }, SetScale(t) {\n      const e = this._currentAnimationFrame, n = e.GetImageInfo(), i = this.GetWorldInfo(), r = i.GetWidth() < 0 ? -1 : 1, a = i.GetHeight() < 0 ? -1 : 1, s = n.GetWidth() * t * r, o = n.GetHeight() * t * a;\n      i.GetWidth() === s && i.GetHeight() === o || (i.SetSize(s, o), i.SetBboxChanged());\n    }, async LoadURL(t, e, n) {\n      const i = this._currentAnimationFrame, r = i.GetImageInfo(), a = this.GetWorldInfo(), s = this._runtime, o = this._sdkType;\n      if (r.GetURL() === t) 0 === e && (a.SetSize(r.GetWidth(), r.GetHeight()), a.SetBboxChanged()), this.Trigger(d1.Plugins.Sprite.Cnds.OnURLLoaded);\n      else {\n        const m = d1.New(d1.ImageInfo);\n        try {\n          if (await m.LoadDynamicAsset(s, t), !m.IsLoaded()) throw new Error(\"image failed to load\");\n          if (this.WasReleased()) return void m.Release();\n          await m.LoadStaticTexture(s.GetRenderer(), { sampling: s.GetSampling() });\n        } catch (t2) {\n          return console.error(\"Load image from URL failed: \", t2), void (this.WasReleased() || this.Trigger(d1.Plugins.Sprite.Cnds.OnURLFailed));\n        }\n        this.WasReleased() ? m.Release() : (r.ReplaceWith(m), o._UpdateAllCurrentTexture(), o.GetObjectClass().Dispatcher().dispatchEvent(new d1.Event(\"animationframeimagechange\")), s.UpdateRender(), 0 === e && (a.SetSize(r.GetWidth(), r.GetHeight()), a.SetBboxChanged()), await this.TriggerAsync(d1.Plugins.Sprite.Cnds.OnURLLoaded));\n      }\n    }, SetCollisions(t) {\n      this.GetWorldInfo().SetCollisionEnabled(t);\n    }, SetSolidCollisionFilter(t, e) {\n      this.GetWorldInfo().SetSolidCollisionFilter(0 === t, e);\n    }, SetEffect(t) {\n      this.GetWorldInfo().SetBlendMode(t), this._runtime.UpdateRender();\n    } };\n  }\n  {\n    const dc = self.C3;\n    dc.Plugins.Sprite.Exps = { AnimationFrame() {\n      return this._GetAnimFrame();\n    }, AnimationFrameTag() {\n      return this._GetAnimFrameTag();\n    }, AnimationFrameCount() {\n      return this._currentAnimation.GetFrameCount();\n    }, AnimationName() {\n      return this._currentAnimation.GetName();\n    }, AnimationSpeed() {\n      return this._GetAnimSpeed();\n    }, OriginalAnimationSpeed() {\n      return this._currentAnimation.GetSpeed();\n    }, ImagePointX(t) {\n      return this.GetImagePoint(t)[0];\n    }, ImagePointY(t) {\n      return this.GetImagePoint(t)[1];\n    }, ImagePointZ(t) {\n      return this.GetImagePoint(t)[2];\n    }, ImagePointCount() {\n      return this.GetImagePointCount();\n    }, ImageWidth() {\n      return this.GetCurrentImageInfo().GetWidth();\n    }, ImageHeight() {\n      return this.GetCurrentImageInfo().GetHeight();\n    }, PolyPointXAt(t) {\n      return this.GetCollisionPolyPoint(t)[0];\n    }, PolyPointYAt(t) {\n      return this.GetCollisionPolyPoint(t)[1];\n    }, PolyPointCount() {\n      return this.GetCollisionPolyPointCount();\n    } };\n  }\n}\n{\n  {\n    const a = self.C3, b = [];\n    a.Plugins.Audio = class extends a.SDKPluginBase {\n      constructor(t) {\n        super(t);\n      }\n      _AddActionPromise(t) {\n        b.push(t);\n      }\n      static async WaitForAllActionPromises() {\n        await Promise.all(b), a.clearArray(b);\n      }\n      Release() {\n        super.Release();\n      }\n    };\n  }\n  {\n    let GetAudioSdkInstance = function() {\n      return e.GetSingleGlobalInstance().GetSdkInstance();\n    }, GetAudioDOMInterface = function() {\n      if (self[\"C3Audio_DOMInterface\"]) return self[\"C3Audio_DOMInterface\"];\n      throw new Error(\"audio scripting API cannot be used here - make sure the project is using DOM mode, not worker mode\");\n    };\n    GetAudioSdkInstance2 = GetAudioSdkInstance, GetAudioDOMInterface2 = GetAudioDOMInterface;\n    const f = self.C3, g = self.C3X;\n    f.Plugins.Audio.Type = class extends f.SDKTypeBase {\n      constructor(t) {\n        super(t);\n      }\n      Release() {\n        super.Release();\n      }\n      OnCreate() {\n      }\n      GetScriptInterfaceClass() {\n        return self.IAudioObjectType;\n      }\n    };\n    let e = null;\n    self.IAudioObjectType = class extends self.IObjectClass {\n      constructor(t) {\n        super(t), e = t;\n      }\n      get audioContext() {\n        return GetAudioDOMInterface()[\"GetAudioContextExtern\"]();\n      }\n      get destinationNode() {\n        return GetAudioDOMInterface()[\"GetDestinationNodeExtern\"]();\n      }\n      get isSilent() {\n        return GetAudioSdkInstance()._IsSilent();\n      }\n      set isSilent(t) {\n        GetAudioSdkInstance()._SetSilent(t);\n      }\n      get masterVolume() {\n        return GetAudioSdkInstance()._GetMasterVolume();\n      }\n      set masterVolume(t) {\n        g.RequireFiniteNumber(t), GetAudioSdkInstance()._SetMasterVolume(t);\n      }\n      stopAll() {\n        GetAudioSdkInstance()._StopAll();\n      }\n    };\n  }\n  {\n    const o = self.C3, p = \"audio\", q = [\"interactive\", \"balanced\", \"playback\"];\n    o.Plugins.Audio.Instance = class extends o.SDKInstanceBase {\n      constructor(t, e) {\n        super(t, p), this._nextPlayTime = 0, this._triggerTags = [], this._enableMultiTags = true, this._timeScaleMode = 0, this._saveLoadMode = 0, this._playInBackground = false, this._panningModel = 1, this._distanceModel = 1, this._listenerPos = [this._runtime.GetViewportWidth() / 2, this._runtime.GetViewportHeight() / 2, 600], this._listenerForwardVec = [0, 0, -1], this._listenerUpVec = [0, 1, 0], this._referenceDistance = 600, this._maxDistance = 1e4, this._rolloffFactor = 1, this._listenerInst = null, this._loadListenerUid = -1, this._masterVolume = 1, this._isSilent = false, this._sampleRate = 0, this._audioContextState = \"suspended\", this._outputLatency = 0, this._effectCount = /* @__PURE__ */ new Map(), this._preloadTotal = 0, this._preloadCount = 0, this._bufferMetadata = /* @__PURE__ */ new Map(), this._remoteUrls = /* @__PURE__ */ new Map();\n        let s = \"interactive\";\n        e && (this._timeScaleMode = e[0], this._saveLoadMode = e[1], this._playInBackground = e[2], s = q[e[3]], this._enableMultiTags = e[4], this._panningModel = e[5], this._distanceModel = e[6], this._listenerPos[2] = e[7], this._referenceDistance = e[8], this._maxDistance = e[9], this._rolloffFactor = e[10]), this._lastAIState = [], this._lastFxState = [], this._lastAnalysersData = [], this.AddDOMMessageHandlers([[\"state\", (t2) => this._OnUpdateState(t2)], [\"audiocontext-state\", (t2) => this._OnAudioContextStateChanged(t2)], [\"fxstate\", (t2) => this._OnUpdateFxState(t2)], [\"trigger\", (t2) => this._OnTrigger(t2)], [\"buffer-metadata\", (t2) => this._OnBufferMetadata(t2)]]);\n        const i = this.GetRuntime().Dispatcher(), a = (this._disposables = new o.CompositeDisposable(o.Disposable.From(i, \"instancedestroy\", (t2) => this._OnInstanceDestroyed(t2.instance)), o.Disposable.From(i, \"afterload\", () => this._OnAfterLoad()), o.Disposable.From(i, \"suspend\", () => this._OnSuspend()), o.Disposable.From(i, \"resume\", () => this._OnResume())), this._runtime.GetExportType()), n = \"Safari\" === o.Platform.Browser, r = this._runtime.IsiOSWebView() || \"macos-wkwebview\" === a, l = this._runtime.GetAssetManager().IsFileProtocol(), h = \"playable-ad-single-file\" === this._runtime.GetExportType(), u = n || r || l || h;\n        this._runtime.AddLoadPromise(this.PostToDOMAsync(\"create-audio-context\", { \"preloadList\": this._runtime.GetAssetManager().GetAudioToPreload().map((t2) => ({ \"originalUrl\": t2.originalUrl, \"url\": t2.url, \"type\": t2.type, \"fileSize\": t2.fileSize })), \"timeScaleMode\": this._timeScaleMode, \"latencyHint\": s, \"panningModel\": this._panningModel, \"distanceModel\": this._distanceModel, \"refDistance\": this._referenceDistance, \"maxDistance\": this._maxDistance, \"rolloffFactor\": this._rolloffFactor, \"listenerPos\": this._listenerPos, \"usePlayMusicAsSoundWorkaround\": u }).then((t2) => {\n          this._sampleRate = t2[\"sampleRate\"], this._audioContextState = t2[\"audioContextState\"], this._outputLatency = t2[\"outputLatency\"];\n        })), this._StartTicking();\n      }\n      Release() {\n        this._listenerInst = null, super.Release();\n      }\n      _SplitTags(t) {\n        return this._enableMultiTags ? t.split(\" \").filter((t2) => !!t2) : t ? [t] : [];\n      }\n      _MatchTagLists(e, t) {\n        for (const s of t) {\n          let t2 = false;\n          for (const i of e) if (o.equalsNoCase(i, s)) {\n            t2 = true;\n            break;\n          }\n          if (!t2) return false;\n        }\n        return true;\n      }\n      _MatchTagListToStr(t, e) {\n        return this._MatchTagLists(t, this._SplitTags(e));\n      }\n      _AddActionPromise(t) {\n        this.GetPlugin()._AddActionPromise(t);\n      }\n      _OnInstanceDestroyed(t) {\n        this._listenerInst === t && (this._listenerInst = null);\n      }\n      DbToLinearNoCap(t) {\n        return Math.pow(10, t / 20);\n      }\n      DbToLinear(t) {\n        const e = this.DbToLinearNoCap(t);\n        return isFinite(e) ? Math.max(Math.min(e, 1), 0) : 0;\n      }\n      LinearToDbNoCap(t) {\n        return Math.log(t) / Math.log(10) * 20;\n      }\n      LinearToDb(t) {\n        return this.LinearToDbNoCap(Math.max(Math.min(t, 1), 0));\n      }\n      _OnSuspend() {\n        this._playInBackground || this.PostToDOM(\"set-suspended\", { \"isSuspended\": true });\n      }\n      _OnResume() {\n        this._playInBackground || this.PostToDOM(\"set-suspended\", { \"isSuspended\": false });\n      }\n      _OnUpdateState(t) {\n        const e = t[\"tickCount\"], s = (this._outputLatency = t[\"outputLatency\"], this._lastAIState.filter((t2) => t2.hasOwnProperty(\"placeholder\") && (t2[\"placeholder\"] > e || -1 === t2[\"placeholder\"])));\n        this._lastAIState = t[\"audioInstances\"], this._lastAnalysersData = t[\"analysers\"], 0 < s.length && o.appendArray(this._lastAIState, s);\n      }\n      _OnBufferMetadata(t) {\n        this._bufferMetadata.set(t[\"originalUrl\"], { duration: t[\"duration\"] });\n      }\n      _OnAudioContextStateChanged(t) {\n        this._audioContextState = t[\"audioContextState\"];\n      }\n      GetAudioContextState() {\n        return this._runtime.IsExportToVideo() ? \"running\" : this._audioContextState;\n      }\n      _OnUpdateFxState(t) {\n        this._lastFxState = t[\"fxstate\"];\n      }\n      _GetFirstAudioStateByTags(t) {\n        const e = this._SplitTags(t);\n        for (const s of this._lastAIState) if (this._MatchTagLists(s[\"tags\"], e)) return s;\n        return null;\n      }\n      _IsTagPlaying(t) {\n        const e = this._SplitTags(t);\n        return this._lastAIState.some((t2) => this._MatchTagLists(t2[\"tags\"], e) && t2[\"isPlaying\"]);\n      }\n      _MaybeMarkAsPlaying(t, e, s, i, a) {\n        if (this._IsTagPlaying(e)) return null;\n        const n = this._bufferMetadata.get(t), o2 = { \"tags\": this._SplitTags(e), \"duration\": n ? n.duration : 0, \"volume\": a, \"isPlaying\": true, \"playbackTime\": 0, \"playbackRate\": 1, \"uid\": -1, \"bufferOriginalUrl\": t, \"bufferUrl\": \"\", \"bufferType\": \"\", \"isMusic\": s, \"isLooping\": i, \"isMuted\": false, \"resumePosition\": 0, \"pan\": null, \"placeholder\": -1 };\n        return this._lastAIState.push(o2), o2;\n      }\n      _MaybeMarkAsStopped(t) {\n        const e = this._SplitTags(t);\n        for (const s of this._lastAIState) this._MatchTagLists(s[\"tags\"], e) && (s[\"isPlaying\"] = false);\n      }\n      async _OnTrigger(t) {\n        const e = t[\"type\"], s = (this._triggerTags = t[\"tags\"], t[\"aiid\"]);\n        if (\"ended\" === e) {\n          for (const i of this._lastAIState) if (i[\"aiid\"] === s) {\n            i[\"isPlaying\"] = false;\n            break;\n          }\n          await this.TriggerAsync(o.Plugins.Audio.Cnds.OnEnded);\n        } else \"fade-ended\" === e && await this.TriggerAsync(o.Plugins.Audio.Cnds.OnFadeEnded);\n      }\n      _MatchTriggerTag(t) {\n        return this._MatchTagListToStr(this._triggerTags, t);\n      }\n      Tick() {\n        const t = { \"timeScale\": this._runtime.GetTimeScale(), \"gameTime\": this._runtime.GetGameTimeRaw(), \"instPans\": this.GetInstancePans(), \"tickCount\": this._runtime.GetTickCountNoSave() };\n        if (this._listenerInst) {\n          const e = this._listenerInst.GetWorldInfo();\n          this._listenerPos[0] = e.GetX(), this._listenerPos[1] = e.GetY(), t[\"listenerPos\"] = this._listenerPos, t[\"listenerOrientation\"] = [...this._listenerForwardVec, ...this._listenerUpVec];\n        }\n        this.PostToDOM(\"tick\", t);\n      }\n      rotatePtAround(t, e, s, i, a) {\n        if (0 !== s) {\n          const n = Math.sin(s), o2 = Math.cos(s), r = (t -= i) * n, l = (e -= a) * n, h = t * o2, u = e * o2;\n          t = h - l, e = u + r, t += i, e += a;\n        }\n        return [t, e];\n      }\n      GetInstancePans() {\n        return this._lastAIState.filter((t) => -1 !== t[\"uid\"]).map((t) => this._runtime.GetInstanceByUID(t[\"uid\"])).filter((t) => t).map((t) => {\n          const e = t.GetWorldInfo(), s = e.GetLayer().GetAngle(), [i, a] = this.rotatePtAround(e.GetX(), e.GetY(), -s, this._listenerPos[0], this._listenerPos[1]);\n          return { \"uid\": t.GetUID(), \"x\": i, \"y\": a, \"z\": e.GetTotalZElevation(), \"angle\": e.GetAngle() - s };\n        });\n      }\n      GetAnalyserData(t, e) {\n        for (const s of this._lastAnalysersData) if (s.index === e && o.equalsNoCase(s[\"tag\"], t)) return s;\n        return null;\n      }\n      _IncrementEffectCount(t) {\n        for (const e of this._SplitTags(t)) {\n          const s = e.toLowerCase();\n          this._effectCount.set(s, (this._effectCount.get(s) || 0) + 1);\n        }\n      }\n      _IsSilent() {\n        return this._isSilent;\n      }\n      _SetSilent(t) {\n        this._isSilent !== (t = !!t) && (this._isSilent = t, this.PostToDOM(\"set-silent\", { \"isSilent\": t }));\n      }\n      _GetMasterVolume() {\n        return this._masterVolume;\n      }\n      _SetMasterVolume(t) {\n        this._masterVolume !== t && (this._masterVolume = t, this.PostToDOM(\"set-master-volume\", { \"vol\": t }));\n      }\n      _StopAll() {\n        this.PostToDOM(\"stop-all\");\n        for (const t of this._lastAIState) t[\"isPlaying\"] = false;\n      }\n      _ShouldSave(t) {\n        return !t.hasOwnProperty(\"placeholder\") && 3 !== this._saveLoadMode && !(t[\"isMusic\"] && 1 === this._saveLoadMode || !t[\"isMusic\"] && 2 === this._saveLoadMode);\n      }\n      SaveToJson() {\n        return { \"isSilent\": this._isSilent, \"masterVolume\": this._masterVolume, \"listenerZ\": this._listenerPos[2], \"listenerForwardVec\": this._listenerForwardVec, \"listenerUpVec\": this._listenerUpVec, \"listenerUid\": this._listenerInst ? this._listenerInst.GetUID() : -1, \"remoteUrls\": [...this._remoteUrls.entries()], \"playing\": this._lastAIState.filter((t) => this._ShouldSave(t)), \"effects\": this._lastFxState, \"analysers\": this._lastAnalysersData };\n      }\n      LoadFromJson(t) {\n        if (this._isSilent = t[\"isSilent\"], this._masterVolume = t[\"masterVolume\"], this._listenerPos[2] = t[\"listenerZ\"], this._listenerInst = null, this._loadListenerUid = t[\"listenerUid\"], t.hasOwnProperty(\"listenerForwardVec\") ? this._listenerForwardVec = t[\"listenerForwardVec\"] : this._listenerForwardVec = [0, 0, -1], t.hasOwnProperty(\"listenerUpVec\") ? this._listenerUpVec = t[\"listenerUpVec\"] : this._listenerUpVec = [0, 1, 0], this._remoteUrls.clear(), t[\"remoteUrls\"]) for (const [e, s] of t[\"remoteUrls\"]) this._remoteUrls.set(e, s);\n        this._lastAIState = t[\"playing\"];\n        for (const i of this._lastAIState) i.hasOwnProperty(\"tag\") && !i.hasOwnProperty(\"tags\") && (i[\"tags\"] = [i[\"tag\"]].filter((t2) => !!t2));\n        this._lastFxState = t[\"effects\"], this._lastAnalysersData = t[\"analysers\"];\n      }\n      _OnAfterLoad() {\n        if (-1 !== this._loadListenerUid && (this._listenerInst = this._runtime.GetInstanceByUID(this._loadListenerUid), this._loadListenerUid = -1, this._listenerInst)) {\n          const t = this._listenerInst.GetWorldInfo();\n          this._listenerPos[0] = t.GetX(), this._listenerPos[1] = t.GetY();\n        }\n        for (const e of this._lastAIState) {\n          const s = this._runtime.GetAssetManager().GetProjectAudioFileUrl(e[\"bufferOriginalUrl\"]);\n          s ? (e[\"bufferUrl\"] = s.url, e[\"bufferType\"] = s.type) : e[\"bufferUrl\"] = null;\n        }\n        for (const i of Object.values(this._lastFxState)) for (const a of i) if (a.hasOwnProperty(\"bufferOriginalUrl\")) {\n          const n = this._runtime.GetAssetManager().GetProjectAudioFileUrl(a[\"bufferOriginalUrl\"]);\n          n && (a[\"bufferUrl\"] = n.url, a[\"bufferType\"] = n.type);\n        }\n        this.PostToDOM(\"load-state\", { \"saveLoadMode\": this._saveLoadMode, \"timeScale\": this._runtime.GetTimeScale(), \"gameTime\": this._runtime.GetGameTimeRaw(), \"listenerPos\": this._listenerPos, \"listenerOrientation\": [...this._listenerForwardVec, ...this._listenerUpVec], \"isSilent\": this._isSilent, \"masterVolume\": this._masterVolume, \"playing\": this._lastAIState.filter((t) => null !== t[\"bufferUrl\"]), \"effects\": this._lastFxState });\n      }\n      GetDebuggerProperties() {\n        const t = [];\n        for (const [s, i] of Object.entries(this._lastFxState)) t.push({ name: \"$\" + s, value: i.map((t2) => t2[\"type\"]).join(\", \") });\n        const e = \"plugins.audio.debugger\";\n        return [{ title: e + \".tag-effects\", properties: t }, { title: e + \".currently-playing\", properties: [{ name: e + \".currently-playing-count\", value: this._lastAIState.length }, ...this._lastAIState.map((t2, e2) => ({ name: \"$#\" + e2, value: `${t2[\"bufferOriginalUrl\"]} (\"${t2[\"tags\"]}\") ${Math.round(10 * t2[\"playbackTime\"]) / 10} / ` + Math.round(10 * t2[\"duration\"]) / 10 }))] }];\n      }\n    };\n  }\n  {\n    const x0 = self.C3;\n    x0.Plugins.Audio.Cnds = { OnEnded(t) {\n      return this._MatchTriggerTag(t);\n    }, OnFadeEnded(t) {\n      return this._MatchTriggerTag(t);\n    }, PreloadsComplete() {\n      return this._preloadCount === this._preloadTotal;\n    }, AdvancedAudioSupported() {\n      return true;\n    }, IsSilent() {\n      return this._IsSilent();\n    }, IsAnyPlaying() {\n      for (const t of this._lastAIState) if (t[\"isPlaying\"]) return true;\n      return false;\n    }, IsTagPlaying(t) {\n      return this._IsTagPlaying(t);\n    } };\n  }\n  {\n    const C0 = self.C3, D0 = [\"lowpass\", \"highpass\", \"bandpass\", \"lowshelf\", \"highshelf\", \"peaking\", \"notch\", \"allpass\"];\n    C0.Plugins.Audio.Acts = { Play(t, e, s, i, a) {\n      const n = C0.Plugins.Audio.Acts._DoPlay.call(this, t, e, s, i, a);\n      return this._AddActionPromise(n), n;\n    }, PlayFromTimeline(t, e, s, i) {\n      C0.Plugins.Audio.Acts._DoPlay.call(this, t, 0, e, 0, s, i);\n    }, async _DoPlay(t, e, s, i, a, n) {\n      if (!this._isSilent) {\n        const o = t[1], r = this._runtime.GetAssetManager().GetProjectAudioFileUrl(t[0]);\n        if (r) {\n          const l = this._nextPlayTime, h = (this._nextPlayTime = 0, this._MaybeMarkAsPlaying(t[0], a, o, 0 !== e, this.DbToLinear(s)));\n          try {\n            await this.PostToDOMAsync(\"play\", { \"originalUrl\": t[0], \"url\": r.url, \"type\": r.type, \"isMusic\": o, \"tags\": this._SplitTags(a), \"isLooping\": 0 !== e, \"vol\": this.DbToLinear(s), \"stereoPan\": C0.clamp(i / 100, -1, 1), \"pos\": n || 0, \"off\": l, \"trueClock\": !!self[\"C3_GetAudioContextCurrentTime\"] });\n          } finally {\n            h && (h[\"placeholder\"] = this._runtime.GetTickCountNoSave());\n          }\n        }\n      }\n    }, async PlayAtPosition(t, e, s, i, a, n, o, r, l, h, u) {\n      if (!this._isSilent) {\n        const c = t[1], d = this._runtime.GetAssetManager().GetProjectAudioFileUrl(t[0]);\n        if (d) {\n          const _ = this._nextPlayTime, p = (this._nextPlayTime = 0, this._MaybeMarkAsPlaying(t[0], u, c, 0 !== e, this.DbToLinear(s)));\n          try {\n            await this.PostToDOMAsync(\"play\", { \"originalUrl\": t[0], \"url\": d.url, \"type\": d.type, \"isMusic\": c, \"tags\": this._SplitTags(u), \"isLooping\": 0 !== e, \"vol\": this.DbToLinear(s), \"pos\": 0, \"off\": _, \"trueClock\": !!self[\"C3_GetAudioContextCurrentTime\"], \"panning\": { \"x\": i, \"y\": a, \"z\": n, \"angle\": C0.toRadians(o), \"innerAngle\": C0.toRadians(r), \"outerAngle\": C0.toRadians(l), \"outerGain\": this.DbToLinear(h) } });\n          } finally {\n            p && (p[\"placeholder\"] = this._runtime.GetTickCountNoSave());\n          }\n        }\n      }\n    }, async PlayAtObject(t, e, s, i, a, n, o, r) {\n      if (!this._isSilent && i) {\n        const l = i.GetFirstPicked();\n        if (l && l.GetWorldInfo()) {\n          const h = l.GetWorldInfo(), u = h.GetLayer().GetAngle(), [c, d] = this.rotatePtAround(h.GetX(), h.GetY(), -u, this._listenerPos[0], this._listenerPos[1]), _ = t[1], p = this._runtime.GetAssetManager().GetProjectAudioFileUrl(t[0]);\n          if (p) {\n            const f = this._nextPlayTime, g = (this._nextPlayTime = 0, this._MaybeMarkAsPlaying(t[0], r, _, 0 !== e, this.DbToLinear(s)));\n            try {\n              await this.PostToDOMAsync(\"play\", { \"originalUrl\": t[0], \"url\": p.url, \"type\": p.type, \"isMusic\": _, \"tags\": this._SplitTags(r), \"isLooping\": 0 !== e, \"vol\": this.DbToLinear(s), \"pos\": 0, \"off\": f, \"trueClock\": !!self[\"C3_GetAudioContextCurrentTime\"], \"panning\": { \"x\": c, \"y\": d, \"z\": h.GetTotalZElevation(), \"angle\": h.GetAngle() - u, \"innerAngle\": C0.toRadians(a), \"outerAngle\": C0.toRadians(n), \"outerGain\": this.DbToLinear(o), \"uid\": l.GetUID() } });\n            } finally {\n              g && (g[\"placeholder\"] = this._runtime.GetTickCountNoSave());\n            }\n          }\n        }\n      }\n    }, async PlayByName(t, e, s, i, a, n) {\n      if (!this._isSilent) {\n        const o = 1 === t, r = this._runtime.GetAssetManager().GetProjectAudioFileUrl(e) || this._remoteUrls.get(e.toLowerCase());\n        if (r) {\n          const l = this._nextPlayTime, h = (this._nextPlayTime = 0, this._MaybeMarkAsPlaying(e, n, o, 0 !== s, this.DbToLinear(i)));\n          try {\n            await this.PostToDOMAsync(\"play\", { \"originalUrl\": e, \"url\": r.url, \"type\": r.type, \"isMusic\": o, \"tags\": this._SplitTags(n), \"isLooping\": 0 !== s, \"vol\": this.DbToLinear(i), \"stereoPan\": C0.clamp(a / 100, -1, 1), \"pos\": 0, \"off\": l, \"trueClock\": !!self[\"C3_GetAudioContextCurrentTime\"] });\n          } finally {\n            h && (h[\"placeholder\"] = this._runtime.GetTickCountNoSave());\n          }\n        }\n      }\n    }, async PlayAtPositionByName(t, e, s, i, a, n, o, r, l, h, u, c) {\n      if (!this._isSilent) {\n        const d = 1 === t, _ = this._runtime.GetAssetManager().GetProjectAudioFileUrl(e) || this._remoteUrls.get(e.toLowerCase());\n        if (_) {\n          const p = this._nextPlayTime, f = (this._nextPlayTime = 0, this._MaybeMarkAsPlaying(e, c, d, 0 !== s, this.DbToLinear(i)));\n          try {\n            await this.PostToDOMAsync(\"play\", { \"originalUrl\": e, \"url\": _.url, \"type\": _.type, \"isMusic\": d, \"tags\": this._SplitTags(c), \"isLooping\": 0 !== s, \"vol\": this.DbToLinear(i), \"pos\": 0, \"off\": p, \"trueClock\": !!self[\"C3_GetAudioContextCurrentTime\"], \"panning\": { \"x\": a, \"y\": n, \"z\": o, \"angle\": C0.toRadians(r), \"innerAngle\": C0.toRadians(l), \"outerAngle\": C0.toRadians(h), \"outerGain\": this.DbToLinear(u) } });\n          } finally {\n            f && (f[\"placeholder\"] = this._runtime.GetTickCountNoSave());\n          }\n        }\n      }\n    }, async PlayAtObjectByName(t, e, s, i, a, n, o, r, l) {\n      if (!this._isSilent && !this._isSilent && a) {\n        const h = a.GetFirstPicked();\n        if (h && h.GetWorldInfo()) {\n          const u = h.GetWorldInfo(), c = u.GetLayer().GetAngle(), [d, _] = this.rotatePtAround(u.GetX(), u.GetY(), -c, this._listenerPos[0], this._listenerPos[1]), p = 1 === t, f = this._runtime.GetAssetManager().GetProjectAudioFileUrl(e) || this._remoteUrls.get(e.toLowerCase());\n          if (f) {\n            const g = this._nextPlayTime, m = (this._nextPlayTime = 0, this._MaybeMarkAsPlaying(e, l, p, 0 !== s, this.DbToLinear(i)));\n            try {\n              await this.PostToDOMAsync(\"play\", { \"originalUrl\": e, \"url\": f.url, \"type\": f.type, \"isMusic\": p, \"tags\": this._SplitTags(l), \"isLooping\": 0 !== s, \"vol\": this.DbToLinear(i), \"pos\": 0, \"off\": g, \"trueClock\": !!self[\"C3_GetAudioContextCurrentTime\"], \"panning\": { \"x\": d, \"y\": _, \"z\": u.GetTotalZElevation(), \"angle\": u.GetAngle() - c, \"innerAngle\": C0.toRadians(n), \"outerAngle\": C0.toRadians(o), \"outerGain\": this.DbToLinear(r), \"uid\": h.GetUID() } });\n            } finally {\n              m && (m[\"placeholder\"] = this._runtime.GetTickCountNoSave());\n            }\n          }\n        }\n      }\n    }, SetLooping(t, e) {\n      this.PostToDOM(\"set-looping\", { \"tags\": this._SplitTags(t), \"isLooping\": 0 === e });\n    }, SetMuted(t, e) {\n      this.PostToDOM(\"set-muted\", { \"tags\": this._SplitTags(t), \"isMuted\": 0 === e });\n    }, SetVolume(t, e) {\n      this.PostToDOM(\"set-volume\", { \"tags\": this._SplitTags(t), \"vol\": this.DbToLinear(e) });\n    }, FadeVolume(t, e, s, i) {\n      this.PostToDOM(\"fade-volume\", { \"tags\": this._SplitTags(t), \"vol\": this.DbToLinear(e), \"duration\": s, \"stopOnEnd\": 0 === i });\n    }, SetStereoPan(t, e) {\n      this.PostToDOM(\"set-stereo-pan\", { \"tags\": this._SplitTags(t), \"p\": C0.clamp(e / 100, -1, 1) });\n    }, async Preload(t) {\n      const e = t[1], s = this._runtime.GetAssetManager().GetProjectAudioFileUrl(t[0]);\n      s && (this._preloadTotal++, await this.PostToDOMAsync(\"preload\", { \"originalUrl\": t[0], \"url\": s.url, \"type\": s.type, \"isMusic\": e }), this._preloadCount++);\n    }, async PreloadByName(t, e) {\n      const s = 1 === t, i = this._runtime.GetAssetManager().GetProjectAudioFileUrl(e) || this._remoteUrls.get(e.toLowerCase());\n      i && (this._preloadTotal++, await this.PostToDOMAsync(\"preload\", { \"originalUrl\": e, \"url\": i.url, \"type\": i.type, \"isMusic\": s }), this._preloadCount++);\n    }, SetPlaybackRate(t, e) {\n      this.PostToDOM(\"set-playback-rate\", { \"tags\": this._SplitTags(t), \"rate\": Math.max(e, 0) });\n    }, Stop(t) {\n      this._MaybeMarkAsStopped(t), this.PostToDOM(\"stop\", { \"tags\": this._SplitTags(t) });\n    }, StopAll() {\n      this._StopAll();\n    }, SetPaused(t, e) {\n      this.PostToDOM(\"set-paused\", { \"tags\": this._SplitTags(t), \"paused\": 0 === e });\n    }, Seek(t, e) {\n      this.PostToDOM(\"seek\", { \"tags\": this._SplitTags(t), \"pos\": e });\n    }, SetSilent(t) {\n      2 === t && (t = this._IsSilent() ? 1 : 0), this._SetSilent(0 === t);\n    }, SetMasterVolume(t) {\n      const e = this.DbToLinear(t);\n      this._SetMasterVolume(e);\n    }, AddFilterEffect(t, e, s, i, a, n, o) {\n      const r = D0[e];\n      this._IncrementEffectCount(t), this.PostToDOM(\"add-effect\", { \"type\": \"filter\", \"tags\": this._SplitTags(t), \"params\": [r, s, i, a, n, C0.clamp(o / 100, 0, 1)] });\n    }, AddDelayEffect(t, e, s, i) {\n      this._IncrementEffectCount(t), this.PostToDOM(\"add-effect\", { \"type\": \"delay\", \"tags\": this._SplitTags(t), \"params\": [e, this.DbToLinear(s), C0.clamp(i / 100, 0, 1)] });\n    }, AddFlangerEffect(t, e, s, i, a, n) {\n      this._IncrementEffectCount(t), this.PostToDOM(\"add-effect\", { \"type\": \"flanger\", \"tags\": this._SplitTags(t), \"params\": [e / 1e3, s / 1e3, i, a / 100, C0.clamp(n / 100, 0, 1)] });\n    }, AddPhaserEffect(t, e, s, i, a, n, o) {\n      this._IncrementEffectCount(t), this.PostToDOM(\"add-effect\", { \"type\": \"phaser\", \"tags\": this._SplitTags(t), \"params\": [e, s, i, a, n, C0.clamp(o / 100, 0, 1)] });\n    }, AddConvolutionEffect(t, e, s, i) {\n      const a = this._runtime.GetAssetManager().GetProjectAudioFileUrl(e[0]);\n      a && (this._IncrementEffectCount(t), this.PostToDOM(\"add-effect\", { \"type\": \"convolution\", \"tags\": this._SplitTags(t), \"bufferOriginalUrl\": e[0], \"bufferUrl\": a.url, \"bufferType\": a.type, \"params\": [0 === s, C0.clamp(i / 100, 0, 1)] }));\n    }, AddGainEffect(t, e) {\n      this._IncrementEffectCount(t), this.PostToDOM(\"add-effect\", { \"type\": \"gain\", \"tags\": this._SplitTags(t), \"params\": [this.DbToLinear(e)] });\n    }, AddStereoPanEffect(t, e) {\n      this._IncrementEffectCount(t), this.PostToDOM(\"add-effect\", { \"type\": \"stereopan\", \"tags\": this._SplitTags(t), \"params\": [C0.clamp(e / 100, -1, 1)] });\n    }, AddMuteEffect(t) {\n      this._IncrementEffectCount(t), this.PostToDOM(\"add-effect\", { \"type\": \"gain\", \"tags\": this._SplitTags(t), \"params\": [0] });\n    }, AddTremoloEffect(t, e, s) {\n      this._IncrementEffectCount(t), this.PostToDOM(\"add-effect\", { \"type\": \"tremolo\", \"tags\": this._SplitTags(t), \"params\": [e, C0.clamp(s / 100, 0, 1)] });\n    }, AddRingModEffect(t, e, s) {\n      this._IncrementEffectCount(t), this.PostToDOM(\"add-effect\", { \"type\": \"ringmod\", \"tags\": this._SplitTags(t), \"params\": [e, C0.clamp(s / 100, 0, 1)] });\n    }, AddDistortionEffect(t, e, s, i, a, n) {\n      this._IncrementEffectCount(t), this.PostToDOM(\"add-effect\", { \"type\": \"distortion\", \"tags\": this._SplitTags(t), \"params\": [this.DbToLinearNoCap(e), this.DbToLinearNoCap(s), i, this.DbToLinearNoCap(a), C0.clamp(n / 100, 0, 1)] });\n    }, AddCompressorEffect(t, e, s, i, a, n) {\n      this._IncrementEffectCount(t), this.PostToDOM(\"add-effect\", { \"type\": \"compressor\", \"tags\": this._SplitTags(t), \"params\": [e, s, i, a / 1e3, n / 1e3] });\n    }, AddAnalyserEffect(t, e, s) {\n      this._IncrementEffectCount(t), this.PostToDOM(\"add-effect\", { \"type\": \"analyser\", \"tags\": this._SplitTags(t), \"params\": [e, s] });\n    }, RemoveEffects(t) {\n      const e = this._SplitTags(t);\n      for (const s of e) this._effectCount.set(s.toLowerCase(), 0);\n      this.PostToDOM(\"remove-effects\", { \"tags\": e }), this._lastFxState = {};\n    }, SetEffectParameter(t, e, s, i, a, n) {\n      this.PostToDOM(\"set-effect-param\", { \"tags\": this._SplitTags(t), \"index\": Math.floor(e), \"param\": s, \"value\": i, \"ramp\": a, \"time\": n });\n    }, SetListenerObject(t) {\n      if (t) {\n        const e = t.GetFirstPicked();\n        e && e.GetWorldInfo() && (this._listenerInst = e);\n      }\n    }, SetListenerZ(t) {\n      this._listenerPos[2] = t;\n    }, SetListenerOrientation(t, e, s, i, a, n) {\n      this._listenerForwardVec[0] = t, this._listenerForwardVec[1] = e, this._listenerForwardVec[2] = -s, this._listenerUpVec[0] = i, this._listenerUpVec[1] = a, this._listenerUpVec[2] = -n;\n    }, ScheduleNextPlay(t) {\n      this._nextPlayTime = Math.max(t, 0);\n    }, UnloadAudio(t) {\n      const e = t[1], s = this._runtime.GetAssetManager().GetProjectAudioFileUrl(t[0]);\n      s && this.PostToDOM(\"unload\", { \"url\": s.url, \"type\": s.type, \"isMusic\": e });\n    }, UnloadAudioByName(t, e) {\n      const s = 1 === t, i = this._runtime.GetAssetManager().GetProjectAudioFileUrl(e) || this._remoteUrls.get(e.toLowerCase());\n      i && this.PostToDOM(\"unload\", { \"url\": i.url, \"type\": i.type, \"isMusic\": s });\n    }, UnloadAll() {\n      this.PostToDOM(\"unload-all\");\n    }, AddRemoteURL(t, e, s) {\n      this._remoteUrls.set(s.toLowerCase(), { url: t, type: e });\n    } };\n  }\n  {\n    const y2 = self.C3;\n    y2.Plugins.Audio.Exps = { Duration(t) {\n      const e = this._GetFirstAudioStateByTags(t);\n      return e ? e[\"duration\"] : 0;\n    }, PlaybackTime(t) {\n      const e = this._GetFirstAudioStateByTags(t);\n      return e ? e[\"playbackTime\"] : 0;\n    }, PlaybackRate(t) {\n      const e = this._GetFirstAudioStateByTags(t);\n      return e ? e[\"playbackRate\"] : 0;\n    }, Volume(t) {\n      const e = this._GetFirstAudioStateByTags(t);\n      return e ? this.LinearToDb(e[\"volume\"]) : 0;\n    }, MasterVolume() {\n      return this.LinearToDb(this._GetMasterVolume());\n    }, EffectCount(t) {\n      return this._effectCount.get(t.toLowerCase()) || 0;\n    }, AnalyserFreqBinCount(t, e) {\n      const s = this.GetAnalyserData(t, Math.floor(e));\n      return s ? s[\"binCount\"] : 0;\n    }, AnalyserFreqBinAt(t, e, s) {\n      const i = this.GetAnalyserData(t, Math.floor(e));\n      return !i || (s = Math.floor(s)) < 0 || s >= i[\"binCount\"] ? 0 : i[\"freqBins\"][s];\n    }, AnalyserPeakLevel(t, e) {\n      const s = this.GetAnalyserData(t, Math.floor(e));\n      return s ? s[\"peak\"] : 0;\n    }, AnalyserRMSLevel(t, e) {\n      const s = this.GetAnalyserData(t, Math.floor(e));\n      return s ? s[\"rms\"] : 0;\n    }, SampleRate() {\n      return this._sampleRate;\n    }, CurrentTime() {\n      return self[\"C3_GetAudioContextCurrentTime\"] ? self[\"C3_GetAudioContextCurrentTime\"]() : performance.now() / 1e3;\n    }, OutputLatency() {\n      return this._outputLatency;\n    }, NormalizedVolume(t, e) {\n      return 0 === (t = y2.clamp(+t, 0, 100) / 100) ? -1 / 0 : t < 0.1 ? this.LinearToDb(y2.lerp(0, this.DbToLinear(e), 10 * t)) : y2.lerp(e, 0, (t - 0.1) / 0.9);\n    } };\n  }\n}\nvar GetAudioSdkInstance2;\nvar GetAudioDOMInterface2;\n{\n  {\n    let MaybeCloseImageBitmap = function(e) {\n      e && e[\"close\"] && e[\"close\"]();\n    };\n    MaybeCloseImageBitmap2 = MaybeCloseImageBitmap;\n    const a = self.C3, b = \"video\";\n    a.Plugins.video = class extends a.SDKDOMPluginBase {\n      constructor(e) {\n        super(e, b), this._postImageBitmaps = false, this._supportedFormats = {}, this._lastStateSequenceNumber = -1, this._videoState = /* @__PURE__ */ new Map(), this._runtime.AddLoadPromise(this._runtime.PostComponentMessageToDOMAsync(\"video\", \"init\", { \"isInWorker\": this._runtime.IsInWorker() }).then((e2) => {\n          this._postImageBitmaps = e2[\"postImageBitmaps\"], this._supportedFormats = e2[\"supportedFormats\"];\n        })), this.AddElementMessageHandler(\"playback-event\", (e2, t) => e2._OnPlaybackEvent(t)), this._runtime.AddDOMComponentMessageHandler(b, \"state\", (e2) => this._OnUpdateState(e2));\n      }\n      Release() {\n        super.Release();\n      }\n      IsPostImageBitmapsMode() {\n        return this._postImageBitmaps;\n      }\n      IsFormatSupported(e) {\n        return !!this._supportedFormats[e];\n      }\n      _OnUpdateState(e) {\n        const t = e[\"sequenceNumber\"];\n        if (t <= this._lastStateSequenceNumber) for (const s of Object.values(e[\"videoData\"])) MaybeCloseImageBitmap(s[\"imageBitmap\"]);\n        else {\n          this._lastStateSequenceNumber = t;\n          for (const i of this._videoState.values()) MaybeCloseImageBitmap(i[\"imageBitmap\"]);\n          this._videoState.clear();\n          for (const [a2, r] of Object.entries(e[\"videoData\"])) this._videoState.set(parseInt(a2, 10), r);\n        }\n      }\n      _DeleteVideoState(e) {\n        this._videoState.delete(e);\n      }\n      GetVideoState(e) {\n        return this._videoState.get(e) || null;\n      }\n    };\n  }\n  {\n    const s = self.C3;\n    s.Plugins.video.Type = class extends s.SDKTypeBase {\n      constructor(e) {\n        super(e);\n      }\n      Release() {\n        super.Release();\n      }\n      OnCreate() {\n      }\n    };\n  }\n  {\n    const v = self.C3, w = v.New(v.Rect), x = v.New(v.Quad), y = \"video\", z = [\"webm-vp8\", \"webm-vp9\", \"webm-av1\", \"mp4-h264\", \"mp4-h265\", \"mp4-av1\"];\n    v.Plugins.video.Instance = class extends v.SDKDOMInstanceBase {\n      constructor(e, t) {\n        super(e, y), this._primarySrc = \"\", this._primaryFormat = \"mp4-h264\", this._secondarySrc = \"\", this._secondaryFormat = \"webm-vp9\", this._autoplay = 2, this._playInBackground = false, this._videoWasPlayingOnSuspend = false, this._webGLTexture = null, this._currentTrigger = -1, this._isSettingSource = 0, this._isPlaying = false, this._isPaused = false, this._hasEnded = false, this._isLooping = false, this._isMuted = false, this._volume = 0, t && (this._primarySrc = t[0], this._primaryFormat = z[t[1]], this._secondarySrc = t[2], this._secondaryFormat = z[t[3]], this._autoplay = t[4], this._playInBackground = t[5], this.GetWorldInfo().SetVisible(t[6]));\n        const s = this._runtime.Dispatcher();\n        this._disposables = new v.CompositeDisposable(v.Disposable.From(s, \"renderercontextlost\", () => this._OnRendererContextLost()), v.Disposable.From(s, \"suspend\", () => this._OnSuspend()), v.Disposable.From(s, \"resume\", () => this._OnResume())), this.CreateElement({ \"src\": this.GetVideoSource(), \"autoplay\": this._autoplay });\n      }\n      Release() {\n        this.GetPlugin()._DeleteVideoState(this.GetElementId()), this._ReleaseTexture(), super.Release();\n      }\n      _MaybeCreateTexture(e, t, s) {\n        if (this._webGLTexture) {\n          if (this._webGLTexture.GetWidth() === t || this._webGLTexture.GetHeight() === s) return;\n          this._ReleaseTexture();\n        }\n        this._webGLTexture = e.CreateDynamicTexture(t, s, { sampling: this._runtime.GetSampling(), mipMap: false });\n      }\n      _ReleaseTexture() {\n        this._webGLTexture && (this._runtime.GetRenderer().DeleteTexture(this._webGLTexture), this._webGLTexture = null);\n      }\n      GetElementState() {\n        return {};\n      }\n      DbToLinearNoCap(e) {\n        return Math.pow(10, e / 20);\n      }\n      DbToLinear(e) {\n        const t = this.DbToLinearNoCap(e);\n        return isFinite(t) ? Math.max(Math.min(t, 1), 0) : 0;\n      }\n      LinearToDbNoCap(e) {\n        return Math.log(e) / Math.log(10) * 20;\n      }\n      LinearToDb(e) {\n        return this.LinearToDbNoCap(Math.max(Math.min(e, 1), 0));\n      }\n      GetVideoSource() {\n        let e = \"\";\n        const t = this.GetPlugin();\n        return t.IsFormatSupported(this._primaryFormat) && this._primarySrc ? e = this._primarySrc : t.IsFormatSupported(this._secondaryFormat) && this._secondarySrc && (e = this._secondarySrc), e && (v.IsRelativeURL(e) ? this._runtime.GetAssetManager().GetMediaFileUrl(e) : e);\n      }\n      _OnRendererContextLost() {\n        this._webGLTexture = null;\n      }\n      async _OnPlaybackEvent(e) {\n        const t = e[\"type\"];\n        5 === t ? this._SetIsPlaying(true) : 2 === t ? (this._SetIsPlaying(false), this._hasEnded = true, this._isPaused = false) : 6 === t && (this._SetIsPlaying(false), this._isPaused = true, this._hasEnded = false), this._currentTrigger = t, await this.TriggerAsync(v.Plugins.video.Cnds.OnPlaybackEvent);\n      }\n      _SetIsPlaying(e) {\n        this._isPlaying = !!e, this._isPlaying ? (this._StartTicking(), this._isPaused = false, this._hasEnded = false) : this._StopTicking();\n      }\n      _OnSuspend() {\n        this._playInBackground || this._isPlaying && (this._videoWasPlayingOnSuspend = true, this.PostToDOMElement(\"pause\"));\n      }\n      _OnResume() {\n        this._playInBackground || this._videoWasPlayingOnSuspend && (this.PostToDOMElement(\"play\"), this._videoWasPlayingOnSuspend = false);\n      }\n      Draw(a) {\n        const r = this.GetWorldInfo();\n        let o = 0, n = 0, h = null;\n        const u = this.GetPlugin().IsPostImageBitmapsMode();\n        if (u) {\n          const e = this.GetMyState();\n          if (!e) return;\n          h = e[\"imageBitmap\"], e[\"imageBitmap\"] = null, o = e[\"videoWidth\"], n = e[\"videoHeight\"];\n        } else {\n          const t = self[\"C3Video_GetElement\"](this.GetElementId());\n          if (!t) return;\n          o = t.videoWidth, n = t.videoHeight, h = t;\n        }\n        if (!(o <= 0 || n <= 0)) {\n          this._MaybeCreateTexture(a, o, n), h && (a.UpdateTexture(h, this._webGLTexture), u) && h[\"close\"] && h[\"close\"]();\n          const l = o / n, d = r.GetWidth(), m = r.GetHeight(), _ = d / m;\n          let e = 0, t = 0, s = 0, i = 0;\n          l < _ ? (s = m * l, i = m, e = Math.max(Math.floor((d - s) / 2), 0)) : (s = d, i = d / l, t = Math.max(Math.floor((m - i) / 2), 0)), a.SetTexture(this._webGLTexture), w.setWH(r.GetX() + e, r.GetY() + t, s, i), x.setFromRect(w), a.Quad(x);\n        }\n      }\n      Tick() {\n        this._runtime.UpdateRender();\n      }\n      GetMyState() {\n        return this.GetPlugin().GetVideoState(this.GetElementId());\n      }\n    };\n  }\n  {\n    const fa = self.C3;\n    fa.Plugins.video.Cnds = { IsPlaying() {\n      return this._isPlaying;\n    }, IsPaused() {\n      return this._isPaused;\n    }, HasEnded() {\n      return this._hasEnded;\n    }, IsMuted() {\n      return this._isMuted;\n    }, OnPlaybackEvent(e) {\n      return this._currentTrigger === e;\n    } };\n  }\n  {\n    const ha = self.C3, ia = [\"webm-vp8\", \"webm-vp9\", \"webm-av1\", \"mp4-h264\", \"mp4-h265\", \"mp4-av1\"];\n    ha.Plugins.video.Acts = { SetSource(e, t) {\n      this._primarySrc = e, this._primaryFormat = \"webm-vp8\", this._secondarySrc = t, this._secondaryFormat = \"mp4-h264\", this.PostToDOMElement(\"set-source\", { \"src\": this.GetVideoSource() }), this._ReleaseTexture();\n    }, SetSource2(e, t, s, i) {\n      this._primarySrc = e, this._primaryFormat = ia[t], this._secondarySrc = s, this._secondaryFormat = ia[i], this.PostToDOMElement(\"set-source\", { \"src\": this.GetVideoSource() }), this._ReleaseTexture();\n    }, SetPlaybackTime(e) {\n      this.PostToDOMElement(\"set-playback-time\", { \"time\": e });\n    }, SetPlaybackRate(e) {\n      this.PostToDOMElement(\"set-playback-rate\", { \"rate\": e });\n    }, SetLooping(e) {\n      this._isLooping !== (e = 0 !== e) && (this._isLooping = e, this.PostToDOMElement(\"set-looping\", { \"isLooping\": e }));\n    }, SetMuted(e) {\n      this._isMuted !== (e = 0 !== e) && (this._isMuted = e, this.PostToDOMElement(\"set-muted\", { \"isMuted\": e }));\n    }, SetVolume(e) {\n      this._volume !== e && (this._volume = e, this.PostToDOMElement(\"set-volume\", { \"volume\": this.DbToLinear(e) }));\n    }, Pause() {\n      this.PostToDOMElement(\"pause\");\n    }, Play() {\n      this._PostToDOMElementMaybeSync(\"play\");\n    } };\n  }\n  {\n    const ua = self.C3;\n    ua.Plugins.video.Exps = { PlaybackTime() {\n      const e = this.GetMyState();\n      return e ? e[\"currentTime\"] : 0;\n    }, PlaybackRate() {\n      const e = this.GetMyState();\n      return e ? e[\"playbackRate\"] : 1;\n    }, Duration() {\n      const e = this.GetMyState();\n      return e ? e[\"duration\"] : 0;\n    }, Volume() {\n      return this._volume;\n    }, VideoWidth() {\n      const e = this.GetMyState();\n      return e ? e[\"videoWidth\"] : 0;\n    }, VideoHeight() {\n      const e = this.GetMyState();\n      return e ? e[\"videoHeight\"] : 0;\n    } };\n  }\n}\nvar MaybeCloseImageBitmap2;\n{\n  {\n    const a = self.C3;\n    a.Plugins.Touch = class extends a.SDKPluginBase {\n      constructor(t) {\n        super(t);\n      }\n      Release() {\n        super.Release();\n      }\n    };\n  }\n  {\n    let GetTouchSdkInstance = function() {\n      return s.GetSingleGlobalInstance().GetSdkInstance();\n    };\n    GetTouchSdkInstance2 = GetTouchSdkInstance;\n    const d = self.C3, e = self.C3X;\n    d.Plugins.Touch.Type = class extends d.SDKTypeBase {\n      constructor(t) {\n        super(t);\n      }\n      Release() {\n        super.Release();\n      }\n      OnCreate() {\n      }\n      GetScriptInterfaceClass() {\n        return self.ITouchObjectType;\n      }\n    };\n    let s = null;\n    self.ITouchObjectType = class extends self.IObjectClass {\n      constructor(t) {\n        super(t), (s = t).GetRuntime()._GetCommonScriptInterfaces().touch = this;\n      }\n      requestPermission(t) {\n        e.RequireString(t);\n        const s2 = GetTouchSdkInstance();\n        if (\"orientation\" === t) return s2._RequestPermission(0);\n        if (\"motion\" === t) return s2._RequestPermission(1);\n        throw new Error(\"invalid type\");\n      }\n    };\n  }\n  {\n    const m = self.C3, n = \"touch\";\n    m.Plugins.Touch.Instance = class extends m.SDKInstanceBase {\n      constructor(t, e) {\n        super(t, n), this._touches = /* @__PURE__ */ new Map(), this._useMouseInput = false, this._isMouseDown = false, this._orientCompassHeading = 0, this._orientAlpha = 0, this._orientBeta = 0, this._orientGamma = 0, this._accX = 0, this._accY = 0, this._accZ = 0, this._accWithGX = 0, this._accWithGY = 0, this._accWithGZ = 0, this._triggerIndex = 0, this._triggerId = 0, this._triggerPermission = 0, this._curTouchX = 0, this._curTouchY = 0, this._getTouchIndex = 0, this._triggerType = 0, this._permissionPromises = [], e && (this._useMouseInput = e[0]), this.AddDOMMessageHandler(\"permission-result\", (t2) => this._OnPermissionResult(t2));\n        const s = this.GetRuntime().Dispatcher();\n        this._disposables = new m.CompositeDisposable(m.Disposable.From(s, \"pointerdown\", (t2) => this._OnPointerDown(t2.data)), m.Disposable.From(s, \"pointermove\", (t2) => this._OnPointerMove(t2.data)), m.Disposable.From(s, \"pointerup\", (t2) => this._OnPointerUp(t2.data, false)), m.Disposable.From(s, \"pointercancel\", (t2) => this._OnPointerUp(t2.data, true)), m.Disposable.From(s, \"deviceorientation\", (t2) => this._OnDeviceOrientation(t2.data)), m.Disposable.From(s, \"deviceorientationabsolute\", (t2) => this._OnDeviceOrientationAbsolute(t2.data)), m.Disposable.From(s, \"devicemotion\", (t2) => this._OnDeviceMotion(t2.data)), m.Disposable.From(s, \"tick2\", (t2) => this._OnTick2()));\n      }\n      Release() {\n        this._touches.clear(), super.Release();\n      }\n      _OnPointerDown(t) {\n        if (\"mouse\" === t[\"pointerType\"]) {\n          if (!this._useMouseInput) return;\n          this._isMouseDown = true;\n        }\n        const e = t[\"pointerId\"];\n        if (!this._touches.has(e)) {\n          const s = t[\"pageX\"] - this._runtime.GetCanvasClientX(), i = t[\"pageY\"] - this._runtime.GetCanvasClientY(), n2 = performance.now(), r = this._touches.size, o = (this._triggerIndex = r, this._triggerId = e, m.New(m.Plugins.Touch.TouchInfo));\n          o.Init(n2, s, i, e, r), this._touches.set(e, o), this.Trigger(m.Plugins.Touch.Cnds.OnNthTouchStart), this.Trigger(m.Plugins.Touch.Cnds.OnTouchStart), this._curTouchX = s, this._curTouchY = i, this._triggerType = 0, this.Trigger(m.Plugins.Touch.Cnds.OnTouchObject);\n        }\n      }\n      _OnPointerMove(t) {\n        if (\"mouse\" !== t[\"pointerType\"] || this._isMouseDown) {\n          const e = this._touches.get(t[\"pointerId\"]);\n          if (e) {\n            const s = performance.now();\n            if (!(s - e.GetTime() < 2)) {\n              const i = t[\"pageX\"] - this._runtime.GetCanvasClientX(), n2 = t[\"pageY\"] - this._runtime.GetCanvasClientY();\n              e.Update(s, i, n2, t[\"width\"], t[\"height\"], t[\"pressure\"]);\n            }\n          }\n        }\n      }\n      _OnPointerUp(t, e) {\n        if (\"mouse\" === t[\"pointerType\"]) {\n          if (!this._isMouseDown) return;\n          this._isMouseDown = false;\n        }\n        const s = performance.now(), i = t[\"pointerId\"], n2 = this._touches.get(i);\n        if (n2) {\n          if (this._triggerIndex = n2.GetStartIndex(), this._triggerId = n2.GetId(), !e) {\n            const r = t[\"pageX\"] - this._runtime.GetCanvasClientX(), o = t[\"pageY\"] - this._runtime.GetCanvasClientY();\n            this._curTouchX = r, this._curTouchY = o, this._triggerType = 1, this.Trigger(m.Plugins.Touch.Cnds.OnTouchObject);\n          }\n          if (this.Trigger(m.Plugins.Touch.Cnds.OnNthTouchEnd), this.Trigger(m.Plugins.Touch.Cnds.OnTouchEnd), !e) {\n            const u = n2.ShouldTriggerTap(s);\n            \"single-tap\" === u ? (this.Trigger(m.Plugins.Touch.Cnds.OnTapGesture), this._curTouchX = n2.GetX(), this._curTouchY = n2.GetY(), this.Trigger(m.Plugins.Touch.Cnds.OnTapGestureObject)) : \"double-tap\" === u && (this.Trigger(m.Plugins.Touch.Cnds.OnDoubleTapGesture), this._curTouchX = n2.GetX(), this._curTouchY = n2.GetY(), this.Trigger(m.Plugins.Touch.Cnds.OnDoubleTapGestureObject));\n          }\n          n2.Release(), this._touches.delete(i);\n        }\n      }\n      _RequestPermission(s) {\n        return this._PostToDOMMaybeSync(\"request-permission\", { \"type\": s }), new Promise((t, e) => {\n          this._permissionPromises.push({ type: s, resolve: t, reject: e });\n        });\n      }\n      _OnPermissionResult(t) {\n        const e = t[\"result\"], s = t[\"type\"], i = (this._triggerPermission = s, this._permissionPromises.filter((t2) => t2.type === s));\n        for (const n2 of i) n2.resolve(e ? \"granted\" : \"denied\");\n        this._permissionPromises = this._permissionPromises.filter((t2) => t2.type !== s), e ? (this.Trigger(m.Plugins.Touch.Cnds.OnPermissionGranted), 0 === s ? this._runtime.RequestDeviceOrientationEvent() : this._runtime.RequestDeviceMotionEvent()) : this.Trigger(m.Plugins.Touch.Cnds.OnPermissionDenied);\n      }\n      _OnDeviceOrientation(t) {\n        \"number\" == typeof t[\"webkitCompassHeading\"] ? this._orientCompassHeading = t[\"webkitCompassHeading\"] : t[\"absolute\"] && (this._orientCompassHeading = t[\"alpha\"]), this._orientAlpha = t[\"alpha\"], this._orientBeta = t[\"beta\"], this._orientGamma = t[\"gamma\"];\n      }\n      _OnDeviceOrientationAbsolute(t) {\n        this._orientCompassHeading = t[\"alpha\"];\n      }\n      _OnDeviceMotion(t) {\n        const e = t[\"acceleration\"], s = (e && (this._accX = e[\"x\"], this._accY = e[\"y\"], this._accZ = e[\"z\"]), t[\"accelerationIncludingGravity\"]);\n        s && (this._accWithGX = s[\"x\"], this._accWithGY = s[\"y\"], this._accWithGZ = s[\"z\"]);\n      }\n      _OnTick2() {\n        const t = performance.now();\n        let e = 0;\n        for (const s of this._touches.values()) s.GetTime() <= t - 50 && s._SetLastTime(t), s.ShouldTriggerHold(t) && (this._triggerIndex = s.GetStartIndex(), this._triggerId = s.GetId(), this._getTouchIndex = e, this.Trigger(m.Plugins.Touch.Cnds.OnHoldGesture), this._curTouchX = s.GetX(), this._curTouchY = s.GetY(), this.Trigger(m.Plugins.Touch.Cnds.OnHoldGestureObject), this._getTouchIndex = 0), ++e;\n      }\n      _GetTouchByIndex(t) {\n        t = Math.floor(t);\n        for (const e of this._touches.values()) {\n          if (0 === t) return e;\n          --t;\n        }\n        return null;\n      }\n      _IsClientPosOnCanvas(t, e) {\n        return 0 <= t && 0 <= e && t < this._runtime.GetCanvasCssWidth() && e < this._runtime.GetCanvasCssHeight();\n      }\n      GetDebuggerProperties() {\n        return [{ title: \"plugins.touch.debugger.touches\", properties: [...this._touches.values()].map((t) => ({ name: \"$\" + t.GetId(), value: t.GetX() + \", \" + t.GetY() })) }];\n      }\n    };\n  }\n  {\n    const ra = self.C3, sa = [];\n    ra.Plugins.Touch.Cnds = { OnTouchStart() {\n      return true;\n    }, OnTouchEnd() {\n      return true;\n    }, IsInTouch() {\n      return 0 < this._touches.size;\n    }, OnTouchObject(t, e) {\n      return !!t && e === this._triggerType && !!this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) && this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(t, [[this._curTouchX, this._curTouchY]], false);\n    }, IsTouchingObject(t) {\n      if (!t) return false;\n      const e = this._runtime.GetCurrentCondition(), s = e.IsInverted(), i = [...this._touches.values()].filter((t2) => this._IsClientPosOnCanvas(t2.GetX(), t2.GetY())).map((t2) => [t2.GetX(), t2.GetY()]);\n      return ra.xor(this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(t, i, s), s);\n    }, CompareTouchSpeed(t, e, s) {\n      const i = this._GetTouchByIndex(t);\n      return !!i && ra.compare(i.GetSpeed(), e, s);\n    }, OrientationSupported() {\n      return true;\n    }, MotionSupported() {\n      return true;\n    }, CompareOrientation(t, e, s) {\n      this._runtime.RequestDeviceOrientationEvent();\n      let i = 0;\n      return i = 0 === t ? this._orientAlpha : 1 === t ? this._orientBeta : this._orientGamma, ra.compare(i, e, s);\n    }, CompareAcceleration(t, e, s) {\n      this._runtime.RequestDeviceMotionEvent();\n      let i = 0;\n      return i = 0 === t ? this._accWithGX : 1 === t ? this._accWithGY : 2 === t ? this._accWithGZ : 3 === t ? this._accX : 4 === t ? this._accY : this._accZ, ra.compare(i, e, s);\n    }, OnNthTouchStart(t) {\n      return (t = Math.floor(t)) === this._triggerIndex;\n    }, OnNthTouchEnd(t) {\n      return (t = Math.floor(t)) === this._triggerIndex;\n    }, HasNthTouch(t) {\n      return t = Math.floor(t), this._touches.size >= t + 1;\n    }, OnHoldGesture() {\n      return true;\n    }, OnTapGesture() {\n      return true;\n    }, OnDoubleTapGesture() {\n      return true;\n    }, OnHoldGestureObject(t) {\n      return !!t && !!this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) && this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(t, [[this._curTouchX, this._curTouchY]], false);\n    }, OnTapGestureObject(t) {\n      return !!t && !!this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) && this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(t, [[this._curTouchX, this._curTouchY]], false);\n    }, OnDoubleTapGestureObject(t) {\n      return !!t && !!this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) && this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(t, [[this._curTouchX, this._curTouchY]], false);\n    }, OnPermissionGranted(t) {\n      return this._triggerPermission === t;\n    }, OnPermissionDenied(t) {\n      return this._triggerPermission === t;\n    } };\n  }\n  {\n    const Va = self.C3;\n    Va.Plugins.Touch.Acts = { RequestPermission(t) {\n      this._RequestPermission(t);\n    } };\n  }\n  {\n    const Xa = self.C3;\n    Xa.Plugins.Touch.Exps = { TouchCount() {\n      return this._touches.size;\n    }, X(t) {\n      const e = this._GetTouchByIndex(this._getTouchIndex);\n      return e ? e.GetPositionForLayer(this._runtime.GetCurrentLayout(), t, true) : 0;\n    }, Y(t) {\n      const e = this._GetTouchByIndex(this._getTouchIndex);\n      return e ? e.GetPositionForLayer(this._runtime.GetCurrentLayout(), t, false) : 0;\n    }, XAt(t, e) {\n      const s = this._GetTouchByIndex(t);\n      return s ? s.GetPositionForLayer(this._runtime.GetCurrentLayout(), e, true) : 0;\n    }, YAt(t, e) {\n      const s = this._GetTouchByIndex(t);\n      return s ? s.GetPositionForLayer(this._runtime.GetCurrentLayout(), e, false) : 0;\n    }, XForID(t, e) {\n      const s = this._touches.get(t);\n      return s ? s.GetPositionForLayer(this._runtime.GetCurrentLayout(), e, true) : 0;\n    }, YForID(t, e) {\n      const s = this._touches.get(t);\n      return s ? s.GetPositionForLayer(this._runtime.GetCurrentLayout(), e, false) : 0;\n    }, AbsoluteX() {\n      const t = this._GetTouchByIndex(0);\n      return t ? t.GetX() : 0;\n    }, AbsoluteY() {\n      const t = this._GetTouchByIndex(0);\n      return t ? t.GetY() : 0;\n    }, AbsoluteXAt(t) {\n      const e = this._GetTouchByIndex(t);\n      return e ? e.GetX() : 0;\n    }, AbsoluteYAt(t) {\n      const e = this._GetTouchByIndex(t);\n      return e ? e.GetY() : 0;\n    }, AbsoluteXForID(t) {\n      const e = this._touches.get(t);\n      return e ? e.GetX() : 0;\n    }, AbsoluteYForID(t) {\n      const e = this._touches.get(t);\n      return e ? e.GetY() : 0;\n    }, SpeedAt(t) {\n      const e = this._GetTouchByIndex(t);\n      return e ? e.GetSpeed() : 0;\n    }, SpeedForID(t) {\n      const e = this._touches.get(t);\n      return e ? e.GetSpeed() : 0;\n    }, AngleAt(t) {\n      const e = this._GetTouchByIndex(t);\n      return e ? Xa.toDegrees(e.GetAngle()) : 0;\n    }, AngleForID(t) {\n      const e = this._touches.get(t);\n      return e ? Xa.toDegrees(e.GetAngle()) : 0;\n    }, CompassHeading() {\n      return this._runtime.RequestDeviceOrientationEvent(), this._orientCompassHeading;\n    }, Alpha() {\n      return this._runtime.RequestDeviceOrientationEvent(), this._orientAlpha;\n    }, Beta() {\n      return this._runtime.RequestDeviceOrientationEvent(), this._orientBeta;\n    }, Gamma() {\n      return this._runtime.RequestDeviceOrientationEvent(), this._orientGamma;\n    }, AccelerationXWithG() {\n      return this._runtime.RequestDeviceMotionEvent(), this._accWithGX;\n    }, AccelerationYWithG() {\n      return this._runtime.RequestDeviceMotionEvent(), this._accWithGY;\n    }, AccelerationZWithG() {\n      return this._runtime.RequestDeviceMotionEvent(), this._accWithGZ;\n    }, AccelerationX() {\n      return this._runtime.RequestDeviceMotionEvent(), this._accX;\n    }, AccelerationY() {\n      return this._runtime.RequestDeviceMotionEvent(), this._accY;\n    }, AccelerationZ() {\n      return this._runtime.RequestDeviceMotionEvent(), this._accZ;\n    }, TouchIndex() {\n      return this._triggerIndex;\n    }, TouchID() {\n      return this._triggerId;\n    }, WidthForID(t) {\n      const e = this._touches.get(t);\n      return e ? e.GetWidth() : 0;\n    }, HeightForID(t) {\n      const e = this._touches.get(t);\n      return e ? e.GetHeight() : 0;\n    }, PressureForID(t) {\n      const e = this._touches.get(t);\n      return e ? e.GetPressure() : 0;\n    } };\n  }\n}\nvar GetTouchSdkInstance2;\n{\n  const C32 = self.C3, GESTURE_HOLD_THRESHOLD = 15, GESTURE_HOLD_TIMEOUT = 500, GESTURE_TAP_TIMEOUT = 333, GESTURE_DOUBLETAP_THRESHOLD = 25;\n  let lastTapX = -1e3, lastTapY = -1e3, lastTapTime = -1e4;\n  C32.Plugins.Touch.TouchInfo = class extends C32.DefendedBase {\n    constructor() {\n      super(), this._pointerId = 0, this._startIndex = 0, this._startTime = 0, this._time = 0, this._lastTime = 0, this._startX = 0, this._startY = 0, this._x = 0, this._y = 0, this._lastX = 0, this._lastY = 0, this._width = 0, this._height = 0, this._pressure = 0, this._hasTriggeredHold = false, this._isTooFarForHold = false;\n    }\n    Release() {\n    }\n    Init(t, s, i, e, _) {\n      this._pointerId = e, this._startIndex = _, this._time = t, this._lastTime = t, this._startTime = t, this._startX = s, this._startY = i, this._x = s, this._y = i, this._lastX = s, this._lastY = i;\n    }\n    Update(t, s, i, e, _, h) {\n      this._lastTime = this._time, this._time = t, this._lastX = this._x, this._lastY = this._y, this._x = s, this._y = i, this._width = e, this._height = _, this._pressure = h, !this._isTooFarForHold && C32.distanceTo(this._startX, this._startY, this._x, this._y) >= GESTURE_HOLD_THRESHOLD && (this._isTooFarForHold = true);\n    }\n    GetId() {\n      return this._pointerId;\n    }\n    GetStartIndex() {\n      return this._startIndex;\n    }\n    GetTime() {\n      return this._time;\n    }\n    _SetLastTime(t) {\n      this._lastTime = t;\n    }\n    GetX() {\n      return this._x;\n    }\n    GetY() {\n      return this._y;\n    }\n    GetSpeed() {\n      const t = C32.distanceTo(this._x, this._y, this._lastX, this._lastY), s = (this._time - this._lastTime) / 1e3;\n      return 0 < s ? t / s : 0;\n    }\n    GetAngle() {\n      return C32.angleTo(this._lastX, this._lastY, this._x, this._y);\n    }\n    GetWidth() {\n      return this._width;\n    }\n    GetHeight() {\n      return this._height;\n    }\n    GetPressure() {\n      return this._pressure;\n    }\n    ShouldTriggerHold(t) {\n      return !this._hasTriggeredHold && t - this._startTime >= GESTURE_HOLD_TIMEOUT && !this._isTooFarForHold && C32.distanceTo(this._startX, this._startY, this._x, this._y) < GESTURE_HOLD_THRESHOLD && (this._hasTriggeredHold = true);\n    }\n    ShouldTriggerTap(t) {\n      return !this._hasTriggeredHold && t - this._startTime <= GESTURE_TAP_TIMEOUT && !this._isTooFarForHold && C32.distanceTo(this._startX, this._startY, this._x, this._y) < GESTURE_HOLD_THRESHOLD ? t - lastTapTime <= 2 * GESTURE_TAP_TIMEOUT && C32.distanceTo(lastTapX, lastTapY, this._x, this._y) < GESTURE_DOUBLETAP_THRESHOLD ? (lastTapX = -1e3, lastTapY = -1e3, lastTapTime = -1e4, \"double-tap\") : (lastTapX = this._x, lastTapY = this._y, lastTapTime = t, \"single-tap\") : \"\";\n    }\n    GetPositionForLayer(t, s, i) {\n      if (void 0 === s) {\n        const e = t.GetLayerByIndex(0);\n        return e.CanvasCssToLayer_DefaultTransform(this._x, this._y)[i ? 0 : 1];\n      }\n      {\n        const _ = t.GetLayer(s);\n        return _ ? _.CanvasCssToLayer(this._x, this._y)[i ? 0 : 1] : 0;\n      }\n    }\n  };\n}\n{\n  {\n    const a = self.C3;\n    a.Plugins.PlatformInfo = class extends a.SDKPluginBase {\n      constructor(e) {\n        super(e);\n      }\n      Release() {\n        super.Release();\n      }\n    };\n  }\n  {\n    const d = self.C3;\n    d.Plugins.PlatformInfo.Type = class extends d.SDKTypeBase {\n      constructor(e) {\n        super(e);\n      }\n      Release() {\n        super.Release();\n      }\n      OnCreate() {\n      }\n    };\n  }\n  {\n    const g = self.C3, h = \"platform-info\";\n    g.Plugins.PlatformInfo.Instance = class extends g.SDKInstanceBase {\n      constructor(e, t) {\n        super(e, h), this._screenWidth = 0, this._screenHeight = 0, this._windowOuterWidth = 0, this._windowOuterHeight = 0, this._safeAreaInset = [0, 0, 0, 0], this._supportsWakeLock = false, this._isWakeLockActive = false, this.AddDOMMessageHandlers([[\"window-resize\", (e2) => this._OnWindowResize(e2)], [\"wake-lock-acquired\", (e2) => this._OnWakeLockAcquired(e2)], [\"wake-lock-error\", (e2) => this._OnWakeLockError(e2)], [\"wake-lock-released\", (e2) => this._OnWakeLockReleased(e2)]]), navigator.connection && navigator.connection.addEventListener(\"change\", () => this._OnNetworkChange()), this._runtime.AddLoadPromise(this.PostToDOMAsync(\"get-initial-state\").then((e2) => {\n          this._screenWidth = e2[\"screenWidth\"], this._screenHeight = e2[\"screenHeight\"], this._windowOuterWidth = e2[\"windowOuterWidth\"], this._windowOuterHeight = e2[\"windowOuterHeight\"], this._safeAreaInset = e2[\"safeAreaInset\"], this._supportsWakeLock = e2[\"supportsWakeLock\"];\n        }));\n      }\n      Release() {\n        super.Release();\n      }\n      _OnWindowResize(e) {\n        this._windowOuterWidth = e[\"windowOuterWidth\"], this._windowOuterHeight = e[\"windowOuterHeight\"], this._safeAreaInset = e[\"safeAreaInset\"];\n      }\n      async _OnNetworkChange() {\n        await this.TriggerAsync(g.Plugins.PlatformInfo.Cnds.OnNetworkChange);\n      }\n      async _OnWakeLockAcquired() {\n        this._isWakeLockActive = true, await this.TriggerAsync(g.Plugins.PlatformInfo.Cnds.OnWakeLockAcquired);\n      }\n      async _OnWakeLockError() {\n        this._isWakeLockActive = false, await this.TriggerAsync(g.Plugins.PlatformInfo.Cnds.OnWakeLockError);\n      }\n      async _OnWakeLockReleased() {\n        this._isWakeLockActive = false, await this.TriggerAsync(g.Plugins.PlatformInfo.Cnds.OnWakeLockReleased);\n      }\n    };\n  }\n  {\n    const r = self.C3;\n    r.Plugins.PlatformInfo.Cnds = { IsOnMobile() {\n      return r.Platform.IsMobile;\n    }, IsOnWindows() {\n      return \"Windows\" === r.Platform.OS;\n    }, IsOnMacOS() {\n      return \"macOS\" === r.Platform.OS;\n    }, IsOnLinux() {\n      return \"Linux\" === r.Platform.OS;\n    }, IsOnChromeOS() {\n      return \"Chrome OS\" === r.Platform.OS;\n    }, IsOnAndroid() {\n      return \"Android\" === r.Platform.OS;\n    }, IsOniOS() {\n      return \"iOS\" === r.Platform.OS;\n    }, IsWebExport() {\n      const e = this._runtime.GetExportType();\n      return \"html5\" === e || \"scirra-arcade\" === e || \"preview\" === e || \"instant-games\" === e;\n    }, IsCordovaExport() {\n      return this._runtime.IsCordova();\n    }, IsNWjsExport() {\n      return this._runtime.IsNWjs();\n    }, IsWindowsUWPExport() {\n      return \"windows-uwp\" === this._runtime.GetExportType();\n    }, IsWindowsWebView2Export() {\n      return this._runtime.IsWindowsWebView2();\n    }, IsMacOSWKWebView2Export() {\n      return \"macos-wkwebview\" === this._runtime.GetExportType();\n    }, IsLinuxCEFExport() {\n      return \"linux-cef\" === this._runtime.GetExportType();\n    }, OnNetworkChange() {\n      return true;\n    }, OnWakeLockAcquired() {\n      return true;\n    }, OnWakeLockError() {\n      return true;\n    }, OnWakeLockReleased() {\n      return true;\n    }, IsWakeLockActive() {\n      return this._isWakeLockActive;\n    }, IsWakeLockSupported() {\n      return this._supportsWakeLock;\n    } };\n  }\n  {\n    const t = self.C3;\n    t.Plugins.PlatformInfo.Acts = { RequestWakeLock() {\n      this._supportsWakeLock && this._PostToDOMMaybeSync(\"request-wake-lock\");\n    }, ReleaseWakeLock() {\n      this._supportsWakeLock && (this._isWakeLockActive = false, this.PostToDOM(\"release-wake-lock\"));\n    } };\n  }\n  {\n    const u = self.C3;\n    u.Plugins.PlatformInfo.Exps = { Renderer() {\n      return this._runtime.GetCanvasManager().GetRendererString();\n    }, RendererDetail() {\n      return this._runtime.GetCanvasManager().GetRendererDetailString();\n    }, DevicePixelRatio() {\n      return this._runtime.GetDevicePixelRatio();\n    }, ScreenWidth() {\n      return this._screenWidth;\n    }, ScreenHeight() {\n      return this._screenHeight;\n    }, WindowInnerWidth() {\n      return this._runtime.GetCanvasManager().GetLastWidth();\n    }, WindowInnerHeight() {\n      return this._runtime.GetCanvasManager().GetLastHeight();\n    }, WindowOuterWidth() {\n      return this._windowOuterWidth;\n    }, WindowOuterHeight() {\n      return this._windowOuterHeight;\n    }, CanvasCssWidth() {\n      return this._runtime.GetCanvasManager().GetCssWidth();\n    }, CanvasCssHeight() {\n      return this._runtime.GetCanvasManager().GetCssHeight();\n    }, CanvasDeviceWidth() {\n      return this._runtime.GetCanvasManager().GetDeviceWidth();\n    }, CanvasDeviceHeight() {\n      return this._runtime.GetCanvasManager().GetDeviceHeight();\n    }, Downlink() {\n      return navigator.connection && navigator.connection[\"downlink\"] || 0;\n    }, DownlinkMax() {\n      return navigator.connection && navigator.connection[\"downlinkMax\"] || 0;\n    }, ConnectionType() {\n      return navigator.connection && navigator.connection[\"type\"] || \"unknown\";\n    }, ConnectionEffectiveType() {\n      return navigator.connection && navigator.connection[\"effectiveType\"] || \"unknown\";\n    }, ConnectionRTT() {\n      return navigator.connection && navigator.connection[\"rtt\"] || 0;\n    }, HardwareConcurrency() {\n      return navigator.hardwareConcurrency || 0;\n    }, DeviceMemory() {\n      return navigator.deviceMemory || 0;\n    }, SafeAreaInsetTop() {\n      return this._safeAreaInset[0];\n    }, SafeAreaInsetRight() {\n      return this._safeAreaInset[1];\n    }, SafeAreaInsetBottom() {\n      return this._safeAreaInset[2];\n    }, SafeAreaInsetLeft() {\n      return this._safeAreaInset[3];\n    }, FramesPerSecond() {\n      return this._runtime.GetFramesPerSecond();\n    }, TicksPerSecond() {\n      return this._runtime.GetTicksPerSecond();\n    } };\n  }\n}\n{\n  {\n    const a = self.C3;\n    a.Plugins.TiledBg = class extends a.SDKPluginBase {\n      constructor(e) {\n        super(e);\n      }\n      Release() {\n        super.Release();\n      }\n    };\n  }\n  {\n    let WrapModeToStr = function(e) {\n      switch (e) {\n        case 0:\n          return \"clamp-to-edge\";\n        case 1:\n          return \"repeat\";\n        case 2:\n          return \"mirror-repeat\";\n      }\n      return \"repeat\";\n    };\n    WrapModeToStr2 = WrapModeToStr;\n    const d = self.C3;\n    d.Plugins.TiledBg.Type = class extends d.SDKTypeBase {\n      constructor(e, t) {\n        super(e), this._wrapX = \"repeat\", this._wrapY = \"repeat\", t && (this._wrapX = WrapModeToStr(t[0]), this._wrapY = WrapModeToStr(t[1]));\n      }\n      Release() {\n        super.Release();\n      }\n      OnCreate() {\n        this.GetImageInfo().LoadAsset(this._runtime);\n      }\n      LoadTextures(e) {\n        return this.GetImageInfo().LoadStaticTexture(e, { sampling: this._runtime.GetSampling(), wrapX: this._wrapX, wrapY: this._wrapY });\n      }\n      ReleaseTextures() {\n        this.GetImageInfo().ReleaseTexture();\n      }\n      GetWrapModeX() {\n        return this._wrapX;\n      }\n      GetWrapModeY() {\n        return this._wrapY;\n      }\n    };\n  }\n  {\n    const j = self.C3, k = self.C3X, l = 0, m = 1, n = 4, o = 5, p = 6, q = 7, r = 8, s = 9, t = 10, u = 11, v = 12, w = 13, x = 14, y = j.New(j.Rect), z = j.New(j.Quad), A = j.New(j.Rect), B = j.New(j.Quad), C = (j.Plugins.TiledBg.Instance = class extends j.SDKWorldInstanceBase {\n      constructor(e, i) {\n        super(e), this._imageOffsetX = 0, this._imageOffsetY = 0, this._imageScaleX = 1, this._imageScaleY = 1, this._imageAngle = 0, this._enableTileRandomization = false, this._tileXRandom = 0, this._tileYRandom = 0, this._tileAngleRandom = 0, this._tileBlendMarginX = 0, this._tileBlendMarginY = 0, this._ownImageInfo = null, i && (this.GetWorldInfo().SetVisible(!!i[l]), this._imageOffsetX = i[n], this._imageOffsetY = i[o], this._imageScaleX = i[p], this._imageScaleY = i[q], this._imageAngle = j.toRadians(i[r]), this._enableTileRandomization = !!i[s], this._tileXRandom = i[t], this._tileYRandom = i[u], this._tileAngleRandom = i[v], this._tileBlendMarginX = i[w], this._tileBlendMarginY = i[x]);\n      }\n      Release() {\n        this._ReleaseOwnImage(), super.Release();\n      }\n      _ReleaseOwnImage() {\n        this._ownImageInfo && (this._ownImageInfo.Release(), this._ownImageInfo = null);\n      }\n      CalculateTextureCoordsFor3DFace(e, t2, i) {\n        const a = this.GetCurrentImageInfo(), n2 = a.GetWidth(), s2 = a.GetHeight(), l2 = this._imageOffsetX / n2, r2 = this._imageOffsetY / s2, g = this._imageAngle;\n        A.set(0, 0, e / (n2 * this._imageScaleX), t2 / (s2 * this._imageScaleY)), A.offset(-l2, -r2), 0 === g ? i.setFromRect(A) : i.setFromRotatedRect(A, -g);\n      }\n      SetTilingShaderProgram(e, t2 = true) {\n        if (this._enableTileRandomization) {\n          const i = this.GetCurrentImageInfo();\n          e.SetTileRandomizationMode(), e.SetTileRandomizationInfo(i.GetWidth() * this._imageScaleX, i.GetHeight() * this._imageScaleY, this._tileXRandom, this._tileYRandom, this._tileAngleRandom, this._tileBlendMarginX, this._tileBlendMarginY);\n        } else t2 && e.SetTextureFillMode();\n      }\n      Draw(e) {\n        const t2 = this.GetCurrentImageInfo(), i = t2.GetTexture();\n        if (null !== i) {\n          this.SetTilingShaderProgram(e), e.SetTexture(i);\n          const a = t2.GetWidth(), n2 = t2.GetHeight(), s2 = this._imageOffsetX / a, l2 = this._imageOffsetY / n2, r2 = this.GetWorldInfo();\n          A.set(0, 0, r2.GetWidth() / (a * this._imageScaleX), r2.GetHeight() / (n2 * this._imageScaleY)), A.offset(-s2, -l2), r2.HasMesh() ? this._DrawMesh(r2, e) : this._DrawStandard(r2, e);\n        }\n      }\n      _DrawStandard(e, t2) {\n        let i = e.GetBoundingQuad();\n        this._runtime.IsPixelRoundingEnabled() && (i = e.PixelRoundQuad(i)), 0 === this._imageAngle ? t2.Quad3(i, A) : (B.setFromRotatedRect(A, -this._imageAngle), t2.Quad4(i, B));\n      }\n      _DrawMesh(i, e) {\n        const a = i.GetTransformedMesh();\n        if (i.IsMeshChanged()) {\n          i.CalculateBbox(y, z, false);\n          let e2 = z, t2 = (this._runtime.IsPixelRoundingEnabled() && (e2 = i.PixelRoundQuad(e2)), A);\n          0 !== this._imageAngle && (B.setFromRotatedRect(A, -this._imageAngle), t2 = B), a.CalculateTransformedMesh(i.GetSourceMesh(), e2, t2), i.SetMeshChanged(false);\n        }\n        a.Draw(e);\n      }\n      GetCurrentImageInfo() {\n        return this._ownImageInfo || this._objectClass.GetImageInfo();\n      }\n      IsOriginalSizeKnown() {\n        return true;\n      }\n      GetTexture() {\n        return this.GetCurrentImageInfo().GetTexture();\n      }\n      _SetMeshChanged() {\n        this.GetWorldInfo().SetMeshChanged(true);\n      }\n      _SetImageOffsetX(e) {\n        this._imageOffsetX !== e && (this._imageOffsetX = e, this._runtime.UpdateRender(), this._SetMeshChanged());\n      }\n      _GetImageOffsetX() {\n        return this._imageOffsetX;\n      }\n      _SetImageOffsetY(e) {\n        this._imageOffsetY !== e && (this._imageOffsetY = e, this._runtime.UpdateRender(), this._SetMeshChanged());\n      }\n      _GetImageOffsetY() {\n        return this._imageOffsetY;\n      }\n      _SetImageScaleX(e) {\n        this._imageScaleX !== e && (this._imageScaleX = e, this._runtime.UpdateRender(), this._SetMeshChanged());\n      }\n      _GetImageScaleX() {\n        return this._imageScaleX;\n      }\n      _SetImageScaleY(e) {\n        this._imageScaleY !== e && (this._imageScaleY = e, this._runtime.UpdateRender(), this._SetMeshChanged());\n      }\n      _GetImageScaleY() {\n        return this._imageScaleY;\n      }\n      _SetImageAngle(e) {\n        this._imageAngle !== e && (this._imageAngle = e, this._runtime.UpdateRender(), this._SetMeshChanged());\n      }\n      _GetImageAngle() {\n        return this._imageAngle;\n      }\n      _SetTileRandomizationEnabled(e) {\n        this._enableTileRandomization !== (e = !!e) && (this._enableTileRandomization = e, this._runtime.UpdateRender());\n      }\n      _IsTileRandomizationEnabled() {\n        return this._enableTileRandomization;\n      }\n      _SetTileXRandom(e) {\n        this._tileXRandom !== e && (this._tileXRandom = e, this._IsTileRandomizationEnabled()) && this._runtime.UpdateRender();\n      }\n      _GetTileXRandom() {\n        return this._tileXRandom;\n      }\n      _SetTileYRandom(e) {\n        this._tileYRandom !== e && (this._tileYRandom = e, this._IsTileRandomizationEnabled()) && this._runtime.UpdateRender();\n      }\n      _GetTileYRandom() {\n        return this._tileYRandom;\n      }\n      _SetTileAngleRandom(e) {\n        this._tileAngleRandom !== e && (this._tileAngleRandom = e, this._IsTileRandomizationEnabled()) && this._runtime.UpdateRender();\n      }\n      _GetTileAngleRandom() {\n        return this._tileAngleRandom;\n      }\n      _SetTileBlendMarginX(e) {\n        this._tileBlendMarginX !== e && (this._tileBlendMarginX = e, this._IsTileRandomizationEnabled()) && this._runtime.UpdateRender();\n      }\n      _GetTileBlendMarginX() {\n        return this._tileBlendMarginX;\n      }\n      _SetTileBlendMarginY(e) {\n        this._tileBlendMarginY !== e && (this._tileBlendMarginY = e, this._IsTileRandomizationEnabled()) && this._runtime.UpdateRender();\n      }\n      _GetTileBlendMarginY() {\n        return this._tileBlendMarginY;\n      }\n      SaveToJson() {\n        const e = {};\n        return 0 !== this._imageOffsetX && (e[\"iox\"] = this._imageOffsetX), 0 !== this._imageOffsetY && (e[\"ioy\"] = this._imageOffsetY), 1 !== this._imageScaleX && (e[\"isx\"] = this._imageScaleX), 1 !== this._imageScaleY && (e[\"isy\"] = this._imageScaleY), 0 !== this._imageAngle && (e[\"ia\"] = this._imageAngle), this._enableTileRandomization && (e[\"tr\"] = true), 1 !== this._tileXRandom && (e[\"trx\"] = this._tileXRandom), 1 !== this._tileYRandom && (e[\"try\"] = this._tileYRandom), 1 !== this._tileAngleRandom && (e[\"tra\"] = this._tileAngleRandom), 0.1 !== this._tileBlendMarginX && (e[\"trbmx\"] = this._tileBlendMarginX), 0.1 !== this._tileBlendMarginY && (e[\"trbmy\"] = this._tileBlendMarginY), e;\n      }\n      LoadFromJson(e) {\n        this._imageOffsetX = e[\"iox\"] || 0, this._imageOffsetY = e[\"ioy\"] || 0, this._imageScaleX = e.hasOwnProperty(\"isx\") ? e[\"isx\"] : 1, this._imageScaleY = e.hasOwnProperty(\"isy\") ? e[\"isy\"] : 1, this._imageAngle = e[\"ia\"] || 0, this._enableTileRandomization = !!e[\"tr\"], this._tileXRandom = e.hasOwnProperty(\"trx\") ? e[\"trx\"] : 1, this._tileYRandom = e.hasOwnProperty(\"try\") ? e[\"try\"] : 1, this._tileAngleRandom = e.hasOwnProperty(\"tra\") ? e[\"tra\"] : 1, this._tileBlendMarginX = e.hasOwnProperty(\"trbmx\") ? e[\"trbmx\"] : 0.1, this._tileBlendMarginY = e.hasOwnProperty(\"trbmy\") ? e[\"trbmy\"] : 0.1;\n      }\n      GetDebuggerProperties() {\n        const e = \"plugins.tiledbg.properties\";\n        return [{ title: e + \".image-transform.name\", properties: [{ name: e + \".image-offset-x.name\", value: this._GetImageOffsetX(), onedit: (e2) => this._SetImageOffsetX(e2) }, { name: e + \".image-offset-y.name\", value: this._GetImageOffsetY(), onedit: (e2) => this._SetImageOffsetY(e2) }, { name: e + \".image-scale-x.name\", value: 100 * this._GetImageScaleX(), onedit: (e2) => this._SetImageScaleX(e2 / 100) }, { name: e + \".image-scale-y.name\", value: 100 * this._GetImageScaleY(), onedit: (e2) => this._SetImageScaleY(e2 / 100) }, { name: e + \".image-angle.name\", value: j.toDegrees(this._GetImageAngle()), onedit: (e2) => this._SetImageAngle(j.toRadians(e2)) }] }, { title: e + \".tile-randomization.name\", properties: [{ name: e + \".enable-tile-randomization.name\", value: this._IsTileRandomizationEnabled(), onedit: (e2) => this._SetTileRandomizationEnabled(e2) }, { name: e + \".x-random.name\", value: 100 * this._GetTileXRandom(), onedit: (e2) => this._SetTileXRandom(e2 / 100) }, { name: e + \".y-random.name\", value: 100 * this._GetTileYRandom(), onedit: (e2) => this._SetTileYRandom(e2 / 100) }, { name: e + \".angle-random.name\", value: 100 * this._GetTileAngleRandom(), onedit: (e2) => this._SetTileAngleRandom(e2 / 100) }, { name: e + \".blend-margin-x.name\", value: 100 * this._GetTileBlendMarginX(), onedit: (e2) => this._SetTileBlendMarginX(e2 / 100) }, { name: e + \".blend-margin-y.name\", value: 100 * this._GetTileBlendMarginY(), onedit: (e2) => this._SetTileBlendMarginY(e2 / 100) }] }];\n      }\n      GetPropertyValueByIndex(e) {\n        switch (e) {\n          case n:\n            return this._GetImageOffsetX();\n          case o:\n            return this._GetImageOffsetY();\n          case p:\n            return this._GetImageScaleX();\n          case q:\n            return this._GetImageScaleY();\n          case r:\n            return this._GetImageAngle();\n          case s:\n            return this._IsTileRandomizationEnabled();\n          case t:\n            return this._GetTileXRandom();\n          case u:\n            return this._GetTileYRandom();\n          case v:\n            return this._GetTileAngleRandom();\n          case w:\n            return this._GetTileBlendMarginX();\n          case x:\n            return this._GetTileBlendMarginY();\n        }\n      }\n      SetPropertyValueByIndex(e, i) {\n        switch (e) {\n          case n:\n            this._SetImageOffsetX(i);\n            break;\n          case o:\n            this._SetImageOffsetY(i);\n            break;\n          case p:\n            this._SetImageScaleX(i);\n            break;\n          case q:\n            this._SetImageScaleY(i);\n            break;\n          case r:\n            this._SetImageAngle(i);\n            break;\n          case s:\n            this._SetTileRandomizationEnabled(!!i);\n            break;\n          case t:\n            this._SetTileXRandom(i);\n            break;\n          case u:\n            this._SetTileYRandom(i);\n            break;\n          case v:\n            this._SetTileAngleRandom(i);\n            break;\n          case w:\n            this._SetTileBlendMarginX(i);\n            break;\n          case x:\n            this._SetTileBlendMarginY(i);\n        }\n      }\n      GetScriptInterfaceClass() {\n        return self.ITiledBackgroundInstance;\n      }\n    }, /* @__PURE__ */ new WeakMap());\n    self.ITiledBackgroundInstance = class extends self.IWorldInstance {\n      constructor() {\n        super(), C.set(this, self.IInstance._GetInitInst().GetSdkInstance());\n      }\n      set imageOffsetX(e) {\n        k.RequireFiniteNumber(e), C.get(this)._SetImageOffsetX(e);\n      }\n      get imageOffsetX() {\n        return C.get(this)._GetImageOffsetX();\n      }\n      set imageOffsetY(e) {\n        k.RequireFiniteNumber(e), C.get(this)._SetImageOffsetY(e);\n      }\n      get imageOffsetY() {\n        return C.get(this)._GetImageOffsetY();\n      }\n      setImageOffset(e, t2) {\n        k.RequireFiniteNumber(e), k.RequireFiniteNumber(t2);\n        const i = C.get(this);\n        i._SetImageOffsetX(e), i._SetImageOffsetY(t2);\n      }\n      getImageOffset() {\n        const e = C.get(this);\n        return [e._GetImageOffsetX(), e._GetImageOffsetY()];\n      }\n      set imageScaleX(e) {\n        k.RequireFiniteNumber(e), C.get(this)._SetImageScaleX(e);\n      }\n      get imageScaleX() {\n        return C.get(this)._GetImageScaleX();\n      }\n      set imageScaleY(e) {\n        k.RequireFiniteNumber(e), C.get(this)._SetImageScaleY(e);\n      }\n      get imageScaleY() {\n        return C.get(this)._GetImageScaleY();\n      }\n      setImageScale(e, t2) {\n        k.RequireFiniteNumber(e), k.RequireFiniteNumber(t2);\n        const i = C.get(this);\n        i._SetImageScaleX(e), i._SetImageScaleY(t2);\n      }\n      getImageScale() {\n        const e = C.get(this);\n        return [e._GetImageScaleX(), e._GetImageScaleY()];\n      }\n      set imageAngle(e) {\n        k.RequireFiniteNumber(e), C.get(this)._SetImageAngle(e);\n      }\n      get imageAngle() {\n        return C.get(this)._GetImageAngle();\n      }\n      set imageAngleDegrees(e) {\n        k.RequireFiniteNumber(e), C.get(this)._SetImageAngle(j.toRadians(e));\n      }\n      get imageAngleDegrees() {\n        return j.toDegrees(C.get(this)._GetImageAngle());\n      }\n      get imageWidth() {\n        return C.get(this).GetCurrentImageInfo().GetWidth();\n      }\n      get imageHeight() {\n        return C.get(this).GetCurrentImageInfo().GetHeight();\n      }\n      getImageSize() {\n        const e = C.get(this).GetCurrentImageInfo();\n        return [e.GetWidth(), e.GetHeight()];\n      }\n      set enableTileRandomization(e) {\n        C.get(this)._SetTileRandomizationEnabled(!!e);\n      }\n      get enableTileRandomization() {\n        return C.get(this)._IsTileRandomizationEnabled();\n      }\n      set tileXRandom(e) {\n        k.RequireFiniteNumber(e), C.get(this)._SetTileXRandom(e);\n      }\n      get tileXRandom() {\n        return C.get(this)._GetTileXRandom();\n      }\n      set tileYRandom(e) {\n        k.RequireFiniteNumber(e), C.get(this)._SetTileYRandom(e);\n      }\n      get tileYRandom() {\n        return C.get(this)._GetTileYRandom();\n      }\n      setTileRandom(e, t2) {\n        k.RequireFiniteNumber(e), k.RequireFiniteNumber(t2);\n        const i = C.get(this);\n        i._SetTileXRandom(e), i._SetTileYRandom(t2);\n      }\n      getTileRandom() {\n        const e = C.get(this);\n        return [e._GetTileXRandom(), e._GetTileYRandom()];\n      }\n      set tileAngleRandom(e) {\n        k.RequireFiniteNumber(e), C.get(this)._SetTileAngleRandom(e);\n      }\n      get tileAngleRandom() {\n        return C.get(this)._GetTileAngleRandom();\n      }\n      set tileBlendMarginX(e) {\n        k.RequireFiniteNumber(e), C.get(this)._SetTileBlendMarginX(e);\n      }\n      get tileBlendMarginX() {\n        return C.get(this)._GetTileBlendMarginX();\n      }\n      set tileBlendMarginY(e) {\n        k.RequireFiniteNumber(e), C.get(this)._SetTileBlendMarginY(e);\n      }\n      get tileBlendMarginY() {\n        return C.get(this)._GetTileBlendMarginY();\n      }\n      setTileBlendMargin(e, t2) {\n        k.RequireFiniteNumber(e), k.RequireFiniteNumber(t2);\n        const i = C.get(this);\n        i._SetTileBlendMarginX(e), i._SetTileBlendMarginY(t2);\n      }\n      getTileBlendMargin() {\n        const e = C.get(this);\n        return [e._GetTileBlendMarginX(), e._GetTileBlendMarginY()];\n      }\n      async replaceImage(e) {\n        k.RequireInstanceOf(e, Blob);\n        const t2 = C.get(this), i = t2.GetRuntime(), a = j.New(j.ImageInfo);\n        a.LoadDynamicBlobAsset(i, e), await a.LoadStaticTexture(i.GetRenderer(), { sampling: i.GetSampling(), wrapX: t2.GetSdkType().GetWrapModeX(), wrapY: t2.GetSdkType().GetWrapModeY() }), t2.WasReleased() ? a.Release() : (t2._ReleaseOwnImage(), t2._ownImageInfo = a, i.UpdateRender());\n      }\n    };\n  }\n  {\n    const o0 = self.C3;\n    o0.Plugins.TiledBg.Cnds = { OnURLLoaded() {\n      return true;\n    }, OnURLFailed() {\n      return true;\n    }, IsTileRandomizationEnabled() {\n      return this._IsTileRandomizationEnabled();\n    } };\n  }\n  {\n    const p0 = self.C3;\n    p0.Plugins.TiledBg.Acts = { SetImageOffsetX(e) {\n      this._SetImageOffsetX(e);\n    }, SetImageOffsetY(e) {\n      this._SetImageOffsetY(e);\n    }, SetImageScaleX(e) {\n      this._SetImageScaleX(e / 100);\n    }, SetImageScaleY(e) {\n      this._SetImageScaleY(e / 100);\n    }, SetImageAngle(e) {\n      this._SetImageAngle(p0.toRadians(e));\n    }, SetTileRandomizationEnabled(e) {\n      this._SetTileRandomizationEnabled(e);\n    }, SetTilePosRandom(e, t) {\n      this._SetTileXRandom(e / 100), this._SetTileYRandom(t / 100);\n    }, SetTileAngleRandom(e) {\n      this._SetTileAngleRandom(e / 100);\n    }, SetTileBlendMargin(e, t) {\n      this._SetTileBlendMarginX(e / 100), this._SetTileBlendMarginY(t / 100);\n    }, SetEffect(e) {\n      this.GetWorldInfo().SetBlendMode(e), this._runtime.UpdateRender();\n    }, async LoadURL(e, t) {\n      if (!this._ownImageInfo || this._ownImageInfo.GetURL() !== e) {\n        const i = this._runtime, a = p0.New(p0.ImageInfo);\n        try {\n          if (await a.LoadDynamicAsset(i, e), !a.IsLoaded()) throw new Error(\"image failed to load\");\n          if (this.WasReleased()) return a.Release(), null;\n          const n = await a.LoadStaticTexture(i.GetRenderer(), { sampling: i.GetSampling(), wrapX: this.GetSdkType().GetWrapModeX(), wrapY: this.GetSdkType().GetWrapModeY() });\n          if (!n) return;\n        } catch (e2) {\n          return console.error(\"Load image from URL failed: \", e2), void (this.WasReleased() || this.Trigger(p0.Plugins.TiledBg.Cnds.OnURLFailed));\n        }\n        this.WasReleased() ? a.Release() : (this._ReleaseOwnImage(), this._ownImageInfo = a, i.UpdateRender(), await this.TriggerAsync(p0.Plugins.TiledBg.Cnds.OnURLLoaded));\n      }\n    } };\n  }\n  {\n    const I0 = self.C3;\n    I0.Plugins.TiledBg.Exps = { ImageWidth() {\n      return this.GetCurrentImageInfo().GetWidth();\n    }, ImageHeight() {\n      return this.GetCurrentImageInfo().GetHeight();\n    }, ImageOffsetX() {\n      return this._imageOffsetX;\n    }, ImageOffsetY() {\n      return this._imageOffsetY;\n    }, ImageScaleX() {\n      return 100 * this._imageScaleX;\n    }, ImageScaleY() {\n      return 100 * this._imageScaleY;\n    }, ImageAngle() {\n      return I0.toDegrees(this._imageAngle);\n    }, TileXRandom() {\n      return 100 * this._GetTileXRandom();\n    }, TileYRandom() {\n      return 100 * this._GetTileYRandom();\n    }, TileAngleRandom() {\n      return 100 * this._GetTileAngleRandom();\n    }, TileBlendMarginX() {\n      return 100 * this._GetTileBlendMarginX();\n    }, TileBlendMarginY() {\n      return 100 * this._GetTileBlendMarginY();\n    } };\n  }\n}\nvar WrapModeToStr2;\n{\n  {\n    const a = self.C3;\n    a.Behaviors.Tween = class extends a.SDKBehaviorBase {\n      constructor(e) {\n        super(e);\n      }\n      Release() {\n        super.Release();\n      }\n    };\n  }\n  {\n    const d = self.C3;\n    d.Behaviors.Tween.Type = class extends d.SDKBehaviorTypeBase {\n      constructor(e) {\n        super(e);\n      }\n      Release() {\n        super.Release();\n      }\n      OnCreate() {\n      }\n    };\n  }\n  {\n    const g = self.C3, h = g.Behaviors.Tween, i = 0;\n    h.Instance = class extends g.SDKBehaviorInstanceBase {\n      constructor(e, s) {\n        super(e), this._allowMultiple = false, this._enabled = true, s && (this._allowMultiple = false, this._enabled = !!s[i]), this._activeTweens = /* @__PURE__ */ new Map(), this._disabledTweens = [], this._waitingForReleaseTweens = /* @__PURE__ */ new Map(), this._finishingTween = null, this._activeTweensJson = null, this._disabledTweensJson = null, this._waitingForReleaseTweensJson = null, this._finishingTweenName = \"\", this._triggerTweens = [], this._afterLoad = (e2) => this._OnAfterLoad(), this.GetRuntime().Dispatcher().addEventListener(\"afterload\", this._afterLoad);\n      }\n      Release() {\n        this.GetRuntime().Dispatcher().removeEventListener(\"afterload\", this._afterLoad), this._afterLoad = null, this._finishingTween && (this.ReleaseAndCompleteTween(this._finishingTween), this._finishingTween = null), this.ReleaseAndCompleteTweens(), this._tweens = null, this.ClearDisabledList(), this._disabledTweens = null, this._ReleaseWaitingTweens(), this._waitingForReleaseTweens = null, this._triggerTweens = null, super.Release();\n      }\n      PushTriggerTween(e) {\n        this._triggerTweens.push(e);\n      }\n      PopTriggerTween() {\n        this._triggerTweens.pop();\n      }\n      GetTriggerTween() {\n        return this._triggerTweens[this._triggerTweens.length - 1];\n      }\n      SetEnabled(e) {\n        this._enabled = !!e, e ? this._waitingForReleaseTweens && this._waitingForReleaseTweens.size && this._StartTicking2() : this._StopTicking2();\n        for (const s of this.AllTweens()) e ? this.IsInDisabledList(s) && s.Resume() : ((s.IsPlaying() || s.IsScheduled()) && this.AddToDisabledList(s), s.Stop());\n        e && this.ClearDisabledList();\n      }\n      IsEnabled() {\n        return this._enabled;\n      }\n      AddToDisabledList(e) {\n        this._disabledTweens.push(e);\n      }\n      IsInDisabledList(e) {\n        return this._disabledTweens.includes(e);\n      }\n      ClearDisabledList() {\n        g.clearArray(this._disabledTweens);\n      }\n      GetFinishingTween() {\n        return this._finishingTween;\n      }\n      IsInstanceValid() {\n        const e = this.GetObjectInstance();\n        return !!e && !e.IsDestroyed();\n      }\n      GetTween(e, s, t = false) {\n        const n = s ? this.PropertyTweens(s, t) : this.AllTweens(t);\n        if (n && n.length) {\n          for (const i2 of n) if (i2.HasTags(e)) return i2;\n        }\n      }\n      CheckTweensWithTags(e, s) {\n        for (const t of this._activeTweens.values()) for (const n of t) if (!n.IsReleased() && n.HasTags(e) && s(n)) return true;\n        for (const i2 of this._waitingForReleaseTweens.values()) for (const a of i2) if (!a.IsReleased() && a.HasTags(e) && s(a)) return true;\n        return false;\n      }\n      CheckTweens(e) {\n        for (const s of this._activeTweens.values()) for (const t of s) if (!t.IsReleased() && e(t)) return true;\n        for (const n of this._waitingForReleaseTweens.values()) for (const i2 of n) if (!i2.IsReleased() && e(i2)) return true;\n        return false;\n      }\n      GetTweenIncludingWaitingForRelease(e, s) {\n        return this.GetTween(e, s, true);\n      }\n      *GetTweens(e, s, t = false) {\n        const n = s ? this.PropertyTweens(s, t) : this.AllTweens(t);\n        if (n && n.length) for (const i2 of n) i2.HasTags(e) && (yield i2);\n      }\n      *GetTweensIncludingWaitingForRelease(e, s) {\n        yield* this.GetTweens(e, s, true);\n      }\n      PropertyTweens(t, e) {\n        if (e) {\n          let e2 = this._activeTweens.get(t), s = this._waitingForReleaseTweens.get(t);\n          return e2 = e2 || [], s = s || [], e2.concat(s).filter((e3) => e3).filter((e3) => !e3.IsReleased());\n        }\n        {\n          let e2 = this._activeTweens.get(t);\n          return (e2 = e2 || []).filter((e3) => e3).filter((e3) => !e3.IsReleased());\n        }\n      }\n      AllTweens(e) {\n        if (e) {\n          const s = [...this._activeTweens.values()].flat(), t = [...this._waitingForReleaseTweens.values()].flat();\n          return s.concat(t).filter((e2) => e2).filter((e2) => !e2.IsReleased());\n        }\n        {\n          const n = [...this._activeTweens.values()].flat();\n          return n.filter((e2) => e2).filter((e2) => !e2.IsReleased());\n        }\n      }\n      AllTweensIncludingWaitingForRelease() {\n        return this.AllTweens(true);\n      }\n      SaveToJson(e = 0) {\n        return { \"s\": false, \"e\": !!this._enabled, \"at\": this._SaveActiveTweensToJson(), \"dt\": this._SaveDisabledTweensToJson(), \"wt\": this._SaveWaitingForReleaseTweensToJson(), \"ft\": this._SaveFinishingTweenToJson() };\n      }\n      LoadFromJson(e, s = \"full\") {\n        e && (this._activeTweensJson = e[\"at\"], this._disabledTweensJson = e[\"dt\"], this._waitingForReleaseTweensJson = e[\"wt\"], this._finishingTweenName = e[\"ft\"], this._allowMultiple = false, this._enabled = !!e[\"e\"], \"state\" === s) && this._OnAfterLoad();\n      }\n      _OnAfterLoad() {\n        const e = this.GetRuntime().GetTimelineManager();\n        if (this._PopulateTweenMap(this._activeTweensJson, this._activeTweens, e), this._disabledTweensJson) {\n          g.clearArray(this._disabledTweens);\n          for (const s of this._disabledTweensJson) this._PopulateTweenArray(this._disabledTweens, s, e);\n        }\n        this._PopulateTweenMap(this._waitingForReleaseTweensJson, this._waitingForReleaseTweens, e), this._finishingTween = this._GetTween(this._finishingTweenName, e), this._enabled ? this._waitingForReleaseTweens && this._waitingForReleaseTweens.size && this._StartTicking2() : this._StopTicking2();\n      }\n      _PopulateTweenMap(s, t, n) {\n        if (s) for (const i2 in s) {\n          let e = t.get(i2);\n          e ? g.clearArray(e) : e = [];\n          const a = s[i2];\n          for (const r of a) {\n            const o = this._PopulateTweenArray(e, r[\"name\"], n);\n            if (o) this._LoadTweenFromJson(r[\"name\"], r, n);\n            else {\n              const l = g.TweenState.Build({ runtime: this.GetRuntime(), json: r });\n              g.TweenState.SetInstanceUID(l, this.GetObjectInstance().GetUID()), l.AddCompletedCallback((e2) => this._FinishTriggers(e2)), n.AddScheduledTimeline(l), this._PopulateTweenArray(e, l, n);\n            }\n          }\n          t.set(i2, e);\n        }\n      }\n      _GetTween(e, s) {\n        return s.GetScheduledOrPlayingTimelineByName(e);\n      }\n      _PopulateTweenArray(e, s, t) {\n        if (\"string\" != typeof s) return !!e.push(s);\n        {\n          const n = this._GetTween(s, t);\n          if (n) return !!e.push(n);\n        }\n        return false;\n      }\n      _LoadTweenFromJson(e, s, t) {\n        if (\"string\" == typeof e) {\n          const n = this._GetTween(e, t);\n          n && (n._LoadFromJson(s), g.TweenState.SetInstanceUID(n, this.GetObjectInstance().GetUID()));\n        } else e._LoadFromJson(s), g.TweenState.SetInstanceUID(e, this.GetObjectInstance().GetUID());\n      }\n      _SaveActiveTweensToJson() {\n        const e = {};\n        for (const [s, t] of this._activeTweens) e[s] = t.filter((e2) => !e2.IsReleased()).map((e2) => e2._SaveToJson());\n        return e;\n      }\n      _SaveDisabledTweensToJson() {\n        return this._disabledTweens.filter((e) => !e.IsReleased()).map((e) => e.GetName());\n      }\n      _SaveWaitingForReleaseTweensToJson() {\n        const e = {};\n        for (const [s, t] of this._waitingForReleaseTweens) e[s] = t.map((e2) => e2._SaveToJson());\n        return e;\n      }\n      _SaveFinishingTweenToJson() {\n        return this._finishingTween ? this._finishingTween.GetName() : \"\";\n      }\n      Tick2() {\n        this._ReleaseWaitingTweens();\n      }\n      CreateTween(e) {\n        const s = h.Config.GetPropertyTracksConfig(e.property, e.startValue, e.endValue, e.ease, e.resultMode, this.GetObjectInstance()), t = h.Maps.GetPropertyFromIndex(e.property), n = (h.Maps.IsValueId(t) || this.ReleaseTweens(e.property), g.TweenState.Build({ runtime: this.GetRuntime(), id: t, tags: e.tags, time: e.time, instance: this.GetObjectInstance(), releaseOnComplete: !!e.releaseOnComplete, loop: !!e.loop, pingPong: !!e.pingPong, repeatCount: e.repeatCount, initialValueMode: e.initialValueMode, propertyTracksConfig: s }));\n        return n.AddCompletedCallback((e2) => this._FinishTriggers(e2)), this._AddTween(n, e.property), n;\n      }\n      _MaybeRemoveFromActiveTweenMap(e) {\n        const s = e.GetId();\n        if (this._activeTweens.has(s)) {\n          const t = this._activeTweens.get(s);\n          if (t) {\n            const n = t.indexOf(e);\n            -1 !== n && t.splice(n, 1);\n          }\n        }\n      }\n      ReleaseTween(e, s = false) {\n        this._MaybeRemoveFromActiveTweenMap(e), e.IsReleased() || this._IsInWaitingList(e) || (e.Stop(s), this._AddToWaitingList(e));\n      }\n      ReleaseTweens(e, s = false) {\n        if (g.IsFiniteNumber(e)) {\n          const t = h.Maps.GetPropertyFromIndex(e);\n          if (this._activeTweens.has(t)) {\n            const n = this._activeTweens.get(t), i2 = this.GetFinishingTween();\n            for (const a of n) a === i2 || a.IsReleased() || this._IsInWaitingList(a) || (a.Stop(s), a.Release());\n            g.clearArray(n);\n          }\n        } else {\n          const r = this.GetFinishingTween();\n          for (const o of this.AllTweens()) o === r || o.IsReleased() || this._IsInWaitingList(o) || (o.Stop(s), o.Release());\n          for (const l of this._activeTweens.keys()) g.clearArray(this._activeTweens.get(l)), this._activeTweens.delete(l);\n          this._activeTweens.clear();\n        }\n      }\n      ReleaseAndCompleteTween(e) {\n        this.ReleaseTween(e, true);\n      }\n      ReleaseAndCompleteTweens() {\n        this.ReleaseTweens(NaN, true);\n      }\n      GetPropertyValueByIndex(e) {\n        if (e === i) return this._enabled;\n      }\n      SetPropertyValueByIndex(e, s) {\n        e === i && (this._enabled = !!s);\n      }\n      _GetBehaviorType(e) {\n        const s = e.GetInstance(), t = s.GetBehaviorInstances();\n        for (const n of t) {\n          const i2 = n.GetBehaviorType();\n          if (i2.GetInstanceSdkCtor() === this.constructor) return i2;\n        }\n      }\n      Trigger(e, s, t, n) {\n        return this._runtime ? super.Trigger(e) : s.Trigger(e, t, n);\n      }\n      _FinishTriggers(e) {\n        this._finishingTween = e, h.Cnds.SetFinishingTween(e);\n        let s, t;\n        if (this.GetRuntime()) s = this._inst, t = this._runtime, this.Trigger(h.Cnds.OnTweensFinished), this.Trigger(h.Cnds.OnAnyTweensFinished), this.ReleaseTween(e);\n        else {\n          if (!(s = e.GetInstance())) return;\n          if (s && s.IsDestroyed()) return;\n          t = s.GetRuntime();\n          const n = this._GetBehaviorType(e);\n          this.Trigger(h.Cnds.OnTweensFinished, t, s, n), this.Trigger(h.Cnds.OnAnyTweensFinished, t, s, n), e.Stop();\n        }\n        this._finishingTween = null, h.Cnds.SetFinishingTween(null), e.GetDestroyInstanceOnComplete() && t.DestroyInstance(s);\n      }\n      _AddTween(e, s) {\n        const t = h.Maps.GetPropertyFromIndex(s), n = (this._activeTweens.has(t) || this._activeTweens.set(t, []), this._activeTweens.get(t));\n        n.push(e);\n      }\n      _AddToWaitingList(e) {\n        const s = e.GetId();\n        this._waitingForReleaseTweens.has(s) || this._waitingForReleaseTweens.set(s, []), this._waitingForReleaseTweens.get(s).push(e), this.IsTicking2() || this._StartTicking2();\n      }\n      _IsInWaitingList(e) {\n        const s = e.GetId();\n        return !!this._waitingForReleaseTweens.has(s) && this._waitingForReleaseTweens.get(s).includes(e);\n      }\n      _ReleaseWaitingTweens() {\n        if (this._waitingForReleaseTweens.size) {\n          for (const e of this._waitingForReleaseTweens.values()) {\n            for (const s of e) s.IsReleased() || s.Release();\n            g.clearArray(e);\n          }\n          this._waitingForReleaseTweens.clear(), this.IsTicking2() && this._StopTicking2();\n        }\n      }\n      GetDebuggerProperties() {\n        return [{ title: \"$\" + this.GetBehaviorType().GetName(), properties: [{ name: \"behaviors.tween.properties.enabled.name\", value: this.IsEnabled(), onedit: (e) => this.SetEnabled(e) }] }];\n      }\n      GetScriptInterfaceClass() {\n        return self.ITweenBehaviorInstance;\n      }\n    };\n  }\n  {\n    const M0 = self.C3;\n    let s = null;\n    M0.Behaviors.Tween.Cnds = { OnAnyTweenLoop() {\n      return true;\n    }, OnTweensLoop(e) {\n      const s2 = this.GetTriggerTween();\n      return !!s2 && s2.HasTags(e);\n    }, OnAnyTweenPingPong(e) {\n      const s2 = this.GetTriggerTween();\n      return !!s2 && (s2.GetPingPongState() === e || 2 === e);\n    }, OnTweensPingPong(e, s2) {\n      const t = this.GetTriggerTween();\n      return !!t && (t.GetPingPongState() === s2 || 2 === s2) && t.HasTags(e);\n    }, SetFinishingTween(e) {\n      s = e;\n    }, OnTweensFinished(e) {\n      return s.HasTags(e);\n    }, OnAnyTweensFinished() {\n      return true;\n    }, IsPlaying(e) {\n      return this.CheckTweensWithTags(e, M0.TweenState.IsPlaying);\n    }, IsAnyPlaying() {\n      return this.CheckTweens(M0.TweenState.IsPlaying);\n    }, IsPaused(e) {\n      return this.CheckTweensWithTags(e, M0.TweenState.IsPaused);\n    }, IsAnyPaused() {\n      return this.CheckTweens(M0.TweenState.IsPaused);\n    }, IsPingPong(e, s2) {\n      return 0 === s2 ? this.CheckTweensWithTags(e, M0.TweenState.IsPing) : 1 === s2 && this.CheckTweensWithTags(e, M0.TweenState.IsPong);\n    }, IsAnyPingPong(e) {\n      return 0 === e ? this.CheckTweens(M0.TweenState.IsPing) : 1 === e && this.CheckTweens(M0.TweenState.IsPong);\n    } };\n  }\n  {\n    const ab = self.C3, bb = self.Ease, cb = ab.Behaviors.Tween;\n    cb.Acts = { SetEnabled(e) {\n      this.SetEnabled(!!e);\n    }, async TweenOneProperty(...e) {\n      if (this.IsEnabled() && this.IsInstanceValid()) {\n        const s = this.CreateTween(cb.TweenArguments.OneProperty(this, ...e));\n        s.Play() && await s.GetPlayPromise();\n      }\n    }, async TweenTwoProperties(...e) {\n      if (this.IsEnabled() && this.IsInstanceValid()) {\n        const s = this.CreateTween(cb.TweenArguments.TwoProperties(this, ...e));\n        s.Play() && await s.GetPlayPromise();\n      }\n    }, async TweenValue(...e) {\n      if (this.IsEnabled() && this.IsInstanceValid()) {\n        const s = this.CreateTween(cb.TweenArguments.ValueProperty(this, ...e));\n        s.Play() && await s.GetPlayPromise();\n      }\n    }, PauseTweens(e) {\n      if (this.IsEnabled() && this.IsInstanceValid()) for (const s of this.GetTweens(e)) s.Stop();\n    }, PauseAllTweens() {\n      if (this.IsEnabled() && this.IsInstanceValid()) for (const e of this.AllTweens()) e.Stop();\n    }, ResumeTweens(e) {\n      if (this.IsEnabled() && this.IsInstanceValid()) for (const s of this.GetTweens(e)) s.Resume();\n    }, ResumeAllTweens() {\n      if (this.IsEnabled() && this.IsInstanceValid()) for (const e of this.AllTweens()) e.Resume();\n    }, StopTweens(e) {\n      if (this.IsEnabled() && this.IsInstanceValid()) for (const s of this.GetTweens(e)) this.ReleaseTween(s);\n    }, StopAllTweens() {\n      if (this.IsEnabled() && this.IsInstanceValid()) for (const e of this.AllTweens()) this.ReleaseTween(e);\n    }, SetOnePropertyTweensEndValue(e, s, t) {\n      if (this.IsEnabled() && this.IsInstanceValid()) {\n        const n = ab.Behaviors.Tween.Maps.GetSinglePropertyFromIndex(s);\n        for (const i of this.GetTweens(e)) i.BeforeSetEndValues([n]), i.SetEndValue(t, n);\n      }\n    }, SetTwoPropertiesTweensEndValue(e, s, t, n) {\n      if (this.IsEnabled() && this.IsInstanceValid()) {\n        const i = ab.Behaviors.Tween.Maps.GetRealProperties(s);\n        for (const a of this.GetTweens(e)) a.BeforeSetEndValues(i), a.SetEndValue(t, i[0]), a.SetEndValue(n, i[1]);\n      }\n    }, SetValuePropertyTweensStartValue(e, s) {\n      if (this.IsEnabled() && this.IsInstanceValid()) for (const t of this.GetTweens(e, \"value\")) t.SetStartValue(s, \"value\");\n    }, SetValuePropertyTweensEndValue(e, s) {\n      if (this.IsEnabled() && this.IsInstanceValid()) for (const t of this.GetTweens(e, \"value\")) t.BeforeSetEndValues([\"value\"]), t.SetEndValue(s, \"value\");\n    }, SetTweensEase(e, s) {\n      if (this.IsEnabled() && this.IsInstanceValid()) {\n        const t = bb.GetEaseFromIndex(s);\n        for (const n of this.GetTweens(e)) n.SetEase(t);\n      }\n    }, SetAllTweensEase(e) {\n      if (this.IsEnabled() && this.IsInstanceValid()) {\n        const s = bb.GetEaseFromIndex(e);\n        for (const t of this.AllTweens()) t.SetEase(s);\n      }\n    }, SetTweensTime(e, s) {\n      if (this.IsEnabled() && this.IsInstanceValid()) for (const t of this.GetTweens(e)) t.SetTime(s);\n    }, SetAllTweensTime(e) {\n      if (this.IsEnabled() && this.IsInstanceValid()) for (const s of this.AllTweens()) s.SetTime(e);\n    }, SetTweensPlaybackRate(e, s) {\n      if (this.IsEnabled() && this.IsInstanceValid()) for (const t of this.GetTweens(e)) t.SetPlaybackRate(s);\n    }, SetAllTweensPlaybackRate(e) {\n      if (this.IsEnabled() && this.IsInstanceValid()) for (const s of this.AllTweens()) s.SetPlaybackRate(e);\n    }, SetTweensDestroyOnComplete(e, s) {\n      if (this.IsEnabled() && this.IsInstanceValid()) for (const t of this.GetTweens(e)) t.SetDestroyInstanceOnComplete(!!s);\n    }, SetAllTweensDestroyOnComplete(e) {\n      if (this.IsEnabled() && this.IsInstanceValid()) for (const s of this.AllTweens()) s.SetDestroyInstanceOnComplete(!!e);\n    } };\n  }\n  {\n    const e1 = self.C3;\n    e1.Behaviors.Tween.Exps = { Time(e) {\n      const s = this.GetTweenIncludingWaitingForRelease(e);\n      return s ? s.GetTime() : 0;\n    }, Progress(e) {\n      const s = this.GetTweenIncludingWaitingForRelease(e);\n      return s ? s.GetTime() / s.GetTotalTime() : 0;\n    }, PlaybackRate(e) {\n      const s = this.GetTweenIncludingWaitingForRelease(e);\n      return s ? s.GetPlaybackRate() : 0;\n    }, Value(e) {\n      const s = this.GetTweenIncludingWaitingForRelease(e, \"value\");\n      return s ? s.GetPropertyTrack(\"value\").GetSourceAdapterValue() : 0;\n    }, Tags() {\n      let e = this.GetFinishingTween();\n      return (e = e || this.GetTriggerTween()) ? e.GetStringTags() : \"\";\n    } };\n  }\n}\n{\n  const C32 = self.C3, Ease = self.Ease, PAIR_PROPERTIES = [\"position\", \"size\", \"scale\"], SINGLE_PROPERTIES = [\"offsetX\", \"offsetY\", \"offsetWidth\", \"offsetHeight\", \"offsetAngle\", \"offsetOpacity\", \"offsetColor\", \"offsetZElevation\", \"offsetScaleX\", \"offsetScaleY\"], VALUE_PROPERTIES = [\"value\"], PROPERTY_INDEX_TO_NAME = [].concat(PAIR_PROPERTIES).concat(SINGLE_PROPERTIES).concat(VALUE_PROPERTIES), PROPERTY_PAIR_TO_REAL_PROPERTIES = { \"position\": [\"offsetX\", \"offsetY\"], \"size\": [\"offsetWidth\", \"offsetHeight\"], \"scale\": [\"offsetScaleX\", \"offsetScaleY\"] }, ALL_REAL_PROPERTIES = Object.assign({}, PROPERTY_INDEX_TO_NAME.reduce((e, t) => Object.assign({}, e, { [t]: [t] }), {}), PROPERTY_PAIR_TO_REAL_PROPERTIES);\n  C32.Behaviors.Tween.Maps = class {\n    constructor() {\n    }\n    static GetEases() {\n      return [...Ease.GetRuntimeEaseNames()];\n    }\n    static GetEaseFromIndex(e) {\n      return [...Ease.GetRuntimeEaseNames()][e];\n    }\n    static GetPropertyFromIndex(e) {\n      return PROPERTY_INDEX_TO_NAME[e];\n    }\n    static GetPropertyIndexFromName(e) {\n      return PROPERTY_INDEX_TO_NAME.indexOf(e);\n    }\n    static GetPairPropertyFromIndex(e) {\n      return PAIR_PROPERTIES[e];\n    }\n    static GetSinglePropertyFromIndex(e) {\n      return SINGLE_PROPERTIES[e];\n    }\n    static GetValuePropertyFromIndex(e) {\n      return VALUE_PROPERTIES[e];\n    }\n    static GetPairProperties(e) {\n      return PROPERTY_PAIR_TO_REAL_PROPERTIES[e];\n    }\n    static GetRealProperties(e) {\n      return C32.IsString(e) ? ALL_REAL_PROPERTIES[e] : ALL_REAL_PROPERTIES[PROPERTY_INDEX_TO_NAME[e]];\n    }\n    static IsPairId(e) {\n      return !!PROPERTY_PAIR_TO_REAL_PROPERTIES[e];\n    }\n    static IsColorId(e) {\n      return \"offsetColor\" === e;\n    }\n    static IsAngleId(e) {\n      return \"offsetAngle\" === e;\n    }\n    static IsOpacityId(e) {\n      return \"offsetOpacity\" === e;\n    }\n    static IsValueId(e) {\n      return \"value\" === e;\n    }\n  };\n}\n{\n  const C32 = self.C3, NAMESPACE = C32.Behaviors.Tween, TWEEN_CONFIGURATIONS = /* @__PURE__ */ new Map();\n  NAMESPACE.Config = class {\n    constructor() {\n    }\n    static GetPropertyTracksConfig(e, t, r, o, a, s) {\n      0 === TWEEN_CONFIGURATIONS.size && this._CreateConfigObjects();\n      const n = NAMESPACE.PropertyTypes.Pick(e);\n      let i = TWEEN_CONFIGURATIONS.get(n);\n      return C32.IsFiniteNumber(e) && (e = NAMESPACE.Maps.GetPropertyFromIndex(e)), this._GetConfig(i, e, t, r, o, a, s);\n    }\n    static TransformValue(e, t) {\n      const r = C32.Behaviors.Tween.GetPropertyTracksConfig(e);\n      return r.valueGetter(t);\n    }\n    static _CreateConfigObjects() {\n      const e = NAMESPACE.PropertyTypes, t = NAMESPACE.ValueGetters;\n      this._AddConfigObject(e.PAIR, this._GetPairConfig, t._GetPropertyValue), this._AddConfigObject(e.COLOR, this._GetColorConfig, t._GetColorPropertyValue), this._AddConfigObject(e.ANGLE, this._GetAngleConfig, t._GetPropertyAngleValue), this._AddConfigObject(e.VALUE, this._GetValueConfig, t._GetPropertyValue), this._AddConfigObject(e.OTHER, this._GetCommonConfig, t._GetPropertyValue);\n    }\n    static _AddConfigObject(e, t, r) {\n      TWEEN_CONFIGURATIONS.set(e, this._CreateConfigObject(e, t, r));\n    }\n    static _CreateConfigObject(e, t, r) {\n      return { name: e, configFunc: t, valueGetter: r };\n    }\n    static _GetConfig(e, t, r, o, a, s, n) {\n      return e.configFunc(t, e.valueGetter(r), e.valueGetter(o), a, s, n);\n    }\n    static _GetPairConfig(e, r, o, a, s, t) {\n      const n = NAMESPACE.Maps.GetPairProperties(e);\n      return n.map((e2, t2) => ({ sourceId: \"world-instance\", property: e2, type: \"float\", valueType: \"numeric\", startValue: r[t2], endValue: o[t2], ease: NAMESPACE.Maps.GetEaseFromIndex(a), resultMode: s }));\n    }\n    static _GetColorConfig(e, t, r, o, a, s) {\n      return C32.Plugins.Text && s.GetPlugin() instanceof C32.Plugins.Text ? { sourceId: \"plugin\", sourceArgs: [7], property: \"color\", type: \"color\", valueType: \"color\", startValue: t, endValue: r, ease: NAMESPACE.Maps.GetEaseFromIndex(o), resultMode: a } : { sourceId: \"world-instance\", property: e, type: \"color\", valueType: \"color\", startValue: t, endValue: r, ease: NAMESPACE.Maps.GetEaseFromIndex(o), resultMode: a };\n    }\n    static _GetAngleConfig(e, t, r, o, a, s) {\n      return { sourceId: \"world-instance\", property: e, type: \"angle\", valueType: \"angle\", startValue: t, endValue: r, ease: NAMESPACE.Maps.GetEaseFromIndex(o), resultMode: a };\n    }\n    static _GetCommonConfig(e, t, r, o, a, s) {\n      return { sourceId: \"world-instance\", property: e, type: \"float\", valueType: \"numeric\", startValue: t, endValue: r, ease: NAMESPACE.Maps.GetEaseFromIndex(o), resultMode: a };\n    }\n    static _GetValueConfig(e, t, r, o, a, s) {\n      return { sourceId: \"value\", property: e, type: \"float\", valueType: \"numeric\", startValue: t, endValue: r, ease: NAMESPACE.Maps.GetEaseFromIndex(o), resultMode: a };\n    }\n  };\n}\n{\n  const C32 = self.C3, NAMESPACE = C32.Behaviors.Tween, COMMON_FIXED_ARGS = { resultMode: \"absolute\" }, COMMON_VARIABLE_ARGS = Object.assign({}, COMMON_FIXED_ARGS, { tags: \"\", property: \"\", time: 0, ease: 0, releaseOnComplete: 0, loop: false, pingPong: false, repeatCount: 1 }), ONE_PROPERTY_ARGS = Object.assign({}, COMMON_VARIABLE_ARGS, { initialValueMode: \"current-state\", startValue: 0, endValue: 0 }), TWO_PROPERTIES_ARGS = Object.assign({}, COMMON_VARIABLE_ARGS, { initialValueMode: \"current-state\", startValue: [0, 0], endValue: [0, 0] }), COLOR_PROPERTY_ARGS = Object.assign({}, COMMON_VARIABLE_ARGS, { initialValueMode: \"current-state\", startValue: [0, 0, 0], endValue: [0, 0, 0] }), VALUE_PROPERTY_ARGS = Object.assign({}, ONE_PROPERTY_ARGS, { initialValueMode: \"start-value\" }), X = 0, Y = 1, R = 0, G = 1, B = 2;\n  NAMESPACE.TweenArguments = class {\n    constructor() {\n    }\n    static _SetCommonProperties(e, t, R2, r, P, a, E, O) {\n      e.tags = t, e.time = R2, e.ease = r, e.releaseOnComplete = P, e.loop = a, e.pingPong = E, e.repeatCount = O;\n    }\n    static OneProperty(e, t, r, P, a, E, O, A, _, o) {\n      const s = \"string\" == typeof r ? r : NAMESPACE.Maps.GetSinglePropertyFromIndex(r), n = NAMESPACE.Maps.IsColorId(s) ? COLOR_PROPERTY_ARGS : ONE_PROPERTY_ARGS;\n      return this._SetCommonProperties(n, t, a, E, O, A, _, o), NAMESPACE.Maps.IsColorId(s) ? (COLOR_PROPERTY_ARGS.endValue[R] = C32.GetRValue(P), COLOR_PROPERTY_ARGS.endValue[G] = C32.GetGValue(P), COLOR_PROPERTY_ARGS.endValue[B] = C32.GetBValue(P), COLOR_PROPERTY_ARGS.property = NAMESPACE.Maps.GetPropertyIndexFromName(s)) : NAMESPACE.Maps.IsOpacityId(s) ? ONE_PROPERTY_ARGS.endValue = P / 100 : ONE_PROPERTY_ARGS.endValue = P, n.property = NAMESPACE.Maps.GetPropertyIndexFromName(s), n;\n    }\n    static TwoProperties(e, t, R2, r, P, a, E, O, A, _, o) {\n      this._SetCommonProperties(TWO_PROPERTIES_ARGS, t, a, E, O, A, _, o);\n      const s = \"string\" == typeof R2 ? R2 : NAMESPACE.Maps.GetPairPropertyFromIndex(R2);\n      return TWO_PROPERTIES_ARGS.endValue[X] = r, TWO_PROPERTIES_ARGS.endValue[Y] = P, TWO_PROPERTIES_ARGS.property = NAMESPACE.Maps.GetPropertyIndexFromName(s), TWO_PROPERTIES_ARGS;\n    }\n    static ValueProperty(e, t, R2, r, P, a, E, O, A, _) {\n      return this._SetCommonProperties(VALUE_PROPERTY_ARGS, t, P, a, E, O, A, _), VALUE_PROPERTY_ARGS.startValue = R2, VALUE_PROPERTY_ARGS.endValue = r, VALUE_PROPERTY_ARGS.property = NAMESPACE.Maps.GetPropertyIndexFromName(\"value\"), VALUE_PROPERTY_ARGS;\n    }\n  };\n}\n{\n  const C32 = self.C3, NAMESPACE = C32.Behaviors.Tween, TYPE_CHECK_OBJECTS = [];\n  NAMESPACE.PropertyTypes = class {\n    constructor() {\n    }\n    static Pick(t) {\n      if (0 === TYPE_CHECK_OBJECTS.length) {\n        const e = TYPE_CHECK_OBJECTS;\n        e.push({ checkFunc: NAMESPACE.Maps.IsPairId, result: this.PAIR }), e.push({ checkFunc: NAMESPACE.Maps.IsColorId, result: this.COLOR }), e.push({ checkFunc: NAMESPACE.Maps.IsAngleId, result: this.ANGLE }), e.push({ checkFunc: NAMESPACE.Maps.IsValueId, result: this.VALUE }), e.push({ checkFunc: () => true, result: this.OTHER });\n      }\n      C32.IsFiniteNumber(t) && (t = C32.Behaviors.Tween.Maps.GetPropertyFromIndex(t));\n      for (const s of TYPE_CHECK_OBJECTS) if (s.checkFunc(t)) return s.result;\n    }\n    static get PAIR() {\n      return \"pair\";\n    }\n    static get COLOR() {\n      return \"color\";\n    }\n    static get ANGLE() {\n      return \"angle\";\n    }\n    static get VALUE() {\n      return \"value\";\n    }\n    static get OTHER() {\n      return \"other\";\n    }\n  };\n}\n{\n  const C32 = self.C3, NAMESPACE = C32.Behaviors.Tween;\n  NAMESPACE.ValueGetters = class {\n    constructor() {\n    }\n    static _GetPropertyAngleValue(e) {\n      const t = C32.toRadians(parseFloat(e));\n      return C32.clampAngle(t);\n    }\n    static _GetColorPropertyValue(e) {\n      return e.slice(0);\n    }\n    static _GetPropertyValue(e) {\n      return e;\n    }\n  };\n}\n{\n  let getIndexForEase = function(e) {\n    C3X.RequireString(e);\n    const t = Ease.ToInternal(e);\n    let n;\n    if (-1 === (n = t ? Ease.GetIndexForEase(t, null) : Ease.GetIndexForEase(e, null))) throw new Error(`invalid ease name '${e}'`);\n    return n;\n  }, ValidateTags = function(e, t = false) {\n    if (!(t && null == e || \"string\" == typeof e || Array.isArray(e))) throw new Error(\"invalid tags\");\n  };\n  getIndexForEase2 = getIndexForEase, ValidateTags2 = ValidateTags;\n  const C32 = self.C3, C3X = self.C3X, IBehaviorInstance = self.IBehaviorInstance, Ease = self.Ease, NAMESPACE = C32.Behaviors.Tween, map = /* @__PURE__ */ new WeakMap(), TWEEN_PROPERTIES = /* @__PURE__ */ new Map([[\"x\", { name: \"offsetX\", type: \"one\" }], [\"y\", { name: \"offsetY\", type: \"one\" }], [\"width\", { name: \"offsetWidth\", type: \"one\" }], [\"height\", { name: \"offsetHeight\", type: \"one\" }], [\"angle\", { name: \"offsetAngle\", type: \"one\" }], [\"opacity\", { name: \"offsetOpacity\", type: \"one\" }], [\"color\", { name: \"offsetColor\", type: \"color\" }], [\"z-elevation\", { name: \"offsetZElevation\", type: \"one\" }], [\"x-scale\", { name: \"offsetScaleX\", type: \"one\" }], [\"y-scale\", { name: \"offsetScaleY\", type: \"one\" }], [\"position\", { name: \"position\", type: \"two\" }], [\"size\", { name: \"size\", type: \"two\" }], [\"scale\", { name: \"scale\", type: \"two\" }], [\"value\", { name: \"value\", type: \"value\" }]]);\n  const TWEEN_OPTS = { tags: \"\", destroyOnComplete: false, loop: false, pingPong: false, repeatCount: 1, startValue: 0 }, I_TWEEN_OPTS = { easeToIndexFunc: getIndexForEase };\n  self.ITweenBehaviorInstance = class extends IBehaviorInstance {\n    constructor() {\n      super(), map.set(this, IBehaviorInstance._GetInitInst().GetSdkInstance());\n    }\n    startTween(e, t, n, a, o) {\n      const s = map.get(this);\n      if (!s.IsEnabled() || !s.IsInstanceValid()) return null;\n      const r = TWEEN_PROPERTIES.get(e);\n      if (!r) throw new Error(\"invalid tween property\");\n      \"one\" === r.type || \"value\" === r.type ? C3X.RequireNumber(t) : (C3X.RequireArray(t), \"two\" === r.type ? (C3X.RequireNumber(t[0]), C3X.RequireNumber(t[1])) : \"color\" === r.type && (C3X.RequireNumber(t[0]), C3X.RequireNumber(t[1]), C3X.RequireNumber(t[2]))), \"angle\" === e ? t = C32.toDegrees(t) : \"opacity\" === e ? t *= 100 : \"color\" === e && (t = C32.PackRGBEx(t[0], t[1], t[2]));\n      const l = getIndexForEase(a);\n      C3X.RequireFiniteNumber(n), o = Object.assign({}, TWEEN_OPTS, o), \"value\" === r.type && C3X.RequireNumber(o.startValue), ValidateTags(o.tags, true);\n      let i;\n      if (\"one\" === r.type || \"color\" === r.type ? i = s.CreateTween(NAMESPACE.TweenArguments.OneProperty(s, o.tags, r.name, t, n, l, !!o.destroyOnComplete, !!o.loop, !!o.pingPong, o.repeatCount)) : \"two\" === r.type ? i = s.CreateTween(NAMESPACE.TweenArguments.TwoProperties(s, o.tags, r.name, t[0], t[1], n, l, !!o.destroyOnComplete, !!o.loop, !!o.pingPong, o.repeatCount)) : \"value\" === r.type && (i = s.CreateTween(NAMESPACE.TweenArguments.ValueProperty(s, o.tags, o.startValue, t, n, l, !!o.destroyOnComplete, !!o.loop, !!o.pingPong, o.repeatCount))), i.Play()) return i.GetITweenState(s, I_TWEEN_OPTS);\n      throw new Error(\"failed to start tween\");\n    }\n    *allTweens() {\n      const e = map.get(this);\n      for (const t of e.AllTweens()) yield t.GetITweenState(e, I_TWEEN_OPTS);\n    }\n    *tweensByTags(e) {\n      ValidateTags(e);\n      const t = map.get(this);\n      for (const n of t.GetTweens(e)) yield n.GetITweenState(t, I_TWEEN_OPTS);\n    }\n    get isEnabled() {\n      return map.get(this).IsEnabled();\n    }\n    set isEnabled(e) {\n      map.get(this).SetEnabled(e);\n    }\n  };\n}\nvar getIndexForEase2;\nvar ValidateTags2;\n{\n  {\n    const a = self.C3;\n    a.Behaviors.Sin = class extends a.SDKBehaviorBase {\n      constructor(e) {\n        super(e);\n      }\n      Release() {\n        super.Release();\n      }\n    };\n  }\n  {\n    const d = self.C3;\n    d.Behaviors.Sin.Type = class extends d.SDKBehaviorTypeBase {\n      constructor(e) {\n        super(e);\n      }\n      Release() {\n        super.Release();\n      }\n      OnCreate() {\n      }\n    };\n  }\n  {\n    const g = self.C3, h = self.C3X, i = self.IBehaviorInstance, j = 0, k = 1, l = 2, m = 3, n = 4, o = 5, p = 6, q = 7, r = 8, s = 0, t = 1, u = 2, v = 3, w = 4, x = 5, y = 6, z = 7, A = 8, B = 9, C = 0, D = 1, E = 2, F = 3, G = 4, H = 2 * Math.PI, I = Math.PI / 2, J = 3 * Math.PI / 2, K = [0, 1, 8, 3, 4, 2, 5, 6, 9, 7], L = (g.Behaviors.Sin.Instance = class extends g.SDKBehaviorInstanceBase {\n      constructor(e, t2) {\n        super(e), this._i = 0, this._movement = 0, this._wave = 0, this._period = 0, this._mag = 0, this._isEnabled = true, this._basePeriod = 0, this._basePeriodOffset = 0, this._baseMag = 0, this._periodRandom = 0, this._periodOffsetRandom = 0, this._magnitudeRandom = 0, this._initialValue = 0, this._initialValue2 = 0, this._lastKnownValue = 0, this._lastKnownValue2 = 0, this._ratio = 0, t2 && (this._movement = K[t2[j]], this._wave = t2[k], this._periodRandom = this._runtime.Random() * t2[m], this._basePeriod = t2[l], this._period = t2[l], this._period += this._periodRandom, this._basePeriodOffset = t2[n], 0 !== this._period && (this._periodOffsetRandom = this._runtime.Random() * t2[o], this._i = t2[n] / this._period * H, this._i += this._periodOffsetRandom / this._period * H), this._magnitudeRandom = this._runtime.Random() * t2[q], this._baseMag = t2[p], this._mag = t2[p], this._mag += this._magnitudeRandom, this._isEnabled = !!t2[r]), this._movement === x && (this._mag = g.toRadians(this._mag)), this.Init(), this._isEnabled && this._StartTicking();\n      }\n      Release() {\n        super.Release();\n      }\n      SaveToJson() {\n        return { \"i\": this._i, \"e\": this._isEnabled, \"mv\": this._movement, \"w\": this._wave, \"p\": this._period, \"mag\": this._mag, \"iv\": this._initialValue, \"iv2\": this._initialValue2, \"r\": this._ratio, \"lkv\": this._lastKnownValue, \"lkv2\": this._lastKnownValue2 };\n      }\n      LoadFromJson(e) {\n        this._i = e[\"i\"], this._SetEnabled(e[\"e\"]), this._movement = e[\"mv\"], this._wave = e[\"w\"], this._period = e[\"p\"], this._mag = e[\"mag\"], this._initialValue = e[\"iv\"], this._initialValue2 = e[\"iv2\"], this._ratio = e[\"r\"], this._lastKnownValue = e[\"lkv\"], this._lastKnownValue2 = e[\"lkv2\"];\n      }\n      Init() {\n        const e = this._inst.GetWorldInfo();\n        switch (this._movement) {\n          case s:\n            this._initialValue = e.GetX();\n            break;\n          case t:\n            this._initialValue = e.GetY();\n            break;\n          case u:\n            this._initialValue = e.GetWidth(), this._ratio = e.GetHeight() / e.GetWidth();\n            break;\n          case v:\n            this._initialValue = e.GetWidth();\n            break;\n          case w:\n            this._initialValue = e.GetHeight();\n            break;\n          case x:\n            this._initialValue = e.GetAngle();\n            break;\n          case y:\n            this._initialValue = e.GetOpacity();\n            break;\n          case z:\n            this._initialValue = 0;\n            break;\n          case A:\n            this._initialValue = e.GetX(), this._initialValue2 = e.GetY();\n            break;\n          case B:\n            this._initialValue = e.GetZElevation();\n        }\n        this._lastKnownValue = this._initialValue, this._lastKnownValue2 = this._initialValue2;\n      }\n      WaveFunc(e) {\n        switch (e %= H, this._wave) {\n          case C:\n            return Math.sin(e);\n          case D:\n            return e <= I ? e / I : e <= J ? 1 - 2 * (e - I) / Math.PI : (e - J) / I - 1;\n          case E:\n            return 2 * e / H - 1;\n          case F:\n            return -2 * e / H + 1;\n          case G:\n            return e < Math.PI ? -1 : 1;\n        }\n        return 0;\n      }\n      Tick() {\n        const e = this._runtime.GetDt(this._inst);\n        this._isEnabled && 0 !== e && (0 === this._period ? this._i = 0 : this._i = (this._i + e / this._period * H) % H, this._UpdateFromPhase());\n      }\n      _UpdateFromPhase() {\n        const e = this._inst.GetWorldInfo();\n        switch (this._movement) {\n          case s:\n            e.GetX() !== this._lastKnownValue && (this._initialValue += e.GetX() - this._lastKnownValue), e.SetX(this._initialValue + this.WaveFunc(this._i) * this._mag), this._lastKnownValue = e.GetX();\n            break;\n          case t:\n            e.GetY() !== this._lastKnownValue && (this._initialValue += e.GetY() - this._lastKnownValue), e.SetY(this._initialValue + this.WaveFunc(this._i) * this._mag), this._lastKnownValue = e.GetY();\n            break;\n          case u:\n            e.SetWidth(this._initialValue + this.WaveFunc(this._i) * this._mag), e.SetHeight(e.GetWidth() * this._ratio);\n            break;\n          case v:\n            e.SetWidth(this._initialValue + this.WaveFunc(this._i) * this._mag);\n            break;\n          case w:\n            e.SetHeight(this._initialValue + this.WaveFunc(this._i) * this._mag);\n            break;\n          case x:\n            e.GetAngle() !== this._lastKnownValue && (this._initialValue = g.clampAngle(this._initialValue + (e.GetAngle() - this._lastKnownValue))), e.SetAngle(this._initialValue + this.WaveFunc(this._i) * this._mag), this._lastKnownValue = e.GetAngle();\n            break;\n          case y:\n            e.SetOpacity(this._initialValue + this.WaveFunc(this._i) * this._mag / 100);\n            break;\n          case A:\n            e.GetX() !== this._lastKnownValue && (this._initialValue += e.GetX() - this._lastKnownValue), e.GetY() !== this._lastKnownValue2 && (this._initialValue2 += e.GetY() - this._lastKnownValue2), e.SetX(this._initialValue + Math.cos(e.GetAngle()) * this.WaveFunc(this._i) * this._mag), e.SetY(this._initialValue2 + Math.sin(e.GetAngle()) * this.WaveFunc(this._i) * this._mag), this._lastKnownValue = e.GetX(), this._lastKnownValue2 = e.GetY();\n            break;\n          case B:\n            e.SetZElevation(this._initialValue + this.WaveFunc(this._i) * this._mag);\n        }\n        e.SetBboxChanged();\n      }\n      _OnSpriteFrameChanged(e, t2) {\n      }\n      _SetPeriod(e) {\n        this._period = e;\n      }\n      _GetPeriod() {\n        return this._period;\n      }\n      _SetMagnitude(e) {\n        this._mag = e;\n      }\n      _SetMagnitude_ConvertAngle(e) {\n        5 === this._movement && (e = g.toRadians(e)), this._SetMagnitude(e);\n      }\n      _GetMagnitude() {\n        return this._mag;\n      }\n      _GetMagnitude_ConvertAngle() {\n        let e = this._GetMagnitude();\n        return e = 5 === this._movement ? g.toDegrees(e) : e;\n      }\n      _SetMovement(e) {\n        5 === this._movement && 5 !== e && (this._mag = g.toDegrees(this._mag)), this._movement = e, this.Init();\n      }\n      _GetMovement() {\n        return this._movement;\n      }\n      _SetWave(e) {\n        this._wave = e;\n      }\n      _GetWave() {\n        return this._wave;\n      }\n      _SetPhase(e) {\n        this._i = g.clamp(e, 0, 2 * Math.PI), this._UpdateFromPhase();\n      }\n      _GetPhase() {\n        return this._i;\n      }\n      _SetEnabled(e) {\n        this._isEnabled = !!e, this._isEnabled ? this._StartTicking() : this._StopTicking();\n      }\n      _IsEnabled() {\n        return this._isEnabled;\n      }\n      GetPropertyValueByIndex(e) {\n        switch (e) {\n          case j:\n            return this._movement;\n          case k:\n            return this._wave;\n          case l:\n            return this._basePeriod;\n          case p:\n            return this._baseMag;\n          case r:\n            return this._isEnabled;\n        }\n      }\n      SetPropertyValueByIndex(e, t2) {\n        switch (e) {\n          case j:\n            this._movement = K[t2], this.Init();\n            break;\n          case k:\n            this._wave = t2;\n            break;\n          case l:\n            this._basePeriod = t2, this._period = this._basePeriod + this._periodRandom, this._isEnabled || (0 !== this._period ? (this._i = this._basePeriodOffset / this._period * H, this._i += this._periodOffsetRandom / this._period * H) : this._i = 0);\n            break;\n          case p:\n            this._baseMag = t2, this._mag = this._baseMag + this._magnitudeRandom, this._movement === x && (this._mag = g.toRadians(this._mag));\n            break;\n          case r:\n            this._isEnabled = !!t2;\n        }\n      }\n      GetDebuggerProperties() {\n        const e = \"behaviors.sin\";\n        return [{ title: \"$\" + this.GetBehaviorType().GetName(), properties: [{ name: e + \".properties.enabled.name\", value: this._IsEnabled(), onedit: (e2) => this._SetEnabled(e2) }, { name: e + \".properties.period.name\", value: this._GetPeriod(), onedit: (e2) => this._SetPeriod(e2) }, { name: e + \".properties.magnitude.name\", value: this._GetMagnitude_ConvertAngle(), onedit: (e2) => this._SetMagnitude_ConvertAngle(e2) }, { name: e + \".debugger.value\", value: this.WaveFunc(this._GetPhase()) * this._GetMagnitude_ConvertAngle() }] }];\n      }\n      GetScriptInterfaceClass() {\n        return self.ISineBehaviorInstance;\n      }\n    }, /* @__PURE__ */ new WeakMap()), M = [\"horizontal\", \"vertical\", \"size\", \"width\", \"height\", \"angle\", \"opacity\", \"value-only\", \"forwards-backwards\", \"z-elevation\"], N = [\"sine\", \"triangle\", \"sawtooth\", \"reverse-sawtooth\", \"square\"];\n    self.ISineBehaviorInstance = class extends i {\n      constructor() {\n        super(), L.set(this, i._GetInitInst().GetSdkInstance());\n      }\n      set period(e) {\n        h.RequireFiniteNumber(e), L.get(this)._SetPeriod(e);\n      }\n      get period() {\n        return L.get(this)._GetPeriod();\n      }\n      set magnitude(e) {\n        h.RequireFiniteNumber(e), L.get(this)._SetMagnitude(e);\n      }\n      get magnitude() {\n        return L.get(this)._GetMagnitude();\n      }\n      set phase(e) {\n        L.get(this)._SetPhase(e);\n      }\n      get phase() {\n        return L.get(this)._GetPhase();\n      }\n      set movement(e) {\n        h.RequireString(e);\n        const t2 = M.indexOf(e);\n        if (-1 === t2) throw new Error(\"invalid movement\");\n        L.get(this)._SetMovement(t2);\n      }\n      get movement() {\n        return M[L.get(this)._GetMovement()];\n      }\n      set wave(e) {\n        h.RequireString(e);\n        const t2 = N.indexOf(e);\n        if (-1 === t2) throw new Error(\"invalid wave\");\n        L.get(this)._SetWave(t2);\n      }\n      get wave() {\n        return N[L.get(this)._GetWave()];\n      }\n      get value() {\n        const e = L.get(this);\n        return e.WaveFunc(e._GetPhase()) * e._GetMagnitude();\n      }\n      updateInitialState() {\n        L.get(this).Init();\n      }\n      set isEnabled(e) {\n        L.get(this)._SetEnabled(!!e);\n      }\n      get isEnabled() {\n        return L.get(this)._IsEnabled();\n      }\n    };\n  }\n  {\n    const va = self.C3;\n    va.Behaviors.Sin.Cnds = { IsEnabled() {\n      return this._IsEnabled();\n    }, CompareMovement(e) {\n      return this._GetMovement() === e;\n    }, ComparePeriod(e, t) {\n      return va.compare(this._GetPeriod(), e, t);\n    }, CompareMagnitude(e, t) {\n      return va.compare(this._GetMagnitude_ConvertAngle(), e, t);\n    }, CompareWave(e) {\n      return this._GetWave() === e;\n    } };\n  }\n  {\n    const Ca = self.C3;\n    Ca.Behaviors.Sin.Acts = { SetEnabled(e) {\n      this._SetEnabled(0 !== e);\n    }, SetPeriod(e) {\n      this._SetPeriod(e);\n    }, SetMagnitude(e) {\n      this._SetMagnitude_ConvertAngle(e);\n    }, SetMovement(e) {\n      this._SetMovement(e);\n    }, SetWave(e) {\n      this._wave = e;\n    }, SetPhase(e) {\n      const t = 2 * Math.PI;\n      this._SetPhase(e * t % t);\n    }, UpdateInitialState() {\n      this.Init();\n    } };\n  }\n  {\n    const Ka = self.C3;\n    Ka.Behaviors.Sin.Exps = { CyclePosition() {\n      return this._GetPhase() / (2 * Math.PI);\n    }, Period() {\n      return this._GetPeriod();\n    }, Magnitude() {\n      return this._GetMagnitude_ConvertAngle();\n    }, Value() {\n      return this.WaveFunc(this._GetPhase()) * this._GetMagnitude_ConvertAngle();\n    } };\n  }\n}\n{\n  let unaryminus = function(n) {\n    return typeof n === \"number\" ? -n : n;\n  }, bothNumbers = function(a, b) {\n    return typeof a === \"number\" && typeof b === \"number\";\n  }, add = function(l, r) {\n    if (bothNumbers(l, r))\n      return l + r;\n    else\n      return l;\n  }, subtract = function(l, r) {\n    if (bothNumbers(l, r))\n      return l - r;\n    else\n      return l;\n  }, multiply = function(l, r) {\n    if (bothNumbers(l, r))\n      return l * r;\n    else\n      return l;\n  }, divide = function(l, r) {\n    if (bothNumbers(l, r))\n      return l / r;\n    else\n      return l;\n  }, mod = function(l, r) {\n    if (bothNumbers(l, r))\n      return l % r;\n    else\n      return l;\n  }, pow = function(l, r) {\n    if (bothNumbers(l, r))\n      return Math.pow(l, r);\n    else\n      return l;\n  }, and = function(l, r) {\n    if (typeof l === \"string\" || typeof r === \"string\") {\n      let lstr, rstr;\n      if (typeof l === \"number\")\n        lstr = (Math.round(l * 1e10) / 1e10).toString();\n      else\n        lstr = l;\n      if (typeof r === \"number\")\n        rstr = (Math.round(r * 1e10) / 1e10).toString();\n      else\n        rstr = r;\n      return lstr + rstr;\n    } else {\n      return l && r ? 1 : 0;\n    }\n  }, or = function(l, r) {\n    if (bothNumbers(l, r))\n      return l || r ? 1 : 0;\n    else\n      return l;\n  };\n  unaryminus2 = unaryminus, bothNumbers2 = bothNumbers, add2 = add, subtract2 = subtract, multiply2 = multiply, divide2 = divide, mod2 = mod, pow2 = pow, and2 = and, or2 = or;\n  const C32 = self.C3;\n  self.C3_ExpressionFuncs = [\n    () => \"https://arturbier.github.io/gamedevcorp/music/bg_sound.mp3\",\n    () => \"audio/webm; codecs=opus\",\n    () => \"BG.mp3\",\n    () => \"https://arturbier.github.io/gamedevcorp/sounds/click.wav\",\n    () => \"Click.wav\",\n    () => \"https://arturbier.github.io/gamedevcorp/video/mainvideo.mp4\",\n    () => \"BG\",\n    () => -15,\n    () => 0,\n    (p) => {\n      const n0 = p._GetNode(0);\n      return () => n0.ExpObject();\n    },\n    () => 1.1,\n    () => 7,\n    (p) => {\n      const f0 = p._GetNode(0).GetBoundMethod();\n      return () => f0() * 0.1;\n    },\n    () => \"\",\n    () => 1.8,\n    () => 4,\n    () => 5.1,\n    () => 5.7,\n    () => \"First_Scene\",\n    () => 100,\n    () => 0.1,\n    () => 1,\n    () => \"Next_Screen\",\n    () => 0.5,\n    () => 0.15,\n    () => 8.5,\n    () => \"Attack_1\",\n    () => \"Atack_1\",\n    () => 10,\n    () => 10.6,\n    () => \"Attack_2\",\n    () => 11.5,\n    () => 3,\n    () => 14.51,\n    () => \"Last_Scene\",\n    () => \"Last_Screen\",\n    () => 0.2,\n    () => 16,\n    () => 17,\n    () => 19.3,\n    () => 20,\n    () => 22,\n    () => \"Finish\",\n    () => 24,\n    () => 25.1,\n    () => 25.35,\n    () => \"Store\",\n    () => 353\n  ];\n}\nvar unaryminus2;\nvar bothNumbers2;\nvar add2;\nvar subtract2;\nvar multiply2;\nvar divide2;\nvar mod2;\nvar pow2;\nvar and2;\nvar or2;\n\n// file-map:scripts/objRefTable.js\nvar C3 = self.C3;\nself.C3_GetObjectRefTable = function() {\n  return [\n    C3.Plugins.Text,\n    C3.Plugins.Sprite,\n    C3.Behaviors.Tween,\n    C3.Plugins.Audio,\n    C3.Plugins.video,\n    C3.Behaviors.Sin,\n    C3.Plugins.Touch,\n    C3.Plugins.PlatformInfo,\n    C3.Plugins.TiledBg,\n    C3.Plugins.System.Cnds.OnLayoutStart,\n    C3.ScriptsInEvents.EventSheet1_Event1_Act1,\n    C3.Plugins.Audio.Acts.AddRemoteURL,\n    C3.Plugins.video.Acts.SetSource2,\n    C3.Plugins.video.Acts.SetMuted,\n    C3.Plugins.Audio.Acts.PreloadByName,\n    C3.Plugins.video.Acts.Play,\n    C3.Plugins.Audio.Cnds.IsTagPlaying,\n    C3.Plugins.Audio.Acts.PlayByName,\n    C3.Plugins.System.Cnds.Compare,\n    C3.Plugins.video.Exps.PlaybackTime,\n    C3.Plugins.System.Cnds.TriggerOnce,\n    C3.Plugins.System.Cnds.Repeat,\n    C3.Plugins.System.Acts.Wait,\n    C3.Plugins.System.Exps.loopindex,\n    C3.Plugins.Audio.Acts.Play,\n    C3.Plugins.video.Acts.SetPlaybackTime,\n    C3.Plugins.video.Acts.Pause,\n    C3.Plugins.Sprite.Cnds.HasTags,\n    C3.Behaviors.Tween.Acts.TweenOneProperty,\n    C3.Plugins.video.Cnds.IsPaused,\n    C3.Plugins.Touch.Cnds.OnTouchObject,\n    C3.Plugins.System.Acts.SetVar,\n    C3.Plugins.System.Acts.WaitForPreviousActions,\n    C3.Plugins.System.Cnds.CompareVar,\n    C3.Plugins.TiledBg.Acts.SetY,\n    C3.Plugins.PlatformInfo.Cnds.IsOniOS,\n    C3.ScriptsInEvents.EventSheet1_Event63_Act1,\n    C3.ScriptsInEvents.EventSheet1_Event63_Act2,\n    C3.Plugins.PlatformInfo.Cnds.IsOnAndroid,\n    C3.ScriptsInEvents.EventSheet1_Event64_Act1,\n    C3.ScriptsInEvents.EventSheet1_Event64_Act2,\n    C3.ScriptsInEvents.EventSheet1_Event65_Act1,\n    C3.ScriptsInEvents.EventSheet1_Event65_Act2\n  ];\n};\nself.C3_JsPropNameTable = [\n  { All_Text: 0 },\n  { Tween: 0 },\n  { Hand: 0 },\n  { Audio: 0 },\n  { Video: 0 },\n  { Sine: 0 },\n  { circle: 0 },\n  { Touch: 0 },\n  { Attack: 0 },\n  { PlatformInfo: 0 },\n  { TiledBackground: 0 },\n  { Event: 0 },\n  { ios_url: 0 },\n  { android_url: 0 }\n];\nself.InstanceType = {\n  All_Text: class extends self.ITextInstance {\n  },\n  Hand: class extends self.ISpriteInstance {\n  },\n  Audio: class extends self.IInstance {\n  },\n  Video: class extends self.IWorldInstance {\n  },\n  circle: class extends self.ISpriteInstance {\n  },\n  Touch: class extends self.IInstance {\n  },\n  Attack: class extends self.ISpriteInstance {\n  },\n  PlatformInfo: class extends self.IInstance {\n  },\n  TiledBackground: class extends self.ITiledBackgroundInstance {\n  }\n};\n\n// file-map:scripts/project/main.js\nvar LibRuntime;\nrunOnStartup(async (runtime) => {\n  runtime.addEventListener(\"beforeprojectstart\", () => OnBeforeProjectStart(runtime));\n});\nasync function OnBeforeProjectStart(runtime) {\n  runtime.addEventListener(\"tick\", () => Tick(runtime));\n}\nfunction Tick(runtime) {\n  LibRuntime = runtime;\n}\nwindow.Game_Start = function() {\n  _firstinit(LibRuntime);\n};\nfunction _firstinit(runtime) {\n  runtime.goToLayout(\"game\");\n}\nwindow.Game_Close = function(runtime) {\n  console.log(\"game closed!\");\n};\nwindow.Audio_Callback = function(v) {\n  c3_callFunction(\"MasterVolume\", [v]);\n};\nwindow.Init_Game = function(ts) {\n  c3_callFunction(\"InitGame\", [ts]);\n};\nwindow.CTA_Clicked = function(phone) {\n  if (phone == \"android\") {\n    mraid.open(\"https://play.google.com/store/apps/details?id=com.gm_shaber.dayr\");\n  } else if (phone == \"ios\") {\n    mraid.open(\"https://apps.apple.com/de/app/day-r-survival-%C3%BCberleben-rpg/id1060470475\");\n  } else if (phone == \"web\") {\n    mraid.open(\"https://play.google.com/store/apps/details?id=com.gm_shaber.dayr\");\n  }\n};\n\n// file-map:scripts/project/scriptsInEvents.js\nvar scriptsInEvents = {\n  async EventSheet1_Event1_Act1(runtime, localVars) {\n    window.Game_Ready();\n  },\n  async EventSheet1_Event63_Act1(runtime, localVars) {\n    window.CTA_Clicked(\"ios\");\n  },\n  async EventSheet1_Event63_Act2(runtime, localVars) {\n    mraid.open(runtime.globalVars.ios_url);\n  },\n  async EventSheet1_Event64_Act1(runtime, localVars) {\n    window.CTA_Clicked(\"android\");\n  },\n  async EventSheet1_Event64_Act2(runtime, localVars) {\n    mraid.open(runtime.globalVars.android_url);\n  },\n  async EventSheet1_Event65_Act1(runtime, localVars) {\n    window.CTA_Clicked(\"android\");\n  },\n  async EventSheet1_Event65_Act2(runtime, localVars) {\n    mraid.open(runtime.globalVars.android_url);\n  }\n};\nself.C3.ScriptsInEvents = scriptsInEvents;\n"
	},
	"scripts/dispatchworker.js": {
		"type": "application/javascript",
		"str": "\"use strict\";self.inputPort=null,self.jobQueue=[],self.jobWorkers=[],self.sentBlobs=[],self.sentBuffers=[],self.importedScripts=[],self.lastBroadcasts=new Map;class JobWorker{constructor(e,s){this._port=e,this._number=s,this._isReady=!1,this._isBusy=!1,this._port.onmessage=e=>this._OnMessage(e.data)}ImportScripts(e){this._port.postMessage({\"type\":\"_import_scripts\",\"scripts\":e})}SendBlob(e,s){this._port.postMessage({\"type\":\"_send_blob\",\"blob\":e,\"id\":s})}SendBuffer(e,s){this._port.postMessage({\"type\":\"_send_buffer\",\"buffer\":e,\"id\":s})}SendJob(e){if(this._isBusy||!this._isReady)throw new Error(\"cannot take job\");this._isBusy=!0,this._port.postMessage(e,e[\"transferables\"])}_InitBroadcast(e){this._port.postMessage(e,e[\"transferables\"])}SendReady(){this._port.postMessage({\"type\":\"_ready\"})}IsReady(){return this._isReady}_OnReady(){this._isReady=!0,this.MaybeStartNextJob()}IsBusy(){return this._isBusy}GetNumber(){return this._number}_OnMessage(e){const s=e[\"type\"];switch(s){case\"ready\":return void this._OnReady();case\"done\":return void this._OnJobDone();default:return void console.error(\"unknown message from worker '\"+s+\"'\")}}_OnJobDone(){this._isBusy=!1,this.MaybeStartNextJob()}MaybeStartNextJob(){if(!this._isBusy&&this._isReady){const e=this._FindAvailableJob();if(-1!==e){const s=self.jobQueue[e],t=s[\"isBroadcast\"];(!t||(s[\"doneFlags\"][this._number]=!0,s[\"doneFlags\"].every(e=>e)))&&self.jobQueue.splice(e,1),this.SendJob(s)}}}_FindAvailableJob(){for(let e=0,s=self.jobQueue.length;e<s;++e){const t=self.jobQueue[e];if(!(\"number\"==typeof t[\"maxWorkerNum\"]&&this._number>=t[\"maxWorkerNum\"])&&(!t[\"isBroadcast\"]||this._number<t[\"doneFlags\"].length&&!t[\"doneFlags\"][this._number]))return e}return-1}}let number=0;function AddJobWorker(e){const s=new JobWorker(e,number++);self.jobWorkers.push(s);for(const[t,o]of self.sentBlobs)s.SendBlob(t,o);for(const[r,n]of self.sentBuffers)s.SendBuffer(r,n);for(const a of self.importedScripts)s.ImportScripts(a);for(const i of self.lastBroadcasts.values())s._InitBroadcast(i);s.SendReady()}function CancelJob(t){for(let e=0,s=self.jobQueue.length;e<s;++e)if(self.jobQueue[e].jobId===t)return void self.jobQueue.splice(e,1)}function OnInputPortMessage(e){const s=e.data,t=s[\"type\"];if(\"_cancel\"===t)CancelJob(s.jobId);else if(\"_import_scripts\"===t){const o=s[\"scripts\"];for(const r of self.jobWorkers)r.ImportScripts(o);void self.importedScripts.push(o)}else if(\"_send_blob\"===t){const n=s[\"blob\"],a=s[\"id\"];for(const i of self.jobWorkers)i.SendBlob(n,a);void self.sentBlobs.push([n,a])}else if(\"_send_buffer\"===t){const f=s[\"buffer\"],l=s[\"id\"];for(const u of self.jobWorkers)u.SendBuffer(f,l);void self.sentBuffers.push([f,l])}else if(\"_no_more_workers\"===t)self.sentBlobs.length=0,self.sentBuffers.length=0,self.importedScripts.length=0,self.lastBroadcasts.clear();else{if(self.jobQueue.push(s),s[\"isBroadcast\"]){const b=s[\"maxWorkerNum\"],d=self.jobWorkers.length,p=\"number\"==typeof b?Math.min(b,d):d,c=(s[\"doneFlags\"]=new Array(p).fill(!1),s[\"transferables\"]=[],s[\"params\"]&&s[\"params\"][\"broadcastKey\"]?s[\"params\"][\"broadcastKey\"]:s[\"type\"]);self.lastBroadcasts.delete(c),self.lastBroadcasts.set(c,s)}for(const _ of self.jobWorkers)_.MaybeStartNextJob()}}self.addEventListener(\"message\",e=>{const s=e.data,t=s[\"type\"];\"_init\"===t?(self.inputPort=s[\"in-port\"],self.inputPort.onmessage=OnInputPortMessage):\"_addJobWorker\"===t&&AddJobWorker(s[\"port\"])});"
	},
	"scripts/jobworker.js": {
		"type": "application/javascript",
		"str": "\"use strict\";function FlipImageData(e,t,s){const r=4*t,o=new Uint8Array(r),n=e.buffer;for(let e=0,t=Math.floor(s/2);e<t;++e){const a=s-e-1,l=new Uint8Array(n,e*r,r),f=new Uint8Array(n,a*r,r);o.set(l),l.set(f),f.set(o)}}function UnpremultiplyImageData(s){for(let e=0,t=s.length;e<t;e+=4){const r=s[e+3];if(255!==r){const o=255/r;s[e]*=o,s[e+1]*=o,s[e+2]*=o}}}function SendReady(){self.dispatchPort.postMessage({\"type\":\"ready\"}),self.outputPort.postMessage({\"type\":\"ready\"})}function SendError(e,t){e||self.outputPort.postMessage({\"type\":\"error\",\"jobId\":self.activeJobId,\"error\":t.toString()}),SendDone()}function SendResult(e,t){if(!e){const s=t.transferables||[];self.outputPort.postMessage({\"type\":\"result\",\"jobId\":self.activeJobId,\"result\":t.result},s)}SendDone()}function SendDone(){self.activeJobId=null,self.dispatchPort.postMessage({\"type\":\"done\"})}function SendProgress(e){self.outputPort.postMessage({\"type\":\"progress\",\"jobId\":self.activeJobId,\"progress\":e})}function OnDispatchWorkerMessage(t){const s=t.data,r=s[\"type\"];if(\"_import_scripts\"===r)importScripts(...s[\"scripts\"]);else if(\"_send_blob\"===r)self.sentBlobs.set(s[\"id\"],s[\"blob\"]);else if(\"_send_buffer\"===r)self.sentBuffers.set(s[\"id\"],s[\"buffer\"]);else if(\"_ready\"===r)SendReady();else{const o=s[\"jobId\"],n=s[\"isBroadcast\"],a=s[\"params\"];let e;if(self.activeJobId=o,self.JobHandlers.hasOwnProperty(r)){try{e=self.JobHandlers[r](a)}catch(t){return void SendError(n,\"Exception in job handler: \"+t)}e&&e.then?e.then(e=>SendResult(n,e)).catch(e=>SendError(n,\"Rejection in job handler: \"+e)):SendResult(n,e)}else console.error(`no handler for message type '${r}'`)}}self.dispatchPort=null,self.outputPort=null,self.workerNumber=-1,self.activeJobId=null,self.sentBlobs=new Map,self.sentBuffers=new Map,self.JobHandlers={},self.JobHandlers[\"ProcessImageData\"]=function(e){const t=e[\"buffer\"],s=new Uint8Array(t),r=e[\"width\"],o=e[\"height\"];return e[\"flipY\"]&&FlipImageData(s,r,o),e[\"unpremultiply\"]&&UnpremultiplyImageData(s),{result:t,transferables:[t]}},self.addEventListener(\"message\",e=>{const t=e.data,s=t[\"type\"];switch(s){case\"init\":return self.workerNumber=t[\"number\"],self.dispatchPort=t[\"dispatch-port\"],self.dispatchPort.onmessage=OnDispatchWorkerMessage,void(self.outputPort=t[\"output-port\"]);case\"terminate\":return void self.close();default:return void console.error(\"unknown message '\"+s+\"'\")}});"
	},
	"data.json": {
		"type": "application/json",
		"str": "{\"project\":[\"gamedevcorp\",\"Game\",[[[0,false,true,true,true,true,true,true,true,false,false,false,false,true,true,false,true,false,false,1,\"\"],[1,false,true,true,true,true,true,true,true,false,false,false,false,true,true,true,true,false,false,1,\"\"],[3,true,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,1,\"\"],[4,false,true,true,true,false,true,true,true,false,false,false,false,false,false,false,false,false,false,1,\"\"],[6,true,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,1,\"\"],[7,true,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,1,\"\"],[8,false,true,true,true,true,true,true,true,true,false,false,false,true,true,false,true,false,false,1,\"\"]],[[2,1,\"\"],[5,1,\"\"]]],[[\"All_Text\",0,false,[],0,0,null,null,[],false,false,800174320228188,[],null,0,null],[\"Hand\",1,false,[],1,0,null,[[\"Animation 1\",0,false,1,0,false,631399427738980,[[\"images/shared-0-lsheet1.webp\",3082,0,0,95,164,false,1,0.3473684210526316,0.036585365853658534,[],[],\"\"]]]],[[\"Tween\",2,544556132103797,1]],false,true,940492912810028,[],null,2,null],[\"Audio\",3,false,[],0,0,null,null,[],false,false,858122597038345,[],null,3,null,[0,0,false,0,true,1,1,600,600,10000,1]],[\"Video\",4,false,[],0,0,null,null,[],false,true,289376081640810,[],null,4,null],[\"circle\",1,false,[],2,0,null,[[\"Default\",30,true,1,0,false,576319155323466,[[\"images/shared-0-lsheet0.webp\",7722,0,0,481,481,false,1,0.5,0.5,[],[],\"\"]]]],[[\"Tween\",2,929901495640073,1],[\"Sine\",5,998348254950213,5]],false,true,519540228504908,[],null,6,null],[\"Touch\",6,false,[],0,0,null,null,[],false,false,857727281614089,[],null,7,null,[true]],[\"Attack\",1,false,[],2,0,null,[[\"Animation 1\",0,false,1,0,false,826670310021485,[[\"images/shared-0-sheet0.webp\",229764,0,0,1500,101,false,1,0.5,0.5,[],[-0.2625,-0.5,0.33359375,-0.4885057471264368,0.3427083333333333,-0.4386973180076628,0.2963541666666667,0.5,-0.29661458333333335,0.4808429118773946,-0.3065104166666667,-0.4885057471264368],\"\"]]]],[[\"Tween\",2,984798721644812,1],[\"Sine\",5,951695318510607,5]],false,true,933323816933607,[],null,8,null],[\"PlatformInfo\",7,false,[],0,0,null,null,[],false,false,249362415449281,[],null,9,null,[]],[\"TiledBackground\",8,false,[],0,0,[\"images/tiledbackground-sheet0.webp\",42,0,0,250,250,false],null,[],false,true,436008520106984,[],null,10,[1,1]]],[],[[\"Game\",1280,720,false,false,0.5,0.5,\"Event sheet 1\",168191085445968,[[\"Screen\",0,685176189318694,true,[255,255,255],true,1,1,1,false,false,1,0,true,[[[0,0,0,1280,720,0,0,[1,1,1,1],0,0,0,0,[],null,null,null,[\"\",\"\"]],3,29,[],[],[\"\",3,\"\",1,2,false,true],\"\"]],[],0,true,false,false,[]],[\"UI\",1,952270297827438,true,[255,255,255],true,0,0,1,false,false,1,0,true,[[[640,80,0,1500,101,0,0,[1,1,1,0],0.5,0.5,0,0,[],null,null,null,[\"\",\"\"]],6,4,[],[[true],[5,0,0.9,0,0,0,20,0,true]],[true,\"Animation 1\",0,true],\"\"],[[640,457,0,160,160,0,0,[1,1,1,0],0.5,0.5,0,0,[],null,null,null,[\"\",\"\"]],4,50,[],[[true],[5,0,0.9,0,0,0,20,0,true]],[true,\"Default\",0,true],\"Atack_1\"],[[836,283,0,240.5,240.5,0,0,[1,1,1,0],0.5,0.5,0,0,[],null,null,null,[\"\",\"\"]],4,3,[],[[true],[5,0,0.9,0,0,0,20,0,true]],[true,\"Default\",0,true],\"Next_Screen\"],[[806.1419849415485,105.98734178571323,0,110.37869906303483,110.37869906303483,0,0,[1,1,1,0],0.5,0.5,0,0,[],null,null,null,[\"\",\"\"]],4,5,[],[[true],[5,0,0.9,0,0,0,20,0,true]],[true,\"Default\",0,true],\"Last_Screen\"],[[844.1023709188922,260.4575823183323,0,123.34336873401651,212.92960497240747,0,5.982706979165492,[1,1,1,0],0.3473684210526316,0.036585365853658534,0,0,[],null,null,null,[\"\",\"\"]],1,55,[],[[true]],[true,\"Animation 1\",0,true],\"First_Scene\"],[[805.4646528445699,102.04760248181117,0,123.34336873401651,212.92960497240747,0,5.973929699293807,[1,1,1,0],0.3473684210526316,0.036585365853658534,0,0,[],null,null,null,[\"\",\"\"]],1,7,[],[[true]],[true,\"Animation 1\",0,true],\"Last_Screen\"],[[858.4260327427043,566.2771322933372,0,110.63000000000001,110.63000000000001,0,0,[1,1,1,0],0.5,0.5,0,0,[],null,null,null,[\"\",\"\"]],4,8,[],[[true],[5,0,0.9,0,0,0,20,0,true]],[true,\"Default\",0,true],\"Finish\"],[[858.6130192787258,504.3044341053992,0,123.34336873401651,212.92960497240747,0,5.971730420623852,[1,1,1,0],0.3473684210526316,0.036585365853658534,0,0,[],null,null,null,[\"\",\"\"]],1,9,[],[[true]],[true,\"Animation 1\",0,true],\"Finish\"],[[380,786,0,521,395,0,0,[1,1,1,1],0,0,0,0,[],null,null,null,[\"\",\"\"]],8,6,[],[],[true,0,1,1,0,0,1,1,0,false,1,1,1,0.1,0.1],\"\"]],[],0,true,false,false,[]]],[],[]]],[[\"Event sheet 1\",[[1,\"Event\",1,\"\",false,false,209302112381357,false,11],[1,\"ios_url\",1,\"https://apps.apple.com/de/app/day-r-survival-Ã¼berleben-rpg/id1060470475\",false,false,553735243795012,false,12],[1,\"android_url\",1,\"https://play.google.com/store/apps/details?id=com.gm_shaber.dayr\",false,false,308088595843537,false,13],[0,0,false,null,863546497167698,1,[[-1,9,null,1,false,false,false,824037935477194,null]],[[-3,10,[false,false,0]],[2,11,null,113236848661223,0,null,[[1,[0]],[1,[1]],[1,[2]]]],[2,11,null,627781255592493,0,null,[[1,[3]],[1,[1]],[1,[4]]]],[3,12,null,442788124822002,0,null,[[1,[5]],[3,4],[1,[5]],[3,4]]],[3,13,null,303777041753083,0,null,[[3,1]]],[2,14,null,367597618422579,2048,null,[[3,0],[1,[4]]]],[2,14,null,512836763729725,2048,null,[[3,1],[1,[2]]]],[3,15,null,832336874354375,0,null]],[[0,0,false,null,854378466177707,2,[[2,16,null,0,false,true,false,308405389880273,null,[[1,[6]]]]],[[2,17,null,679578561755780,0,null,[[3,1],[1,[2]],[3,0],[0,[7]],[0,[8]],[1,[6]]]]]]]],[0,0,false,null,462261184827846,3,[[-1,18,null,0,false,false,false,482680111048141,null,[[7,[9,[1,3,19,false]]],[8,5],[7,[10]]]]],[],[[0,0,false,null,288663699526209,4,[[-1,20,null,0,false,false,false,526830265978364,null]],[],[[0,0,false,null,233771062182004,5,[[-1,21,null,0,true,false,false,373738986545900,null,[[0,[11]]]]],[[-1,22,null,541460459503403,4096,null,[[0,[12,[4,23]]],[16,true]]],[2,24,null,583684578530576,0,null,[[2,[\"click\",false]],[3,0],[0,[8]],[0,[8]],[1,[13]]]]]]]]]],[0,0,false,null,415895610896010,6,[[-1,18,null,0,false,false,false,985625239465340,null,[[7,[9,[1,3,19,false]]],[8,5],[7,[14]]]]],[],[[0,0,false,null,549741137016151,7,[[-1,20,null,0,false,false,false,903214148287943,null]],[[2,24,null,977869480843931,0,null,[[2,[\"spell_heal\",false]],[3,0],[0,[8]],[0,[8]],[1,[13]]]]]]]],[0,0,true,null,916938050265719,8,[[-1,18,null,0,false,false,false,597355053979481,null,[[7,[9,[1,3,19,false]]],[8,5],[7,[15]]]]],[],[[0,0,false,null,228202393923724,9,[[-1,20,null,0,false,false,false,737691046376904,null]],[[2,24,null,460502711352364,0,null,[[2,[\"Pop\",false]],[3,0],[0,[8]],[0,[8]],[1,[13]]]]]]]],[0,0,true,null,844124048214855,10,[[-1,18,null,0,false,false,false,416054359118987,null,[[7,[9,[1,3,19,false]]],[8,5],[7,[16]]]]],[],[[0,0,false,null,172816336934914,11,[[-1,20,null,0,false,false,false,717790486595023,null]],[[2,24,null,806148640743704,0,null,[[2,[\"Pop\",false]],[3,0],[0,[8]],[0,[8]],[1,[13]]]]]]]],[0,0,false,null,122744186935779,12,[[-1,18,null,0,false,false,false,704446700916591,null,[[7,[9,[1,3,19,false]]],[8,5],[7,[17]]]]],[],[[0,0,false,null,483790465827495,13,[[-1,20,null,0,false,false,false,337810893684732,null]],[[3,25,null,492842062278317,0,null,[[0,[17]]]],[3,26,null,400633308045857,0,null]],[[0,0,false,null,888802618574836,14,[[1,27,null,0,false,false,false,395451358206930,null,[[1,[18]]]]],[[1,28,\"Tween\",212528567825532,2048,null,[[1,[13]],[3,5],[0,[19]],[0,[20]],[18,4],[3,0],[3,0],[3,0],[0,[21]]]]]],[0,0,false,null,412401293687876,15,[[4,27,null,0,false,false,false,133164828776667,null,[[1,[22]]]]],[[4,28,\"Tween\",680105308607999,2048,null,[[1,[13]],[3,5],[0,[19]],[0,[23]],[18,4],[3,0],[3,0],[3,0],[0,[21]]]]]]]],[0,0,false,null,864134450069533,16,[[3,29,null,0,false,false,false,610473480435837,null]],[],[[0,0,false,null,570504909313833,17,[[5,30,null,1,false,false,false,290003636063769,null,[[4,4],[3,0]]],[4,27,null,0,false,false,false,842584177579180,null,[[1,[22]]]]],[[3,15,null,376200247811512,0,null],[2,24,null,294808511054260,0,null,[[2,[\"click\",false]],[3,0],[0,[8]],[0,[8]],[1,[13]]]],[4,28,\"Tween\",342855623966175,2048,null,[[1,[13]],[3,5],[0,[8]],[0,[20]],[18,4],[3,1],[3,0],[3,0],[0,[21]]]]],[[0,0,false,null,941015217036728,18,[[1,27,null,0,false,false,false,779822860129004,null,[[1,[18]]]]],[[1,28,\"Tween\",121044956369754,2048,null,[[1,[13]],[3,5],[0,[8]],[0,[24]],[18,4],[3,0],[3,0],[3,0],[0,[21]]]]]]]]]]]],[0,0,false,null,429914245561170,19,[[-1,18,null,0,false,false,false,776750297929701,null,[[7,[9,[1,3,19,false]]],[8,5],[7,[25]]]]],[],[[0,0,false,null,668525691144718,20,[[-1,20,null,0,false,false,false,610289281286332,null]],[[-1,31,null,555480625710518,0,null,[[11,209302112381357],[7,[26]]]],[3,25,null,529242124248749,0,null,[[0,[25]]]],[3,26,null,233116810616046,0,null],[-1,32,null,819313616496529,4096,null]],[[0,0,false,null,938982287356024,21,[[4,27,null,0,false,false,false,133933210164140,null,[[1,[27]]]]],[[4,28,\"Tween\",468957352348673,2048,null,[[1,[13]],[3,5],[0,[19]],[0,[23]],[18,4],[3,0],[3,0],[3,0],[0,[21]]]],[6,28,\"Tween\",799041175986290,2048,null,[[1,[13]],[3,5],[0,[19]],[0,[23]],[18,4],[3,0],[3,0],[3,0],[0,[21]]]]]]]],[0,0,false,null,658732967418160,22,[[3,29,null,0,false,false,false,812321244815108,null]],[],[[0,0,false,null,910702308272444,23,[[5,30,null,1,false,false,false,934965223740977,null,[[4,4],[3,0]]],[4,27,null,0,false,false,false,846574375535790,null,[[1,[27]]]],[-1,33,null,0,false,false,false,110380350673680,null,[[11,209302112381357],[8,0],[7,[26]]]]],[[3,15,null,401935183503677,0,null],[2,24,null,540804316549750,0,null,[[2,[\"click\",false]],[3,0],[0,[8]],[0,[8]],[1,[13]]]],[-1,31,null,197350176471312,0,null,[[11,209302112381357],[7,[13]]]],[2,24,null,580435426379407,0,null,[[2,[\"craftgun\",false]],[3,0],[0,[8]],[0,[8]],[1,[13]]]],[4,28,\"Tween\",475354697609129,2048,null,[[1,[13]],[3,5],[0,[8]],[0,[23]],[18,4],[3,0],[3,0],[3,0],[0,[21]]]],[6,28,\"Tween\",121377081235619,2048,null,[[1,[13]],[3,5],[0,[8]],[0,[23]],[18,4],[3,0],[3,0],[3,0],[0,[21]]]]]]]]]],[0,0,false,null,562757847092280,24,[[-1,18,null,0,false,false,false,727218556295938,null,[[7,[9,[1,3,19,false]]],[8,5],[7,[28]]]]],[],[[0,0,false,null,498235535507589,25,[[-1,20,null,0,false,false,false,221952571426409,null]],[[2,24,null,357823497626827,0,null,[[2,[\"hit\",false]],[3,0],[0,[8]],[0,[8]],[1,[13]]]]]]]],[0,0,false,null,311432962337021,26,[[-1,18,null,0,false,false,false,383716118931805,null,[[7,[9,[1,3,19,false]]],[8,5],[7,[29]]]]],[],[[0,0,false,null,657822803363598,27,[[-1,20,null,0,false,false,false,330426464612429,null]],[[-1,31,null,862518111483704,0,null,[[11,209302112381357],[7,[30]]]],[3,25,null,446356752779809,0,null,[[0,[29]]]],[3,26,null,499414109765125,0,null],[-1,32,null,349167756512806,4096,null]],[[0,0,false,null,967606339823878,28,[[4,27,null,0,false,false,false,320235553231739,null,[[1,[27]]]]],[[4,28,\"Tween\",520246793814141,2048,null,[[1,[13]],[3,5],[0,[19]],[0,[23]],[18,4],[3,0],[3,0],[3,0],[0,[21]]]],[6,28,\"Tween\",129210190923512,2048,null,[[1,[13]],[3,5],[0,[19]],[0,[23]],[18,4],[3,0],[3,0],[3,0],[0,[21]]]]]]]],[0,0,false,null,705676851774419,29,[[3,29,null,0,false,false,false,916275726502970,null]],[],[[0,0,false,null,551156255588141,30,[[5,30,null,1,false,false,false,101299370597411,null,[[4,4],[3,0]]],[4,27,null,0,false,false,false,867463164511356,null,[[1,[27]]]],[-1,33,null,0,false,false,false,264284782936895,null,[[11,209302112381357],[8,0],[7,[30]]]]],[[3,15,null,160087787150923,0,null],[2,24,null,129626303806202,0,null,[[2,[\"click\",false]],[3,0],[0,[8]],[0,[8]],[1,[13]]]],[-1,31,null,680590120997236,0,null,[[11,209302112381357],[7,[13]]]],[2,24,null,627251716825941,0,null,[[2,[\"craftgun\",false]],[3,0],[0,[8]],[0,[8]],[1,[13]]]],[4,28,\"Tween\",280105007909984,2048,null,[[1,[13]],[3,5],[0,[8]],[0,[23]],[18,4],[3,1],[3,0],[3,0],[0,[21]]]],[6,28,\"Tween\",521640209736633,2048,null,[[1,[13]],[3,5],[0,[8]],[0,[23]],[18,4],[3,1],[3,0],[3,0],[0,[21]]]]]]]]]],[0,0,false,null,893984933029708,31,[[-1,18,null,0,false,false,false,834320642614134,null,[[7,[9,[1,3,19,false]]],[8,5],[7,[31]]]]],[],[[0,0,false,null,261662052193722,32,[[-1,20,null,0,false,false,false,200149717728313,null]],[],[[0,0,false,null,561323717222168,33,[[-1,21,null,0,true,false,false,553109128324417,null,[[0,[32]]]]],[[-1,22,null,144198563312348,4096,null,[[0,[12,[4,23]]],[16,true]]],[2,24,null,726182162766289,0,null,[[2,[\"click\",false]],[3,0],[0,[28]],[0,[8]],[1,[13]]]]]]]]]],[0,0,false,null,143554562034030,34,[[-1,18,null,0,false,false,false,510265619359312,null,[[7,[9,[1,3,19,false]]],[8,5],[7,[33]]]]],[],[[0,0,false,null,548837171355334,35,[[-1,20,null,0,false,false,false,696002945145766,null]],[[2,24,null,876713593765417,0,null,[[2,[\"Pop\",false]],[3,0],[0,[8]],[0,[8]],[1,[13]]]],[-1,31,null,910955210280182,0,null,[[11,209302112381357],[7,[34]]]],[3,25,null,444730515650949,0,null,[[0,[33]]]],[3,26,null,480753889136828,0,null],[-1,32,null,211144026497116,4096,null]],[[0,0,false,null,212418205475504,36,[[4,27,null,0,false,false,false,381115263561782,null,[[1,[35]]]]],[[4,28,\"Tween\",820547789008837,2048,null,[[1,[13]],[3,5],[0,[19]],[0,[23]],[18,4],[3,0],[3,0],[3,0],[0,[21]]]]]],[0,0,false,null,135385670672671,37,[[1,27,null,0,false,false,false,917479298903349,null,[[1,[35]]]]],[[1,28,\"Tween\",908955730947077,2048,null,[[1,[13]],[3,5],[0,[19]],[0,[23]],[18,4],[3,0],[3,0],[3,0],[0,[21]]]]]]]],[0,0,false,null,416714808763092,38,[[3,29,null,0,false,false,false,329709983418115,null]],[],[[0,0,false,null,456163925867395,39,[[5,30,null,1,false,false,false,470291120244219,null,[[4,4],[3,0]]],[4,27,null,0,false,false,false,533258060286193,null,[[1,[35]]]],[-1,33,null,0,false,false,false,795463561283730,null,[[11,209302112381357],[8,0],[7,[34]]]]],[[3,15,null,708610078976163,0,null],[2,24,null,341150898645304,0,null,[[2,[\"click\",false]],[3,0],[0,[8]],[0,[8]],[1,[13]]]],[-1,31,null,974109282408953,0,null,[[11,209302112381357],[7,[13]]]],[4,28,\"Tween\",683468880527586,2048,null,[[1,[13]],[3,5],[0,[8]],[0,[20]],[18,4],[3,1],[3,0],[3,0],[0,[21]]]]],[[0,0,false,null,786193177560858,40,[[1,27,null,0,false,false,false,642720925206005,null,[[1,[35]]]]],[[1,28,\"Tween\",299414832406254,2048,null,[[1,[13]],[3,5],[0,[8]],[0,[36]],[18,4],[3,1],[3,0],[3,0],[0,[21]]]]]]]]]]]],[0,0,false,null,490959177461759,41,[[-1,18,null,0,false,false,false,303589835942273,null,[[7,[9,[1,3,19,false]]],[8,5],[7,[37]]]]],[],[[0,0,false,null,237038383988971,42,[[-1,20,null,0,false,false,false,850465381619553,null]],[[2,24,null,632030560162813,0,null,[[2,[\"click\",false]],[3,0],[0,[8]],[0,[8]],[1,[13]]]]]]]],[0,0,false,null,660011842559356,43,[[-1,18,null,0,false,false,false,252522919370697,null,[[7,[9,[1,3,19,false]]],[8,5],[7,[38]]]]],[],[[0,0,false,null,693051307767575,44,[[-1,20,null,0,false,false,false,677140930563314,null]],[[2,24,null,809802201454047,0,null,[[2,[\"click\",false]],[3,0],[0,[8]],[0,[8]],[1,[13]]]]]]]],[0,0,false,null,356563220715852,45,[[-1,18,null,0,false,false,false,878122217552494,null,[[7,[9,[1,3,19,false]]],[8,5],[7,[39]]]]],[],[[0,0,false,null,839973598733537,46,[[-1,20,null,0,false,false,false,937521906907508,null]],[[2,24,null,119512578370880,0,null,[[2,[\"collect\",false]],[3,0],[0,[8]],[0,[8]],[1,[13]]]]]]]],[0,0,false,null,760811393420090,47,[[-1,18,null,0,false,false,false,206525969906728,null,[[7,[9,[1,3,19,false]]],[8,5],[7,[40]]]]],[],[[0,0,false,null,400581210123453,48,[[-1,20,null,0,false,false,false,475060644806677,null]],[[2,24,null,426147377207185,0,null,[[2,[\"[T]_Zoom - Simple_1\",false]],[3,0],[0,[8]],[0,[8]],[1,[13]]]]]]]],[0,0,false,null,798054630875571,49,[[-1,18,null,0,false,false,false,751071335395295,null,[[7,[9,[1,3,19,false]]],[8,5],[7,[41]]]]],[],[[0,0,false,null,261370188480343,50,[[-1,20,null,0,false,false,false,425832094252344,null]],[[-1,31,null,531455611369807,0,null,[[11,209302112381357],[7,[42]]]],[3,25,null,811912726021257,0,null,[[0,[41]]]],[3,26,null,990231620735673,0,null],[-1,32,null,474777009457761,4096,null]],[[0,0,false,null,280275462792158,51,[[4,27,null,0,false,false,false,757882347570818,null,[[1,[42]]]]],[[4,28,\"Tween\",796688202297808,2048,null,[[1,[13]],[3,5],[0,[19]],[0,[23]],[18,4],[3,0],[3,0],[3,0],[0,[21]]]]]],[0,0,false,null,887489335211940,52,[[1,27,null,0,false,false,false,186063089670666,null,[[1,[42]]]]],[[1,28,\"Tween\",727021705239003,2048,null,[[1,[13]],[3,5],[0,[19]],[0,[23]],[18,4],[3,0],[3,0],[3,0],[0,[21]]]]]]]],[0,0,false,null,114508062767340,53,[[3,29,null,0,false,false,false,595788650472846,null]],[],[[0,0,false,null,719375810182583,54,[[5,30,null,1,false,false,false,313555127239910,null,[[4,4],[3,0]]],[4,27,null,0,false,false,false,251708140156078,null,[[1,[42]]]],[-1,33,null,0,false,false,false,943713873545336,null,[[11,209302112381357],[8,0],[7,[42]]]]],[[3,15,null,111584926159631,0,null],[2,24,null,681713113750021,0,null,[[2,[\"click\",false]],[3,0],[0,[8]],[0,[8]],[1,[13]]]],[-1,31,null,899815251839401,0,null,[[11,209302112381357],[7,[13]]]],[4,28,\"Tween\",227279956892578,2048,null,[[1,[13]],[3,5],[0,[8]],[0,[20]],[18,4],[3,1],[3,0],[3,0],[0,[21]]]]],[[0,0,false,null,282826845933016,55,[[1,27,null,0,false,false,false,733172947200890,null,[[1,[42]]]]],[[1,28,\"Tween\",100328237573566,2048,null,[[1,[13]],[3,5],[0,[8]],[0,[36]],[18,4],[3,0],[3,0],[3,0],[0,[21]]]]]]]]]]]],[0,0,false,null,157940082513555,56,[[-1,18,null,0,false,false,false,885886324845511,null,[[7,[9,[1,3,19,false]]],[8,5],[7,[43]]]]],[],[[0,0,false,null,293135362225959,57,[[-1,20,null,0,false,false,false,511537916591788,null]],[[2,24,null,354137728053986,0,null,[[2,[\"click\",false]],[3,0],[0,[8]],[0,[8]],[1,[13]]]]]]]],[0,0,false,null,245399176730483,58,[[-1,18,null,0,false,false,false,376904997662796,null,[[7,[9,[1,3,19,false]]],[8,5],[7,[44]]]]],[],[[0,0,false,null,582858319821128,59,[[-1,20,null,0,false,false,false,914920824190763,null]],[[2,24,null,604294917025080,0,null,[[2,[\"click\",false]],[3,0],[0,[8]],[0,[8]],[1,[13]]]]]]]],[0,0,false,null,180174110151688,60,[[-1,18,null,0,false,false,false,468699581768793,null,[[7,[9,[1,3,19,false]]],[8,5],[7,[45]]]]],[[-1,31,null,454895492191565,0,null,[[11,209302112381357],[7,[46]]]]],[[0,0,false,null,238858680105812,61,[[-1,20,null,0,false,false,false,904174459614142,null]],[[2,24,null,565316865905497,0,null,[[2,[\"spell_heal\",false]],[3,0],[0,[8]],[0,[8]],[1,[13]]]],[8,34,null,582742185442224,0,null,[[0,[47]]]]]]]],[0,0,false,null,817428753120163,62,[[5,30,null,1,false,false,false,648451582354074,null,[[4,8],[3,0]]],[-1,33,null,0,false,false,false,846066511280159,null,[[11,209302112381357],[8,0],[7,[46]]]]],[[2,24,null,228644174993922,0,null,[[2,[\"click\",false]],[3,0],[0,[8]],[0,[8]],[1,[13]]]]],[[0,0,false,null,597265415179570,63,[[7,35,null,0,false,false,false,738974290815501,null]],[[-3,36,[false,false,0]],[-3,37,[false,false,1]]]],[0,0,false,null,308361684413019,64,[[7,38,null,0,false,false,false,184136072074195,null]],[[-3,39,[false,false,0]],[-3,40,[false,false,1]]]],[0,0,false,null,731945512162778,65,[[7,38,null,0,false,true,false,196625508108173,null],[7,35,null,0,false,true,false,465297741104740,null]],[[-3,41,[false,false,0]],[-3,42,[false,false,1]]]]]]]]],[[\"[T]_Zoom - Simple_1\",[[\"audio/webm; codecs=opus\",\".webm\",3814]],false],[\"spell_heal\",[[\"audio/webm; codecs=opus\",\".webm\",12976]],false],[\"Pop\",[[\"audio/webm; codecs=opus\",\".webm\",2321]],false],[\"click_2\",[[\"audio/webm; codecs=opus\",\".webm\",1785]],false],[\"click\",[[\"audio/webm; codecs=opus\",\".webm\",2845]],false],[\"craftgun\",[[\"audio/webm; codecs=opus\",\".webm\",4199]],false],[\"hit\",[[\"audio/webm; codecs=opus\",\".webm\",4549]],false],[\"collect\",[[\"audio/webm; codecs=opus\",\".webm\",18935]],false]],\"media/\",false,1280,720,4,false,\"trilinear\",false,\"1.0.0.0\",false,true,2,2,56,false,true,1,true,0.7853981633974483,[],\"icons/\",[],\"normalized\",\"hkiibupdhjq\",\"fonts/\",[[\"Timeline 1\",5,0.1,\"default\",\"default\",[],0,0,1,\"\",1,1]],\"high-performance\",[],1741996922231,\"vsync\",\"\",\"icons/loading-logo.png\",false,4,false,null,[],\"folders\",1,10000,false,[[\"Flowchart 1\",[]]],\"auto\"]}"
	},
	"media/[T]_Zoom - Simple_1.webm": "data:audio/webm; codecs=opus;base64,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",
	"media/spell_heal.webm": "data:audio/webm; codecs=opus;base64,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",
	"media/click_2.webm": "data:audio/webm; codecs=opus;base64,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",
	"media/Pop.webm": "data:audio/webm; codecs=opus;base64,GkXfowEAAAAAAAAfQoaBAUL3gQFC8oEEQvOBCEKChHdlYm1Ch4EEQoWBAhhTgGcBAAAAAAAI2hFNm3RAHU27i1OrhBVJqWZTrIHlTbuMU6uEFlSua1OsggEj7AEAAAAAAAC5AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmAQAAAAAAADIq17GDD0JATYCNTGF2ZjU3LjU2LjEwMFdBjUxhdmY1Ny41Ni4xMDBEiYhAerAAAAAAABZUrmsBAAAAAAAAYq4BAAAAAAAAWdeBAXPFgQGcgQAitZyDdW5khoZBX09QVVNWqoNjLqBWu4QExLQAg4EC4QEAAAAAAAARn4EBtYhA53AAAAAAAGJkgSBjopNPcHVzSGVhZAEBOAGAuwAAAAAAH0O2dQEAAAAAAAc954EAo/mBAACA+H3HtmyrvpCPVEGOrB8eUzxOPhSvf4D6sJMd9dATBTw2GKZiYhqni3pVrzV2MjKHlUUiP5waGGbukAGL614P2/tzGKl/h3f/+il9qYNyd+bQuY0e+EFookwg69lRa8KhyGUs+InEua4C1MdPRiMPlDQnm8RMo7uBABWA+FQkwaWqTGDnxW0KrO2lK7tGfnGg6bJonNUPc/+gSH2a4pwML/ua019sxyRx2dGQRFXZIJoD96PCgQApgPgElA1VuFTEOVn5hWMcXleGgq3IRQK6fElq0bhIzBpkT+b5bGB812m2DFUYHh+dfbKdAvAmXmpRPcazi75to8GBAD2A+ASpy/Tr1Yyi1V5KqQEvA9fwIZRRMjbBkA2evMKHxf66djV+XmL4L2FtWnQwN1uWztjpJakcsQvTX8/KjqPDgQBRgPgEXrUmwgm++mF7WbiAjuwkl0U50bR9xY9ceanDgOOX6FraktXqrzRqEgBv2pb7UBekElZQwl89bDBtLIkYn6PTgQBlgPhUXuC6ksgsTVTfLLUycfWe40JFj1LpFb7JbnnG9EkR/uoI6tQMp+kQsD3lu6KhNcajytRZAo2vgwKuJi/pBZH8bWFJ1aj+H+xE/2U0Yqej1YEAeYD4BEuMy+PP0wPNDZxVJCqOluLOvmj6VY3fMHfHa2uq7UYJipYCxkxKZSzAdDHXF5Ipk6vbb2uR0iRweM2mR/8q+x2FhuslHIp/MDX5uTzL7xSjzoEAjYD4JlYTuOhRC2Dm29GkKNWFXbkwDk989Fk7PfKz/YdGgCpMbhEjXlapmkLhE3E7YhHWXdGUizgWHr9P9H557KcX/KerSsgTZOSiTKPVgQChgPgkddL+dTK5VPQG61zwiu9QywFc+Pm7lGr9/PesS28HURQu+U7u7GHrBgdctevdPm++O5fB9hf6MmNd1Q3ctnHt/jUBhtrh3f+F4xv89GhjF6PdgQC1gPgsG0zH3u6wLZiy23rWengt3IpGivCfgUvYYj8mhBRtMzQ9PPxWaoiLVS5TCmciqdHyhCtKaR32HQFKU2MmOmeO7zPGtgl/nOxAy7EkGq1upZvgncQPXDxCo9eBAMmA+KuVRy0zUk8j07X6brp9h48qyxZjE532mUECtY2DpS5ZcSBCze77r1sl2G7CUOYY2msvEFlO1seSG614ymEpnYt3aJsB9c5xJds+B9oYleWjXpujz4EA3YD4LEehTlK6029RCgaQ3wU/iKJFWGlv2EYea8ZLM8AKxZre3MDNvpBfeopqn3tS5FPleGK2NTLvUYnDBCquOhUkP/jauVUjNHqOvDqj14EA8YD4IS0agOOerW9JEo9A2IBm9r/MyAv4VT7LXwcQJzPc5drk/VB9C2pPLFMNiUr6qcVsD5t+ugHAFo3ifdFCy7m/Ppq6P4bArUVwFoIWSrbE9kyanqPOgQEFgPhB3vX17lvVKkdkUdopYIrQcEviFR4l6ue8NqUYnh1F0xSB4uP5hlZvBc/G8LbLX/GTA6rdNEDSIUbLb6/GX3krrMUd9rzOuP9vo0CBgQEZgPh10BweiHZgyhISYSjxordWUSn/PXCEO4ulEnffhzIZ+j5B+KhVM2nB8X9Xl7qFXX2gyuQrygG6pqGAi0EOZLKM3ql/vHAkbVqeM46fo4vVBXo16zl5i4L7keccOC2AcLkjyhqcyHV9ArhlVwksy+/HRo9iYDcHviR7IJ/Io8aBAS2A+IWr3Ml9ZzD/YsRoRCrejDOlzsCLnjfwQwsF/TDzOHDvzUZcZs4r1h4swx2lxtNyCdG7V8jjI+CP2y8HphvbvTxAo8aBAUGA+IWur9uLSE/HcMHF01v7WqtpNIY5Q12ALjDVUA9iDilNdBiuswl2btt1iaC6cVsPOVORvpAWUK+Mam6ITvB/UgPAo7mBAVWA+IVbiqXxm1GA1+Hvul6d3uBF2WZ05WwFe6tcTKHWRKwWlCGQvVc/m3YzDIDx57QCgsp94kCjuIEBaYD4haV68HfHwujtwFrk1up6wL4v6ga4r0cFFjR/5vMGLRAFn3WA2LdRx7TwY04FutLXmP7ao7mBAX2A+LF8NTVhyv7lOch5juLyj6VekfvXJfSlpjM44QISQDyxaHMFID2clGsQYDdh23Xb9LoN3UKjuYEBkYD4nFqvZWw5U9aygheuc50kA7hgkuDeMovUvOMknGxpIMX48+WXc73ONHX3apFZtkk0PKWUsqABAAAAAAAAqaFAn4EBpQD4iiQD9K6Gd7kye2sTys1ZRkUf4vmMVdGqes0np1DtxAwWXMw2/R7gozd1Tkj/oKitQZOc84XSJL9fXAJ3M9SsHVYIYeuIo5+Uz2lzL3jDfjrDL5JSp7WAz/nTwHE9yBc/sUZYOfJNfOoHXULrGzPK1hQL0B9AMTLB0oX5fKjFLflu+zwNAPVEgqqVXYhWWxjtlPhlVS+L+GRlUHWihADOoSM=",
	"media/click.webm": "data:audio/webm; codecs=opus;base64,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",
	"media/craftgun.webm": "data:audio/webm; codecs=opus;base64,GkXfowEAAAAAAAAfQoaBAUL3gQFC8oEEQvOBCEKChHdlYm1Ch4EEQoWBAhhTgGcBAAAAAAAQMBFNm3RAHU27i1OrhBVJqWZTrIHlTbuMU6uEFlSua1OsggEj7AEAAAAAAAC5AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmAQAAAAAAADIq17GDD0JATYCNTGF2ZjU3LjU2LjEwMFdBjUxhdmY1Ny41Ni4xMDBEiYhAj4AAAAAAABZUrmsBAAAAAAAAYq4BAAAAAAAAWdeBAXPFgQGcgQAitZyDdW5khoZBX09QVVNWqoNjLqBWu4QExLQAg4EC4QEAAAAAAAARn4ECtYhA53AAAAAAAGJkgSBjopNPcHVzSGVhZAECOAGAuwAAAAAAH0O2dQEAAAAAAA6T54EAo0CmgQAAgPx/clGrTxQZansnwm/ID/zikj5cnbJ2kqwj/f980BdO/vKPcxP3EyUsgAUrDwdqK+ARGc8D6YQKQMUlyW97dTPjI+tkDM29POWYjdOeRXtweNrXrlhkkWbTQVn1HstrogurPfBQ0/Rsk8k+a27bwAUlzg3LCCRATRBib0WCC0oXz7Kc50+du2OIx9rk+lKgz6NFmXzxP9lEgWkr0H/uNmaIiKPSgQAVgPxe3FXJIC6kPq0riuX9WiqAx6wAUkyveorg5airwBiuFmD3890SnyKth6Bv4uuR+5yTx4lLQ/2kf/fVnzGGZHCsJlTLm6j2wBVrz/0TDaPYgQApgPxTu/p7nqvaWiSzOYGMldBkfgjZ5klXa0EzhHih4U6jUnx6qzH0mXZria1QUx5nDxmEx+D6wUi6fTuY8Gn+eRJRt3myPsJVUJXElihMFnw8wMdEb6PkgQA9gPxe1D2D2vFKCNeIzUUr+pg3AhwKwPTVU4MKeFyumH+TItMN/82hMSaS7KaxnQEI0LnK4i2KympVq1psy8HpC89/nmsSY0oCjEQuiQFCnaXk6Gli5Mq21jPw9qHPBUkQGaPigQBRgPxbZaOPtjf/NdefZfew9YkyGhY2CYa17szwU6LHnzQAxTIeuE0kCPqe87VBS1TKwkJaDOpJEglRx1kzaEnQwR66KdzfZ24m5JXY/eJkbG8z0HtG24uA/wpUfxQPviGj4YEAZYD8Xt7JoOk+UokJrjxeJfPV03hKbwxEAvI84PAd3wnQe3tPiC2nY/waAdT5Ry5MrZRZalOBQAlfBQV8qPtEEQf7IvT7W2l7BlZtYB4i4NTwchrLGJMq/WuCkwPvGxOj1oEAeYD8QfIYDIqRO4W4lqGmQE92SN3NoznHN1CfFuQf8tTIRTpF0hhYjndIt+ubEjTC7pjb+oQ6/U6mfaOAVsDgwZhnqhkfA2KlP4xjfPA1r17Ah2nCo9uBAI2A/FO8ALaAIJVEgPqhdzhtr42pHpE6baamtRkYDsncAwmC+ag63Nt0cAmVsoQSUVLZGR0zfXU6KWqqWfK6S2yg7JInPb2KKlKVeMKae/+xQFTWqUDwRG4Fo96BAKGA/EPrJDzBXerTBjf+uVp0cpkdW2iAhfIa+BQyjxgsA+Ic8yUbvs+Uu0F5/NCSoYUs5h3zOF0AQrA13QQ+eJawjgTeTfDBeL/Djq1eoIBbz5OaIdzVVpsPAt3Uo9+BALWA/FQJK7ouTjJCY1wW0tVfXYxD4AzQWCb5dhdfGlomM2L8v0KBMVyMhpX9O/DjQWs34G1uV9tSpX7Bi9U0sTa/227IqLf6XM0yQcZ27TU2Ld51qlz0AD/B/s3nsKPggQDJgPxTu/nqa4gsgu/dyfoikmieFlaxWYK+oaZ8vXMC4kuXuVAQ8D2CBqN4c4hkftx3MtiQsDkmOd0SO3leonKwPZxl3iKG6R1aMqZM4xq+GnTDlFDlewwAQwBYO6SSo9uBAN2A/FtiFE638nKKkKR/SNHV7YbjYtDpQ7FOo88IPyW60BToVhiAd0tLoEtjrC6o50S1LeQHSdZG8WAQnvMRf2yIlJ/7uEt35JLgDCTJ4ifalzTw9Q0gKjN3o/6BAPGA/H3aO42fqeYJmRv56dmpidnmazAQXH0CrVFwnkxWxwPEYvWaVgA5a4jEp4AOlNrkRPv1nha8wWXa7YEZ2JTzs0OPpWUdEsYLLQ6UsNM/bBj7jvXadbN+zcKrPI8XBFIiDxUgrh1jueHHahif1TAu4zunNBaRQAxj/9SjzYEBBYD8Xa9t20l8eXQZD/ixanTvjUgm/wuJwPmF7+AXmPU3JRzG/4TztCI1f4gvBQEOn3pkJAMjN8HSJ90JD1kF76Ckrd/DpVr1PJP8o8uBARmA/DaLRwGUHqLuQIqg2E/3nL+6K8hSLaLHHu1o06M7qF/kPG6lVF9lcBLdzPhpJH/i8/pJRVDxQD/wa1JIPE30Ul5ZofrHv5mj2oEBLYD8TRPCav1ZOnQvDA28ikudLW61MHvGAziHHy59ofjZzNyH60Xb/wVKghLrIa4Xt876KSEq/MoC9Np46/RKiLDyVpg1P/P10hC1yi7p/bjbll+mwJDsR6PTgQFBgPwChN/QrArkgoPvtmBfNQibjDgb6jQAY4OcptvaIEUxLLTXyl4hJduu9d4k3I4SrHSwxmSsGynfuo+c+5tcQCJOcXfpflnJAkcsE+TGUkmj0YEBVYD8TTBY4JRRx7f+GZy86k+FEVQwxbAJ4utAdHfCbsrqI8ncocqCSggC/JZYbj9a0hI8FttBhr8rViXekHEL4sQvrExQ/lGMEJMK/wB/rqPKgQFpgPwxpMphc5wHcbAAzj3rF4RjTWt4vBhIAslTnyb/MiG+l7DKCOnG6xkWUDfC1bjTTCRThe9+Wp6T81WksHUSpyMVqgvDGi+jyYEBfYD8TTJIw3F6LBPPhfQwWmqpKBf4ip33/HAEoMGBEqS8PcpQGO9HDMP7LnNxhMXDp09qKfihg0RXWowTC23sdvM/r6/D4w+jxoEBkYD8LgyUXYNTP3/8xRhiR2Fk6Zz0Vm968wYd4UL8w1KuaAU+nOKYa5nogYCF84OY+ohZzLhhpl0tlEmCxbzEpZRTog2jx4EBpYD8TK6VeT+SJ+AiF0/oRIVVPi7nS01oZ/z8tnZ/QUBIf7VjT4RxBeCb/0yyJYFQBY9cGT9Z57dbtrheUW3YMFavMFTyo8SBAbmA/C9L6SLUstp9AftaZk76SkFrpXj5A/JG9ydiFkvkUbUR2sJ0w/jLDpFLg6Vp4j5fGITT/P0zcLQHcLwB+/DSt6PDgQHNgPxNKJNGn5vfiA73sSdxvb/wpHiflzq2Ls+BFTmiXpKAjeG65UjmVnJuVR0ss7CE5RZSoQHU9RUy9LPrBg99rKO9gQHhgPw1Q5Oj3FNLIZqyOKBAMooCAH7jGTlVsd2JGXQybW6GQREnVhQwH3JKuDuzg0dHvn6vWEGnCcAoLaO4gQH1gPwCC6EarXl9av/3SK3CYuOcH5+yz/jpOhimUF+w+AvobtjJ0E7Wt9KBkbnEWGZKIXDQ/LGjt4ECCYD8LxyjALvG1PV+S0OIFWa+expMIVmJfG9lzsjuuU4UQu4wmDn1oV0LDNDdJm4KbpT+bIajsoECHYD8AQzbgY/R8wY6FDx6IABDeptFgyMZbaHr70txtFg8BG+x/lqGWMHCjTx2H8M/o7mBAjGA/BgT1xHqlNXfcnAs8ps4qC0MdDkMZRNnZm5SJUjIjtiLSKJze/xjvsAYecB8xlyLWDk8t7ujtYECRYD8BnYDLZ9Vx1tkb+B9F8NlKeyA8bPsu36SMQOm25zbeSYDBHnYcdOsikXU6Wac9IEVo7KBAlmA/AAVbrDPSqlUNiAoSLkzdLlaqCBvHZ4UmcosS55X+pj348wqs1o0c/AI9MuRQ6OxgQJtgPwXM02PyPXGC8ZOt50chMxT2Cf1+51eK6ikQkORjfM/vlnyCWRAkNOHbA5fo6O0gQKBgPwwr4mhhGoXKwfJKeK7Lg6y1UpKDkQcC5HpwyycHO+rbmh5DJ4o/+G3SaxzAD5guKOsgQKVgPwGS0XNYAzzKFuoepd6BgjvjrNwmuaxZ3fxhhsPTrA3BqpPPsvfwNWjsoECqYD8Ak5b2QNw7KDvPN65XfEnw8hyE3/NoMYkGhJIJ+6ZUieV+XHXOHr5kgsnPw62o7CBAr2A/BZZWNkNzXR/t2rquUMdY034rDS78XwoKuhu99ows4KOEoydugmkGOVHM7yjr4EC0YD8EoMALk/yua5wTUaPXtW9B4BYZ7J2oF+sAg+uEeh6yteYlmRsl6OO2g/Zo62BAuWA/AP3ZtVBoy41KYR6JBu2RZRJ8pcfOl5/e2WHc2CshHDcgTkdADSwID6jtYEC+YD8QmjU1MWYSnbeOBcNioMYKowLMmZt08ZcPYThk8L3lcmvIQcvqtTf4az1k87fKxwzo66BAw2A/BCkp2HBd8nUl7AzCAwtXt3Tv7pfzqirvTdsSjMWMlphKXAAshYQTJwho62BAyGA/AFIImR3OFv68mFuujJpWzIE/q1aL7XytoV0B1Th04TuRaxQ8/Uw49ujs4EDNYD8E7vPE7nZhpROfaVL12Sg7vOOTqajjyV3Jf0B8Fi5jza+6JloqizMTKsv8kjDt6OwgQNJgPwVfcM3l33rFi0v77P05xxWToFTqGdxYzMJSHikhBrNcmLxoHQdR3Fv4883o62BA12A/AGEdqI4f5294uSx/lAeoq7UFkxMd+pA83bSAxGBS+905Ny8Or3AhMyjsIEDcYD8BEFV9bABt5T+dLw1rn4/LvEJhUFdpuirurJFH0261VHJHlcww3K0eDvwZqO0gQOFgPyB/B14peMmhxV6OmuvW2kI3yNOjEw/MblUR8vjrC689AwL1uD0WSDG7uVv2wlmNqOygQOZgPxBofFsCoW6R61B2/dVENqLXf9MK8LDDD8JhU4qmQQ7XwEOfuo6JPatww//N+ijtoEDrYD8QgJ1wBeU6yInqxyjPJhcRA+GfTdmJ/4Bw+JB06T+RwsTXR+WOYIxKc+0K/sRAKjcKKOygQPBgPxUEDWuxzBWQBgPeEH18gCclVotKx+R2oFCVnOfIhhwCdFtpLNXD+vMrfiIflujtoED1YD8Wym1DK0cWMnAlN6aGWjw+AF8o8W1a3Amu+wq4Jl/xej2XkHnAhFqeBQ2wM/HMZ7DNqABAAAAAAAApqFAnIED6QD8e/ZZphUWWxMGlrU9KRKxIIr8XXHIeF4SfqfupoLGVYMdvETE9V7hPHTmltVC8yFLHIZfL5NbNy8ruZPhYxJMDSi281RzyhLKS1Ga61EaLh1y7tRQPJ4cKRI9KGt8up3MA11NGPWNY7NEhjTI7Pry4wAYwaD22DR9NejJU5xw4M1CMD9wbkAXOrqkkAMHS5jj62StjoFfUnWihADN/mA=",
	"media/hit.webm": "data:audio/webm; codecs=opus;base64,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",
	"media/collect.webm": "data:audio/webm; codecs=opus;base64,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",
	"images/shared-0-lsheet1.webp": "data:image/webp;base64,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",
	"images/tiledbackground-sheet0.webp": "data:image/webp;base64,UklGRiIAAABXRUJQVlA4TBUAAAAv+UA+EAcQEREAUKT//ymi/6n/fwYA",
	"images/shared-0-lsheet0.webp": "data:image/webp;base64,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",
	"images/shared-0-sheet0.webp": "data:image/webp;base64,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"
};
</script>
<script>
"use strict";!function(){let p=!0,r=new class{#prop="pass";getProp(){return this.#prop}};(p="pass"!==r.getProp()?!1:p)&&(window["C3_ModernJSSupport_OK"]=!0)}();
</script>
<script>
"use strict";!function(){var e,t,r,n,o=!!document.querySelector('script[src*="kaspersky"]'),s=[];document.createElement("canvas").getContext("webgl")||s.push("WebGL"),"undefined"==typeof WebAssembly&&s.push("WebAssembly"),"noModule"in HTMLScriptElement.prototype||s.push("JavaScript Modules"),window["Intl"]&&window["Intl"]["Segmenter"]||s.push("Internationalization support (Intl.Segmenter)"),window["C3_ModernJSSupport_OK"]||s.push("Modern JavaScript support"),0!==s.length||o?((e=document.createElement("div")).id="notSupportedWrap",document.body.appendChild(e),(t=document.createElement("h2")).id="notSupportedTitle",t.textContent=o?"Kaspersky Internet Security broke this export":"Software update needed",e.appendChild(t),(t=document.createElement("p")).className="notSupportedMessage",r="This content is not supported because your device's software appears to be out-of-date. ",n=navigator.userAgent,/android/i.test(n)?r+='<br><br>On Android, fix this by making sure the <a href="https://play.google.com/store/apps/details?id=com.google.android.webview">Android System Webview</a> app has updates enabled and is up-to-date.':/iphone|ipad|ipod/i.test(n)?r+="Alternatively if <strong>Lockdown mode</strong> is enabled, try turning it off to view this content.":/msie/i.test(n)||/trident/i.test(n)||/edge\//i.test(n)?r+="<br><br>Note: <strong>Internet Explorer</strong> and the <strong>legacy Edge browser</strong> are not supported. Try using <a href='https://www.google.com/chrome'>Chrome</a> or <a href='https://www.mozilla.org/firefox'>Firefox</a> instead.":o?r="It appears a script was added to this export by Kaspersky software. This prevents the exported project from working. Try disabling Kaspersky and exporting again.":r+="Try installing any available software updates. Alternatively try on a different device.",r+="<br><br><em>Missing features: "+s.join(", ")+"<br>User agent: "+navigator.userAgent+"</em>",t.innerHTML=r,e.appendChild(t),document.addEventListener("deviceready",()=>{navigator["splashscreen"]&&navigator["splashscreen"]["hide"]&&navigator["splashscreen"]["hide"]()})):window["C3_Is_Supported"]=!0}();
</script>
<script>
// Generated by Construct, the game and animation creation tool
// Visit: https://www.construct.net

// Generated by Construct, the game and animation creation tool
// Visit: https://www.construct.net

// workers/domHandler.js
"use strict";window.DOMHandler=class{constructor(t,i){this._iRuntime=t,this._componentId=i,this._hasTickCallback=!1,this._tickCallback=()=>this.Tick()}Attach(){}PostToRuntime(t,i,e,s){this._iRuntime.PostToRuntimeComponent(this._componentId,t,i,e,s)}PostToRuntimeAsync(t,i,e,s){return this._iRuntime.PostToRuntimeComponentAsync(this._componentId,t,i,e,s)}_PostToRuntimeMaybeSync(t,i,e){this._iRuntime.UsesWorker()?this.PostToRuntime(t,i,e):this._iRuntime._GetLocalRuntime()["_OnMessageFromDOM"]({"type":"event","component":this._componentId,"handler":t,"dispatchOpts":e||null,"data":i,"responseId":null})}AddRuntimeMessageHandler(t,i){this._iRuntime.AddRuntimeComponentMessageHandler(this._componentId,t,i)}AddRuntimeMessageHandlers(t){for(const[i,e]of t)this.AddRuntimeMessageHandler(i,e)}GetRuntimeInterface(){return this._iRuntime}GetComponentID(){return this._componentId}_StartTicking(){this._hasTickCallback||(this._iRuntime._AddRAFCallback(this._tickCallback),this._hasTickCallback=!0)}_StopTicking(){this._hasTickCallback&&(this._iRuntime._RemoveRAFCallback(this._tickCallback),this._hasTickCallback=!1)}Tick(){}},window.RateLimiter=class{constructor(t,i){this._callback=t,this._interval=i,this._timerId=-1,this._lastCallTime=-1/0,this._timerCallFunc=()=>this._OnTimer(),this._ignoreReset=!1,this._canRunImmediate=!1}SetCanRunImmediate(t){this._canRunImmediate=!!t}Call(){if(-1===this._timerId){const t=Date.now(),i=t-this._lastCallTime,e=this._interval;e<=i&&this._canRunImmediate?(this._lastCallTime=t,this._RunCallback()):this._timerId=self.setTimeout(this._timerCallFunc,Math.max(e-i,4))}}_RunCallback(){this._ignoreReset=!0,this._callback(),this._ignoreReset=!1}Reset(){this._ignoreReset||(this._CancelTimer(),this._lastCallTime=Date.now())}_OnTimer(){this._timerId=-1,this._lastCallTime=Date.now(),this._RunCallback()}_CancelTimer(){-1!==this._timerId&&(self.clearTimeout(this._timerId),this._timerId=-1)}Release(){this._CancelTimer(),this._callback=null,this._timerCallFunc=null}};

// workers/domElementHandler.js
"use strict";{class a{constructor(e){this._elem=e,this._hadFirstUpdate=!1,this._isVisibleFlag=!0,this._wantHtmlIndex=-1,this._actualHtmlIndex=-1,this._htmlZIndex=-1}SetVisibleFlag(e){this._isVisibleFlag=!!e}GetVisibleFlag(){return this._isVisibleFlag}HadFirstUpdate(){return this._hadFirstUpdate}SetHadFirstUpdate(){this._hadFirstUpdate=!0}GetWantHTMLIndex(){return this._wantHtmlIndex}SetWantHTMLIndex(e){this._wantHtmlIndex=e}GetActualHTMLIndex(){return this._actualHtmlIndex}SetActualHTMLIndex(e){this._actualHtmlIndex=e}SetHTMLZIndex(e){this._htmlZIndex=e}GetHTMLZIndex(){return this._htmlZIndex}GetElement(){return this._elem}}window.DOMElementHandler=class extends self.DOMHandler{constructor(e,t){super(e,t),this._elementMap=new Map,this._autoAttach=!0,this.AddRuntimeMessageHandlers([["create",e=>this._OnCreate(e)],["destroy",e=>this._OnDestroy(e)],["set-visible",e=>this._OnSetVisible(e)],["update-position",e=>this._OnUpdatePosition(e)],["update-state",e=>this._OnUpdateState(e)],["focus",e=>this._OnSetFocus(e)],["set-css-style",e=>this._OnSetCssStyle(e)],["set-attribute",e=>this._OnSetAttribute(e)],["remove-attribute",e=>this._OnRemoveAttribute(e)]]),this.AddDOMElementMessageHandler("get-element",e=>e)}SetAutoAttach(e){this._autoAttach=!!e}AddDOMElementMessageHandler(e,s){this.AddRuntimeMessageHandler(e,e=>{const t=e["elementId"],n=this.GetElementById(t);return s(n,e)})}AddDOMElementMessageHandlers(e){for(const[t,n]of e)this.AddDOMElementMessageHandler(t,n)}_OnCreate(e){const t=e["elementId"],n=this.CreateElement(t,e),s=new a(n),i=(this._elementMap.set(t,s),n.style.boxSizing="border-box",n.style.display="none",s.SetVisibleFlag(e["isVisible"]),this._GetFocusElement(n)),l=(i.addEventListener("focus",e=>this._OnFocus(t)),i.addEventListener("blur",e=>this._OnBlur(t)),e["htmlIndex"]);if(s.SetWantHTMLIndex(l),s.SetHTMLZIndex(e["htmlZIndex"]),this._autoAttach){const d=this.GetRuntimeInterface().GetAvailableHTMLIndex(l),r=(s.SetActualHTMLIndex(d),this.GetRuntimeInterface().GetHTMLWrapElement(d));r.appendChild(n)}}CreateElement(e,t){throw new Error("required override")}DestroyElement(e){}_OnDestroy(e){const t=e["elementId"],n=this.GetElementById(t);this.DestroyElement(n),this._autoAttach&&n.parentElement.removeChild(n),this._elementMap.delete(t)}PostToRuntimeElement(e,t,n){(n=n||{})["elementId"]=t,this.PostToRuntime(e,n)}_PostToRuntimeElementMaybeSync(e,t,n){(n=n||{})["elementId"]=t,this._PostToRuntimeMaybeSync(e,n)}_OnSetVisible(e){if(this._autoAttach){const t=this._elementMap.get(e["elementId"]),n=t.GetElement();t.HadFirstUpdate()?n.style.display=e["isVisible"]?"":"none":t.SetVisibleFlag(e["isVisible"])}}_OnUpdatePosition(e){if(this._autoAttach){const t=this._elementMap.get(e["elementId"]),n=t.GetElement(),s=this.GetRuntimeInterface(),i=(n.style.left=e["left"]+"px",n.style.top=e["top"]+"px",n.style.width=e["width"]+"px",n.style.height=e["height"]+"px",e["fontSize"]),l=(null!==i&&(n.style.fontSize=i+"em"),e["htmlIndex"]),a=(t.SetWantHTMLIndex(l),s.GetAvailableHTMLIndex(l));if(a!==t.GetActualHTMLIndex()){n.remove();const r=s.GetHTMLWrapElement(a);r.appendChild(n),t.SetActualHTMLIndex(a),s._UpdateHTMLElementsZOrder()}const d=e["htmlZIndex"];d!==t.GetHTMLZIndex()&&(t.SetHTMLZIndex(d),s._UpdateHTMLElementsZOrder()),t.HadFirstUpdate()||(t.SetHadFirstUpdate(),t.GetVisibleFlag()&&(n.style.display=""))}}_OnHTMLLayersChanged(){if(this._autoAttach)for(const e of this._elementMap.values()){const t=this.GetRuntimeInterface().GetAvailableHTMLIndex(e.GetWantHTMLIndex()),n=e.GetActualHTMLIndex();if(-1!==t&&-1!==n&&t!==n){const s=e.GetElement(),i=(s.remove(),this.GetRuntimeInterface().GetHTMLWrapElement(t));i.appendChild(s),e.SetActualHTMLIndex(t)}}}_GetAllElementStatesForZOrderUpdate(){return this._autoAttach?[...this._elementMap.values()]:null}_OnUpdateState(e){const t=this.GetElementById(e["elementId"]);this.UpdateState(t,e)}UpdateState(e,t){throw new Error("required override")}_GetFocusElement(e){return e}_OnFocus(e){this.PostToRuntimeElement("elem-focused",e)}_OnBlur(e){this.PostToRuntimeElement("elem-blurred",e)}_OnSetFocus(e){const t=this._GetFocusElement(this.GetElementById(e["elementId"]));e["focus"]?t.focus():t.blur()}_OnSetCssStyle(e){const t=this.GetElementById(e["elementId"]),n=e["prop"],s=e["val"];n.startsWith("--")?t.style.setProperty(n,s):t.style[n]=s}_OnSetAttribute(e){const t=this.GetElementById(e["elementId"]);t.setAttribute(e["name"],e["val"])}_OnRemoveAttribute(e){const t=this.GetElementById(e["elementId"]);t.removeAttribute(e["name"])}GetElementById(e){const t=this._elementMap.get(e);if(t)return t.GetElement();throw new Error("no element with id "+e)}}}

// workers/domSide.js
"use strict";{const a=/(iphone|ipod|ipad|macos|macintosh|mac os x)/i.test(navigator.userAgent),b=/android/i.test(navigator.userAgent),c=/safari/i.test(navigator.userAgent)&&!/(chrome|chromium|edg\/|OPR\/|nwjs)/i.test(navigator.userAgent);let d=0;function AddScript(s){const r=document.createElement("script");return r.async=!1,r.type="module",s.isStringSrc?new Promise(e=>{const t="c3_resolve_"+d;++d,self[t]=e,r.textContent=s.str+`

self["${t}"]();`,document.head.appendChild(r)}):new Promise((e,t)=>{r.onload=e,r.onerror=t,r.src=s,document.head.appendChild(r)})}async function CheckSupportsWorkerMode(){if(!navigator["userActivation"]||"undefined"==typeof OffscreenCanvas)return!1;try{let e=!1;const t=new Blob([`
	self.addEventListener("message", () =>
	{
		try {
			const offscreenCanvas = new OffscreenCanvas(32, 32);
			const gl = offscreenCanvas.getContext("webgl");
			self.postMessage(!!gl);
		}
		catch (err)
		{
			console.warn("Feature detection worker error:", err);
			self.postMessage(false);
		}
	});`],{"type":"text/javascript"}),s=new Worker(URL.createObjectURL(t),{get type(){e=!0}}),r=await new Promise(t=>{s.addEventListener("message",e=>{s.terminate(),t(e.data)}),s.postMessage("")});return e&&r}catch(e){return console.warn("Error feature detecting worker mode: ",e),!1}}let e=new Audio;const f={"audio/webm; codecs=opus":!!e.canPlayType("audio/webm; codecs=opus"),"audio/ogg; codecs=opus":!!e.canPlayType("audio/ogg; codecs=opus"),"audio/webm; codecs=vorbis":!!e.canPlayType("audio/webm; codecs=vorbis"),"audio/ogg; codecs=vorbis":!!e.canPlayType("audio/ogg; codecs=vorbis"),"audio/mp4":!!e.canPlayType("audio/mp4"),"audio/mpeg":!!e.canPlayType("audio/mpeg")};async function BlobToString(e){const t=await BlobToArrayBuffer(e),s=new TextDecoder("utf-8");return s.decode(t)}function BlobToArrayBuffer(r){return new Promise((t,s)=>{const e=new FileReader;e.onload=e=>t(e.target.result),e.onerror=e=>s(e),e.readAsArrayBuffer(r)})}e=null;const g=[];let r=0;const i=8,j=(window["RealFile"]=window["File"],[]),k=new Map,l=new Map;let h=0;const n=[],o=(self.runOnStartup=function(e){if("function"!=typeof e)throw new Error("runOnStartup called without a function");n.push(e)},new Set(["cordova","playable-ad-single-file","playable-ad-zip","instant-games"]));function IsWebViewExportType(e){return o.has(e)}let t=!1;window.RuntimeInterface=class Q{constructor(e){if(this._useWorker=e.useWorker,this._messageChannelPort=null,this._runtimeBaseUrl="",this._scriptFolder=e.scriptFolder,this._worker=null,this._localRuntime=null,this._domHandlers=[],this._runtimeDomHandler=null,this._isFirstSizeUpdate=!0,this._canvasLayers=[],this._pendingRemoveElements=[],this._pendingUpdateHTMLZOrder=!1,this._updateHTMLZOrderRAFCallback=()=>this._DoUpdateHTMLElementsZOrder(),this._isExportingToVideo=!1,this._exportToVideoDuration=0,this._jobScheduler=null,this._rafId=-1,this._rafFunc=()=>this._OnRAFCallback(),this._rafCallbacks=new Set,this._wrapperInitResolve=null,this._wrapperComponentIds=[],this._exportType=e.exportType,this._isFileProtocol="file"===location.protocol.substr(0,4),this._directoryHandles=[],"playable-ad-single-file"!==this._exportType&&"playable-ad-zip"!==this._exportType&&"instant-games"!==this._exportType||(this._useWorker=!1),c&&(this._useWorker=!1),"cordova"===this._exportType&&this._useWorker&&b){const t=/Chrome\/(\d+)/i.exec(navigator.userAgent);t&&90<=parseInt(t[1],10)||(this._useWorker=!1)}this.IsAnyWebView2Wrapper()?self["chrome"]["webview"].addEventListener("message",e=>this._OnWrapperMessage(e.data,e["additionalObjects"])):"macos-wkwebview"===this._exportType?self["C3WrapperOnMessage"]=e=>this._OnWrapperMessage(JSON.parse(e)):"linux-cef"===this._exportType&&self["c3_linux_cef_set_message_callback"](e=>this._OnWrapperMessage(JSON.parse(e))),this._localFileBlobs=null,this._localFileStrings=null,"html5"!==this._exportType||window.isSecureContext||console.warn("[Construct] Warning: the browser indicates this is not a secure context. Some features may be unavailable. Use secure (HTTPS) hosting to ensure all features are available."),this.AddRuntimeComponentMessageHandler("canvas","update-size",e=>this._OnUpdateCanvasSize(e)),this.AddRuntimeComponentMessageHandler("canvas","set-html-layer-count",e=>this["_OnSetHTMLLayerCount"](e)),this.AddRuntimeComponentMessageHandler("canvas","cleanup-html-layers",()=>this._OnCleanUpHTMLLayers()),this.AddRuntimeComponentMessageHandler("canvas","update-html-layer-dom-state",e=>this._UpdateHTMLLayerDOMProperties(e["layersDomState"])),this.AddRuntimeComponentMessageHandler("runtime","cordova-fetch-local-file",e=>this._OnCordovaFetchLocalFile(e)),this.AddRuntimeComponentMessageHandler("runtime","create-job-worker",e=>this._OnCreateJobWorker(e)),this.AddRuntimeComponentMessageHandler("runtime","send-wrapper-extension-message",e=>this._OnSendWrapperExtensionMessage(e)),"cordova"===this._exportType?document.addEventListener("deviceready",()=>this._Init(e)):this._Init(e),this._skipAndroidVirtualKeyboardDetection=0}Release(){this._CancelAnimationFrame(),this._messageChannelPort&&(this._messageChannelPort.onmessage=null,this._messageChannelPort=null),this._worker&&(this._worker.terminate(),this._worker=null),this._localRuntime&&(this._localRuntime.Release(),this._localRuntime=null);for(const{canvas:e,htmlWrap:t}of this._canvasLayers)e.remove(),t.remove();this._canvasLayers.length=0}GetMainCanvas(){return this._canvasLayers[0].canvas}GetAvailableHTMLIndex(e){return Math.min(e,this._canvasLayers.length-1)}GetHTMLWrapElement(e){if(e<0||e>=this._canvasLayers.length)throw new RangeError("invalid canvas layer");return this._canvasLayers[e].htmlWrap}["_GetHTMLWrapElement"](e){return this.GetHTMLWrapElement(e)}GetRuntimeBaseURL(){return this._runtimeBaseUrl}UsesWorker(){return this._useWorker}GetExportType(){return this._exportType}IsFileProtocol(){return this._isFileProtocol}GetScriptFolder(){return this._scriptFolder}IsiOSCordova(){return a&&"cordova"===this._exportType}IsiOSWebView(){const e=navigator.userAgent;return a&&IsWebViewExportType(this._exportType)||navigator["standalone"]||/crios\/|fxios\/|edgios\//i.test(e)}IsAndroid(){return b}IsAndroidWebView(){return b&&IsWebViewExportType(this._exportType)}IsWindowsWebView2(){return"windows-webview2"===this._exportType||!!("preview"===this._exportType&&window["chrome"]&&window["chrome"]["webview"]&&window["chrome"]["webview"]["postMessage"])}IsAnyWebView2Wrapper(){return this.IsWindowsWebView2()||"xbox-uwp-webview2"===this._exportType}SkipNextAndroidVirtualKeyboardDetection(){this.IsAndroidWebView()&&this._skipAndroidVirtualKeyboardDetection++}CanDoAndroidVirtualKeyboardDetection(){return this._CanDoAndroidVirtualKeyboardDetection().next().value}*_CanDoAndroidVirtualKeyboardDetection(){if(!this.IsAndroidWebView())return!0;yield 0===this._skipAndroidVirtualKeyboardDetection,0<this._skipAndroidVirtualKeyboardDetection&&this._skipAndroidVirtualKeyboardDetection--}async _Init(e){if(this._useWorker){const s=await CheckSupportsWorkerMode();s||(this._useWorker=!1)}if("macos-wkwebview"===this._exportType&&this._SendWrapperMessage({"type":"ready"}),this.IsAnyWebView2Wrapper()||"macos-wkwebview"===this._exportType||"linux-cef"===this._exportType){this._SetupDesktopWrapperPolyfills();const r=await this._InitWrapper();this._wrapperComponentIds=r["registeredComponentIds"]}if("playable-ad-single-file"===this._exportType&&(this._localFileBlobs=self["c3_base64files"],this._localFileStrings={},await this._ConvertDataUrisToBlobs()),"nwjs"===this._exportType&&self["nw"]){const i=self["nw"]["Window"]["get"]();if(i["on"]("close",()=>self["nw"]["App"]["quit"]()),self["nw"]["App"]["manifest"]["c3-steam-mode"]){let e=0;this._AddRAFCallback(()=>{e++,document.documentElement.style.opacity=e%2==0?"1":"0.999"})}}if(e.runtimeBaseUrl)this._runtimeBaseUrl=e.runtimeBaseUrl;else{const n=location.origin,a=(this._runtimeBaseUrl=("null"===n?"file:///":n)+location.pathname,this._runtimeBaseUrl.lastIndexOf("/"));-1!==a&&(this._runtimeBaseUrl=this._runtimeBaseUrl.substr(0,a+1))}const t=new MessageChannel;if(this._messageChannelPort=t.port1,this._messageChannelPort.onmessage=e=>this["_OnMessageFromRuntime"](e.data),window["c3_addPortMessageHandler"]&&window["c3_addPortMessageHandler"](e=>this._OnMessageFromDebugger(e)),this._jobScheduler=new self.JobSchedulerDOM(this),await this._jobScheduler.Init(),"object"==typeof window["StatusBar"]&&window["StatusBar"]["hide"](),"object"==typeof window["AndroidFullScreen"])try{await new Promise((e,t)=>{window["AndroidFullScreen"]["immersiveMode"](e,t)})}catch(e){console.error("Failed to enter Android immersive mode: ",e)}this._useWorker?await this._InitWorker(e,t.port2):await this._InitDOM(e,t.port2)}_GetCommonRuntimeOptions(e){return{"runtimeBaseUrl":this._runtimeBaseUrl,"previewUrl":location.href,"windowInnerWidth":this._GetWindowInnerWidth(),"windowInnerHeight":this._GetWindowInnerHeight(),"cssDisplayMode":this.GetCssDisplayMode(),"devicePixelRatio":window.devicePixelRatio,"isFullscreen":Q.IsDocumentFullscreen(),"swClientId":window["cr_swClientId"]||"","exportType":e.exportType,"isNWjs":"undefined"!=typeof nw,"fileMap":globalThis.c3_swFileMap??new Map(Object.entries(this._localFileBlobs??{})),"scriptFolder":this._scriptFolder,"isDebug":new URLSearchParams(self.location.search).has("debug"),"ife":!!self.ife,"jobScheduler":this._jobScheduler.GetPortData(),"supportedAudioFormats":f,"isFileProtocol":this._isFileProtocol,"isiOSCordova":this.IsiOSCordova(),"isiOSWebView":this.IsiOSWebView(),"isWindowsWebView2":this.IsWindowsWebView2(),"isAnyWebView2Wrapper":this.IsAnyWebView2Wrapper(),"wrapperComponentIds":this._wrapperComponentIds,"isFBInstantAvailable":void 0!==self["FBInstant"]}}async _InitWorker(e,t){const i=e.workerMainUrl,s=("preview"===this._exportType?(this._worker=new Worker("previewworker.js",{type:"module",name:"Runtime"}),await new Promise((t,s)=>{const r=e=>{this._worker.removeEventListener("message",r),(e.data&&"ok"===e.data["type"]?t:s)()};this._worker.addEventListener("message",r),this._worker.postMessage({"type":"construct-worker-init","import":new URL(i,this._runtimeBaseUrl).toString()})})):this._worker=await this.CreateWorker(i,{type:"module",name:"Runtime"}),document.createElement("canvas")),r=(s.style.display="none",s["transferControlToOffscreen"]()),n=(document.body.appendChild(s),document.createElement("div"));n.className="c3htmlwrap",n.setAttribute("interactive",""),document.body.appendChild(n),this._canvasLayers.push({canvas:s,htmlWrap:n,lastHtmlLayerDomState:{isVisible:!0,opacity:1,isInteractive:!0}}),window["c3canvas"]=s,self["C3_InsertHTMLPlaceholders"]&&self["C3_InsertHTMLPlaceholders"](),this._worker.postMessage(Object.assign(this._GetCommonRuntimeOptions(e),{"type":"init-runtime","isInWorker":!0,"messagePort":t,"canvas":r,"runtimeScriptList":e.runtimeScriptList,"projectMainScriptPath":e.projectMainScriptPath,"scriptsInEventsPath":e.scriptsInEventsPath}),[t,r,...this._jobScheduler.GetPortTransferables()]),this._domHandlers=j.map(e=>new e(this)),this._FindRuntimeDOMHandler(),this._runtimeDomHandler._AddDefaultCanvasEventHandlers(s),this._runtimeDomHandler._AddDefaultHTMLWrapEventHandlers(n),this._runtimeDomHandler._EnableWindowResizeEvent(),self["c3_callFunction"]=(e,t)=>this._runtimeDomHandler._InvokeFunctionFromJS(e,t),"preview"===this._exportType&&(self["goToLastErrorScript"]=()=>this.PostToRuntimeComponent("runtime","go-to-last-error-script"))}async _InitDOM(e,t){const s=document.createElement("canvas"),r=(s.style.display="none",document.body.appendChild(s),document.createElement("div")),i=(r.className="c3htmlwrap",r.setAttribute("interactive",""),document.body.appendChild(r),this._canvasLayers.push({canvas:s,htmlWrap:r,lastHtmlLayerDomState:{isVisible:!0,opacity:1,isInteractive:!0}}),window["c3canvas"]=s,self["C3_InsertHTMLPlaceholders"]&&self["C3_InsertHTMLPlaceholders"](),this._domHandlers=j.map(e=>new e(this)),this._FindRuntimeDOMHandler(),this._runtimeDomHandler._AddDefaultCanvasEventHandlers(s),this._runtimeDomHandler._AddDefaultHTMLWrapEventHandlers(r),await Promise.all(e.runtimeScriptList.map(e=>this._MaybeGetPlatformSpecificScriptURL(e)))),a=(await Promise.all(i.map(e=>AddScript(e))),e.projectMainScriptPath),o=e.scriptsInEventsPath;if(a)try{if(await AddScript(a),"preview"===this._exportType&&!globalThis.C3_ProjectMainScriptOK)throw new Error("main script did not run to completion")}catch(e){this._RemoveLoadingMessage(),console.error("Error loading project main script: ",e),alert(`Failed to load the project main script (${a}). Check all your JavaScript code has valid syntax, all imports are written correctly, and that an exception was not thrown running the script. Press F12 and check the console for error details.`)}if(o)try{if(await AddScript(o),"preview"===this._exportType&&!globalThis.C3.ScriptsInEvents)throw new Error("scripts in events did not run to completion")}catch(e){this._RemoveLoadingMessage(),console.error("Error loading scripts in events: ",e),alert("Failed to load scripts in events. Check all your JavaScript code has valid syntax, all imports are written correctly, and that an exception was not thrown running the 'Imports for events' script. Press F12 and check the console for error details.")}const l=Object.assign(this._GetCommonRuntimeOptions(e),{"isInWorker":!1,"messagePort":t,"canvas":s,"runOnStartupFunctions":n});this._runtimeDomHandler._EnableWindowResizeEvent(),this._OnBeforeCreateRuntime(),this._localRuntime=self["C3_CreateRuntime"](l),await self["C3_InitRuntime"](this._localRuntime,l)}async CreateWorker(e,t){if(e.startsWith("blob:"))return new Worker(e,t);if("cordova"===this._exportType&&this._isFileProtocol){const i=await this.CordovaFetchLocalFileAsArrayBuffer(e),n=new Blob([i],{type:"application/javascript"});return new Worker(URL.createObjectURL(n),t)}if("playable-ad-single-file"===this._exportType){const a=this._localFileBlobs[e];if(a)return new Worker(URL.createObjectURL(a),t);throw new Error("missing script: "+e)}const s=new URL(e,location.href),r=location.origin!==s.origin;if(r){const o=await fetch(s);if(!o.ok)throw new Error("failed to fetch worker script");const l=await o.blob();return new Worker(URL.createObjectURL(l),t)}return new Worker(s,t)}_GetWindowInnerWidth(){return Math.max(window.innerWidth,1)}_GetWindowInnerHeight(){return Math.max(window.innerHeight,1)}GetCssDisplayMode(){if(this.IsAnyWebView2Wrapper())return"standalone";const e=this.GetExportType(),t=new Set(["cordova","nwjs","macos-wkwebview","linux-cef"]);return t.has(e)?"standalone":window.matchMedia("(display-mode: fullscreen)").matches?"fullscreen":window.matchMedia("(display-mode: standalone)").matches?"standalone":window.matchMedia("(display-mode: minimal-ui)").matches?"minimal-ui":navigator["standalone"]?"standalone":"browser"}_OnBeforeCreateRuntime(){this._RemoveLoadingMessage()}_RemoveLoadingMessage(){const e=window["cr_previewLoadingElem"];e&&(e.parentElement.removeChild(e),window["cr_previewLoadingElem"]=null)}async _OnCreateJobWorker(e){const t=await this._jobScheduler._CreateJobWorker();return{"outputPort":t,"transferables":[t]}}_OnUpdateCanvasSize(e){if(!this.IsExportingToVideo()){const t=e["styleWidth"]+"px",s=e["styleHeight"]+"px",r=e["marginLeft"]+"px",i=e["marginTop"]+"px";for(const{canvas:n,htmlWrap:a}of this._canvasLayers)n.style.width=t,n.style.height=s,n.style.marginLeft=r,n.style.marginTop=i,a.style.width=t,a.style.height=s,a.style.marginLeft=r,a.style.marginTop=i,this._isFirstSizeUpdate&&(n.style.display="",a.style.display="");document.documentElement.style.setProperty("--construct-scale",e["displayScale"]),this._isFirstSizeUpdate=!1}}["_OnSetHTMLLayerCount"](e){const s=e["count"],t=e["layersDomState"],r=e["immediate"],i=e["styleWidth"]+"px",n=e["styleHeight"]+"px",a=e["marginLeft"]+"px",o=e["marginTop"]+"px",l=[],c=[];if(s<this._canvasLayers.length)for(;this._canvasLayers.length>s;){const{canvas:d,htmlWrap:h}=this._canvasLayers.pop();h.remove(),this._useWorker&&!r?this._pendingRemoveElements.push(d):d.remove()}else if(s>this._canvasLayers.length)for(let e=0,t=s-this._canvasLayers.length;e<t;++e){const p=document.createElement("canvas");if(p.classList.add("c3overlay"),this._useWorker){const u=p["transferControlToOffscreen"]();l.push(u),c.push(u)}else l.push(p);document.body.appendChild(p);const m=document.createElement("div");m.classList.add("c3htmlwrap","c3overlay"),m.setAttribute("interactive",""),document.body.appendChild(m),p.style.width=i,p.style.height=n,p.style.marginLeft=a,p.style.marginTop=o,m.style.width=i,m.style.height=n,m.style.marginLeft=a,m.style.marginTop=o,this._runtimeDomHandler._AddDefaultCanvasEventHandlers(p),this._runtimeDomHandler._AddDefaultHTMLWrapEventHandlers(m),this._canvasLayers.push({canvas:p,htmlWrap:m,lastHtmlLayerDomState:{isVisible:!0,opacity:1,isInteractive:!0}})}this._UpdateHTMLLayerDOMProperties(t);for(const _ of this._domHandlers)_ instanceof window.DOMElementHandler&&_._OnHTMLLayersChanged();return this._UpdateHTMLElementsZOrder(),{"addedCanvases":l,"transferables":c}}_UpdateHTMLLayerDOMProperties(s){for(let e=0,t=Math.min(this._canvasLayers.length,s.length);e<t;++e){const{htmlWrap:r,lastHtmlLayerDomState:i}=this._canvasLayers[e],n=s[e],a=n["isVisible"],o=n["opacity"],l=n["isInteractive"];a!==i.isVisible&&(r.style.display=a?"":"none",i.isVisible=a),o!==i.opacity&&(r.style.opacity=1===o?"":String(o),i.opacity=o),l!==i.isInteractive&&(r.style.pointerEvents=l?"":"none",l?r.setAttribute("interactive",""):r.removeAttribute("interactive"),i.isInteractive=l)}}_OnCleanUpHTMLLayers(){for(const e of this._pendingRemoveElements)e.remove();this._pendingRemoveElements.length=0}_UpdateHTMLElementsZOrder(){this._pendingUpdateHTMLZOrder||(this._pendingUpdateHTMLZOrder=!0,this._AddRAFCallback(this._updateHTMLZOrderRAFCallback))}_DoUpdateHTMLElementsZOrder(){this._RemoveRAFCallback(this._updateHTMLZOrderRAFCallback),this._pendingUpdateHTMLZOrder=!1;let e=[];for(const n of this._domHandlers)if(n instanceof window.DOMElementHandler){const a=n._GetAllElementStatesForZOrderUpdate();a&&e.push(...a)}e.sort((e,t)=>{const s=e.GetActualHTMLIndex(),r=t.GetActualHTMLIndex();if(s!==r)return s-r;const i=e.GetHTMLZIndex(),n=t.GetHTMLZIndex();return i-n});let t=0,s=0,r=0,i=e.length;for(;r<i;++r){const o=e[r];o.GetActualHTMLIndex()!==t&&(this._DoUpdateHTMLElementsZOrderOnHTMLLayer(t,e.slice(s,r)),t=o.GetActualHTMLIndex(),s=r)}s<r&&this._DoUpdateHTMLElementsZOrderOnHTMLLayer(t,e.slice(s,r))}_DoUpdateHTMLElementsZOrderOnHTMLLayer(e,t){if(!(t.length<=1||e>=this._canvasLayers.length)){const r=t.map(e=>e.GetElement()),s=new Set(r),i=this.GetHTMLWrapElement(e),n=Array.from(i.children).filter(e=>s.has(e));for(let e=0,t=0,s=r.length;e<s;++e){const a=r[e],o=n[t];a===o?++t:i.insertBefore(a,o)}}}_GetLocalRuntime(){if(this._useWorker)throw new Error("not available in worker mode");return this._localRuntime}PostToRuntimeComponent(e,t,s,r,i){this._messageChannelPort.postMessage({"type":"event","component":e,"handler":t,"dispatchOpts":r||null,"data":s,"responseId":null},i)}PostToRuntimeComponentAsync(e,t,s,r,i){const n=h++,a=new Promise((e,t)=>{l.set(n,{resolve:e,reject:t})});return this._messageChannelPort.postMessage({"type":"event","component":e,"handler":t,"dispatchOpts":r||null,"data":s,"responseId":n},i),a}["_OnMessageFromRuntime"](e){const t=e["type"];if("event"===t)return this._OnEventFromRuntime(e);if("result"===t)this._OnResultFromRuntime(e);else if("runtime-ready"===t)this._OnRuntimeReady();else if("alert-error"===t)this._RemoveLoadingMessage(),alert(e["message"]);else{if("creating-runtime"!==t)throw new Error(`unknown message '${t}'`);this._OnBeforeCreateRuntime()}}_OnEventFromRuntime(e){const t=e["component"],s=e["handler"],r=e["data"],i=e["responseId"],n=k.get(t);if(n){const a=n.get(s);if(a){let e=null;try{e=a(r)}catch(e){return console.error(`Exception in '${t}' handler '${s}':`,e),void(null!==i&&this._PostResultToRuntime(i,!1,""+e))}if(null===i)return e;e&&e.then?e.then(e=>this._PostResultToRuntime(i,!0,e)).catch(e=>{console.error(`Rejection from '${t}' handler '${s}':`,e),this._PostResultToRuntime(i,!1,""+e)}):this._PostResultToRuntime(i,!0,e)}else console.warn(`[DOM] No handler '${s}' for component '${t}'`)}else console.warn(`[DOM] No event handlers for component '${t}'`)}_PostResultToRuntime(e,t,s){let r;s&&s["transferables"]&&(r=s["transferables"]),this._messageChannelPort.postMessage({"type":"result","responseId":e,"isOk":t,"result":s},r)}_OnResultFromRuntime(e){const t=e["responseId"],s=e["isOk"],r=e["result"],i=l.get(t);s?i.resolve(r):i.reject(r),l.delete(t)}AddRuntimeComponentMessageHandler(e,t,s){let r=k.get(e);if(r||(r=new Map,k.set(e,r)),r.has(t))throw new Error(`[DOM] Component '${e}' already has handler '${t}'`);r.set(t,s)}static AddDOMHandlerClass(e){if(j.includes(e))throw new Error("DOM handler already added");j.push(e)}_FindRuntimeDOMHandler(){for(const e of this._domHandlers)if("runtime"===e.GetComponentID())return void(this._runtimeDomHandler=e);throw new Error("cannot find runtime DOM handler")}_OnMessageFromDebugger(e){this.PostToRuntimeComponent("debugger","message",e)}_OnRuntimeReady(){for(const e of this._domHandlers)e.Attach()}static IsDocumentFullscreen(){return!!(document["fullscreenElement"]||document["webkitFullscreenElement"]||document["mozFullScreenElement"]||t)}static _SetWrapperIsFullscreenFlag(e){t=!!e}async GetRemotePreviewStatusInfo(){return this.PostToRuntimeComponentAsync("runtime","get-remote-preview-status-info")}_AddRAFCallback(e){this._rafCallbacks.add(e),this._RequestAnimationFrame()}_RemoveRAFCallback(e){this._rafCallbacks.delete(e),0===this._rafCallbacks.size&&this._CancelAnimationFrame()}_RequestAnimationFrame(){-1===this._rafId&&0<this._rafCallbacks.size&&(this._rafId=requestAnimationFrame(this._rafFunc))}_CancelAnimationFrame(){-1!==this._rafId&&(cancelAnimationFrame(this._rafId),this._rafId=-1)}_OnRAFCallback(){this._rafId=-1;for(const e of this._rafCallbacks)e();this._RequestAnimationFrame()}TryPlayMedia(e){this._runtimeDomHandler.TryPlayMedia(e)}RemovePendingPlay(e){this._runtimeDomHandler.RemovePendingPlay(e)}_PlayPendingMedia(){this._runtimeDomHandler._PlayPendingMedia()}SetSilent(e){this._runtimeDomHandler.SetSilent(e)}IsAudioFormatSupported(e){return!!f[e]}SetIsExportingToVideo(e){this._isExportingToVideo=!0,this._exportToVideoDuration=e}IsExportingToVideo(){return this._isExportingToVideo}GetExportToVideoDuration(){return this._exportToVideoDuration}IsAbsoluteURL(e){return/^(?:[a-z\-]+:)?\/\//.test(e)||"data:"===e.substr(0,5)||"blob:"===e.substr(0,5)}IsRelativeURL(e){return!this.IsAbsoluteURL(e)}async _MaybeGetPlatformSpecificScriptURL(t){if("cordova"===this._exportType&&(t.startsWith("file:")||this._isFileProtocol&&this.IsRelativeURL(t))){let e=t;e.startsWith(this._runtimeBaseUrl)&&(e=e.substr(this._runtimeBaseUrl.length));const s=await this.CordovaFetchLocalFileAsArrayBuffer(e),r=new Blob([s],{type:"application/javascript"});return URL.createObjectURL(r)}if("playable-ad-single-file"!==this._exportType)return t;if(this._localFileStrings.hasOwnProperty(t))return{isStringSrc:!0,str:this._localFileStrings[t]};if(this._localFileBlobs.hasOwnProperty(t))return URL.createObjectURL(this._localFileBlobs[t]);throw new Error("missing script: "+t)}async _OnCordovaFetchLocalFile(e){const t=e["filename"];switch(e["as"]){case"text":return this.CordovaFetchLocalFileAsText(t);case"buffer":return this.CordovaFetchLocalFileAsArrayBuffer(t);default:throw new Error("unsupported type")}}CordovaFetchLocalFile(e){const r=window["cordova"]["file"]["applicationDirectory"]+"www/"+e;return new Promise((t,s)=>{window["resolveLocalFileSystemURL"](r,e=>{e["file"](t,s)},s)})}async CordovaFetchLocalFileAsText(e){const t=await this.CordovaFetchLocalFile(e);return BlobToString(t)}_CordovaMaybeStartNextArrayBufferRead(){if(g.length&&!(r>=i)){r++;const e=g.shift();this._CordovaDoFetchLocalFileAsAsArrayBuffer(e.filename,e.successCallback,e.errorCallback)}}CordovaFetchLocalFileAsArrayBuffer(e){return new Promise((t,s)=>{g.push({filename:e,successCallback:e=>{r--,this._CordovaMaybeStartNextArrayBufferRead(),t(e)},errorCallback:e=>{r--,this._CordovaMaybeStartNextArrayBufferRead(),s(e)}}),this._CordovaMaybeStartNextArrayBufferRead()})}async _CordovaDoFetchLocalFileAsAsArrayBuffer(e,t,s){try{const r=await this.CordovaFetchLocalFile(e),i=await BlobToArrayBuffer(r);t(i)}catch(e){s(e)}}["_PlayableAdFetchBlob"](e){if(this._localFileBlobs.hasOwnProperty(e))return this._localFileBlobs[e];throw new Error("missing file: "+e)}_GetPermissionAPI(){const e=window["cordova"]&&window["cordova"]["plugins"]&&window["cordova"]["plugins"]["permissions"];if("object"!=typeof e)throw new Error("Permission API is not loaded");return e}_MapPermissionID(e,t){const s=e[t];if("string"!=typeof s)throw new Error("Invalid permission name");return s}_HasPermission(s){const r=this._GetPermissionAPI();return new Promise((t,e)=>r["checkPermission"](this._MapPermissionID(r,s),e=>t(!!e["hasPermission"]),e))}_RequestPermission(s){const r=this._GetPermissionAPI();return new Promise((t,e)=>r["requestPermission"](this._MapPermissionID(r,s),e=>t(!!e["hasPermission"]),e))}async RequestPermissions(e){if("cordova"===this.GetExportType()&&!this.IsiOSCordova())for(const t of e){const s=await this._HasPermission(t);if(!s){const r=await this._RequestPermission(t);if(!1===r)return!1}}return!0}async RequirePermissions(...e){if(!1===await this.RequestPermissions(e))throw new Error("Permission not granted")}_OnWrapperMessage(e,t){if("object"==typeof e&&e){const s=e["type"];if("directory-handles"===s)this._directoryHandles=t;else if("wrapper-init-response"===s)this._wrapperInitResolve(e),this._wrapperInitResolve=null;else if("fullscreen-change"===s)Q._SetWrapperIsFullscreenFlag(e["isFullscreen"]),this._runtimeDomHandler._OnFullscreenChange();else if("log-to-console"===s)switch(e["logType"]){case"error":console.error(e["message"]);break;case"warning":console.warn(e["message"]);break;default:console.log(e["message"])}else"extension-message"===s?this.PostToRuntimeComponent("runtime","wrapper-extension-message",e):console.warn("Unknown wrapper message: ",e)}else console.warn("Unknown wrapper message: ",e)}_OnSendWrapperExtensionMessage(e){this._SendWrapperMessage({"type":"extension-message","componentId":e["componentId"],"messageId":e["messageId"],"params":e["params"]||[],"asyncId":e["asyncId"]})}_SendWrapperMessage(e){this.IsAnyWebView2Wrapper()?window["chrome"]["webview"]["postMessage"](JSON.stringify(e)):"macos-wkwebview"===this._exportType?window["webkit"]["messageHandlers"]["C3Wrapper"]["postMessage"](JSON.stringify(e)):"linux-cef"===this._exportType&&window["c3_linux_cef_sendmessage"](JSON.stringify(e))}_SetupDesktopWrapperPolyfills(){window.moveTo=(e,t)=>{this._SendWrapperMessage({"type":"set-window-position","windowX":Math.ceil(e),"windowY":Math.ceil(t)})},window.resizeTo=(e,t)=>{this._SendWrapperMessage({"type":"set-window-size","windowWidth":Math.ceil(e),"windowHeight":Math.ceil(t)})}}_InitWrapper(){return new Promise(e=>{this._wrapperInitResolve=e,this._SendWrapperMessage({"type":"wrapper-init"})})}_GetDirectoryHandles(){return this._directoryHandles}async _ConvertDataUrisToBlobs(){const e=[];for(const[t,s]of Object.entries(this._localFileBlobs))e.push(this._ConvertDataUriToBlobs(t,s));await Promise.all(e)}async _ConvertDataUriToBlobs(t,s){if("object"==typeof s)this._localFileBlobs[t]=new Blob([s["str"]],{"type":s["type"]}),this._localFileStrings[t]=s["str"];else{let e=await this._FetchDataUri(s);e=e||this._DataURIToBinaryBlobSync(s),this._localFileBlobs[t]=e}}async _FetchDataUri(e){try{const t=await fetch(e);return await t.blob()}catch(e){return console.warn("Failed to fetch a data: URI. Falling back to a slower workaround. This is probably because the Content Security Policy unnecessarily blocked it. Allow data: URIs in your CSP to avoid this.",e),null}}_DataURIToBinaryBlobSync(e){const t=this._ParseDataURI(e);return this._BinaryStringToBlob(t.data,t.mime_type)}_ParseDataURI(e){const t=e.indexOf(",");if(t<0)throw new URIError("expected comma in data: uri");const s=e.substring(5,t),r=e.substring(t+1),i=s.split(";"),n=i[0]||"",a=i[1],o=i[2];let l;return{mime_type:n,data:l=("base64"===a||"base64"===o?atob:decodeURIComponent)(r)}}_BinaryStringToBlob(e,t){let s=e.length,r=s>>2,i=new Uint8Array(s),n=new Uint32Array(i.buffer,0,r),a,o;for(a=0,o=0;a<r;++a)n[a]=e.charCodeAt(o++)|e.charCodeAt(o++)<<8|e.charCodeAt(o++)<<16|e.charCodeAt(o++)<<24;let l=3&s;for(;l--;)i[o]=e.charCodeAt(o),++o;return new Blob([i],{"type":t})}}}

// workers/runtimeDomEvents.js
"use strict";{const a=self.RuntimeInterface;function IsCompatibilityMouseEvent(e){return e["sourceCapabilities"]&&e["sourceCapabilities"]["firesTouchEvents"]||e["originalEvent"]&&e["originalEvent"]["sourceCapabilities"]&&e["originalEvent"]["sourceCapabilities"]["firesTouchEvents"]}const b=new Map([["OSLeft","MetaLeft"],["OSRight","MetaRight"]]),c={"dispatchRuntimeEvent":!0,"dispatchUserScriptEvent":!0},d={"dispatchUserScriptEvent":!0},e={"dispatchRuntimeEvent":!0};function AddStyleSheet(i){return new Promise((e,t)=>{const n=document.createElement("link");n.onload=()=>e(n),n.onerror=e=>t(e),n.rel="stylesheet",n.href=i,document.head.appendChild(n)})}function FetchImage(i){return new Promise((e,t)=>{const n=new Image;n.onload=()=>e(n),n.onerror=e=>t(e),n.src=i})}async function BlobToImage(e){const t=URL.createObjectURL(e);try{return await FetchImage(t)}finally{URL.revokeObjectURL(t)}}function BlobToString(i){return new Promise((t,n)=>{let e=new FileReader;e.onload=e=>t(e.target.result),e.onerror=e=>n(e),e.readAsText(i)})}function IsInContentEditable(e){do{if(e.parentNode&&e.hasAttribute("contenteditable"))return!0}while(e=e.parentNode);return!1}const f=new Set(["input","textarea","datalist","select"]);function IsKeyboardInputElement(e){return f.has(e.tagName.toLowerCase())||IsInContentEditable(e)}const g=new Set(["canvas","body","html"]);function PreventDefaultOnCanvasOrDoc(e){if(e.target.tagName){const t=e.target.tagName.toLowerCase();g.has(t)&&e.preventDefault()}}function PreventDefaultOnHTMLWrap(e){e.target.tagName&&e.target.classList.contains("c3htmlwrap")&&e.preventDefault()}function BlockWheelZoom(e){(e.metaKey||e.ctrlKey)&&e.preventDefault()}self["C3_GetSvgImageSize"]=async function(e){const t=await BlobToImage(e);if(0<t.width&&0<t.height)return[t.width,t.height];{t.style.position="absolute",t.style.left="0px",t.style.top="0px",t.style.visibility="hidden",document.body.appendChild(t);const n=t.getBoundingClientRect();return document.body.removeChild(t),[n.width,n.height]}};let t=!(self["C3_RasterSvgImageBlob"]=async function(e,t,n,i,o){const s=await BlobToImage(e),a=document.createElement("canvas"),r=(a.width=i,a.height=o,a.getContext("2d"));return r.drawImage(s,0,0,t,n),a});function ParentHasFocus(){try{return window.parent&&window.parent.document.hasFocus()}catch(e){return!1}}document.addEventListener("pause",()=>t=!0),document.addEventListener("resume",()=>t=!1);const i="runtime",j=class extends self.DOMHandler{constructor(e){super(e,i),this._enableWindowResizeEvent=!1,this._simulatedResizeTimerId=-1,this._targetOrientation="any",this._attachedDeviceOrientationEvent=!1,this._attachedDeviceMotionEvent=!1,this._pageVisibilityIsHidden=!1,this._screenReaderTextWrap=document.createElement("div"),this._screenReaderTextWrap.className="c3-screen-reader-text",this._screenReaderTextWrap.setAttribute("aria-live","polite"),document.body.appendChild(this._screenReaderTextWrap),this._debugHighlightElem=null,this._isExportToVideo=!1,this._exportVideoProgressMessage="",this._exportVideoUpdateTimerId=-1,this._enableAndroidVKDetection=!1,this._lastWindowWidth=e._GetWindowInnerWidth(),this._lastWindowHeight=e._GetWindowInnerHeight(),this._virtualKeyboardHeight=0,this._vkTranslateYOffset=0,e.AddRuntimeComponentMessageHandler("runtime","invoke-download",e=>this._OnInvokeDownload(e)),e.AddRuntimeComponentMessageHandler("runtime","load-webfonts",e=>this._OnLoadWebFonts(e)),e.AddRuntimeComponentMessageHandler("runtime","raster-svg-image",e=>this._OnRasterSvgImage(e)),e.AddRuntimeComponentMessageHandler("runtime","get-svg-image-size",e=>this._OnGetSvgImageSize(e)),e.AddRuntimeComponentMessageHandler("runtime","set-target-orientation",e=>this._OnSetTargetOrientation(e)),e.AddRuntimeComponentMessageHandler("runtime","register-sw",()=>this._OnRegisterSW()),e.AddRuntimeComponentMessageHandler("runtime","post-to-debugger",e=>this._OnPostToDebugger(e)),e.AddRuntimeComponentMessageHandler("runtime","go-to-script",e=>this._OnPostToDebugger(e)),e.AddRuntimeComponentMessageHandler("runtime","before-start-ticking",()=>this._OnBeforeStartTicking()),e.AddRuntimeComponentMessageHandler("runtime","debug-highlight",e=>this._OnDebugHighlight(e)),e.AddRuntimeComponentMessageHandler("runtime","enable-device-orientation",()=>this._AttachDeviceOrientationEvent()),e.AddRuntimeComponentMessageHandler("runtime","enable-device-motion",()=>this._AttachDeviceMotionEvent()),e.AddRuntimeComponentMessageHandler("runtime","add-stylesheet",e=>this._OnAddStylesheet(e)),e.AddRuntimeComponentMessageHandler("runtime","script-create-worker",e=>this._OnScriptCreateWorker(e)),e.AddRuntimeComponentMessageHandler("runtime","alert",e=>this._OnAlert(e)),e.AddRuntimeComponentMessageHandler("runtime","screen-reader-text",e=>this._OnScreenReaderTextEvent(e)),e.AddRuntimeComponentMessageHandler("runtime","hide-cordova-splash",()=>this._OnHideCordovaSplash()),e.AddRuntimeComponentMessageHandler("runtime","set-exporting-to-video",e=>this._SetExportingToVideo(e)),e.AddRuntimeComponentMessageHandler("runtime","export-to-video-progress",e=>this._OnExportVideoProgress(e)),e.AddRuntimeComponentMessageHandler("runtime","exported-to-video",e=>this._OnExportedToVideo(e)),e.AddRuntimeComponentMessageHandler("runtime","exported-to-image-sequence",e=>this._OnExportedToImageSequence(e));const o=new Set(["input","textarea","datalist"]);if(window.addEventListener("contextmenu",e=>{const t=e.target,n=t.tagName.toLowerCase();o.has(n)||IsInContentEditable(t)||e.preventDefault()}),window.addEventListener("selectstart",PreventDefaultOnCanvasOrDoc),window.addEventListener("gesturehold",PreventDefaultOnCanvasOrDoc),window.addEventListener("touchstart",PreventDefaultOnCanvasOrDoc,{"passive":!1}),window.addEventListener("pointerdown",PreventDefaultOnCanvasOrDoc,{"passive":!1}),this._mousePointerLastButtons=0,window.addEventListener("mousedown",e=>{1===e.button&&e.preventDefault()}),window.addEventListener("mousewheel",BlockWheelZoom,{"passive":!1}),window.addEventListener("wheel",BlockWheelZoom,{"passive":!1}),window.addEventListener("resize",()=>this._OnWindowResize()),window.addEventListener("fullscreenchange",()=>this._OnFullscreenChange()),window.addEventListener("webkitfullscreenchange",()=>this._OnFullscreenChange()),window.addEventListener("mozfullscreenchange",()=>this._OnFullscreenChange()),window.addEventListener("fullscreenerror",e=>this._OnFullscreenError(e)),window.addEventListener("webkitfullscreenerror",e=>this._OnFullscreenError(e)),window.addEventListener("mozfullscreenerror",e=>this._OnFullscreenError(e)),e.IsiOSWebView()){let t=1/0;window["visualViewport"].addEventListener("resize",()=>{const e=window["visualViewport"].height;e>t&&(document.scrollingElement.scrollTop=0,document.scrollingElement.scrollLeft=0),t=e}),document.documentElement.setAttribute("ioswebview","")}this._mediaPendingPlay=new Set,this._mediaRemovedPendingPlay=new WeakSet,this._isSilent=!1}_AddDefaultCanvasEventHandlers(e){e.addEventListener("selectstart",PreventDefaultOnCanvasOrDoc),e.addEventListener("gesturehold",PreventDefaultOnCanvasOrDoc),e.addEventListener("pointerdown",PreventDefaultOnCanvasOrDoc)}_AddDefaultHTMLWrapEventHandlers(e){e.addEventListener("selectstart",PreventDefaultOnHTMLWrap),e.addEventListener("gesturehold",PreventDefaultOnHTMLWrap),e.addEventListener("touchstart",PreventDefaultOnHTMLWrap)}_OnBeforeStartTicking(){return self.setTimeout(()=>{this._enableAndroidVKDetection=!0},1e3),"cordova"===this._iRuntime.GetExportType()?(document.addEventListener("pause",()=>this._OnVisibilityChange(!0)),document.addEventListener("resume",()=>this._OnVisibilityChange(!1))):document.addEventListener("visibilitychange",()=>this._OnVisibilityChange("hidden"===document.visibilityState)),this._pageVisibilityIsHidden=!("hidden"!==document.visibilityState&&!t),{"isSuspended":this._pageVisibilityIsHidden}}Attach(){window.addEventListener("focus",()=>this._PostRuntimeEvent("window-focus")),window.addEventListener("blur",()=>{this._PostRuntimeEvent("window-blur",{"parentHasFocus":ParentHasFocus()}),this._mousePointerLastButtons=0}),window.addEventListener("focusin",e=>{IsKeyboardInputElement(e.target)&&this._PostRuntimeEvent("keyboard-blur")}),window.addEventListener("keydown",e=>this._OnKeyEvent("keydown",e)),window.addEventListener("keyup",e=>this._OnKeyEvent("keyup",e)),window.addEventListener("mousedown",e=>this._OnMouseEvent("mousedown",e,d)),window.addEventListener("mousemove",e=>this._OnMouseEvent("mousemove",e,d)),window.addEventListener("mouseup",e=>this._OnMouseEvent("mouseup",e,d)),window.addEventListener("dblclick",e=>this._OnMouseEvent("dblclick",e,c)),window.addEventListener("wheel",e=>this._OnMouseWheelEvent("wheel",e,c)),window.addEventListener("pointerdown",e=>{this._HandlePointerDownFocus(e),this._OnPointerEvent("pointerdown",e)}),this._iRuntime.UsesWorker()&&void 0!==window["onpointerrawupdate"]&&self===self.top?window.addEventListener("pointerrawupdate",e=>this._OnPointerRawUpdate(e)):window.addEventListener("pointermove",e=>this._OnPointerEvent("pointermove",e)),window.addEventListener("pointerup",e=>this._OnPointerEvent("pointerup",e)),window.addEventListener("pointercancel",e=>this._OnPointerEvent("pointercancel",e));const e=()=>this._PlayPendingMedia();window.addEventListener("pointerup",e,!0),window.addEventListener("touchend",e,!0),window.addEventListener("click",e,!0),window.addEventListener("keydown",e,!0),window.addEventListener("gamepadconnected",e,!0),this._iRuntime.IsAndroid()&&!this._iRuntime.IsAndroidWebView()&&navigator["virtualKeyboard"]&&(navigator["virtualKeyboard"]["overlaysContent"]=!0,navigator["virtualKeyboard"].addEventListener("geometrychange",()=>{this._OnAndroidVirtualKeyboardChange(this._GetWindowInnerHeight(),navigator["virtualKeyboard"]["boundingRect"]["height"])})),this._iRuntime.IsiOSWebView()&&(document.scrollingElement.scrollTop=0,document.scrollingElement.scrollLeft=0)}_OnAndroidVirtualKeyboardChange(t,n){if(document.body.style.position="",document.body.style.overflow="",document.body.style.transform="",(this._vkTranslateYOffset=0)<n){const i=document.activeElement;if(i){const o=i.getBoundingClientRect(),s=(o.top+o.bottom)/2,a=(t-n)/2;let e=s-a;0<(e=(e=e>n?n:e)<0?0:e)&&(document.body.style.position="absolute",document.body.style.overflow="visible",document.body.style.transform=`translateY(${-e}px)`,this._vkTranslateYOffset=e)}}}_PostRuntimeEvent(t,n){this.PostToRuntime(t,n||null,e)}_GetWindowInnerWidth(){return this._iRuntime._GetWindowInnerWidth()}_GetWindowInnerHeight(){return this._iRuntime._GetWindowInnerHeight()}_EnableWindowResizeEvent(){this._enableWindowResizeEvent=!0,this._lastWindowWidth=this._iRuntime._GetWindowInnerWidth(),this._lastWindowHeight=this._iRuntime._GetWindowInnerHeight()}_OnWindowResize(){if(!this._isExportToVideo&&this._enableWindowResizeEvent){const e=this._GetWindowInnerWidth(),t=this._GetWindowInnerHeight();if(this._iRuntime.IsAndroidWebView()){if(this._enableAndroidVKDetection){const n=this._iRuntime.CanDoAndroidVirtualKeyboardDetection();if(n&&this._lastWindowWidth===e&&t<this._lastWindowHeight)return this._virtualKeyboardHeight=this._lastWindowHeight-t,void this._OnAndroidVirtualKeyboardChange(this._lastWindowHeight,this._virtualKeyboardHeight);0<this._virtualKeyboardHeight&&(this._virtualKeyboardHeight=0,this._OnAndroidVirtualKeyboardChange(t,this._virtualKeyboardHeight))}this._lastWindowWidth=e,this._lastWindowHeight=t}this.PostToRuntime("window-resize",{"innerWidth":e,"innerHeight":t,"devicePixelRatio":window.devicePixelRatio,"isFullscreen":a.IsDocumentFullscreen(),"cssDisplayMode":this._iRuntime.GetCssDisplayMode()}),this._iRuntime.IsiOSWebView()&&(-1!==this._simulatedResizeTimerId&&clearTimeout(this._simulatedResizeTimerId),this._OnSimulatedResize(e,t,0))}}_ScheduleSimulatedResize(e,t,n){-1!==this._simulatedResizeTimerId&&clearTimeout(this._simulatedResizeTimerId),this._simulatedResizeTimerId=setTimeout(()=>this._OnSimulatedResize(e,t,n),48)}_OnSimulatedResize(e,t,n){const i=this._GetWindowInnerWidth(),o=this._GetWindowInnerHeight();this._simulatedResizeTimerId=-1,i!=e||o!=t?this.PostToRuntime("window-resize",{"innerWidth":i,"innerHeight":o,"devicePixelRatio":window.devicePixelRatio,"isFullscreen":a.IsDocumentFullscreen(),"cssDisplayMode":this._iRuntime.GetCssDisplayMode()}):n<10&&this._ScheduleSimulatedResize(i,o,n+1)}_OnSetTargetOrientation(e){this._targetOrientation=e["targetOrientation"]}_TrySetTargetOrientation(){const t=this._targetOrientation;if(screen["orientation"]&&screen["orientation"]["lock"])screen["orientation"]["lock"](t).catch(e=>console.warn("[Construct] Failed to lock orientation: ",e));else try{let e=!1;screen["lockOrientation"]?e=screen["lockOrientation"](t):screen["webkitLockOrientation"]?e=screen["webkitLockOrientation"](t):screen["mozLockOrientation"]?e=screen["mozLockOrientation"](t):screen["msLockOrientation"]&&(e=screen["msLockOrientation"](t)),e||console.warn("[Construct] Failed to lock orientation")}catch(e){console.warn("[Construct] Failed to lock orientation: ",e)}}_OnFullscreenChange(){if(!this._isExportToVideo){const e=a.IsDocumentFullscreen();e&&"any"!==this._targetOrientation&&this._TrySetTargetOrientation(),this.PostToRuntime("fullscreenchange",{"isFullscreen":e,"innerWidth":this._GetWindowInnerWidth(),"innerHeight":this._GetWindowInnerHeight()})}}_OnFullscreenError(e){console.warn("[Construct] Fullscreen request failed: ",e),this.PostToRuntime("fullscreenerror",{"isFullscreen":a.IsDocumentFullscreen(),"innerWidth":this._GetWindowInnerWidth(),"innerHeight":this._GetWindowInnerHeight()})}_OnVisibilityChange(e){if(this._pageVisibilityIsHidden!==e&&((this._pageVisibilityIsHidden=e)?this._iRuntime._CancelAnimationFrame():this._iRuntime._RequestAnimationFrame(),this.PostToRuntime("visibilitychange",{"hidden":e}),!e)&&this._iRuntime.IsiOSWebView()){const t=()=>{document.scrollingElement.scrollTop=0,document.scrollingElement.scrollLeft=0};setTimeout(t,50),setTimeout(t,100),setTimeout(t,250),setTimeout(t,500)}}_OnKeyEvent(e,t){if(void 0!==t.key&&("Backspace"===t.key&&PreventDefaultOnCanvasOrDoc(t),"nwjs"===this._iRuntime.GetExportType()&&"u"===t.key&&(t.ctrlKey||t.metaKey)&&t.preventDefault(),!this._isExportToVideo)){const n=b.get(t.code)||t.code;this._PostToRuntimeMaybeSync(e,{"code":n,"key":t.key,"which":t.which,"repeat":t.repeat,"altKey":t.altKey,"ctrlKey":t.ctrlKey,"metaKey":t.metaKey,"shiftKey":t.shiftKey,"timeStamp":t.timeStamp},c)}}_OnMouseWheelEvent(e,t,n){this._isExportToVideo||this.PostToRuntime(e,{"clientX":t.clientX,"clientY":t.clientY+this._vkTranslateYOffset,"pageX":t.pageX,"pageY":t.pageY+this._vkTranslateYOffset,"deltaX":t.deltaX,"deltaY":t.deltaY,"deltaZ":t.deltaZ,"deltaMode":t.deltaMode,"timeStamp":t.timeStamp},n)}_OnMouseEvent(e,t,n){this._isExportToVideo||IsCompatibilityMouseEvent(t)||this._PostToRuntimeMaybeSync(e,{"button":t.button,"buttons":t.buttons,"clientX":t.clientX,"clientY":t.clientY+this._vkTranslateYOffset,"pageX":t.pageX,"pageY":t.pageY+this._vkTranslateYOffset,"movementX":t.movementX||0,"movementY":t.movementY||0,"timeStamp":t.timeStamp},n)}_OnPointerEvent(t,n){if(!this._isExportToVideo){let e=0;"mouse"===n.pointerType&&(e=this._mousePointerLastButtons),this._PostToRuntimeMaybeSync(t,{"pointerId":n.pointerId,"pointerType":n.pointerType,"button":n.button,"buttons":n.buttons,"lastButtons":e,"clientX":n.clientX,"clientY":n.clientY+this._vkTranslateYOffset,"pageX":n.pageX,"pageY":n.pageY+this._vkTranslateYOffset,"movementX":n.movementX||0,"movementY":n.movementY||0,"width":n.width||0,"height":n.height||0,"pressure":n.pressure||0,"tangentialPressure":n["tangentialPressure"]||0,"tiltX":n.tiltX||0,"tiltY":n.tiltY||0,"twist":n["twist"]||0,"timeStamp":n.timeStamp},c),"mouse"===n.pointerType&&(this._mousePointerLastButtons=n.buttons)}}_OnPointerRawUpdate(e){this._OnPointerEvent("pointermove",e)}_OnTouchEvent(n,i){if(!this._isExportToVideo)for(let e=0,t=i.changedTouches.length;e<t;++e){const o=i.changedTouches[e];this._PostToRuntimeMaybeSync(n,{"pointerId":o.identifier,"pointerType":"touch","button":0,"buttons":0,"lastButtons":0,"clientX":o.clientX,"clientY":o.clientY+this._vkTranslateYOffset,"pageX":o.pageX,"pageY":o.pageY+this._vkTranslateYOffset,"movementX":i.movementX||0,"movementY":i.movementY||0,"width":2*(o["radiusX"]||o["webkitRadiusX"]||0),"height":2*(o["radiusY"]||o["webkitRadiusY"]||0),"pressure":o["force"]||o["webkitForce"]||0,"tangentialPressure":0,"tiltX":0,"tiltY":0,"twist":o["rotationAngle"]||0,"timeStamp":i.timeStamp},c)}}_HandlePointerDownFocus(e){window!==window.top&&window.focus(),this._IsElementCanvasOrDocument(e.target)&&document.activeElement&&!this._IsElementCanvasOrDocument(document.activeElement)&&document.activeElement.blur()}_IsElementCanvasOrDocument(e){return!e||e===document||e===window||e===document.body||"canvas"===e.tagName.toLowerCase()}_AttachDeviceOrientationEvent(){this._attachedDeviceOrientationEvent||(this._attachedDeviceOrientationEvent=!0,window.addEventListener("deviceorientation",e=>this._OnDeviceOrientation(e)),window.addEventListener("deviceorientationabsolute",e=>this._OnDeviceOrientationAbsolute(e)))}_AttachDeviceMotionEvent(){this._attachedDeviceMotionEvent||(this._attachedDeviceMotionEvent=!0,window.addEventListener("devicemotion",e=>this._OnDeviceMotion(e)))}_OnDeviceOrientation(e){this._isExportToVideo||this.PostToRuntime("deviceorientation",{"absolute":!!e["absolute"],"alpha":e["alpha"]||0,"beta":e["beta"]||0,"gamma":e["gamma"]||0,"timeStamp":e.timeStamp,"webkitCompassHeading":e["webkitCompassHeading"],"webkitCompassAccuracy":e["webkitCompassAccuracy"]},c)}_OnDeviceOrientationAbsolute(e){this._isExportToVideo||this.PostToRuntime("deviceorientationabsolute",{"absolute":!!e["absolute"],"alpha":e["alpha"]||0,"beta":e["beta"]||0,"gamma":e["gamma"]||0,"timeStamp":e.timeStamp},c)}_OnDeviceMotion(i){if(!this._isExportToVideo){let e=null;const o=i["acceleration"];o&&(e={"x":o["x"]||0,"y":o["y"]||0,"z":o["z"]||0});let t=null;const s=i["accelerationIncludingGravity"];s&&(t={"x":s["x"]||0,"y":s["y"]||0,"z":s["z"]||0});let n=null;const a=i["rotationRate"];a&&(n={"alpha":a["alpha"]||0,"beta":a["beta"]||0,"gamma":a["gamma"]||0}),this.PostToRuntime("devicemotion",{"acceleration":e,"accelerationIncludingGravity":t,"rotationRate":n,"interval":i["interval"],"timeStamp":i.timeStamp},c)}}_OnInvokeDownload(e){const t=e["url"],n=e["filename"],i=document.createElement("a"),o=document.body;i.textContent=n,i.href=t,i.download=n,o.appendChild(i),i.click(),o.removeChild(i)}async _OnLoadWebFonts(e){const t=e["webfonts"];await Promise.all(t.map(async e=>{const t=new FontFace(e.name,`url('${e.url}')`);document.fonts.add(t),await t.load()}))}async _OnRasterSvgImage(e){const t=e["blob"],n=e["imageWidth"],i=e["imageHeight"],o=e["surfaceWidth"],s=e["surfaceHeight"],a=e["imageBitmapOpts"],r=await self["C3_RasterSvgImageBlob"](t,n,i,o,s);let d;return{"imageBitmap":d=a?await createImageBitmap(r,a):await createImageBitmap(r),"transferables":[d]}}async _OnGetSvgImageSize(e){return self["C3_GetSvgImageSize"](e["blob"])}async _OnAddStylesheet(e){await AddStyleSheet(e["url"])}_PlayPendingMedia(){const e=[...this._mediaPendingPlay];if(this._mediaPendingPlay.clear(),!this._isSilent)for(const t of e){const n=t.play();n&&n.catch(e=>{this._mediaRemovedPendingPlay.has(t)||this._mediaPendingPlay.add(t)})}}TryPlayMedia(t){if("function"!=typeof t.play)throw new Error("missing play function");this._mediaRemovedPendingPlay.delete(t);let e;try{e=t.play()}catch(e){return void this._mediaPendingPlay.add(t)}e&&e.catch(e=>{this._mediaRemovedPendingPlay.has(t)||this._mediaPendingPlay.add(t)})}RemovePendingPlay(e){this._mediaPendingPlay.delete(e),this._mediaRemovedPendingPlay.add(e)}SetSilent(e){this._isSilent=!!e}_OnHideCordovaSplash(){navigator["splashscreen"]&&navigator["splashscreen"]["hide"]&&navigator["splashscreen"]["hide"]()}_OnDebugHighlight(e){const t=e["show"];if(t){this._debugHighlightElem||(this._debugHighlightElem=document.createElement("div"),this._debugHighlightElem.id="inspectOutline",document.body.appendChild(this._debugHighlightElem));const n=this._debugHighlightElem;n.style.display="",n.style.left=e["left"]-1+"px",n.style.top=e["top"]-1+"px",n.style.width=e["width"]+2+"px",n.style.height=e["height"]+2+"px",n.textContent=e["name"]}else this._debugHighlightElem&&(this._debugHighlightElem.style.display="none")}_OnRegisterSW(){window["C3_RegisterSW"]&&window["C3_RegisterSW"]()}_OnPostToDebugger(e){window["c3_postToMessagePort"]&&(e["from"]="runtime",window["c3_postToMessagePort"](e))}_InvokeFunctionFromJS(e,t){return this.PostToRuntimeAsync("js-invoke-function",{"name":e,"params":t})}_OnScriptCreateWorker(e){const t=e["url"],n=e["opts"],i=e["port2"],o=new Worker(t,n);o.postMessage({"type":"construct-worker-init","port2":i},[i])}_OnAlert(e){alert(e["message"])}_OnScreenReaderTextEvent(e){const t=e["type"];if("create"===t){const n=document.createElement("p");n.id="c3-sr-"+e["id"],n.textContent=e["text"],this._screenReaderTextWrap.appendChild(n)}else if("update"===t){const i=document.getElementById("c3-sr-"+e["id"]);i?i.textContent=e["text"]:console.warn("[Construct] Missing screen reader text with id "+e["id"])}else if("release"===t){const o=document.getElementById("c3-sr-"+e["id"]);o?o.remove():console.warn("[Construct] Missing screen reader text with id "+e["id"])}else console.warn(`[Construct] Unknown screen reader text update '${t}'`)}_SetExportingToVideo(e){this._isExportToVideo=!0;const t=document.createElement("h1");t.id="exportToVideoMessage",t.textContent=e["message"],document.body.prepend(t),document.body.classList.add("exportingToVideo"),this.GetRuntimeInterface().GetMainCanvas().style.display="",this._iRuntime.SetIsExportingToVideo(e["duration"])}_OnExportVideoProgress(e){this._exportVideoProgressMessage=e["message"],-1===this._exportVideoUpdateTimerId&&(this._exportVideoUpdateTimerId=setTimeout(()=>this._DoUpdateExportVideoProgressMessage(),250))}_DoUpdateExportVideoProgressMessage(){this._exportVideoUpdateTimerId=-1;const e=document.getElementById("exportToVideoMessage");e&&(e.textContent=this._exportVideoProgressMessage)}_OnExportedToVideo(e){window.c3_postToMessagePort({"type":"exported-video","arrayBuffer":e["arrayBuffer"],"contentType":e["contentType"],"time":e["time"]})}_OnExportedToImageSequence(e){window.c3_postToMessagePort({"type":"exported-image-sequence","blobArr":e["blobArr"],"time":e["time"],"gif":e["gif"]})}};a.AddDOMHandlerClass(j)}

// workers/jobSchedulerDom.js
"use strict";{const a="dispatchworker.js",b="jobworker.js";self.JobSchedulerDOM=class{constructor(t){this._runtimeInterface=t,this._maxNumWorkers=Math.min(navigator.hardwareConcurrency||2,16),this._dispatchWorker=null,this._jobWorkers=[],this._inputPort=null,this._outputPort=null}async Init(){if(this._hasInitialised)throw new Error("already initialised");this._hasInitialised=!0;const t=this._runtimeInterface.GetScriptFolder()+a,r=(this._dispatchWorker=await this._runtimeInterface.CreateWorker(t,{name:"DispatchWorker"}),new MessageChannel);this._inputPort=r.port1,this._dispatchWorker.postMessage({"type":"_init","in-port":r.port2},[r.port2]),this._outputPort=await this._CreateJobWorker()}async _CreateJobWorker(){const t=this._jobWorkers.length,r=this._runtimeInterface.GetScriptFolder()+b,e=await this._runtimeInterface.CreateWorker(r,{name:"JobWorker"+t}),o=new MessageChannel,s=new MessageChannel;return this._dispatchWorker.postMessage({"type":"_addJobWorker","port":o.port1},[o.port1]),e.postMessage({"type":"init","number":t,"dispatch-port":o.port2,"output-port":s.port2},[o.port2,s.port2]),this._jobWorkers.push(e),s.port1}GetPortData(){return{"inputPort":this._inputPort,"outputPort":this._outputPort,"maxNumWorkers":this._maxNumWorkers}}GetPortTransferables(){return[this._inputPort,this._outputPort]}}}

// scripts/plugins/Audio/dom/domSide.js
"use strict";{const a=180/Math.PI,b="audio";self.AudioDOMHandler=class extends self.DOMHandler{constructor(t){super(t,b),this._audioContext=null,this._destinationNode=null,this._hasUnblocked=!1,this._hasAttachedUnblockEvents=!1,this._unblockFunc=()=>this._UnblockAudioContext(),this._audioBuffers=[],this._audioInstances=[],this._lastAudioInstance=null,this._lastPlayedTags=[],this._loadedAudioUrls=new Set,this._lastTickCount=-1,this._pendingTags=new Map,this._masterVolume=1,this._isSilent=!1,this._timeScaleMode=0,this._timeScale=1,this._gameTime=0,this._panningModel="HRTF",this._distanceModel="inverse",this._refDistance=600,this._maxDistance=1e4,this._rolloffFactor=1,this._lastListenerPos=[0,0,0],this._lastListenerOrientation=[0,0,-1,0,1,0],this._playMusicAsSound=!1,this._lastMusicBuffer=null,this._effects=new Map,this._analysers=new Set,this._isPendingPostFxState=!1,this._hasStartedOfflineRender=!1,this._microphoneTag="",this._microphoneSource=null,self["C3Audio_OnMicrophoneStream"]=(t,e)=>this._OnMicrophoneStream(t,e),this._destMediaStreamNode=null,self["C3Audio_GetOutputStream"]=()=>this._OnGetOutputStream(),(self["C3Audio_DOMInterface"]=this).AddRuntimeMessageHandlers([["create-audio-context",t=>this._CreateAudioContext(t)],["play",t=>this._Play(t)],["stop",t=>this._Stop(t)],["stop-all",()=>this._StopAll()],["set-paused",t=>this._SetPaused(t)],["set-volume",t=>this._SetVolume(t)],["fade-volume",t=>this._FadeVolume(t)],["set-master-volume",t=>this._SetMasterVolume(t)],["set-muted",t=>this._SetMuted(t)],["set-silent",t=>this._SetSilent(t)],["set-looping",t=>this._SetLooping(t)],["set-playback-rate",t=>this._SetPlaybackRate(t)],["set-stereo-pan",t=>this._SetStereoPan(t)],["seek",t=>this._Seek(t)],["preload",t=>this._Preload(t)],["unload",t=>this._Unload(t)],["unload-all",()=>this._UnloadAll()],["set-suspended",t=>this._SetSuspended(t)],["add-effect",t=>this._AddEffect(t)],["set-effect-param",t=>this._SetEffectParam(t)],["remove-effects",t=>this._RemoveEffects(t)],["tick",t=>this._OnTick(t)],["load-state",t=>this._OnLoadState(t)],["offline-render-audio",t=>this._OnOfflineRenderAudio(t)],["offline-render-finish",()=>this._OnOfflineRenderFinish()]])}async _CreateAudioContext(t){if(t["usePlayMusicAsSoundWorkaround"]&&(this._playMusicAsSound=!0),this._timeScaleMode=t["timeScaleMode"],this._panningModel=["equalpower","HRTF","soundfield"][t["panningModel"]],this._distanceModel=["linear","inverse","exponential"][t["distanceModel"]],this._refDistance=t["refDistance"],this._maxDistance=t["maxDistance"],this._rolloffFactor=t["rolloffFactor"],this._iRuntime.IsExportingToVideo()){this._playMusicAsSound=!0;this._audioContext=new OfflineAudioContext({"numberOfChannels":2,"sampleRate":48e3,"length":Math.ceil(48e3*this._iRuntime.GetExportToVideoDuration())})}else this._audioContext=new AudioContext({"latencyHint":t["latencyHint"]}),this._AttachUnblockEvents(),this._audioContext.onstatechange=()=>{"running"!==this._audioContext.state&&this._AttachUnblockEvents(),this.PostToRuntime("audiocontext-state",{"audioContextState":this._audioContext.state})};this._destinationNode=this._audioContext["createGain"](),this._destinationNode["connect"](this._audioContext["destination"]);const e=t["listenerPos"];this._lastListenerPos[0]=e[0],this._lastListenerPos[1]=e[1],this._lastListenerPos[2]=e[2],this._audioContext["listener"]["setPosition"](e[0],e[1],e[2]),this._audioContext["listener"]["setOrientation"](...this._lastListenerOrientation),self["C3_GetAudioContextCurrentTime"]=()=>this.GetAudioCurrentTime();try{await Promise.all(t["preloadList"].map(t=>this._GetAudioBuffer(t["originalUrl"],t["url"],t["type"],!1)))}catch(t){console.error("[Construct] Preloading sounds failed: ",t)}return{"sampleRate":this._audioContext["sampleRate"],"audioContextState":this._audioContext.state,"outputLatency":this._audioContext["outputLatency"]||0}}_AttachUnblockEvents(){this._hasAttachedUnblockEvents||(this._hasUnblocked=!1,window.addEventListener("pointerup",this._unblockFunc,!0),window.addEventListener("touchend",this._unblockFunc,!0),window.addEventListener("click",this._unblockFunc,!0),window.addEventListener("keydown",this._unblockFunc,!0),this._hasAttachedUnblockEvents=!0)}_DetachUnblockEvents(){this._hasAttachedUnblockEvents&&(this._hasUnblocked=!0,window.removeEventListener("pointerup",this._unblockFunc,!0),window.removeEventListener("touchend",this._unblockFunc,!0),window.removeEventListener("click",this._unblockFunc,!0),window.removeEventListener("keydown",this._unblockFunc,!0),this._hasAttachedUnblockEvents=!1)}_UnblockAudioContext(){if(!this._hasUnblocked){const t=this._audioContext,e=("suspended"===t["state"]&&t["resume"]&&t["resume"](),t["createBuffer"](1,220,22050)),s=t["createBufferSource"]();s["buffer"]=e,s["connect"](t["destination"]),s["start"](0),"running"===t["state"]&&this._DetachUnblockEvents()}}_MatchTagLists(e,t){for(const s of t){let t=!1;for(const i of e)if(self.AudioDOMHandler.EqualsNoCase(i,s)){t=!0;break}if(!t)return!1}return!0}GetAudioContext(){return this._audioContext}GetAudioCurrentTime(){return this._audioContext["currentTime"]}GetDestinationNode(){return this._destinationNode}["GetAudioContextExtern"](){return this.GetAudioContext()}["GetDestinationNodeExtern"](){return this.GetDestinationNode()}GetDestinationForTag(t){const e=this._effects.get(t.toLowerCase());return e?e[0].GetInputNode():this.GetDestinationNode()}AddEffectForTag(t,e){t=t.toLowerCase();let s=this._effects.get(t);s||(s=[],this._effects.set(t,s)),e._SetIndex(s.length),e._SetTag(t),s.push(e),this._ReconnectEffects(t)}_ReconnectEffects(t){t=t.toLowerCase();let e=this.GetDestinationNode();const s=this._effects.get(t);if(s&&s.length){e=s[0].GetInputNode();for(let t=0,e=s.length;t<e;++t){const i=s[t];t+1===e?i.ConnectTo(this.GetDestinationNode()):i.ConnectTo(s[t+1].GetInputNode())}}for(const n of this.audioInstancesByEffectTag(t))n.Reconnect(e);this._microphoneSource&&this._microphoneTag===t&&(this._microphoneSource["disconnect"](),this._microphoneSource["connect"](e))}GetMasterVolume(){return this._masterVolume}IsSilent(){return this._isSilent}GetTimeScaleMode(){return this._timeScaleMode}GetTimeScale(){return this._timeScale}GetGameTime(){return this._gameTime}IsPlayMusicAsSound(){return this._playMusicAsSound}GetPanningModel(){return this._panningModel}GetDistanceModel(){return this._distanceModel}GetReferenceDistance(){return this._refDistance}GetMaxDistance(){return this._maxDistance}GetRolloffFactor(){return this._rolloffFactor}TryPlayMedia(t){this._iRuntime.TryPlayMedia(t)}RemovePendingPlay(t){this._iRuntime.RemovePendingPlay(t)}ReleaseInstancesForBuffer(s){let i=0;for(let t=0,e=this._audioInstances.length;t<e;++t){const n=this._audioInstances[t];(this._audioInstances[i]=n).GetBuffer()===s?n.Release():++i}this._audioInstances.length=i}ReleaseAllMusicBuffersExceptLast(){let s=0;for(let t=0,e=this._audioBuffers.length;t<e;++t){const i=this._audioBuffers[t];(this._audioBuffers[s]=i).IsMusic()&&i!==this._lastMusicBuffer?i.Release():++s}this._audioBuffers.length=s}*audioInstancesMatchingTags(t){if(0<t.length)for(const e of this._audioInstances)this._MatchTagLists(e.GetTags(),t)&&(yield e);else this._lastAudioInstance&&!this._lastAudioInstance.HasEnded()&&(yield this._lastAudioInstance)}*audioInstancesByEffectTag(t){if(t)for(const e of this._audioInstances)self.AudioDOMHandler.EqualsNoCase(e.GetEffectTag(),t)&&(yield e);else this._lastAudioInstance&&!this._lastAudioInstance.HasEnded()&&(yield this._lastAudioInstance)}async _GetAudioBuffer(t,e,s,i,n){for(const a of this._audioBuffers)if(a.GetUrl()===e)return i&&this._playMusicAsSound&&(this._lastMusicBuffer=a),await a.Load(),a;if(n)return null;i&&this._playMusicAsSound&&this.ReleaseAllMusicBuffersExceptLast();const o=self.C3AudioBuffer.Create(this,t,e,s,i);return this._audioBuffers.push(o),i&&this._playMusicAsSound&&(this._lastMusicBuffer=o),await o.Load(),this._loadedAudioUrls.has(t)||(this.PostToRuntime("buffer-metadata",{"originalUrl":t,"duration":o.GetDuration()}),this._loadedAudioUrls.add(t)),o}async _GetAudioInstance(t,e,s,i,n){for(const r of this._audioInstances)if(r.GetUrl()===e&&(r.CanBeRecycled()||n))return n&&this._playMusicAsSound&&(this._lastMusicBuffer=r.GetBuffer()),r.SetTags(i),r;const o=await this._GetAudioBuffer(t,e,s,n);if(o.WasReleased())throw new Error(`buffer '${t}' unloaded while loading`);const a=o.CreateInstance(i);return this._audioInstances.push(a),a}_AddPendingTags(t){const s=t.join(" ");let i=this._pendingTags.get(s);if(!i){let e=null;const n=new Promise(t=>e=t);i={pendingCount:0,promise:n,resolve:e},this._pendingTags.set(s,i)}i.pendingCount++}_RemovePendingTags(t){const e=t.join(" "),s=this._pendingTags.get(e);if(!s)throw new Error("expected pending tag");s.pendingCount--,0===s.pendingCount&&(s.resolve(),this._pendingTags.delete(e))}TagsReady(t){const e=(0===t.length?this._lastPlayedTags:t).join(" "),s=this._pendingTags.get(e);return s?s.promise:Promise.resolve()}_MaybeStartTicking(){if(0<this._analysers.size)this._StartTicking();else for(const t of this._audioInstances)if(t.IsActive())return void this._StartTicking()}Tick(){for(const s of this._analysers)s.Tick();const t=this.GetAudioCurrentTime();for(const i of this._audioInstances)i.Tick(t);const e=this._audioInstances.filter(t=>t.IsActive()).map(t=>t.GetState());this.PostToRuntime("state",{"tickCount":this._lastTickCount,"outputLatency":this._audioContext["outputLatency"]||0,"audioInstances":e,"analysers":[...this._analysers].map(t=>t.GetData())}),0===e.length&&0===this._analysers.size&&this._StopTicking()}PostTrigger(t,e,s){this.PostToRuntime("trigger",{"type":t,"tags":e,"aiid":s})}async _Play(t){const e=t["originalUrl"],s=t["url"],i=t["type"],n=t["isMusic"],o=t["tags"],a=t["isLooping"],r=t["vol"],l=t["pos"],u=t["panning"],d=t["stereoPan"];let h=t["off"];if(0<h&&!t["trueClock"])if(this._audioContext["getOutputTimestamp"]){const c=this._audioContext["getOutputTimestamp"]();h=h-c["performanceTime"]/1e3+c["contextTime"]}else h=h-performance.now()/1e3+this._audioContext["currentTime"];this._lastPlayedTags=o.slice(0),this._AddPendingTags(o);try{this._lastAudioInstance=await this._GetAudioInstance(e,s,i,o,n),u?(this._lastAudioInstance.SetPannerEnabled(!0),this._lastAudioInstance.SetPan(u["x"],u["y"],u["z"],u["angle"],u["innerAngle"],u["outerAngle"],u["outerGain"]),u.hasOwnProperty("uid")&&this._lastAudioInstance.SetUID(u["uid"])):"number"==typeof d&&0!==d?(this._lastAudioInstance.SetStereoPannerEnabled(!0),this._lastAudioInstance.SetStereoPan(d)):(this._lastAudioInstance.SetPannerEnabled(!1),this._lastAudioInstance.SetStereoPannerEnabled(!1)),this._lastAudioInstance.Play(a,r,l,h)}catch(t){return void console.error("[Construct] Audio: error starting playback: ",t)}finally{this._RemovePendingTags(o)}this._StartTicking()}_Stop(t){const e=t["tags"];for(const s of this.audioInstancesMatchingTags(e))s.Stop()}_StopAll(){for(const t of this._audioInstances)t.Stop()}_SetPaused(t){const e=t["tags"],s=t["paused"];for(const i of this.audioInstancesMatchingTags(e))s?i.Pause():i.Resume();this._MaybeStartTicking()}_SetVolume(t){const e=t["tags"],s=t["vol"];for(const i of this.audioInstancesMatchingTags(e))i.SetVolume(s)}_SetStereoPan(t){const e=t["tags"],s=t["p"];for(const i of this.audioInstancesMatchingTags(e))i.SetStereoPannerEnabled(!0),i.SetStereoPan(s)}async _FadeVolume(t){const e=t["tags"],s=t["vol"],i=t["duration"],n=t["stopOnEnd"];await this.TagsReady(e);for(const o of this.audioInstancesMatchingTags(e))o.FadeVolume(s,i,n);this._MaybeStartTicking()}_SetMasterVolume(t){this._masterVolume=t["vol"],this._destinationNode["gain"]["value"]=this._masterVolume}_SetMuted(t){const e=t["tags"],s=t["isMuted"];for(const i of this.audioInstancesMatchingTags(e))i.SetMuted(s)}_SetSilent(t){this._isSilent=t["isSilent"],this._iRuntime.SetSilent(this._isSilent);for(const e of this._audioInstances)e._UpdateMuted()}_SetLooping(t){const e=t["tags"],s=t["isLooping"];for(const i of this.audioInstancesMatchingTags(e))i.SetLooping(s)}async _SetPlaybackRate(t){const e=t["tags"],s=t["rate"];await this.TagsReady(e);for(const i of this.audioInstancesMatchingTags(e))i.SetPlaybackRate(s)}async _Seek(t){const e=t["tags"],s=t["pos"];await this.TagsReady(e);for(const i of this.audioInstancesMatchingTags(e))i.Seek(s)}async _Preload(t){const e=t["originalUrl"],s=t["url"],i=t["type"],n=t["isMusic"];try{await this._GetAudioInstance(e,s,i,"",n)}catch(t){console.error("[Construct] Audio: error preloading: ",t)}}async _Unload(t){const e=t["url"],s=t["type"],i=t["isMusic"],n=await this._GetAudioBuffer("",e,s,i,!0);if(n){n.Release(),this._lastMusicBuffer===n&&(this._lastMusicBuffer=null);const o=this._audioBuffers.indexOf(n);-1!==o&&this._audioBuffers.splice(o,1)}}_UnloadAll(){for(const t of this._audioBuffers)t.Release(),this._lastMusicBuffer===t&&(this._lastMusicBuffer=null);this._audioBuffers.length=0}_SetSuspended(t){const e=t["isSuspended"];!e&&this._audioContext["resume"]&&this._audioContext["resume"]();for(const s of this._audioInstances)s.SetSuspended(e);e&&this._audioContext["suspend"]&&this._audioContext["suspend"]()}_OnTick(t){if(this._timeScale=t["timeScale"],this._gameTime=t["gameTime"],this._lastTickCount=t["tickCount"],0!==this._timeScaleMode)for(const i of this._audioInstances)i._UpdatePlaybackRate();const e=t["listenerPos"],s=(!e||this._lastListenerPos[0]===e[0]&&this._lastListenerPos[1]===e[1]&&this._lastListenerPos[2]===e[2]||(this._lastListenerPos[0]=e[0],this._lastListenerPos[1]=e[1],this._lastListenerPos[2]=e[2],this._audioContext["listener"]["setPosition"](e[0],e[1],e[2])),t["listenerOrientation"]);if(s&&(this._lastListenerOrientation[0]!==s[0]||this._lastListenerOrientation[1]!==s[1]||this._lastListenerOrientation[2]!==s[2]||this._lastListenerOrientation[3]!==s[3]||this._lastListenerOrientation[4]!==s[4]||this._lastListenerOrientation[5]!==s[5])){for(let t=0;t<6;++t)this._lastListenerOrientation[t]=s[t];this._audioContext["listener"]["setOrientation"](...this._lastListenerOrientation)}for(const n of t["instPans"]){const o=n["uid"];for(const a of this._audioInstances)a.GetUID()===o&&a.SetPanXYZA(n["x"],n["y"],n["z"],n["angle"])}}async _AddEffect(t){const e=t["type"],s=t.hasOwnProperty("tags")?t["tags"]:[t["tag"]],i=t["params"];let n,o;if("convolution"===e)try{o=await this._GetAudioBuffer(t["bufferOriginalUrl"],t["bufferUrl"],t["bufferType"],!1)}catch(t){return void console.log("[Construct] Audio: error loading convolution: ",t)}for(const a of s){if("filter"===e)n=new self.C3AudioFilterFX(this,...i);else if("delay"===e)n=new self.C3AudioDelayFX(this,...i);else if("convolution"===e)(n=new self.C3AudioConvolveFX(this,o.GetAudioBuffer(),...i))._SetBufferInfo(t["bufferOriginalUrl"],t["bufferUrl"],t["bufferType"]);else if("flanger"===e)n=new self.C3AudioFlangerFX(this,...i);else if("phaser"===e)n=new self.C3AudioPhaserFX(this,...i);else if("gain"===e)n=new self.C3AudioGainFX(this,...i);else if("stereopan"===e)n=new self.C3AudioStereoPanFX(this,...i);else if("tremolo"===e)n=new self.C3AudioTremoloFX(this,...i);else if("ringmod"===e)n=new self.C3AudioRingModFX(this,...i);else if("distortion"===e)n=new self.C3AudioDistortionFX(this,...i);else if("compressor"===e)n=new self.C3AudioCompressorFX(this,...i);else{if("analyser"!==e)throw new Error("invalid effect type");n=new self.C3AudioAnalyserFX(this,...i)}this.AddEffectForTag(a,n)}this._PostUpdatedFxState()}_SetEffectParam(t){const e=t["tags"],s=t["index"],i=t["param"],n=t["value"],o=t["ramp"],a=t["time"];for(const r of e){const l=this._effects.get(r.toLowerCase());!l||s<0||s>=l.length||l[s].SetParam(i,n,o,a)}this._PostUpdatedFxState()}_RemoveEffects(t){const e=t["tags"];for(const s of e){const i=s.toLowerCase(),n=this._effects.get(i);if(!n||!n.length)return;for(const o of n)o.Release();this._effects.delete(i),this._ReconnectEffects(i)}}_AddAnalyser(t){this._analysers.add(t),this._MaybeStartTicking()}_RemoveAnalyser(t){this._analysers.delete(t)}_PostUpdatedFxState(){this._isPendingPostFxState||(this._isPendingPostFxState=!0,Promise.resolve().then(()=>this._DoPostUpdatedFxState()))}_DoPostUpdatedFxState(){const t={};for(const[e,s]of this._effects)t[e]=s.map(t=>t.GetState());this.PostToRuntime("fxstate",{"fxstate":t}),this._isPendingPostFxState=!1}async _OnLoadState(t){const e=t["saveLoadMode"];if(3!==e){const o=[];for(const a of this._audioInstances)a.IsMusic()&&1===e||!a.IsMusic()&&2===e?o.push(a):a.Release();this._audioInstances=o}for(const r of this._effects.values())for(const l of r)l.Release();this._effects.clear(),this._timeScale=t["timeScale"],this._gameTime=t["gameTime"];const s=t["listenerPos"],i=(this._lastListenerPos[0]=s[0],this._lastListenerPos[1]=s[1],this._lastListenerPos[2]=s[2],this._audioContext["listener"]["setPosition"](s[0],s[1],s[2]),t["listenerOrientation"]);if(Array.isArray(i)){for(let t=0;t<6;++t)this._lastListenerOrientation[t]=i[t];this._audioContext["listener"]["setOrientation"](...this._lastListenerOrientation)}this._isSilent=t["isSilent"],this._iRuntime.SetSilent(this._isSilent),this._masterVolume=t["masterVolume"],this._destinationNode["gain"]["value"]=this._masterVolume;const n=[];for(const u of Object.values(t["effects"]))n.push(Promise.all(u.map(t=>this._AddEffect(t))));await Promise.all(n),await Promise.all(t["playing"].map(t=>this._LoadAudioInstance(t,e))),this._MaybeStartTicking()}async _LoadAudioInstance(e,t){if(3!==t){const s=e["bufferOriginalUrl"],i=e["bufferUrl"],n=e["bufferType"],o=e["isMusic"],a=e["tags"],r=e["isLooping"],l=e["volume"],u=e["playbackTime"];if((!o||1!==t)&&(o||2!==t)){let t=null;try{t=await this._GetAudioInstance(s,i,n,a,o)}catch(t){return void console.error("[Construct] Audio: error loading audio state: ",t)}t.LoadPanState(e["pan"]),t.LoadStereoPanState(e["stereoPan"]),t.Play(r,l,u,0),e["isPlaying"]||t.Pause(),t._LoadAdditionalState(e)}}}_OnMicrophoneStream(t,e){this._microphoneSource&&this._microphoneSource["disconnect"](),this._microphoneTag=e.toLowerCase(),this._microphoneSource=this._audioContext["createMediaStreamSource"](t),this._microphoneSource["connect"](this.GetDestinationForTag(this._microphoneTag))}_OnGetOutputStream(){return this._destMediaStreamNode||(this._destMediaStreamNode=this._audioContext["createMediaStreamDestination"](),this._destinationNode["connect"](this._destMediaStreamNode)),this._destMediaStreamNode["stream"]}async _OnOfflineRenderAudio(t){try{const e=t["time"],s=this._audioContext["suspend"](e);this._hasStartedOfflineRender?this._audioContext["resume"]():(this._audioContext["startRendering"]().then(t=>this._OnOfflineRenderCompleted(t)).catch(t=>this._OnOfflineRenderError(t)),this._hasStartedOfflineRender=!0),await s}catch(t){this._OnOfflineRenderError(t)}}_OnOfflineRenderFinish(){this._audioContext["resume"]()}_OnOfflineRenderCompleted(s){const i=[];for(let t=0,e=s["numberOfChannels"];t<e;++t){const n=s["getChannelData"](t);i.push(n.buffer)}this._iRuntime.PostToRuntimeComponent("runtime","offline-audio-render-completed",{"duration":s["duration"],"length":s["length"],"numberOfChannels":s["numberOfChannels"],"sampleRate":s["sampleRate"],"channelData":i},null,i)}_OnOfflineRenderError(t){console.error("[Audio] Offline rendering error: ",t)}static EqualsNoCase(t,e){return t===e||t.normalize().toLowerCase()===e.normalize().toLowerCase()}static ToDegrees(t){return t*a}static DbToLinearNoCap(t){return Math.pow(10,t/20)}static DbToLinear(t){return Math.max(Math.min(self.AudioDOMHandler.DbToLinearNoCap(t),1),0)}static LinearToDbNoCap(t){return Math.log(t)/Math.log(10)*20}static LinearToDb(t){return self.AudioDOMHandler.LinearToDbNoCap(Math.max(Math.min(t,1),0))}static e4(t,e){return 1-Math.exp(-e*t)}},self.RuntimeInterface.AddDOMHandlerClass(self.AudioDOMHandler)}

// scripts/plugins/Audio/dom/audioBuffer.js
"use strict";self.C3AudioBuffer=class{constructor(t,e,i,s,o){this._audioDomHandler=t,this._originalUrl=e,this._url=i,this._type=s,this._isMusic=o,this._api="",this._loadState="not-loaded",this._loadPromise=null}Release(){this._loadState="not-loaded",this._audioDomHandler=null,this._loadPromise=null}WasReleased(){return!this._audioDomHandler}static Create(t,e,i,s,o){return new(!o||t.IsPlayMusicAsSound()?self.C3WebAudioBuffer:self.C3Html5AudioBuffer)(t,e,i,s,o)}CreateInstance(t){return new("html5"===this._api?self.C3Html5AudioInstance:self.C3WebAudioInstance)(this._audioDomHandler,this,t)}_Load(){}Load(){return this._loadPromise||(this._loadPromise=this._Load()),this._loadPromise}IsLoaded(){}IsLoadedAndDecoded(){}HasFailedToLoad(){return"failed"===this._loadState}GetAudioContext(){return this._audioDomHandler.GetAudioContext()}GetApi(){return this._api}GetOriginalUrl(){return this._originalUrl}GetUrl(){return this._url}GetContentType(){return this._type}IsMusic(){return this._isMusic}GetDuration(){}};

// scripts/plugins/Audio/dom/html5AudioBuffer.js
"use strict";self.C3Html5AudioBuffer=class extends self.C3AudioBuffer{constructor(e,t,o,i,d){super(e,t,o,i,d),this._api="html5",this._audioElem=new Audio,this._audioElem.crossOrigin="anonymous",this._audioElem.autoplay=!1,this._audioElem.preload="auto",this._loadResolve=null,this._loadReject=null,this._reachedCanPlayThrough=!1,this._audioElem.addEventListener("canplaythrough",()=>this._reachedCanPlayThrough=!0),this._outNode=this.GetAudioContext()["createGain"](),this._mediaSourceNode=null,this._audioElem.addEventListener("canplay",()=>{this._loadResolve&&(this._loadState="loaded",this._loadResolve(),this._loadResolve=null,this._loadReject=null),!this._mediaSourceNode&&this._audioElem&&(this._mediaSourceNode=this.GetAudioContext()["createMediaElementSource"](this._audioElem),this._mediaSourceNode["connect"](this._outNode))}),this.onended=null,this._audioElem.addEventListener("ended",()=>{this.onended&&this.onended()}),this._audioElem.addEventListener("error",e=>this._OnError(e))}Release(){this._audioDomHandler.ReleaseInstancesForBuffer(this),this._outNode["disconnect"](),this._outNode=null,this._mediaSourceNode["disconnect"](),this._mediaSourceNode=null,this._audioElem&&!this._audioElem.paused&&this._audioElem.pause(),this.onended=null,this._audioElem=null,super.Release()}_Load(){return this._loadState="loading",new Promise((e,t)=>{this._loadResolve=e,this._loadReject=t,this._audioElem.src=this._url})}_OnError(e){console.error(`[Construct] Audio '${this._url}' error: `,e),this._loadReject&&(this._loadState="failed",this._loadReject(e),this._loadResolve=null,this._loadReject=null)}IsLoaded(){const e=4<=this._audioElem["readyState"];return e&&(this._reachedCanPlayThrough=!0),e||this._reachedCanPlayThrough}IsLoadedAndDecoded(){return this.IsLoaded()}GetAudioElement(){return this._audioElem}GetOutputNode(){return this._outNode}GetDuration(){return this._audioElem["duration"]}};

// scripts/plugins/Audio/dom/webAudioBuffer.js
"use strict";self.C3WebAudioBuffer=class extends self.C3AudioBuffer{constructor(a,t,e,i,o){super(a,t,e,i,o),this._api="webaudio",this._audioData=null,this._audioBuffer=null}Release(){this._audioDomHandler.ReleaseInstancesForBuffer(this),this._audioData=null,this._audioBuffer=null,super.Release()}async _Fetch(){if(this._audioData)return this._audioData;const a=this._audioDomHandler.GetRuntimeInterface();if("cordova"===a.GetExportType()&&a.IsRelativeURL(this._url)&&a.IsFileProtocol())this._audioData=await a.CordovaFetchLocalFileAsArrayBuffer(this._url);else if("playable-ad-single-file"===a.GetExportType()&&a.IsRelativeURL(this._url)){const t=a["_PlayableAdFetchBlob"](this._url);this._audioData=await t.arrayBuffer()}else{const e=await fetch(this._url);if(!e.ok)throw new Error(`error fetching audio data: ${e.status} `+e.statusText);this._audioData=await e.arrayBuffer()}}async _Decode(){if(this._audioBuffer)return this._audioBuffer;const a=this._audioDomHandler.GetAudioContext();this._audioBuffer=await a["decodeAudioData"](this._audioData),this._audioData=null}async _Load(){try{this._loadState="loading",await this._Fetch(),this.WasReleased()||(await this._Decode(),this._loadState="loaded")}catch(a){this._loadState="failed",console.error(`[Construct] Failed to load audio '${this._url}': `,a)}}IsLoaded(){return!(!this._audioData&&!this._audioBuffer)}IsLoadedAndDecoded(){return!!this._audioBuffer}GetAudioBuffer(){return this._audioBuffer}GetDuration(){return this._audioBuffer?this._audioBuffer["duration"]:0}};

// scripts/plugins/Audio/dom/audioInstance.js
"use strict";{let s=0;self.C3AudioInstance=class{constructor(e,t,n){this._audioDomHandler=e,this._buffer=t,this._tags=n,this._aiId=s++,this._gainNode=this.GetAudioContext()["createGain"](),this._gainNode["connect"](this.GetDestinationNode()),this._pannerNode=null,this._isPannerEnabled=!1,this._pannerPosition=[0,0,0],this._pannerOrientation=[0,0,0],this._pannerConeParams=[0,0,0],this._stereoPannerNode=null,this._isStereoPannerEnabled=!1,this._stereoPan=0,this._isStopped=!0,this._isPaused=!1,this._resumeMe=!1,this._isLooping=!1,this._volume=1,this._isMuted=!1,this._playbackRate=1;const i=this._audioDomHandler.GetTimeScaleMode();this._isTimescaled=1===i&&!this.IsMusic()||2===i,this._instUid=-1,this._fadeEndTime=-1,this._stopOnFadeEnd=!1}Release(){this._audioDomHandler=null,this._buffer=null,this._pannerNode&&(this._pannerNode["disconnect"](),this._pannerNode=null),this._stereoPannerNode&&(this._stereoPannerNode["disconnect"](),this._stereoPannerNode=null),this._gainNode["disconnect"](),this._gainNode=null}GetAudioContext(){return this._audioDomHandler.GetAudioContext()}SetTags(e){this._tags=e}GetTags(){return this._tags}GetEffectTag(){return 0<this._tags.length?this._tags[0]:""}GetDestinationNode(){return this._audioDomHandler.GetDestinationForTag(this.GetEffectTag())}GetCurrentTime(){return this._isTimescaled?this._audioDomHandler.GetGameTime():performance.now()/1e3}GetOriginalUrl(){return this._buffer.GetOriginalUrl()}GetUrl(){return this._buffer.GetUrl()}GetContentType(){return this._buffer.GetContentType()}GetBuffer(){return this._buffer}IsMusic(){return this._buffer.IsMusic()}GetAiId(){return this._aiId}HasEnded(){}CanBeRecycled(){}IsPlaying(){return!this._isStopped&&!this._isPaused&&!this.HasEnded()}IsActive(){return!this._isStopped&&!this.HasEnded()}GetPlaybackTime(){}GetDuration(e){let t=this._buffer.GetDuration();return e&&(t/=this._playbackRate||.001),t}Play(e,t,n,i){}Stop(){}Pause(){}IsPaused(){return this._isPaused}Resume(){}SetVolume(e){this._volume=e,this._gainNode["gain"]["cancelScheduledValues"](0),this._fadeEndTime=-1,this._gainNode["gain"]["value"]=this.GetOutputVolume()}FadeVolume(e,t,n){if(!this.IsMuted()){const i=this._gainNode["gain"],s=(i["cancelScheduledValues"](0),this._audioDomHandler.GetAudioCurrentTime()),a=s+t;i["setValueAtTime"](i["value"],s),i["linearRampToValueAtTime"](e,a),this._volume=e,this._fadeEndTime=a,this._stopOnFadeEnd=n}}_UpdateVolume(){this.SetVolume(this._volume)}Tick(e){-1!==this._fadeEndTime&&e>=this._fadeEndTime&&(this._fadeEndTime=-1,this._stopOnFadeEnd&&this.Stop(),this._audioDomHandler.PostTrigger("fade-ended",this._tags,this._aiId))}GetOutputVolume(){const e=this._volume;return isFinite(e)?e:0}SetMuted(e){this._isMuted!==(e=!!e)&&(this._isMuted=e,this._UpdateMuted())}IsMuted(){return this._isMuted}IsSilent(){return this._audioDomHandler.IsSilent()}_UpdateMuted(){}SetLooping(e){}IsLooping(){return this._isLooping}SetPlaybackRate(e){this._playbackRate!==e&&(this._playbackRate=e,this._UpdatePlaybackRate())}_UpdatePlaybackRate(){}GetPlaybackRate(){return this._playbackRate}Seek(e){}SetSuspended(e){}SetPannerEnabled(e){this._isPannerEnabled!==(e=!!e)&&(this._isPannerEnabled=e,(this._isPannerEnabled?(this.SetStereoPannerEnabled(!1),this._pannerNode||(this._pannerNode=this.GetAudioContext()["createPanner"](),this._pannerNode["panningModel"]=this._audioDomHandler.GetPanningModel(),this._pannerNode["distanceModel"]=this._audioDomHandler.GetDistanceModel(),this._pannerNode["refDistance"]=this._audioDomHandler.GetReferenceDistance(),this._pannerNode["maxDistance"]=this._audioDomHandler.GetMaxDistance(),this._pannerNode["rolloffFactor"]=this._audioDomHandler.GetRolloffFactor()),this._gainNode["disconnect"](),this._gainNode["connect"](this._pannerNode),this._pannerNode):(this._pannerNode["disconnect"](),this._gainNode["disconnect"](),this._gainNode))["connect"](this.GetDestinationNode()))}SetPan(e,t,n,i,s,a,o){if(this._isPannerEnabled){this.SetPanXYZA(e,t,n,i);const r=self.AudioDOMHandler.ToDegrees;this._pannerConeParams[0]!==r(s)&&(this._pannerConeParams[0]=r(s),this._pannerNode["coneInnerAngle"]=r(s)),this._pannerConeParams[1]!==r(a)&&(this._pannerConeParams[1]=r(a),this._pannerNode["coneOuterAngle"]=r(a)),this._pannerConeParams[2]!==o&&(this._pannerConeParams[2]=o,this._pannerNode["coneOuterGain"]=o)}}SetPanXYZA(e,t,n,i){if(this._isPannerEnabled){const s=this._pannerPosition,a=this._pannerOrientation,o=Math.cos(i),r=Math.sin(i);s[0]===e&&s[1]===t&&s[2]===n||(s[0]=e,s[1]=t,s[2]=n,this._pannerNode["setPosition"](...s)),a[0]===o&&a[1]===r&&0===a[2]||(a[0]=o,a[1]=r,a[2]=0,this._pannerNode["setOrientation"](...a))}}SetStereoPannerEnabled(e){this._isStereoPannerEnabled!==(e=!!e)&&(this._isStereoPannerEnabled=e,(this._isStereoPannerEnabled?(this.SetPannerEnabled(!1),this._stereoPannerNode=this.GetAudioContext()["createStereoPanner"](),this._gainNode["disconnect"](),this._gainNode["connect"](this._stereoPannerNode),this._stereoPannerNode):(this._stereoPannerNode["disconnect"](),this._stereoPannerNode=null,this._gainNode["disconnect"](),this._gainNode))["connect"](this.GetDestinationNode()))}SetStereoPan(e){this._isStereoPannerEnabled&&this._stereoPan!==e&&(this._stereoPannerNode["pan"]["value"]=e,this._stereoPan=e)}SetUID(e){this._instUid=e}GetUID(){return this._instUid}GetResumePosition(){}Reconnect(e){const t=this._stereoPannerNode||this._pannerNode||this._gainNode;t["disconnect"](),t["connect"](e)}GetState(){return{"aiid":this.GetAiId(),"tags":this._tags,"duration":this.GetDuration(),"volume":-1===this._fadeEndTime?this._volume:this._gainNode["gain"]["value"],"isPlaying":this.IsPlaying(),"playbackTime":this.GetPlaybackTime(),"playbackRate":this.GetPlaybackRate(),"uid":this._instUid,"bufferOriginalUrl":this.GetOriginalUrl(),"bufferUrl":"","bufferType":this.GetContentType(),"isMusic":this.IsMusic(),"isLooping":this.IsLooping(),"isMuted":this.IsMuted(),"resumePosition":this.GetResumePosition(),"pan":this.GetPanState(),"stereoPan":this.GetStereoPanState()}}_LoadAdditionalState(e){this.SetPlaybackRate(e["playbackRate"]),this.SetMuted(e["isMuted"])}GetPanState(){if(!this._pannerNode)return null;const e=this._pannerNode;return{"pos":this._pannerPosition,"orient":this._pannerOrientation,"cia":e["coneInnerAngle"],"coa":e["coneOuterAngle"],"cog":e["coneOuterGain"],"uid":this._instUid}}LoadPanState(e){if(e){this.SetPannerEnabled(!0);const t=this._pannerNode,n=e["pos"],i=(this._pannerPosition[0]=n[0],this._pannerPosition[1]=n[1],this._pannerPosition[2]=n[2],e["orient"]);this._pannerOrientation[0]=i[0],this._pannerOrientation[1]=i[1],this._pannerOrientation[2]=i[2],t["setPosition"](...this._pannerPosition),t["setOrientation"](...this._pannerOrientation),this._pannerConeParams[0]=e["cia"],this._pannerConeParams[1]=e["coa"],this._pannerConeParams[2]=e["cog"],t["coneInnerAngle"]=e["cia"],t["coneOuterAngle"]=e["coa"],t["coneOuterGain"]=e["cog"],this._instUid=e["uid"]}else this.SetPannerEnabled(!1)}GetStereoPanState(){return this._stereoPannerNode?this._stereoPan:null}LoadStereoPanState(e){"number"!=typeof e?this.SetStereoPannerEnabled(!1):(this.SetStereoPannerEnabled(!0),this.SetStereoPan(e))}}}

// scripts/plugins/Audio/dom/html5AudioInstance.js
"use strict";self.C3Html5AudioInstance=class extends self.C3AudioInstance{constructor(e,t,i){super(e,t,i),this._buffer.GetOutputNode()["connect"](this._gainNode),this._buffer.onended=()=>this._OnEnded()}Release(){this.Stop(),this._buffer.GetOutputNode()["disconnect"](),super.Release()}GetAudioElement(){return this._buffer.GetAudioElement()}_OnEnded(){this._isStopped=!0,this._instUid=-1,this._audioDomHandler.PostTrigger("ended",this._tags,this._aiId)}HasEnded(){return this.GetAudioElement()["ended"]}CanBeRecycled(){return!!this._isStopped||this.HasEnded()}GetPlaybackTime(){let e=this.GetAudioElement()["currentTime"];return e=this._isLooping?e:Math.min(e,this.GetDuration())}Play(e,t,i,s){const d=this.GetAudioElement();if(1!==d.playbackRate&&(d.playbackRate=1),d.loop!==e&&(d.loop=e),this.SetVolume(t),this._isMuted=!1,d.muted&&(d.muted=!1),d.currentTime!==i)try{d.currentTime=i}catch(e){console.warn(`[Construct] Exception seeking audio '${this._buffer.GetUrl()}' to position '${i}': `,e)}this._audioDomHandler.TryPlayMedia(d),this._isStopped=!1,this._isPaused=!1,this._isLooping=e,this._playbackRate=1}Stop(){const e=this.GetAudioElement();e.paused||e.pause(),this._audioDomHandler.RemovePendingPlay(e),this._isStopped=!0,this._isPaused=!1,this._instUid=-1}Pause(){if(!(this._isPaused||this._isStopped||this.HasEnded())){const e=this.GetAudioElement();e.paused||e.pause(),this._audioDomHandler.RemovePendingPlay(e),this._isPaused=!0}}Resume(){!this._isPaused||this._isStopped||this.HasEnded()||(this._audioDomHandler.TryPlayMedia(this.GetAudioElement()),this._isPaused=!1)}_UpdateMuted(){this.GetAudioElement().muted=this._isMuted||this.IsSilent()}SetLooping(e){this._isLooping!==(e=!!e)&&(this._isLooping=e,this.GetAudioElement().loop=e)}_UpdatePlaybackRate(){let t=this._playbackRate;this._isTimescaled&&(t*=this._audioDomHandler.GetTimeScale());try{this.GetAudioElement()["playbackRate"]=t}catch(e){console.warn(`[Construct] Unable to set playback rate '${t}':`,e)}}Seek(t){if(!this._isStopped&&!this.HasEnded())try{this.GetAudioElement()["currentTime"]=t}catch(e){console.warn(`[Construct] Error seeking audio to '${t}': `,e)}}GetResumePosition(){return this.GetPlaybackTime()}SetSuspended(e){e?this.IsPlaying()?(this.GetAudioElement()["pause"](),this._resumeMe=!0):this._resumeMe=!1:this._resumeMe&&(this._audioDomHandler.TryPlayMedia(this.GetAudioElement()),this._resumeMe=!1)}};

// scripts/plugins/Audio/dom/webAudioInstance.js
"use strict";self.C3WebAudioInstance=class extends self.C3AudioInstance{constructor(e,t,s){super(e,t,s),this._bufferSource=null,this._onended_handler=e=>this._OnEnded(e),this._hasPlaybackEnded=!0,this._activeSource=null,this._playStartTime=0,this._playFromSeekPos=0,this._resumePosition=0,this._muteVol=1}Release(){this.Stop(),this._ReleaseBufferSource(),this._onended_handler=null,super.Release()}_ReleaseBufferSource(){this._bufferSource&&(this._bufferSource["onended"]=null,this._bufferSource["disconnect"](),this._bufferSource["buffer"]=null),this._bufferSource=null,this._activeSource=null}_OnEnded(e){this._isPaused||this._resumeMe||e.target===this._activeSource&&(this._hasPlaybackEnded=!0,this._isStopped=!0,this._instUid=-1,this._ReleaseBufferSource(),this._audioDomHandler.PostTrigger("ended",this._tags,this._aiId))}HasEnded(){return!(!this._isStopped&&this._bufferSource&&this._bufferSource["loop"]||this._isPaused)&&this._hasPlaybackEnded}CanBeRecycled(){return!(this._bufferSource&&!this._isStopped)||this.HasEnded()}GetPlaybackTime(){let e=0;return e=this._isPaused?this._resumePosition:this._playFromSeekPos+(this.GetCurrentTime()-this._playStartTime)*this._playbackRate,e=this._isLooping?e:Math.min(e,this.GetDuration())}Play(e,t,s,i){this._isMuted=!1,this._muteVol=1,this.SetVolume(t),this._ReleaseBufferSource(),this._bufferSource=this.GetAudioContext()["createBufferSource"](),this._bufferSource["buffer"]=this._buffer.GetAudioBuffer(),this._bufferSource["connect"](this._gainNode),this._activeSource=this._bufferSource,this._bufferSource["onended"]=this._onended_handler,this._bufferSource["loop"]=e,this._bufferSource["start"](i,s),this._hasPlaybackEnded=!1,this._isStopped=!1,this._isPaused=!1,this._isLooping=e,this._playbackRate=1,this._playStartTime=this.GetCurrentTime(),this._playFromSeekPos=s}Stop(){if(this._bufferSource)try{this._bufferSource["stop"](0)}catch(e){}this._isStopped=!0,this._isPaused=!1,this._instUid=-1}Pause(){this._isPaused||this._isStopped||this.HasEnded()||(this._resumePosition=this.GetPlaybackTime(),this._isLooping&&(this._resumePosition%=this.GetDuration()),this._isPaused=!0,this._bufferSource["stop"](0))}Resume(){!this._isPaused||this._isStopped||this.HasEnded()||(this._ReleaseBufferSource(),this._bufferSource=this.GetAudioContext()["createBufferSource"](),this._bufferSource["buffer"]=this._buffer.GetAudioBuffer(),this._bufferSource["connect"](this._gainNode),this._activeSource=this._bufferSource,this._bufferSource["onended"]=this._onended_handler,this._bufferSource["loop"]=this._isLooping,this._UpdateVolume(),this._UpdatePlaybackRate(),this._bufferSource["start"](0,this._resumePosition),this._playStartTime=this.GetCurrentTime(),this._playFromSeekPos=this._resumePosition,this._isPaused=!1)}GetOutputVolume(){return super.GetOutputVolume()*this._muteVol}_UpdateMuted(){this._muteVol=this._isMuted||this.IsSilent()?0:1,this._UpdateVolume()}SetLooping(e){this._isLooping!==(e=!!e)&&(this._isLooping=e,this._bufferSource)&&(this._bufferSource["loop"]=e)}_UpdatePlaybackRate(){let e=this._playbackRate;this._isTimescaled&&(e*=this._audioDomHandler.GetTimeScale()),this._bufferSource&&(this._bufferSource["playbackRate"]["value"]=e)}Seek(e){this._isStopped||this.HasEnded()||(this._isPaused?this._resumePosition=e:(this.Pause(),this._resumePosition=e,this.Resume()))}GetResumePosition(){return this._resumePosition}SetSuspended(e){e?this.IsPlaying()?(this._resumeMe=!0,this._resumePosition=this.GetPlaybackTime(),this._isLooping&&(this._resumePosition%=this.GetDuration()),this._bufferSource["stop"](0)):this._resumeMe=!1:this._resumeMe&&(this._ReleaseBufferSource(),this._bufferSource=this.GetAudioContext()["createBufferSource"](),this._bufferSource["buffer"]=this._buffer.GetAudioBuffer(),this._bufferSource["connect"](this._gainNode),this._activeSource=this._bufferSource,this._bufferSource["onended"]=this._onended_handler,this._bufferSource["loop"]=this._isLooping,this._UpdateVolume(),this._UpdatePlaybackRate(),this._bufferSource["start"](0,this._resumePosition),this._playStartTime=this.GetCurrentTime(),this._playFromSeekPos=this._resumePosition,this._resumeMe=!1)}_LoadAdditionalState(e){super._LoadAdditionalState(e),this._resumePosition=e["resumePosition"]}};

// scripts/plugins/Audio/dom/effects.js
"use strict";{class a{constructor(e){this._audioDomHandler=e,this._audioContext=e.GetAudioContext(),this._index=-1,this._tag="",this._type="",this._params=null}Release(){this._audioContext=null}_SetIndex(e){this._index=e}GetIndex(){return this._index}_SetTag(e){this._tag=e}GetTag(){return this._tag}CreateGain(){return this._audioContext["createGain"]()}GetInputNode(){}ConnectTo(e){}SetAudioParam(e,t,i,s){if(e["cancelScheduledValues"](0),0===s)e["value"]=t;else{const o=this._audioContext["currentTime"];switch(s+=o,i){case 0:e["setValueAtTime"](t,s);break;case 1:e["setValueAtTime"](e["value"],o),e["linearRampToValueAtTime"](t,s);break;case 2:e["setValueAtTime"](e["value"],o),e["exponentialRampToValueAtTime"](t,s)}}}GetState(){return{"type":this._type,"tag":this._tag,"params":this._params}}}self.C3AudioFilterFX=class extends a{constructor(e,t,i,s,o,a,n){super(e),this._type="filter",this._params=[t,i,s,o,a,n],this._inputNode=this.CreateGain(),this._wetNode=this.CreateGain(),this._wetNode["gain"]["value"]=n,this._dryNode=this.CreateGain(),this._dryNode["gain"]["value"]=1-n,this._filterNode=this._audioContext["createBiquadFilter"](),this._filterNode["type"]=t,this._filterNode["frequency"]["value"]=i,this._filterNode["detune"]["value"]=s,this._filterNode["Q"]["value"]=o,this._filterNode["gain"]["vlaue"]=a,this._inputNode["connect"](this._filterNode),this._inputNode["connect"](this._dryNode),this._filterNode["connect"](this._wetNode)}Release(){this._inputNode["disconnect"](),this._filterNode["disconnect"](),this._wetNode["disconnect"](),this._dryNode["disconnect"](),super.Release()}ConnectTo(e){this._wetNode["disconnect"](),this._wetNode["connect"](e),this._dryNode["disconnect"](),this._dryNode["connect"](e)}GetInputNode(){return this._inputNode}SetParam(e,t,i,s){switch(e){case 0:t=Math.max(Math.min(t/100,1),0),this._params[5]=t,this.SetAudioParam(this._wetNode["gain"],t,i,s),this.SetAudioParam(this._dryNode["gain"],1-t,i,s);break;case 1:this._params[1]=t,this.SetAudioParam(this._filterNode["frequency"],t,i,s);break;case 2:this._params[2]=t,this.SetAudioParam(this._filterNode["detune"],t,i,s);break;case 3:this._params[3]=t,this.SetAudioParam(this._filterNode["Q"],t,i,s);break;case 4:this._params[4]=t,this.SetAudioParam(this._filterNode["gain"],t,i,s)}}},self.C3AudioDelayFX=class extends a{constructor(e,t,i,s){super(e),this._type="delay",this._params=[t,i,s],this._inputNode=this.CreateGain(),this._wetNode=this.CreateGain(),this._wetNode["gain"]["value"]=s,this._dryNode=this.CreateGain(),this._dryNode["gain"]["value"]=1-s,this._mainNode=this.CreateGain(),this._delayNode=this._audioContext["createDelay"](t),this._delayNode["delayTime"]["value"]=t,this._delayGainNode=this.CreateGain(),this._delayGainNode["gain"]["value"]=i,this._inputNode["connect"](this._mainNode),this._inputNode["connect"](this._dryNode),this._mainNode["connect"](this._wetNode),this._mainNode["connect"](this._delayNode),this._delayNode["connect"](this._delayGainNode),this._delayGainNode["connect"](this._mainNode)}Release(){this._inputNode["disconnect"](),this._wetNode["disconnect"](),this._dryNode["disconnect"](),this._mainNode["disconnect"](),this._delayNode["disconnect"](),this._delayGainNode["disconnect"](),super.Release()}ConnectTo(e){this._wetNode["disconnect"](),this._wetNode["connect"](e),this._dryNode["disconnect"](),this._dryNode["connect"](e)}GetInputNode(){return this._inputNode}SetParam(e,t,i,s){const o=self.AudioDOMHandler.DbToLinear;switch(e){case 0:t=Math.max(Math.min(t/100,1),0),this._params[2]=t,this.SetAudioParam(this._wetNode["gain"],t,i,s),this.SetAudioParam(this._dryNode["gain"],1-t,i,s);break;case 4:this._params[1]=o(t),this.SetAudioParam(this._delayGainNode["gain"],o(t),i,s);break;case 5:this._params[0]=t,this.SetAudioParam(this._delayNode["delayTime"],t,i,s)}}},self.C3AudioConvolveFX=class extends a{constructor(e,t,i,s){super(e),this._type="convolution",this._params=[i,s],this._bufferOriginalUrl="",this._bufferUrl="",this._bufferType="",this._inputNode=this.CreateGain(),this._wetNode=this.CreateGain(),this._wetNode["gain"]["value"]=s,this._dryNode=this.CreateGain(),this._dryNode["gain"]["value"]=1-s,this._convolveNode=this._audioContext["createConvolver"](),this._convolveNode["normalize"]=i,this._convolveNode["buffer"]=t,this._inputNode["connect"](this._convolveNode),this._inputNode["connect"](this._dryNode),this._convolveNode["connect"](this._wetNode)}Release(){this._inputNode["disconnect"](),this._convolveNode["disconnect"](),this._wetNode["disconnect"](),this._dryNode["disconnect"](),super.Release()}ConnectTo(e){this._wetNode["disconnect"](),this._wetNode["connect"](e),this._dryNode["disconnect"](),this._dryNode["connect"](e)}GetInputNode(){return this._inputNode}SetParam(e,t,i,s){0===e&&(t=Math.max(Math.min(t/100,1),0),this._params[1]=t,this.SetAudioParam(this._wetNode["gain"],t,i,s),this.SetAudioParam(this._dryNode["gain"],1-t,i,s))}_SetBufferInfo(e,t,i){this._bufferOriginalUrl=e,this._bufferUrl=t,this._bufferType=i}GetState(){const e=super.GetState();return e["bufferOriginalUrl"]=this._bufferOriginalUrl,e["bufferUrl"]="",e["bufferType"]=this._bufferType,e}},self.C3AudioFlangerFX=class extends a{constructor(e,t,i,s,o,a){super(e),this._type="flanger",this._params=[t,i,s,o,a],this._inputNode=this.CreateGain(),this._dryNode=this.CreateGain(),this._dryNode["gain"]["value"]=1-a/2,this._wetNode=this.CreateGain(),this._wetNode["gain"]["value"]=a/2,this._feedbackNode=this.CreateGain(),this._feedbackNode["gain"]["value"]=o,this._delayNode=this._audioContext["createDelay"](t+i),this._delayNode["delayTime"]["value"]=t,this._oscNode=this._audioContext["createOscillator"](),this._oscNode["frequency"]["value"]=s,this._oscGainNode=this.CreateGain(),this._oscGainNode["gain"]["value"]=i,this._inputNode["connect"](this._delayNode),this._inputNode["connect"](this._dryNode),this._delayNode["connect"](this._wetNode),this._delayNode["connect"](this._feedbackNode),this._feedbackNode["connect"](this._delayNode),this._oscNode["connect"](this._oscGainNode),this._oscGainNode["connect"](this._delayNode["delayTime"]),this._oscNode["start"](0)}Release(){this._oscNode["stop"](0),this._inputNode["disconnect"](),this._delayNode["disconnect"](),this._oscNode["disconnect"](),this._oscGainNode["disconnect"](),this._dryNode["disconnect"](),this._wetNode["disconnect"](),this._feedbackNode["disconnect"](),super.Release()}ConnectTo(e){this._wetNode["disconnect"](),this._wetNode["connect"](e),this._dryNode["disconnect"](),this._dryNode["connect"](e)}GetInputNode(){return this._inputNode}SetParam(e,t,i,s){switch(e){case 0:t=Math.max(Math.min(t/100,1),0),this._params[4]=t,this.SetAudioParam(this._wetNode["gain"],t/2,i,s),this.SetAudioParam(this._dryNode["gain"],1-t/2,i,s);break;case 6:this._params[1]=t/1e3,this.SetAudioParam(this._oscGainNode["gain"],t/1e3,i,s);break;case 7:this._params[2]=t,this.SetAudioParam(this._oscNode["frequency"],t,i,s);break;case 8:this._params[3]=t/100,this.SetAudioParam(this._feedbackNode["gain"],t/100,i,s)}}},self.C3AudioPhaserFX=class extends a{constructor(e,t,i,s,o,a,n){super(e),this._type="phaser",this._params=[t,i,s,o,a,n],this._inputNode=this.CreateGain(),this._dryNode=this.CreateGain(),this._dryNode["gain"]["value"]=1-n/2,this._wetNode=this.CreateGain(),this._wetNode["gain"]["value"]=n/2,this._filterNode=this._audioContext["createBiquadFilter"](),this._filterNode["type"]="allpass",this._filterNode["frequency"]["value"]=t,this._filterNode["detune"]["value"]=i,this._filterNode["Q"]["value"]=s,this._oscNode=this._audioContext["createOscillator"](),this._oscNode["frequency"]["value"]=a,this._oscGainNode=this.CreateGain(),this._oscGainNode["gain"]["value"]=o,this._inputNode["connect"](this._filterNode),this._inputNode["connect"](this._dryNode),this._filterNode["connect"](this._wetNode),this._oscNode["connect"](this._oscGainNode),this._oscGainNode["connect"](this._filterNode["frequency"]),this._oscNode["start"](0)}Release(){this._oscNode["stop"](0),this._inputNode["disconnect"](),this._filterNode["disconnect"](),this._oscNode["disconnect"](),this._oscGainNode["disconnect"](),this._dryNode["disconnect"](),this._wetNode["disconnect"](),super.Release()}ConnectTo(e){this._wetNode["disconnect"](),this._wetNode["connect"](e),this._dryNode["disconnect"](),this._dryNode["connect"](e)}GetInputNode(){return this._inputNode}SetParam(e,t,i,s){switch(e){case 0:t=Math.max(Math.min(t/100,1),0),this._params[5]=t,this.SetAudioParam(this._wetNode["gain"],t/2,i,s),this.SetAudioParam(this._dryNode["gain"],1-t/2,i,s);break;case 1:this._params[0]=t,this.SetAudioParam(this._filterNode["frequency"],t,i,s);break;case 2:this._params[1]=t,this.SetAudioParam(this._filterNode["detune"],t,i,s);break;case 3:this._params[2]=t,this.SetAudioParam(this._filterNode["Q"],t,i,s);break;case 6:this._params[3]=t,this.SetAudioParam(this._oscGainNode["gain"],t,i,s);break;case 7:this._params[4]=t,this.SetAudioParam(this._oscNode["frequency"],t,i,s)}}},self.C3AudioGainFX=class extends a{constructor(e,t){super(e),this._type="gain",this._params=[t],this._node=this.CreateGain(),this._node["gain"]["value"]=t}Release(){this._node["disconnect"](),super.Release()}ConnectTo(e){this._node["disconnect"](),this._node["connect"](e)}GetInputNode(){return this._node}SetParam(e,t,i,s){const o=self.AudioDOMHandler.DbToLinear;4===e&&(this._params[0]=o(t),this.SetAudioParam(this._node["gain"],o(t),i,s))}},self.C3AudioStereoPanFX=class extends a{constructor(e,t){super(e),this._type="stereopan",this._params=[t],this._node=this._audioContext["createStereoPanner"](),this._node["pan"]["value"]=t}Release(){this._node["disconnect"](),super.Release()}ConnectTo(e){this._node["disconnect"](),this._node["connect"](e)}GetInputNode(){return this._node}SetParam(e,t,i,s){t=Math.min(Math.max(t/100,-1),1),9===e&&(this._params[0]=t,this.SetAudioParam(this._node["pan"],t,i,s))}},self.C3AudioTremoloFX=class extends a{constructor(e,t,i){super(e),this._type="tremolo",this._params=[t,i],this._node=this.CreateGain(),this._node["gain"]["value"]=1-i/2,this._oscNode=this._audioContext["createOscillator"](),this._oscNode["frequency"]["value"]=t,this._oscGainNode=this.CreateGain(),this._oscGainNode["gain"]["value"]=i/2,this._oscNode["connect"](this._oscGainNode),this._oscGainNode["connect"](this._node["gain"]),this._oscNode["start"](0)}Release(){this._oscNode["stop"](0),this._oscNode["disconnect"](),this._oscGainNode["disconnect"](),this._node["disconnect"](),super.Release()}ConnectTo(e){this._node["disconnect"](),this._node["connect"](e)}GetInputNode(){return this._node}SetParam(e,t,i,s){switch(e){case 0:t=Math.max(Math.min(t/100,1),0),this._params[1]=t,this.SetAudioParam(this._node["gain"],1-t/2,i,s),this.SetAudioParam(this._oscGainNode["gain"],t/2,i,s);break;case 7:this._params[0]=t,this.SetAudioParam(this._oscNode["frequency"],t,i,s)}}},self.C3AudioRingModFX=class extends a{constructor(e,t,i){super(e),this._type="ringmod",this._params=[t,i],this._inputNode=this.CreateGain(),this._wetNode=this.CreateGain(),this._wetNode["gain"]["value"]=i,this._dryNode=this.CreateGain(),this._dryNode["gain"]["value"]=1-i,this._ringNode=this.CreateGain(),this._ringNode["gain"]["value"]=0,this._oscNode=this._audioContext["createOscillator"](),this._oscNode["frequency"]["value"]=t,this._oscNode["connect"](this._ringNode["gain"]),this._oscNode["start"](0),this._inputNode["connect"](this._ringNode),this._inputNode["connect"](this._dryNode),this._ringNode["connect"](this._wetNode)}Release(){this._oscNode["stop"](0),this._oscNode["disconnect"](),this._ringNode["disconnect"](),this._inputNode["disconnect"](),this._wetNode["disconnect"](),this._dryNode["disconnect"](),super.Release()}ConnectTo(e){this._wetNode["disconnect"](),this._wetNode["connect"](e),this._dryNode["disconnect"](),this._dryNode["connect"](e)}GetInputNode(){return this._inputNode}SetParam(e,t,i,s){switch(e){case 0:t=Math.max(Math.min(t/100,1),0),this._params[1]=t,this.SetAudioParam(this._wetNode["gain"],t,i,s),this.SetAudioParam(this._dryNode["gain"],1-t,i,s);break;case 7:this._params[0]=t,this.SetAudioParam(this._oscNode["frequency"],t,i,s)}}},self.C3AudioDistortionFX=class extends a{constructor(e,t,i,s,o,a){super(e),this._type="distortion",this._params=[t,i,s,o,a],this._inputNode=this.CreateGain(),this._preGain=this.CreateGain(),this._postGain=this.CreateGain(),this._SetDrive(s,o),this._wetNode=this.CreateGain(),this._wetNode["gain"]["value"]=a,this._dryNode=this.CreateGain(),this._dryNode["gain"]["value"]=1-a,this._waveShaper=this._audioContext["createWaveShaper"](),this._curve=new Float32Array(65536),this._GenerateColortouchCurve(t,i),this._waveShaper.curve=this._curve,this._inputNode["connect"](this._preGain),this._inputNode["connect"](this._dryNode),this._preGain["connect"](this._waveShaper),this._waveShaper["connect"](this._postGain),this._postGain["connect"](this._wetNode)}Release(){this._inputNode["disconnect"](),this._preGain["disconnect"](),this._waveShaper["disconnect"](),this._postGain["disconnect"](),this._wetNode["disconnect"](),this._dryNode["disconnect"](),super.Release()}_SetDrive(e,t){this._preGain["gain"]["value"]=e=e<.01?.01:e,this._postGain["gain"]["value"]=Math.pow(1/e,.6)*t}_GenerateColortouchCurve(i,s){const o=32768;for(let t=0;t<o;++t){let e=t/o;e=this._Shape(e,i,s),this._curve[o+t]=e,this._curve[o-t-1]=-e}}_Shape(e,t,i){const s=1.05*i*t,o=s-t,a=e<0?-1:1,n=e<0?-e:e;let d=n<t?n:t+o*self.AudioDOMHandler.e4(n-t,1/o);return d*=a}ConnectTo(e){this._wetNode["disconnect"](),this._wetNode["connect"](e),this._dryNode["disconnect"](),this._dryNode["connect"](e)}GetInputNode(){return this._inputNode}SetParam(e,t,i,s){0===e&&(t=Math.max(Math.min(t/100,1),0),this._params[4]=t,this.SetAudioParam(this._wetNode["gain"],t,i,s),this.SetAudioParam(this._dryNode["gain"],1-t,i,s))}},self.C3AudioCompressorFX=class extends a{constructor(e,t,i,s,o,a){super(e),this._type="compressor",this._params=[t,i,s,o,a],this._node=this._audioContext["createDynamicsCompressor"](),this._node["threshold"]["value"]=t,this._node["knee"]["value"]=i,this._node["ratio"]["value"]=s,this._node["attack"]["value"]=o,this._node["release"]["value"]=a}Release(){this._node["disconnect"](),super.Release()}ConnectTo(e){this._node["disconnect"](),this._node["connect"](e)}GetInputNode(){return this._node}SetParam(e,t,i,s){}},self.C3AudioAnalyserFX=class extends a{constructor(e,t,i){super(e),this._type="analyser",this._params=[t,i],this._node=this._audioContext["createAnalyser"](),this._node["fftSize"]=t,this._node["smoothingTimeConstant"]=i,this._freqBins=new Float32Array(this._node["frequencyBinCount"]),this._signal=new Uint8Array(t),this._peak=0,this._rms=0,this._audioDomHandler._AddAnalyser(this)}Release(){this._audioDomHandler._RemoveAnalyser(this),this._node["disconnect"](),super.Release()}Tick(){this._node["getFloatFrequencyData"](this._freqBins),this._node["getByteTimeDomainData"](this._signal);const e=this._node["fftSize"];let i=this._peak=0;for(let t=0;t<e;++t){let e=(this._signal[t]-128)/128;e<0&&(e=-e),this._peak<e&&(this._peak=e),i+=e*e}const t=self.AudioDOMHandler.LinearToDb;this._peak=t(this._peak),this._rms=t(Math.sqrt(i/e))}ConnectTo(e){this._node["disconnect"](),this._node["connect"](e)}GetInputNode(){return this._node}SetParam(e,t,i,s){}GetData(){return{"tag":this.GetTag(),"index":this.GetIndex(),"peak":this._peak,"rms":this._rms,"binCount":this._node["frequencyBinCount"],"freqBins":this._freqBins}}}}

// scripts/plugins/video/dom/domSide.js
"use strict";{function IsVideoPlaying(e){return e&&!e.paused&&!e.ended&&0<e.currentTime}const a="video",b=class extends self.DOMElementHandler{constructor(e){super(e,a),this.SetAutoAttach(!1),this._isRuntimeInWorker=!1,this._supportsRvfc=!1,this._postImageBitmaps=!1,this._sequenceNumber=0,this._numVideos=0,this._destroyedVideos=new WeakSet,this.AddRuntimeMessageHandler("init",e=>this._OnInit(e)),this.AddDOMElementMessageHandlers([["play",e=>this._OnPlay(e)],["pause",e=>this._OnPause(e)],["set-source",(e,t)=>this._OnSetSource(e,t)],["set-playback-time",(e,t)=>this._OnSetPlaybackTime(e,t)],["set-playback-rate",(e,t)=>this._OnSetPlaybackRate(e,t)],["set-looping",(e,t)=>this._OnSetLooping(e,t)],["set-muted",(e,t)=>this._OnSetMuted(e,t)],["set-volume",(e,t)=>this._OnSetVolume(e,t)]]),self["C3Video_GetElement"]=e=>this.GetElementById(e)}async _OnInit(e){this._isRuntimeInWorker=e["isInWorker"];const t=document.createElement("video"),a=(this._supportsRvfc=!!t["requestVideoFrameCallback"]&&!this._iRuntime.IsAndroidWebView(),!!self["createImageBitmap"]);return this._postImageBitmaps=this._isRuntimeInWorker||a,{"postImageBitmaps":this._postImageBitmaps,"supportedFormats":{"webm-vp8":!!t.canPlayType("video/webm;codecs=vp8"),"webm-vp9":!!t.canPlayType("video/webm;codecs=vp9"),"webm-av1":!!t.canPlayType("video/webm;codecs=av01.0.00M.08"),"mp4-h264":!!t.canPlayType("video/mp4;codecs=avc1.420034"),"mp4-h265":!!t.canPlayType("video/mp4;codecs=hev1.1.2.L93.B0"),"mp4-av1":!!t.canPlayType("video/mp4;codecs=av01.0.00M.08")}}}TryPlayMedia(e){this._iRuntime.TryPlayMedia(e),this._postImageBitmaps&&this._supportsRvfc&&-1===e["c3_rvfcId"]&&(e["c3_rvfcId"]=e["requestVideoFrameCallback"](()=>this._OnVideoFrameCallback(e)))}RemovePendingPlay(e){this._iRuntime.RemovePendingPlay(e),this._postImageBitmaps&&this._supportsRvfc&&-1!==e["c3_rvfcId"]&&(e["cancelVideoFrameCallback"](e["c3_rvfcId"]),e["c3_rvfcId"]=-1)}async _OnVideoFrameCallback(e){if(!this._destroyedVideos.has(e)){e["c3_rvfcId"]=e["requestVideoFrameCallback"](()=>this._OnVideoFrameCallback(e));try{const t=e["c3_sequenceNumber"]++,a=await createImageBitmap(e);t>e["c3_lastFrameSequence"]&&(e["c3_imageBitmap"]=a,e["c3_lastFrameSequence"]=t)}catch(e){}}}CreateElement(e,t){const a=document.createElement("video"),i=(a.crossOrigin="anonymous",a["playsInline"]=!0,a["c3_imageBitmap"]=null,a["c3_rvfcId"]=-1,a["c3_sequenceNumber"]=0,a["c3_lastFrameSequence"]=-1,a.addEventListener("canplay",()=>this._SendPlaybackEvent(a,e,0)),a.addEventListener("canplaythrough",()=>this._SendPlaybackEvent(a,e,1)),a.addEventListener("ended",()=>this._SendPlaybackEvent(a,e,2)),a.addEventListener("error",()=>this._SendPlaybackEvent(a,e,3)),a.addEventListener("loadstart",()=>this._SendPlaybackEvent(a,e,4)),a.addEventListener("playing",()=>this._SendPlaybackEvent(a,e,5)),a.addEventListener("pause",()=>this._SendPlaybackEvent(a,e,6)),a.addEventListener("stalled",()=>this._SendPlaybackEvent(a,e,7)),t["autoplay"]);return 0===i?(a.autoplay=!1,a.preload="none"):1===i?(a.autoplay=!1,a.preload="auto"):a.autoplay=!0,t["src"]&&(a.src=t["src"]),2===i&&this.TryPlayMedia(a),this._numVideos++,this._StartTicking(),a}_SendPlaybackEvent(e,t,a){this._destroyedVideos.has(e)||this.PostToRuntimeElement("playback-event",t,{"type":a})}UpdateState(e,t){}DestroyElement(e){this.RemovePendingPlay(e),IsVideoPlaying(e)&&e.pause(),e.src="",this._numVideos=Math.max(this._numVideos-1,0),0===this._numVideos&&this._StopTicking(),this._destroyedVideos.add(e)}_OnPlay(e){this.TryPlayMedia(e)}_OnPause(e){this.RemovePendingPlay(e),e.pause()}_OnSetSource(e,t){e.src=t["src"],e.load()}_OnSetPlaybackTime(e,t){try{e.currentTime=t["time"]}catch(e){console.error("[Video] Exception setting playback time: ",e)}}_OnSetPlaybackRate(e,t){try{e.playbackRate=t["rate"]}catch(e){console.error("[Video] Exception setting playback rate: ",e)}}_OnSetLooping(e,t){e.loop=t["isLooping"]}_OnSetMuted(e,t){e.muted=t["isMuted"]}_OnSetVolume(e,t){e.volume=t["volume"]}Tick(){const e={},t={"sequenceNumber":this._sequenceNumber++,"videoData":e},a=[],i=[];for(const[s,n]of this._elementMap.entries()){const c=n.GetElement(),o={"currentTime":c.currentTime,"playbackRate":c.playbackRate,"duration":c.duration,"videoWidth":c.videoWidth,"videoHeight":c.videoHeight};if(this._postImageBitmaps)if(this._supportsRvfc){const d=c["c3_imageBitmap"];c["c3_imageBitmap"]=null,(o["imageBitmap"]=d)&&a.push(d)}else i.push(createImageBitmap(c).then(e=>{o["imageBitmap"]=e,a.push(e)}).catch(e=>{o["imageBitmap"]=null}));e[s.toString()]=o}Promise.all(i).then(()=>{this._isRuntimeInWorker?this.PostToRuntime("state",t,!1,a):this._PostToRuntimeMaybeSync("state",t)})}};self.RuntimeInterface.AddDOMHandlerClass(b)}

// scripts/plugins/Touch/dom/domSide.js
"use strict";{const a="touch",b=class extends self.DOMHandler{constructor(e){super(e,a),this.AddRuntimeMessageHandler("request-permission",e=>this._OnRequestPermission(e))}async _OnRequestPermission(e){const t=e["type"];let s=!0;0===t?s=await this._RequestOrientationPermission():1===t&&(s=await this._RequestMotionPermission()),this.PostToRuntime("permission-result",{"type":t,"result":s})}async _RequestOrientationPermission(){if(!self["DeviceOrientationEvent"]||!self["DeviceOrientationEvent"]["requestPermission"])return!0;try{const e=await self["DeviceOrientationEvent"]["requestPermission"]();return"granted"===e}catch(e){return console.warn("[Touch] Failed to request orientation permission: ",e),!1}}async _RequestMotionPermission(){if(!self["DeviceMotionEvent"]||!self["DeviceMotionEvent"]["requestPermission"])return!0;try{const e=await self["DeviceMotionEvent"]["requestPermission"]();return"granted"===e}catch(e){return console.warn("[Touch] Failed to request motion permission: ",e),!1}}};self.RuntimeInterface.AddDOMHandlerClass(b)}

// scripts/plugins/PlatformInfo/dom/domSide.js
"use strict";{const a="platform-info";function GetAndroidInsetTop(s){return new Promise((e,t)=>{s["getInsetTop"](e,t)})}function GetAndroidInsetRight(s){return new Promise((e,t)=>{s["getInsetRight"](e,t)})}function GetAndroidInsetBottom(s){return new Promise((e,t)=>{s["getInsetBottom"](e,t)})}function GetAndroidInsetLeft(s){return new Promise((e,t)=>{s["getInsetLeft"](e,t)})}const b=class extends self.DOMHandler{constructor(e){super(e,a),this.AddRuntimeMessageHandlers([["get-initial-state",()=>this._OnGetInitialState()],["request-wake-lock",()=>this._OnRequestWakeLock()],["release-wake-lock",()=>this._OnReleaseWakeLock()]]),window.addEventListener("resize",()=>this._OnResize()),this._screenWakeLock=null}async _OnGetInitialState(){const e=await this._GetSafeAreaInset();return{"screenWidth":screen.width,"screenHeight":screen.height,"windowOuterWidth":window.outerWidth,"windowOuterHeight":window.outerHeight,"safeAreaInset":e,"supportsWakeLock":!!navigator["wakeLock"]}}async _GetSafeAreaInset(){const e=self["AndroidNotch"];if(!e){const t=document.body,s=t.style,n=(s.setProperty("--temp-sai-top","env(safe-area-inset-top)"),s.setProperty("--temp-sai-right","env(safe-area-inset-right)"),s.setProperty("--temp-sai-bottom","env(safe-area-inset-bottom)"),s.setProperty("--temp-sai-left","env(safe-area-inset-left)"),getComputedStyle(t)),o=[n.getPropertyValue("--temp-sai-top"),n.getPropertyValue("--temp-sai-right"),n.getPropertyValue("--temp-sai-bottom"),n.getPropertyValue("--temp-sai-left")].map(e=>{const t=parseInt(e,10);return isFinite(t)?t:0});return s.removeProperty("--temp-sai-top"),s.removeProperty("--temp-sai-right"),s.removeProperty("--temp-sai-bottom"),s.removeProperty("--temp-sai-left"),o}try{return await Promise.all([GetAndroidInsetTop(e),GetAndroidInsetRight(e),GetAndroidInsetBottom(e),GetAndroidInsetLeft(e)])}catch(e){return console.error("[Construct] Failed to get Android safe area inset: ",e),[0,0,0,0]}}async _OnResize(){const e=await this._GetSafeAreaInset();this.PostToRuntime("window-resize",{"windowOuterWidth":window.outerWidth,"windowOuterHeight":window.outerHeight,"safeAreaInset":e})}async _OnRequestWakeLock(){if(!this._screenWakeLock)try{this._screenWakeLock=await navigator["wakeLock"]["request"]("screen"),this._screenWakeLock.addEventListener("release",()=>this._OnWakeLockReleased()),console.log("[Construct] Screen wake lock acquired"),this.PostToRuntime("wake-lock-acquired")}catch(e){console.warn("[Construct] Failed to acquire screen wake lock: ",e),this.PostToRuntime("wake-lock-error")}}_OnReleaseWakeLock(){this._screenWakeLock&&(this._screenWakeLock["release"](),this._screenWakeLock=null)}_OnWakeLockReleased(){console.log("[Construct] Screen wake lock released"),this._screenWakeLock=null,this.PostToRuntime("wake-lock-released")}};self.RuntimeInterface.AddDOMHandlerClass(b)}

// start-export.js
"use strict";if(window["C3_Is_Supported"]){const a=false;window["c3_runtimeInterface"]=new self.RuntimeInterface({useWorker:a,workerMainUrl:"workermain.js",runtimeScriptList:["scripts/c3main.js"],scriptFolder:"scripts/",exportType:"playable-ad-single-file"})}

</script>


</body> 
</html>